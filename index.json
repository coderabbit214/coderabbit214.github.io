[{"categories":["机器学习"],"content":"llama模型本地Running ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:0:0","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["机器学习"],"content":"代码准备 下载代码 git@github.com:coderabbit214/llama.cpp.git 编译代码 cd llama.cpp make ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:1:0","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["机器学习"],"content":"Python环境准备 本机环境Python 3.10 可以使用 pipenv shell --python 3.10 创建一个环境 安装依赖 pip3 install torch numpy sentencepiece 把模型文件放到当前目录下 ./models/7B/consolidated.00.pth 文件大小应该是13GB 将模型转化为\"ggml FP16 format\" python3 convert-pth-to-ggml.py models/7B/ 1 生成文件： ./models/7B/ggml-model-f16.bin 大小：13GB 将模型转化为4-bits 注意 ：如果是多个模型，例如13B，则需要给每个模型运行命令 ./quantize ./models/13B/ggml-model-f16.bin ./models/13B/ggml-model-q4_0.bin 2 ./quantize ./models/13B/ggml-model-f16.bin.1 ./models/13B/ggml-model-q4_0.bin.1 2 ./quantize ./models/7B/ggml-model-f16.bin ./models/7B/ggml-model-q4_0.bin 2 生成文件： ./models/7B/ggml-model-q4_0.bin 大小：3.9GB ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:2:0","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["机器学习"],"content":"Running ./main -m ./models/7B/ggml-model-q4_0.bin \\ -t 8 \\ -n 128 \\ -p 'The first man on the moon was ' ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:3:0","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["机器学习"],"content":"参数说明 -t:线程数 -n:令牌数 -p:提示 帮助： ./main -h usage: ./main [options] options: -h, --help show this help message and exit -i, --interactive run in interactive mode --interactive-start run in interactive mode and poll user input at startup -r PROMPT, --reverse-prompt PROMPT in interactive mode, poll user input upon seeing PROMPT --color colorise output to distinguish prompt and user input from generations -s SEED, --seed SEED RNG seed (default: -1) -t N, --threads N number of threads to use during computation (default: 4) -p PROMPT, --prompt PROMPT prompt to start generation with (default: random) -f FNAME, --file FNAME prompt file to start generation. -n N, --n_predict N number of tokens to predict (default: 128) --top_k N top-k sampling (default: 40) --top_p N top-p sampling (default: 0.9) --repeat_last_n N last n tokens to consider for penalize (default: 64) --repeat_penalty N penalize repeat sequence of tokens (default: 1.3) --temp N temperature (default: 0.8) -b N, --batch_size N batch size for prompt processing (default: 8) -m FNAME, --model FNAME model path (default: models/llama-7B/ggml-model.bin) ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:3:1","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["数据库"],"content":"Neo4j实践 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"关于 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"是什么 图形数据库管理系统，是一个高性能、面向对象的数据库系统，用于存储、管理和查询大规模的图形数据。它是一个开源的、ACID兼容的数据库，采用了图形模型来表示数据，这使得它在处理复杂的关系数据方面表现出色。Neo4j是目前最受欢迎的图形数据库之一，它可以被用于许多应用程序领域，包括社交网络、推荐系统、网络安全、生物信息学等。它支持多种编程语言和平台，并且具有良好的可扩展性和高可用性。 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"为什么使用 更适合处理复杂关系型数据：Neo4j采用图形模型来表示数据，可以很好地处理复杂的关系型数据。与传统的关系型数据库相比，Neo4j更加灵活和高效。 更快的查询速度：Neo4j是一个面向对象的数据库系统，它使用了索引和缓存技术来提高查询性能。在查询图形数据时，Neo4j可以使用遍历算法来优化查询性能，从而实现更快的查询速度。 更好的可扩展性：Neo4j可以轻松地扩展到多个节点，可以实现分布式计算，因此可以处理更大的数据集。 更适合处理实时数据：Neo4j是一个内存数据库，支持实时数据处理，适用于实时应用程序和实时数据分析。 更容易理解和使用：Neo4j使用基于图形模型的查询语言Cypher，这种查询语言与现代应用程序的数据结构更加相似，因此更容易理解和使用。 综上所述，如果你需要处理复杂关系型数据，需要更快的查询速度、更好的可扩展性和实时数据处理能力，Neo4j可能是更好的选择。而如果你需要处理传统的关系型数据，或者需要使用SQL查询语言，那么传统的关系型数据库可能更适合你的需求。 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"实践 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"安装 version: '3' services: neo4j: image: neo4j:4.3.7 volumes: - $PWD/data:/data #把容器内的数据目录挂载到宿主机的对应目录下 - $PWD/logs:/logs #挂载日志目录 - $PWD/conf:/var/lib/neo4j/conf #挂载配置目录 - $PWD/import:/var/lib/neo4j/import #挂载数据导入目录 - $PWD/plugins:/plugins environment: - NEO4J_dbms_memory_heap_maxSize=4G - NEO4J_AUTH=neo4j/123456 #修改默认用户密码 ports: - \"7474:7474\" #映射容器的端口号到宿主机的端口号 - \"7687:7687\" restart: always ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Cypher 简介 用法 CREATE 创建 创建节点，关系和属性 MATCH 匹配 检索有关节点，关系和属性数据 RETURN 返回 返回查询结果 WHERE 哪里 提供条件过滤检索数据 DELETE 删除 删除节点和关系 REMOVE 移除 删除节点和关系的属性 ORDER BY 以…排序 排序检索数据 SET 添加或更新标签 设置属性 LOAD load cv from \"file:///xxx.csv\" as line create (:xiyouRelation (from: line[1],relation:line[3],to: line[0]}) MATCH // 查询某个标签全部节点 match (n:xiyouRelation) return n // 查询所有数量 match (n:xiyouRelation) return count(n) // 条件查询 in,is null match (n:xiyouRelation {from:\"孙悟空\"}) return n match (n:xiyouRelation) where n.from in[\"孙悟空\",\"猪八戒\"] return n //关系查询 [:西游关系*n] n确定层级 0只返回自己 MATCH (n:person {name:'孙悟空'})-[:西游关系*2]-\u003e(b:person) return n,b MATCH (n:person {name:'孙悟空'})\u003c-[:西游关系*2]-(b:person) return n,b // 查询其他参数 // ORDER BY MATCH (n:person {name:'孙悟空'})-[:西游关系*2]-\u003e(b:person) return n,b ORDER BY n.name // LIMIT MATCH (n:person {name:'孙悟空'})-[:西游关系*2]-\u003e(b:person) return n,b LIMIT 10 // SKIP MATCH (n:person {name:'孙悟空'})-[:西游关系*2]-\u003e(b:person) return n,b SKIP 10 CREATE // 创建一个标签为person的节点，节点有一个name属性，属性值为'小红' create (n:person {name:\"小红\"}) return n // 属性设置 match (n:person {name:\"小红\"}) set n.age=18 return n // 给某个标签对外的所有关系增加属性 MATCH p=(person {name:'孙悟空'})-[r:西游关系]-\u003e() SET r={since:\"2017-01-02\"} RETURN p; DELETE // 删除a节点 match (n:person {name:\"小红\"}) delete n //删除关系属性 match (n:person {name:'孙悟空'})-[r:西游关系]-\u003e(m:person) REMOVE r.since ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Springboot 集成 springboot版本 3.0.4 引入依赖 implementation 'org.springframework.boot:spring-boot-starter-data-neo4j' 配置 spring: neo4j: uri: bolt://localhost:7687 authentication: username: neo4j password: 123456 data: neo4j: database: neo4j logging: level: org: springframework: data: neo4j: debug 创建实体 @Data @Node(\"person\") public class Person { @Id @GeneratedValue private Long id; @Property private String name; } Repository @Repository public interface PersonRepository extends Neo4jRepository\u003cPerson, Long\u003e { /** * 根据名称查询 * @param name * @return */ Person findByName(String name); /** * 创建关系 * * @param from * @param relation * @param to */ @Query(\"MATCH (n:person {name:$from}),(m:person {name:$to}) CREATE (n)-[:西游关系{relation:$relation}]-\u003e(m)\") void createRelation(String from, String relation, String to); } 测试 @Test public void testFindAll() { List\u003cPerson\u003e all = personRepository.findAll(); for (Person person : all) { System.out.println(person); } } @Test public void testFindById() { Optional\u003cPerson\u003e person = personRepository.findById(295L); person.ifPresent(System.out::println); } @Test public void testDelete() { personRepository.deleteById(295L); } @Test public void testCreateObject() { Person person = new Person(); person.setName(\"牛魔王\"); Person save = personRepository.save(person); System.out.println(save); } 关系 简单关系 在自身中存储 @Data @Node(\"person\") public class Person { @Id @GeneratedValue private Long id; @Property private String name; @Relationship(type = \"师傅\") public Set\u003cPerson\u003e masters; @Relationship(type = \"师兄\") public Set\u003cPerson\u003e brothers; //指定师傅关系 public void masters(Person person) { if (masters == null) { masters = new HashSet\u003c\u003e(); } masters.add(person); } public void brothers(Person person) { if (brothers == null) { brothers = new HashSet\u003c\u003e(); } brothers.add(person); } public String toString() { return this.name + \" 师傅 =\u003e \" + Optional.ofNullable(this.masters).orElse( Collections.emptySet()).stream().map( Person::getName).collect(Collectors.toList()) + \" 师兄 =\u003e \" + Optional.ofNullable(this.brothers).orElse( Collections.emptySet()).stream().map( Person::getName).collect(Collectors.toList()); } } test @Test public void testCreateRelation() { Person san = new Person(); san.setName(\"张三\"); Person si = new Person(); si.setName(\"李四\"); Person wu = new Person(); wu.setName(\"王武\"); san.masters(si); san.brothers(wu); personRepository.save(san); // 张三 师傅 =\u003e [李四] 师兄 =\u003e [王武] Person name = personRepository.findByName(\"张三\"); System.out.println(name); } 复杂关系(关系中有一些其他属性) 创建关系类 @RelationshipProperties : 指定是一个关系类 @TargetNode : 指定关联对象 @RelationshipProperties @Data public class XiYouRelationPerson { @RelationshipId private Long id; private String relation; @TargetNode private Person property; } 使用 @Data @Node(\"person\") public class Person { @Id @GeneratedValue private Long id; @Property private String name; @Relationship(type = \"西游关系\") public List\u003cXiYouRelationPerson\u003e xiYouRelationPeople; } ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["go"],"content":"Go-WebAssembly实践 在网页端实现一个json转struct ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:0:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"Hello Word 创建项目目录 Documents/ └── webassembly ├── assets └── cmd ├── server └── wasm 在 webassembly初始化go项目 go mod init teswebassembly 在webassembly/cmd/wasm下创建main.go package main import ( \"fmt\" ) func main() { fmt.Println(\"Go Web Assembly\") } 编译 cd webassembly/cmd/wasm/ GOOS=js GOARCH=wasm go build -o ../../assets/json.wasm 生成了在浏览器中运行的二进制文件 获取wasm_exec.js用来调用json.wasm cp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" webassembly/assets/ 在webassembly/cmd/wasm下创建index.html \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003cscript src=\"wasm_exec.js\"\u003e\u003c/script\u003e \u003cscript\u003e const go = new Go(); WebAssembly.instantiateStreaming(fetch(\"json.wasm\"), go.importObject).then((result) =\u003e { go.run(result.instance); }); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e\u003c/body\u003e \u003c/html\u003e 目前目录 Documents/ └── webassembly ├── assets │ ├── index.html │ ├── json.wasm │ └── wasm_exec.js └── cmd ├── server └── wasm └── main.go └── go.mod 做一个简单服务器用来运行index.html,编译器自带也可以 在webassembly/cmd/server下创建main.go package main import ( \"fmt\" \"net/http\" ) func main() { err := http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\"../../assets\"))) if err != nil { fmt.Println(\"Failed to start server\", err) return } } 运行 cd webassembly/cmd/server/ go run main.go 在控制台中可以看到打印 ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:1:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"功能实现 Json2Go 使用的是 github.com/m-zajac/json2go 在webassembly/cmd/wasm/main.go中添加 添加功能代码 import ( \"github.com/m-zajac/json2go\" ) func Json2Go(input string) string { parser := json2go.NewJSONParser(\"Document\") parser.FeedBytes([]byte(input)) res := parser.String() return res } 将函数暴露到Javascript import ( \"syscall/js\" ) func main() { fmt.Println(\"Go Web Assembly\") js.Global().Set(\"json2Go\", Json2GoWrapper()) //避免 Error: Go program has already exited \u003c-make(chan bool) } func Json2GoWrapper() js.Func { jsonFunc := js.FuncOf(func(this js.Value, args []js.Value) any { if len(args) != 1 { return \"Invalid no of arguments passed\" } inputJSON := args[0].String() res := Json2Go(inputJSON) return res }) return jsonFunc } syscall/js 编译器报错设置 编写ui \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003cscript src=\"wasm_exec.js\"\u003e\u003c/script\u003e \u003cscript\u003e const go = new Go(); WebAssembly.instantiateStreaming(fetch(\"json.wasm\"), go.importObject).then((result) =\u003e { go.run(result.instance); }); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ctextarea id=\"jsoninput\" name=\"jsoninput\" cols=\"80\" rows=\"20\"\u003e\u003c/textarea\u003e \u003cinput id=\"button\" type=\"submit\" name=\"button\" value=\"pretty json\" onclick=\"json(jsoninput.value)\"/\u003e \u003ctextarea id=\"jsonoutput\" name=\"jsonoutput\" cols=\"80\" rows=\"20\"\u003e\u003c/textarea\u003e \u003c/body\u003e \u003cscript\u003e var json = function (input) { jsonoutput.value = json2Go(input) } \u003c/script\u003e \u003c/html\u003e 测试 ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:2:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"DOM操作 修改webassembly/cmd/wasm/main.go中Json2GoWrapper方法 func Json2GoWrapper() js.Func { jsonfunc := js.FuncOf(func(this js.Value, args []js.Value) any { if len(args) != 1 { result := map[string]any{ \"error\": \"Invalid no of arguments passed\", } return result } jsDoc := js.Global().Get(\"document\") if !jsDoc.Truthy() { result := map[string]any{ \"error\": \"Invalid no of arguments passed\", } return result } jsonOuputTextArea := jsDoc.Call(\"getElementById\", \"jsonoutput\") if !jsonOuputTextArea.Truthy() { result := map[string]any{ \"error\": \"Invalid no of arguments passed\", } return result } inputJSON := args[0].String() res := Json2Go(inputJSON) jsonOuputTextArea.Set(\"value\", res) return nil }) return jsonfunc } 修改webassembly/assets/index.html \u003cscript\u003e var json = function (input) { var result = json2Go(input) if (( result != null) \u0026\u0026 ('error' in result)) { console.log(\"Go return value\", result) jsonoutput.value = \"\" alert(result.error) } // jsonoutput.value = json2Go(input) } \u003c/script\u003e ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:3:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"错误处理 由于js无法处理error类型，对应表：https://pkg.go.dev/syscall/js#ValueOf 所以错误处理返回map[string]interface{} result := map[string]any{ \"error\": \"error message\", } ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:4:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"Json参数传递 index.html \u003cscript\u003e var json = function (input) { jsonoutput.value = json2Go({\"json\": input}) } \u003c/script\u003e Go接收 func Json2GoWrapper() js.Func { jsonFunc := js.FuncOf(func(this js.Value, args []js.Value) any { if len(args) != 1 { return \"Invalid no of arguments passed\" } inputJSON := args[0].Get(\"json\").String() res := Json2Go(inputJSON) return res }) return jsonFunc } ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:5:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"gin基础 ","date":"2022-11-13","objectID":"/gin/:0:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"HelloWord func main() { // 1.创建路由 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 2.绑定路由规则，执行的函数 // gin.Context，封装了request和response r.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") }) // 监听端口，默认在8080 // Run(\"里面不指定端口号默认为8080\") r.Run(\":8000\") } ","date":"2022-11-13","objectID":"/gin/:1:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"请求接收 ","date":"2022-11-13","objectID":"/gin/:2:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"路由参数 : 匹配一个 * 匹配0个或多个 127.0.0.1:8888/user/1/1234 匹配 127.0.0.1:8888/user/1/1234/1234 匹配 127.0.0.1:8888/user/1 匹配 //api 参数 Param 方法 r.GET(\"/user/:name/*action\", func(c *gin.Context) { name := c.Param(\"name\") action := c.Param(\"action\") //截取/ action = strings.Trim(action, \"/\") c.String(http.StatusOK, name+\" is \"+action) }) ","date":"2022-11-13","objectID":"/gin/:2:1","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"URL参数 DefaultQuery : 获取不到取默认值 Query : 获取参数 127.0.0.1:8888/user?action=1234 //url参数 DefaultQuery Query r.GET(\"/user\", func(c *gin.Context) { name := c.DefaultQuery(\"name\", \"哈哈哈\") action := c.Query(\"action\") c.String(http.StatusOK, name+\" is \"+action) }) ","date":"2022-11-13","objectID":"/gin/:2:2","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"表单参数 //表单参数 表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencoded或from-data格式的参数 r.POST(\"/form\", func(c *gin.Context) { types := c.DefaultPostForm(\"type\", \"post\") username := c.PostForm(\"username\") password := c.PostForm(\"userpassword\") c.String(http.StatusOK, fmt.Sprintf(\"username:%s,password:%s,type:%s\", username, password, types)) }) ","date":"2022-11-13","objectID":"/gin/:2:3","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"JSON参数 //json参数 // 定义接收数据的结构体 type Login struct { // binding:\"required\"修饰的字段，若接收为空值，则报错，是必须字段 // form：表单 // json：json // uri：url参数 User string `form:\"username\" json:\"user\" uri:\"user\" xml:\"user\" binding:\"required\"` Password string `form:\"password\" json:\"password\" uri:\"password\" xml:\"password\" binding:\"required\"` } //数据绑定 r.POST(\"/loginJSON\", func(c *gin.Context) { // 声明接收的变量 var json Login // c.ShouldBindJSON 将request的body中的数据，自动按照json格式解析到结构体 // c.ShouldBindUri 解析url参数 // c.Bind Bind()默认解析并绑定form格式 根据请求头中content-type自动推断 if err := c.Bind(\u0026json); err != nil { // 返回错误信息 // gin.H封装了生成json数据的工具 c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) return } // 判断用户名密码是否正确 if json.User != \"root\" || json.Password != \"admin\" { c.JSON(http.StatusBadRequest, gin.H{\"status\": \"304\"}) return } c.JSON(http.StatusOK, gin.H{\"status\": \"200\"}) }) ","date":"2022-11-13","objectID":"/gin/:2:4","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"文件上传 //文件上传大小限制 单位k r.MaxMultipartMemory = 8 \u003c\u003c 20 //单文件上传 r.POST(\"/upload\", func(c *gin.Context) { file, err := c.FormFile(\"file\") if err != nil { c.String(500, \"上传图片出错\") } //文件存储 c.SaveUploadedFile(file, \"/Users/mr_j/\"+file.Filename) c.String(http.StatusOK, file.Filename) }) //多文件 r.POST(\"/uploadBatch\", func(c *gin.Context) { form, err := c.MultipartForm() if err != nil { c.String(http.StatusBadRequest, fmt.Sprintf(\"get err %s\", err.Error())) } // 获取所有图片 files := form.File[\"files\"] // 遍历所有图片 for _, file := range files { // 逐个存 if err := c.SaveUploadedFile(file, \"/Users/mr_j/\"+file.Filename); err != nil { c.String(http.StatusBadRequest, fmt.Sprintf(\"upload err %s\", err.Error())) return } } c.String(200, fmt.Sprintf(\"upload ok %d files\", len(files))) }) ","date":"2022-11-13","objectID":"/gin/:2:5","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"响应 ","date":"2022-11-13","objectID":"/gin/:3:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"JSON r.GET(\"/someJSON\", func(c *gin.Context) { c.JSON(200, gin.H{\"message\": \"someJSON\", \"status\": 200}) }) ","date":"2022-11-13","objectID":"/gin/:3:1","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"结构体 r.GET(\"/someStruct\", func(c *gin.Context) { var msg struct { Name string Message string Number int } //是否可以添加构造方法 msg.Name = \"root\" msg.Message = \"message\" msg.Number = 123 c.JSON(200, msg) }) ","date":"2022-11-13","objectID":"/gin/:3:2","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"其他 // 3.XML r.GET(\"/someXML\", func(c *gin.Context) { c.XML(200, gin.H{\"message\": \"abc\"}) }) // 4.YAML响应 r.GET(\"/someYAML\", func(c *gin.Context) { c.YAML(200, gin.H{\"name\": \"zhangsan\"}) }) // 5.protobuf格式,谷歌开发的高效存储读取的工具 // 数组？切片？如果自己构建一个传输格式，应该是什么格式？ r.GET(\"/someProtoBuf\", func(c *gin.Context) { reps := []int64{int64(1), int64(2)} // 定义数据 label := \"label\" // 传protobuf格式数据 data := \u0026protoexample.Test{ Label: \u0026label, Reps: reps, } c.ProtoBuf(200, data) }) ","date":"2022-11-13","objectID":"/gin/:3:3","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"路由拆分 ","date":"2022-11-13","objectID":"/gin/:4:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"同文件拆分 func main() { r := gin.Default() //路由分组 // 路由组1 ，处理GET请求 v1 := r.Group(\"/v1\") // {} 是书写规范 { v1.GET(\"/login\", login) v1.GET(\"/submit\", submit) } v2 := r.Group(\"/v2\") { v2.POST(\"/login\", login) v2.POST(\"/submit\", submit) } // 监听端口，默认在8080 // Run(\"里面不指定端口号默认为8080\") r.Run(\":8000\") } func login(c *gin.Context) { name := c.DefaultQuery(\"name\", \"jack\") c.String(200, fmt.Sprintf(\"hello %s\\n\", name)) } func submit(c *gin.Context) { name := c.DefaultQuery(\"name\", \"lily\") c.String(200, fmt.Sprintf(\"hello %s\\n\", name)) } ","date":"2022-11-13","objectID":"/gin/:4:1","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"单独拆分路由文件 ./main.go func main() { r := setupRouter() if err := r.Run(\":8000\"); err != nil { fmt.Printf(\"startup service failed, err:%v\\n\", err) } } ./routers.go func helloHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello www.topgoer.com!\", }) } func setupRouter() *gin.Engine { r := gin.Default() r.GET(\"/topgoer\", helloHandler) return r } ","date":"2022-11-13","objectID":"/gin/:4:2","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"按照包拆分路由文件 ./main.go package main // 按照包拆分路由文件 func main() { r := routers.SetupRouter() if err := r.Run(\":8000\"); err != nil { fmt.Printf(\"startup service failed, err:%v\\n\", err) } } ./routers/routers.go package routers func helloHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello www.topgoer.com!\", }) } func SetupRouter() *gin.Engine { r := gin.Default() r.GET(\"/topgoer\", helloHandler) return r } ","date":"2022-11-13","objectID":"/gin/:4:3","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"路由拆分成多个文件 ./main.go package main // 路由拆分成多个文件 func main() { r := gin.Default() //加载路由 routers.LoadUser(r) routers.LoadBlog(r) if err := r.Run(\":8000\"); err != nil { fmt.Printf(\"startup service failed, err:%v\\n\", err) } } ./routers/user.go package routers func LoadUser(e *gin.Engine) { loadUser := e.Group(\"/user\") { loadUser.GET(\"/:id\", getById) loadUser.DELETE(\"/:id\", deleteById) } } func deleteById(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") } func getById(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") } ./routers/blog.go package routers func LoadBlog(e *gin.Engine) { loadBlog := e.Group(\"/blog\") { loadBlog.GET(\"/:id\", getBlogById) loadBlog.DELETE(\"/:id\", deleteBlogById) } } func getBlogById(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") } func deleteBlogById(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") } ","date":"2022-11-13","objectID":"/gin/:4:4","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"中间件 // MiddleWare 定义 func MiddleWare() gin.HandlerFunc { return func(c *gin.Context) { fmt.Println(\"中间件开始执行了\") req := c.Query(\"request\") // 设置变量到Context的key中，可以通过Get()取 c.Set(\"request\", \"成功\") if req == \"1\" { //执行处理 c.Next() } else { c.JSON(500, gin.H{\"error\": req}) //不执行处理 但是这个中间件中代码会执行完 c.Abort() } fmt.Println(\"返回时执行\") } } func main() { // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 注册中间件 r.Use(MiddleWare()) // {}为了代码规范 { r.GET(\"/ce\", func(c *gin.Context) { // 取值 req, _ := c.Get(\"request\") fmt.Println(\"request:\", req) // 页面接收 c.JSON(200, gin.H{\"request\": req}) }) } r.Run() } ","date":"2022-11-13","objectID":"/gin/:5:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"gRPC ","date":"2022-11-13","objectID":"/grpc/:0:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"环境准备 brew install grpc brew install protobuf brew install protoc-gen-go brew install protoc-gen-go-grpc ","date":"2022-11-13","objectID":"/grpc/:1:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"HelloWord 创建文件./pb/hello_grpc.proto syntax = \"proto3\"; package hello_grpc; option go_package = \"./;hello_grpc\"; message Req { string message = 1; } message Res { string message = 1; } service HelloGRPC { rpc SayHi(Req) returns (Res); } 生成文件 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative ./pb/hello_grpc.proto 创建服务端文件./server/main.go package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"net\" hello_grpc2 \"test/grpc/01hello_word/pb\" ) //1.取出server //2.挂载方法 //3.注册服务 //4.创建监听 // 1取出server type server struct { hello_grpc2.UnimplementedHelloGRPCServer } // SayHi 2挂载方法 func (s *server) SayHi(ctx context.Context, req *hello_grpc2.Req) (res *hello_grpc2.Res, err error) { fmt.Println(req.GetMessage()) return \u0026hello_grpc2.Res{Message: \"我是从服务端返回的信息\"}, nil } func main() { // 3注册服务 listen, err := net.Listen(\"tcp\", \":8888\") if err != nil { fmt.Println(\"net.Listen err:\", err) return } defer listen.Close() s := grpc.NewServer() hello_grpc2.RegisterHelloGRPCServer(s, \u0026server{}) // 4创建监听 s.Serve(listen) } 创建客户端文件./client/main.go package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" hello_grpc2 \"test/grpc/01hello_word/pb\" ) //1.创建链接 //2.new client //3.调用client //4.获取返回值 func main() { dial, err := grpc.Dial(\"127.0.0.1:8888\", grpc.WithInsecure()) if err != nil { fmt.Println(\"grpc.Dial err:\", err) } defer dial.Close() client := hello_grpc2.NewHelloGRPCClient(dial) hi, err := client.SayHi(context.Background(), \u0026hello_grpc2.Req{Message: \"我从客户端来\"}) if err != nil { fmt.Println(\"client.SayHi err:\", err) } fmt.Println(hi.GetMessage()) } 测试 ","date":"2022-11-13","objectID":"/grpc/:2:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"proto文件详解 ","date":"2022-11-13","objectID":"/grpc/:3:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"目录格式 ","date":"2022-11-13","objectID":"/grpc/:3:1","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"基本格式 syntax = \"proto3\"; //告诉编辑器 用 proto3 解读 package person; //包名 // go_package= \"包路径(从mod下开始写);别名\" option go_package = \"test/grpc/02proto/pb/person;person\"; //引入 import \"home/home.proto\"; //类似结构体 信息传递的媒介 message Person{ } //定义服务 请求返回定义 service SearchService { //即时响应 rpc Search(Person) returns (Person); } ","date":"2022-11-13","objectID":"/grpc/:3:2","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"message //类似结构体 message Person{ // 类型 名称 = 唯一标识; string name = 1; int32 age = 2; // bool sex = 3; //数组 切片 repeated string test = 4; //map map\u003cstring, string\u003e test_map = 5; //枚举 必须要有0 enum SEX { //如果有的值需要一样则需要设置 option allow_alias = true; MAN = 0; WOMAN = 1; GIRL = 1; OTHER = 2; } SEX sex = 3; //不同类型相同名称使用 oneof TestOneOf{ string one = 6; string two = 7; string three = 8; } home.Home i_home = 9; //设置保留关键字 不允许定义 // reserved \"test_map\",\"test\"; // reserved 2; } //message 嵌套 message Home{ repeated Person persons = 1; //定义 message V { string name = 1; } //声明 V v = 2; } oneof 使用说明 proto //省略前边 message Person { oneof TestOneOf{ string one = 6; string two = 7; string three = 8; } } service SearchService { rpc Search(Person) returns (Person); } server func (s *spaceServer) Search(context context.Context, req *space.SpaceReq) (res *space.SpaceRes, err error) { name := req.GetName() fmt.Println(name) oneOf := req.TestOneOf switch v := oneOf.(type) { case *space.SpaceReq_One: fmt.Println(v.One) case *space.SpaceReq_Two: fmt.Println(v.Two) case *space.SpaceReq_Three: fmt.Println(v.Three) } res = \u0026space.SpaceRes{ Name: \"服务端\", } return res, nil } client dial, err := grpc.Dial(\"127.0.0.1:8888\", grpc.WithInsecure()) if err != nil { fmt.Println(\"grpc.Dial err:\", err) } defer dial.Close() client := space.NewSearchServiceClient(dial) //及时相应 var p = space.SpaceReq{Name: \"asdf\", TestOneOf: \u0026space.SpaceReq_One{One: \"asdfasdf\"}} hi, err := client.Search(context.Background(), \u0026p) if err != nil { fmt.Println(\"client.SayHi err:\", err) } fmt.Println(hi.GetName()) ","date":"2022-11-13","objectID":"/grpc/:3:3","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"import引入其他proto 创建需要引入的proto./pb/home/home.proto syntax = \"proto3\"; //告诉编辑器 用 proto3 解读 package home; //包名 // go_package= \"包路径(从mod下开始写);别名\" option go_package = \"test/grpc/02proto/pb/home;home\"; message Home{ string name = 1; } 在需要引入文件中引入 //引入 import \"home/home.proto\"; message Person { //使用 home.Home i_home = 9; } 编译 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative ./person/person.proto protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative ./home/home.proto ","date":"2022-11-13","objectID":"/grpc/:3:4","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"service 使用 space包下文件 proto./pb/space/space.proto syntax = \"proto3\"; package space; option go_package = \"test/grpc/02proto/pb/space;space\"; message SpaceReq{ string name = 1; } message SpaceRes{ string name = 1; } //定义服务 service SearchService { //即时响应 rpc Search(SpaceReq) returns (SpaceRes); //入参为流 rpc SearchIn(stream SpaceReq) returns (SpaceRes); //相应为流 rpc SearchOut(SpaceReq) returns (stream SpaceRes); //出入都为流 rpc SearchIO(stream SpaceReq) returns (stream SpaceRes); } service package main import ( \"context\" \"fmt\" \"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\" \"google.golang.org/grpc\" \"net\" \"net/http\" \"test/grpc/02proto/pb/space\" ) type spaceServer struct { space.UnimplementedSearchServiceServer } func (s *spaceServer) Search(context context.Context, req *space.SpaceReq) (res *space.SpaceRes, err error) { name := req.GetName() fmt.Println(name) res = \u0026space.SpaceRes{ Name: \"服务端\", } return res, nil } func (s *spaceServer) SearchIn(server space.SearchService_SearchInServer) error { for { req, err := server.Recv() //传输结束 if err != nil { server.SendAndClose(\u0026space.SpaceRes{Name: \"完成了\"}) break } fmt.Println(req) } return nil } func (s *spaceServer) SearchOut(req *space.SpaceReq, server space.SearchService_SearchOutServer) error { name := req.Name fmt.Println(name) for i := 0; i \u003c 10; i++ { server.Send(\u0026space.SpaceRes{Name: \"服务端\"}) } return nil } func (s *spaceServer) SearchIO(server space.SearchService_SearchIOServer) error { strChan := make(chan string, 1) go func() { for { recv, err := server.Recv() if err != nil { fmt.Println(err) strChan \u003c- \"结束\" break } fmt.Println(recv) strChan \u003c- recv.Name } }() for { name := \u003c-strChan if \"结束\" == name { break } server.Send(\u0026space.SpaceRes{Name: name}) } return nil } func main() { listen, err := net.Listen(\"tcp\", \":8888\") if err != nil { fmt.Println(\"net.Listen err\", err) return } s := spaceServer{} server := grpc.NewServer() space.RegisterSearchServiceServer(server, \u0026s) server.Serve(listen) } client package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"sync\" \"test/grpc/02proto/pb/space\" ) func main() { dial, err := grpc.Dial(\"127.0.0.1:8888\", grpc.WithInsecure()) if err != nil { fmt.Println(\"grpc.Dial err:\", err) } defer dial.Close() client := space.NewSearchServiceClient(dial) //及时相应 //var p = space.SpaceReq{Name: \"asdf\", TestOneOf: \u0026space.SpaceReq_One{One: \"asdfasdf\"}} //hi, err := client.Search(context.Background(), \u0026p) //if err != nil { // fmt.Println(\"client.SayHi err:\", err) //} //fmt.Println(hi.GetName()) //输入为流 //c, _ := client.SearchIn(context.Background()) //for i := 0; i \u003c 10; i++ { // c.Send(\u0026space.SpaceReq{Name: \"哈哈哈\"}) // time.Sleep(1 * time.Second) //} //recv, _ := c.CloseAndRecv() //fmt.Println(recv) //输出为流 //out, _ := client.SearchOut(context.Background(), \u0026space.SpaceReq{Name: \"1324\"}) //for { // recv, err := out.Recv() // if err != nil { // fmt.Println(err) // break // } // fmt.Println(recv) //} //输入输出为流 group := sync.WaitGroup{} group.Add(1) io, _ := client.SearchIO(context.Background()) go func() { for { recv, err2 := io.Recv() if err2 != nil { fmt.Println(err2) group.Done() break } fmt.Println(\"服务端返回：\", recv) } }() for i := 0; i \u003c 10; i++ { err := io.Send(\u0026space.SpaceReq{Name: \"1324\"}) if err != nil { fmt.Println(err) break } } io.CloseSend() group.Wait() } ","date":"2022-11-13","objectID":"/grpc/:3:5","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"grpc-gateway ","date":"2022-11-13","objectID":"/grpc/:4:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"安装插件 go install \\ github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway ","date":"2022-11-13","objectID":"/grpc/:4:1","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"代码编写 proto service SearchService { //即时响应 rpc Search(SpaceReq) returns (SpaceRes){ option(google.api.http) = { post:\"/api/space\", body:\"*\" }; }; } 编译 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative --grpc-gateway_out . --grpc-gateway_opt paths=source_relative ./space/space.proto server func main() { go registerGetaway() listen, err := net.Listen(\"tcp\", \":8888\") if err != nil { fmt.Println(\"net.Listen err\", err) return } s := spaceServer{} server := grpc.NewServer() space.RegisterSearchServiceServer(server, \u0026s) server.Serve(listen) } //具体实现 func registerGetaway() { mux := runtime.NewServeMux() conn, _ := grpc.DialContext( context.Background(), \"127.0.0.1:8888\", grpc.WithBlock(), grpc.WithInsecure(), ) gwServer := \u0026http.Server{ Handler: mux, Addr: \":8090\", } space.RegisterSearchServiceHandler(context.Background(), mux, conn) gwServer.ListenAndServe() } 发送post请求测试 ","date":"2022-11-13","objectID":"/grpc/:4:2","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"Go使用cobra构建命令行工具 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:0:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"安装CLI go install github.com/spf13/cobra-cli@latest ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:1:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"创建项目并引入依赖 # 创建go项目 mkdir my_command cd my_command go mod init my_command # 使用cobra-cli初始化项目 cobra-cli init ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:2:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"测试 go build main.go main root ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:3:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"开发 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"命令 # 添加命令 cobra-cli add version 添加后在cmd下生成一个新的文件 version.go 文件内容略微修改后如下 /* Copyright © 2022 NAME HERE \u003cEMAIL ADDRESS\u003e */ package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) // versionCmd represents the version command var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"一个简短介绍\", Long: `一个长介绍`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version命令操作\") }, } func init() { rootCmd.AddCommand(versionCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // versionCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\") // Cobra supports local flags which will only run when this command // is called directly, e.g.: // versionCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } 执行命令 接受参数 存储在 args中 ... var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"一个简短介绍\", Long: `一个长介绍`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version命令操作\") fmt.Println(args) }, } ... ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:1","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"flag 局部flag 定义变量 /* 定义局部变量 */ var all string 在对应文件的init方法中添加flag versionCmd.Flags().StringVarP(\u0026all, \"all\", \"a\", \"这是默认值\", \"这是一条介绍\") 使用 在run方法中 fmt.Println(\"a参数：\"+all) 完整代码 /* Copyright © 2022 NAME HERE \u003cEMAIL ADDRESS\u003e */ package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) /* 定义局部变量 */ var all string // versionCmd represents the version command var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"一个简短介绍\", Long: `一个长介绍`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version命令操作\") fmt.Println(args) fmt.Println(\"a参数：\"+all) }, } func init() { rootCmd.AddCommand(versionCmd) versionCmd.Flags().StringVarP(\u0026all, \"all\", \"a\", \"这是默认值\", \"这是一条介绍\") //是否必填 默认可以不填 versionCmd.MarkFlagRequired(\"all\") } 演示 全局flag 在root中编写，代码与局部flag相同 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:2","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"嵌套命令 cobra-cli add -p \"父命令Cmd\" # 举例 cobra-cli add show -p \"versionCmd\" 使用 代码解释 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:3","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"获取命令行参数 常用 MinimumNArgs(int) 当参数数目低于配置的最小参数个数时报错 MaximumNArgs(int) 当参数数目大于配置的最大参数个数时报错 ExactArgs(int) 如果参数数目不是配置的参数个数时报错 NoArgs 没有参数则报错 使用 ... var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"一个简短介绍\", Long: `一个长介绍`, Args: cobra.ExactArgs(1), Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version命令操作\") fmt.Println(args) fmt.Println(\"a参数：\"+all) }, } ... 测试 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:4","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["云原生"],"content":"Kubernetes ","date":"2022-07-13","objectID":"/kubernetes/:0:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"命令 # 查看节点状态 kubectl get nodes # ---后缀--- -oyaml 获取yaml # ---pod--- # 创建pod kubectl run mynginx --image=nginx # 跟根据yaml添加pod kubectl apply -f calico.yaml # 查看default名称空间的Pod kubectl get pod watch -n 1 kubectl get pods #使用标签检索Pod kubectl get pod -l app=my-dep # 查看集群部署了哪些应 kubectl get pods -A # 根据命名空间 kubectl get pods -n kubernetes-dashboard # 描述(可以看到具体执行以及在哪个节点上运行) kubectl describe pod 你自己的Pod名字 # 删除 kubectl delete pod Pod名字 # 查看Pod的运行日志 kubectl logs Pod名字 # 获取详细信息 kubectl get pod -owide # 进入容器内部 kubectl exec -it myapp -- /bin/bash # ---命名空间--- # 查看命名空间 kubectl get ns # 创建命名空间 kubectl create ns a # 删除命名空间 kubectl delete ns a # ---deployment--- # 创建 kubectl create deployment mytomcat --image=tomcat:8.5.68 # 查看 kubectl get deploy # 删除 kubectl delete deploy mytomcat # 修改 kubectl edit deployment my-dep # 多副本 --replicas=3 kubectl create deployment my-dep --image=nginx --replicas=3 # 扩缩容 kubectl scale --replicas=5 deployment/my-dep # 版本更新 kubectl set image deployment/my-dep nginx=nginx:1.16.1 --record kubectl set image deployment/[deployment名字] [容器名字]=nginx:1.16.1 --record # 查看容器名字 kubectl get deploy -oyaml # --版本回退-- # 查看状态 kubectl rollout status deployment/my-dep # 历史记录 kubectl rollout history deployment/my-dep # 查看某个历史详情 kubectl rollout history deployment/my-dep --revision=2 # 回滚(回到上次) kubectl rollout undo deployment/my-dep # 回滚(回到指定版本) kubectl rollout undo deployment/my-dep --to-revision=2 # service,ingress 等资源都是可以用get，edit，-oyaml等命令 ","date":"2022-07-13","objectID":"/kubernetes/:1:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"yaml快速编写 使用kubectl create生成yaml文件 # 生成文件内容到控制台 kubectl create deployment web --image=nginx -o yaml --dry-run # 输出内容到文件 kubectl create deployment web --image=nginx -o yaml --dry-run \u003e my.yaml 使用kubectl get命令导出yaml文件 kubectl get deploy nginx -o=yaml --export \u003e my2.yaml ","date":"2022-07-13","objectID":"/kubernetes/:2:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"定义 服务发现和负载均衡 Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。 存储编排 Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。 自动部署和回滚 你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。 自动完成装箱计算 Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。 自我修复 Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。 密钥与配置管理 Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 ","date":"2022-07-13","objectID":"/kubernetes/:3:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"架构 ","date":"2022-07-13","objectID":"/kubernetes/:3:1","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"工作方式 Kubernetes Cluster = N Master Node + N Worker Node：N主节点+N工作节点； N\u003e=1 ","date":"2022-07-13","objectID":"/kubernetes/:3:2","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"组件架构 ","date":"2022-07-13","objectID":"/kubernetes/:4:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"控制平面组件（Control Plane Components） 控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 replicas 字段时，启动新的 pod）。 控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅使用 kubeadm 构建高可用性集群 中关于多 VM 控制平面设置的示例。 kube-apiserver API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。 Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。 etcd etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。 您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。 要了解 etcd 更深层次的信息，请参考 etcd 文档。 kube-scheduler 控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。 调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。 kube-controller-manager 在主节点上运行 控制器 的组件。 从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应 任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod) 服务帐户和令牌控制器（Service Account \u0026 Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌 cloud-controller-manager 云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器允许您链接集群到云提供商的应用编程接口中， 并把和该云平台交互的组件与只和您的集群交互的组件分离开。 cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。 与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。 下面的控制器都包含对云平台驱动的依赖： 节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除 路由控制器（Route Controller）: 用于在底层云基础架构中设置路由 服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器 ","date":"2022-07-13","objectID":"/kubernetes/:4:1","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Node 组件 节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。 kubelet 一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。 kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。 kube-proxy kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。 kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。 如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。 ","date":"2022-07-13","objectID":"/kubernetes/:4:2","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"kubeadm创建集群 ","date":"2022-07-13","objectID":"/kubernetes/:5:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"环境准备 配置yum源 sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo Docker安装 sudo yum install -y docker-ce docker-ce-cli containerd.io sudo yum remove docker* yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6 # 启动 systemctl enable docker --now # 配置加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://lu9qvzo1.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker linux设置 一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux 发行版以及一些不提供包管理器的发行版提供通用的指令 每台机器 2 GB 或更多的 RAM （如果少于这个数字将会影响你应用的运行内存) 2 CPU 核或更多 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以) 设置防火墙放行规则 节点之中不可以有重复的主机名、MAC 地址或 product_uuid。请参见这里了解更多详细信息。 设置不同hostname 开启机器上的某些端口。请参见这里 了解更多详细信息。 内网互信 禁用交换分区。为了保证 kubelet 正常工作，你 必须 禁用交换分区。 永久关闭 #各个机器设置自己的域名 hostnamectl set-hostname xxxx # 将 SELinux 设置为 permissive 模式（相当于将其禁用） sudo setenforce 0 sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config #关闭swap swapoff -a sed -ri 's/.*swap.*/#\u0026/' /etc/fstab #允许 iptables 检查桥接流量 cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system ","date":"2022-07-13","objectID":"/kubernetes/:5:1","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"安装kubelet、kubeadm、kubectl（每台服务器） cat \u003c\u003cEOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes sudo systemctl enable --now kubelet 查看kubelet状态 systemctl status kubelet ","date":"2022-07-13","objectID":"/kubernetes/:5:2","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"使用kubeadm引导集群 下载各个机器需要的镜像 sudo tee ./images.sh \u003c\u003c-'EOF' #!/bin/bash images=( kube-apiserver:v1.20.9 kube-proxy:v1.20.9 kube-controller-manager:v1.20.9 kube-scheduler:v1.20.9 coredns:1.7.0 etcd:3.4.13-0 pause:3.2 ) for imageName in ${images[@]} ; do docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageName done EOF chmod +x ./images.sh \u0026\u0026 ./images.sh 初始化主节点 #所有机器添加master域名映射，以下需要修改为自己的 echo \"172.16.1.3 cluster-endpoint\" \u003e\u003e /etc/hosts #主节点初始化 kubeadm init \\ --apiserver-advertise-address=172.16.1.3 \\ --control-plane-endpoint=cluster-endpoint \\ --image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \\ --kubernetes-version v1.20.9 \\ --service-cidr=10.96.0.0/16 \\ --pod-network-cidr=192.168.0.0/16 #所有网络范围不重叠 成功后提示 Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ You can now join any number of control-plane nodes by copying certificate authorities and service account keys on each node and then running the following as root: kubeadm join cluster-endpoint:6443 --token 9o3q1b.z2sxmoppiqf9yh5j \\ --discovery-token-ca-cert-hash sha256:f5cee157412f35851006863d1d26478ae692c3eaa03486604c4493118e47d39a \\ --control-plane Then you can join any number of worker nodes by running the following on each as root: kubeadm join cluster-endpoint:6443 --token 9o3q1b.z2sxmoppiqf9yh5j \\ --discovery-token-ca-cert-hash sha256:f5cee157412f35851006863d1d26478ae692c3eaa03486604c4493118e47d39a 根据提示操作 创建 .kube mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 配置网络插件 # 注意版本 curl https://docs.projectcalico.org/manifests/calico.yaml -O curl https://docs.projectcalico.org/v3.18/manifests/calico.yaml -O kubectl apply -f calico.yaml 在其他节点加入 新令牌 kubeadm token create –print-join-command master kubeadm join cluster-endpoint:6443 --token 9o3q1b.z2sxmoppiqf9yh5j \\ --discovery-token-ca-cert-hash sha256:f5cee157412f35851006863d1d26478ae692c3eaa03486604c4493118e47d39a \\ --control-plane node kubeadm join cluster-endpoint:6443 --token 9o3q1b.z2sxmoppiqf9yh5j \\ --discovery-token-ca-cert-hash sha256:f5cee157412f35851006863d1d26478ae692c3eaa03486604c4493118e47d39a 验证 kubectl get nodes ","date":"2022-07-13","objectID":"/kubernetes/:5:3","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"部署dashboard 启动 curl https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml -O kubectl apply -f recommended.yaml 设置访问端口 # type: ClusterIP 改为 type: NodePort kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard ## 找到端口，在安全组放行 kubectl get svc -A |grep kubernetes-dashboard 创建访问账号 #创建访问账号，准备一个yaml文件； vi dash.yaml apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard kubectl apply -f dash.yaml 获取访问令牌 kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=\"{.secrets[0].name}\") -o go-template=\"{{.data.token | base64decode}}\" 隐私错误 ，直接输入thisisunsafe ","date":"2022-07-13","objectID":"/kubernetes/:5:4","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"安装文件系统 安装nfs # 在每个机器。 yum install -y nfs-utils # 在master 执行以下命令 echo \"/nfs/data/ *(insecure,rw,sync,no_root_squash)\" \u003e /etc/exports # 执行以下命令，启动 nfs 服务;创建共享目录 mkdir -p /nfs/data # 在master执行 systemctl enable rpcbind systemctl enable nfs-server systemctl start rpcbind systemctl start nfs-server # 使配置生效 exportfs -r #检查配置是否生效 exportfs 从节点 showmount -e [masterip] mkdir -p /nfs/data mount -t nfs [masterip]:/nfs/data /nfs/data 配置默认存储 注意修改ip ## 创建了一个存储类 apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-storage annotations: storageclass.kubernetes.io/is-default-class: \"true\" provisioner: k8s-sigs.io/nfs-subdir-external-provisioner parameters: archiveOnDelete: \"true\" ## 删除pv的时候，pv的内容是否要备份 --- apiVersion: apps/v1 kind: Deployment metadata: name: nfs-client-provisioner labels: app: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default spec: replicas: 1 strategy: type: Recreate selector: matchLabels: app: nfs-client-provisioner template: metadata: labels: app: nfs-client-provisioner spec: serviceAccountName: nfs-client-provisioner containers: - name: nfs-client-provisioner image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/nfs-subdir-external-provisioner:v4.0.2 # resources: # limits: # cpu: 10m # requests: # cpu: 10m volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME value: k8s-sigs.io/nfs-subdir-external-provisioner - name: NFS_SERVER value: 172.31.0.4 ## 指定自己nfs服务器地址 - name: NFS_PATH value: /nfs/data ## nfs服务器共享的目录 volumes: - name: nfs-client-root nfs: server: 172.31.0.4 path: /nfs/data --- apiVersion: v1 kind: ServiceAccount metadata: name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-client-provisioner-runner rules: - apiGroups: [\"\"] resources: [\"nodes\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"\"] resources: [\"persistentvolumes\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"delete\"] - apiGroups: [\"\"] resources: [\"persistentvolumeclaims\"] verbs: [\"get\", \"list\", \"watch\", \"update\"] - apiGroups: [\"storage.k8s.io\"] resources: [\"storageclasses\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"\"] resources: [\"events\"] verbs: [\"create\", \"update\", \"patch\"] --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: run-nfs-client-provisioner subjects: - kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default roleRef: kind: ClusterRole name: nfs-client-provisioner-runner apiGroup: rbac.authorization.k8s.io --- kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: leader-locking-nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default rules: - apiGroups: [\"\"] resources: [\"endpoints\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\"] --- kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: leader-locking-nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default subjects: - kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default roleRef: kind: Role name: leader-locking-nfs-client-provisioner apiGroup: rbac.authorization.k8s.io ","date":"2022-07-13","objectID":"/kubernetes/:5:5","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"安装metrics-server 集群指标监控组件 apiVersion: v1 kind: ServiceAccount metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: k8s-app: metrics-server rbac.authorization.k8s.io/aggregate-to-admin: \"true\" rbac.authorization.k8s.io/aggregate-to-edit: \"true\" rbac.authorization.k8s.io/aggregate-to-view: \"true\" name: system:aggregated-metrics-reader rules: - apiGroups: - metrics.k8s.io resources: - pods - nodes verbs: - get - list - watch --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: k8s-app: metrics-server name: system:metrics-server rules: - apiGroups: - \"\" resources: - pods - nodes - nodes/stats - namespaces - configmaps verbs: - get - list - watch --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: labels: k8s-app: metrics-server name: metrics-server-auth-reader namespace: kube-system roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: extension-apiserver-authentication-reader subjects: - kind: ServiceAccount name: metrics-server namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: labels: k8s-app: metrics-server name: metrics-server:system:auth-delegator roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:auth-delegator subjects: - kind: ServiceAccount name: metrics-server namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: labels: k8s-app: metrics-server name: system:metrics-server roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:metrics-server subjects: - kind: ServiceAccount name: metrics-server namespace: kube-system --- apiVersion: v1 kind: Service metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system spec: ports: - name: https port: 443 protocol: TCP targetPort: https selector: k8s-app: metrics-server --- apiVersion: apps/v1 kind: Deployment metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system spec: selector: matchLabels: k8s-app: metrics-server strategy: rollingUpdate: maxUnavailable: 0 template: metadata: labels: k8s-app: metrics-server spec: containers: - args: - --cert-dir=/tmp - --kubelet-insecure-tls - --secure-port=4443 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-use-node-status-port image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/metrics-server:v0.4.3 imagePullPolicy: IfNotPresent livenessProbe: failureThreshold: 3 httpGet: path: /livez port: https scheme: HTTPS periodSeconds: 10 name: metrics-server ports: - containerPort: 4443 name: https protocol: TCP readinessProbe: failureThreshold: 3 httpGet: path: /readyz port: https scheme: HTTPS periodSeconds: 10 securityContext: readOnlyRootFilesystem: true runAsNonRoot: true runAsUser: 1000 volumeMounts: - mountPath: /tmp name: tmp-dir nodeSelector: kubernetes.io/os: linux priorityClassName: system-cluster-critical serviceAccountName: metrics-server volumes: - emptyDir: {} name: tmp-dir --- apiVersion: apiregistration.k8s.io/v1 kind: APIService metadata: labels: k8s-app: metrics-server name: v1beta1.metrics.k8s.io spec: group: metrics.k8s.io groupPriorityMinimum: 100 insecureSkipTLSVerify: true service: name: metrics-server namespace: kube-system version: v1beta1 versionPriority: 100 ","date":"2022-07-13","objectID":"/kubernetes/:5:6","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"核心 ","date":"2022-07-13","objectID":"/kubernetes/:6:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"总结 资源创建两种方式 命令行 yaml文件 ","date":"2022-07-13","objectID":"/kubernetes/:6:1","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Namespace 命令行 # 查看命名空间 kubectl get ns # 创建命名空间 kubectl create ns a # 删除命名空间 kubectl delete ns a # 如果是使用文件创建的，还可以治直接使用文件删除 kubectl delete -f hello.yaml yaml文件 apiVersion: v1 kind: Namespace metadata: name: hello ","date":"2022-07-13","objectID":"/kubernetes/:6:2","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Pod 运行中的一组容器，Pod是kubernetes中应用的最小单位 命令行 kubectl run mynginx --image=nginx # 查看default名称空间的Pod kubectl get pod # 描述(可以看到具体执行以及在哪个节点上运行) kubectl describe pod 你自己的Pod名字 # 删除 kubectl delete pod Pod名字 # 查看Pod的运行日志 kubectl logs Pod名字 # 每个Pod - k8s都会分配一个ip kubectl get pod -owide # 进入容器内部 kubectl exec -it myapp -- /bin/bash # 集群中的任意一个机器以及任意的应用都能通过Pod分配的ip来访问这个Pod 配置文件 apiVersion: v1 kind: Pod metadata: labels: run: mynginx name: mynginx # namespace: default spec: containers: - image: nginx name: mynginx apiVersion: v1 kind: Pod metadata: labels: run: myapp name: myapp spec: containers: - image: nginx name: nginx - image: tomcat:8.5.68 name: tomcat 特性 同一个pod中的容器共享网络(同ip，端口) 同一个pod中的容器共享存储 镜像拉取策略 IfNotPresent:默认值，镜像不存在时拉取 Always:每次都拉取 Never:永远不主动拉取 apiVersion: v1 kind: Pod metadata: name: myapp spec: containers: - image: nginx name: nginx imagePullPolicy: Always 资源限制 sepc: containers: - name: db image: mysql resources: # 调度资源限制(最大) requests: memory: \"64Mi\" # 1核 = 1000m cpu: \"250m\" # 运行时资源限制(最大) limits: memory: \"128Mi\" cpu: \"500m\" restartPolicy: Always 重启机制 Always:总是重启(默认) OnFailure:异常退出（状态码非0），才重启 Never:从不重启 sepc: containers: - name: db image: mysql restartPolicy: Always 健康检查 检查方式 livenessProbe(存活检查) readinessProbe(就绪检查) 检查方法 httpGet exec topSocket 调度策略 影响调度的属性 资源限制 节点选择器 对节点打标签 # 打标签 kubectl label node node01 env_role=prod # 查看标签 kubectl get node --show-labels 使用 apiVersion: v1 kind: Pod metadata: name: myapp spec: nodeSelector: env_role: prod containers: - image: nginx name: nginx imagePullPolicy: Always 节点亲和性 硬亲和性(约束条件必须满足) 软亲和性(尝试满足) 污点和污点容忍(节点属性) 查看污点情况 kubectl describe node k8s-master01 | grep Taint 三种情况 NoSchedule:一定不被调度 PreferNoSchdule:尽量不被调度 NoExecute:不会被调度，而且还会驱逐Node已有Pod 创建污点 kubeclt taint node [node] [key]=[value]:[污点的三种情况] ## 举例 kubeclt taint node k8s-master01 env_role=yes:NoSchedule 删除污点 kubeclt taint node [node] key:[污点的三种情况]- ## 举例 kubeclt taint node k8s-master01 key:NoSchedule- 污点容忍 spec: tolerations: - key: \"key1\" operator: \"Equal\" value: \"value1\" effect: \"NoSchedule\" - key: \"key1\" operator: \"Equal\" value: \"value1\" effect: \"NoExecute\" - key: \"node.alpha.kubernetes.io/unreachable\" operator: \"Exists\" effect: \"NoExecute\" tolerationSeconds: 6000 ","date":"2022-07-13","objectID":"/kubernetes/:6:3","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Deployment(一种工作负载) 控制Pod，使Pod拥有多副本，自愈，扩缩容等能力 操作 命令行 # 创建 kubectl create deployment mytomcat --image=tomcat:8.5.68 # 查看 kubectl get deploy # 删除 kubectl delete deploy mytomcat # 修改 kubectl edit deployment my-dep # 多副本 --replicas=3 kubectl create deployment my-dep --image=nginx --replicas=3 # 扩缩容 kubectl scale --replicas=5 deployment/my-dep # 版本更新 kubectl set image deployment/my-dep nginx=nginx:1.16.1 --record kubectl set image deployment/[deployment名字] [容器名字]=nginx:1.16.1 --record # 查看容器名字 kubectl get deploy -oyaml # --版本回退-- # 查看状态 kubectl rollout status deployment/my-dep # 历史记录 kubectl rollout history deployment/my-dep # 查看某个历史详情 kubectl rollout history deployment/my-dep --revision=2 # 回滚(回到上次) kubectl rollout undo deployment/my-dep # 回滚(回到指定版本) kubectl rollout undo deployment/my-dep --to-revision=2 yaml apiVersion: apps/v1 kind: Deployment metadata: labels: app: my-dep name: my-dep spec: replicas: 3 selector: matchLabels: app: my-dep template: metadata: labels: app: my-dep spec: containers: - image: nginx name: nginx 特性 自愈 多副本 扩缩容 滚动更新 版本回退 ","date":"2022-07-13","objectID":"/kubernetes/:6:4","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Service 统一多个pod对外统一暴露端口，负载均衡 使用ip或者域名访问 域名只能在pod(可以不在一个service中)中使用，不可以在主机上使用 域名规则：服务名.所在空间名称.svc(my-dep.default.svc) 命令 #创建 默认 --type=ClusterIP kubectl expose deployment my-dep --port=8000 --target-port=80 #对外暴露端口 kubectl expose deployment my-dep --port=8000 --target-port=80 --type=NodePort # 获取列表 kubectl get service # 删除 kubectl delete svc my-dep yaml apiVersion: v1 kind: Service metadata: labels: app: my-dep name: my-dep spec: selector: app: my-dep ports: - port: 8000 protocol: TCP targetPort: 80 ClusterIP 不对外暴露，只有集群内部可以访问 NodePort 对外暴露端口 ","date":"2022-07-13","objectID":"/kubernetes/:6:5","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Ingress 官网 安装 wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml kubectl apply deploy.yaml 使用 #获取网关端口 kubectl get svc -A 创建测试环境 vi test.yaml kubectl apply -f test.yaml test.yaml apiVersion: apps/v1 kind: Deployment metadata: name: hello-server spec: replicas: 2 selector: matchLabels: app: hello-server template: metadata: labels: app: hello-server spec: containers: - name: hello-server image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server ports: - containerPort: 9000 --- apiVersion: apps/v1 kind: Deployment metadata: labels: app: nginx-demo name: nginx-demo spec: replicas: 2 selector: matchLabels: app: nginx-demo template: metadata: labels: app: nginx-demo spec: containers: - image: nginx name: nginx --- apiVersion: v1 kind: Service metadata: labels: app: nginx-demo name: nginx-demo spec: selector: app: nginx-demo ports: - port: 8000 protocol: TCP targetPort: 80 --- apiVersion: v1 kind: Service metadata: labels: app: hello-server name: hello-server spec: selector: app: hello-server ports: - port: 8000 protocol: TCP targetPort: 9000 需求： 访问sit.jsh.com转给服务nginx-demo,访问uat.jsh.com转给服务hello-server 实现： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ingress-host-bar spec: ingressClassName: nginx rules: - host: \"uat.jsh.com\" http: paths: - pathType: Prefix path: \"/\" backend: service: name: hello-server port: number: 8000 - host: \"sit.jsh.com\" http: paths: - pathType: Prefix path: \"/nginx\" # 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404 backend: service: name: nginx-demo ## java，比如使用路径重写，去掉前缀nginx port: number: 8000 路径重写 - host: \"sit.jsh.com\" http: paths: - pathType: Prefix path: \"/nginx(/|$)(.*)\" # backend: service: name: nginx-demo ## java，比如使用路径重写，去掉前缀nginx port: number: 8000 ","date":"2022-07-13","objectID":"/kubernetes/:6:6","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"存储 环境准备 所有节点 #所有机器安装 yum install -y nfs-utils 主节点:暴露目录 #nfs主节点 echo \"/nfs/data/ *(insecure,rw,sync,no_root_squash)\" \u003e /etc/exports mkdir -p /nfs/data systemctl enable rpcbind --now systemctl enable nfs-server --now #配置生效 exportfs -r 从节点 showmount -e 172.16.1.3 #执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount mkdir -p /nfs/data mount -t nfs 172.16.1.3:/nfs/data /nfs/data # 写入一个测试文件 echo \"hello nfs server\" \u003e /nfs/data/test.txt 原生方式数据挂载 Pod 删除后数据不会自动删除 apiVersion: apps/v1 kind: Deployment metadata: labels: app: nginx-pv-demo name: nginx-pv-demo spec: replicas: 2 selector: matchLabels: app: nginx-pv-demo template: metadata: labels: app: nginx-pv-demo spec: containers: - image: nginx name: nginx volumeMounts: - name: html mountPath: /usr/share/nginx/html volumes: - name: html nfs: server: 172.16.1.3 path: /nfs/data/nginx-pv PV\u0026PVC PV：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置 PVC：持久卷申明（Persistent Volume Claim），申明需要使用的持久卷规格 创建pv池 准备 #nfs主节点 mkdir -p /nfs/data/01 mkdir -p /nfs/data/02 mkdir -p /nfs/data/03 创建 apiVersion: v1 kind: PersistentVolume metadata: name: pv01-10m spec: capacity: storage: 10M accessModes: - ReadWriteMany storageClassName: nfs nfs: path: /nfs/data/01 server: 172.16.1.3 --- apiVersion: v1 kind: PersistentVolume metadata: name: pv02-1gi spec: capacity: storage: 1Gi accessModes: - ReadWriteMany storageClassName: nfs nfs: path: /nfs/data/02 server: 172.16.1.3 --- apiVersion: v1 kind: PersistentVolume metadata: name: pv03-3gi spec: capacity: storage: 3Gi accessModes: - ReadWriteMany storageClassName: nfs nfs: path: /nfs/data/03 server: 172.16.1.3 创建pvc kind: PersistentVolumeClaim apiVersion: v1 metadata: name: nginx-pvc spec: accessModes: - ReadWriteMany resources: requests: storage: 200Mi storageClassName: nfs 绑定pvc和pod apiVersion: apps/v1 kind: Deployment metadata: labels: app: nginx-deploy-pvc name: nginx-deploy-pvc spec: replicas: 2 selector: matchLabels: app: nginx-deploy-pvc template: metadata: labels: app: nginx-deploy-pvc spec: containers: - image: nginx name: nginx volumeMounts: - name: html mountPath: /usr/share/nginx/html volumes: - name: html persistentVolumeClaim: claimName: nginx-pvc ConfigMap 主要存放配置，可以实时更新 创建配置文件redis.conf appendonly yes 创建配置集 kubectl create cm redis-conf --from-file=redis.conf # 查看详情 kubectl get cm redis-conf -oyaml 创建pod apiVersion: v1 kind: Pod metadata: name: redis spec: containers: - name: redis image: redis command: - redis-server - \"/redis-master/redis.conf\" #指的是redis容器内部的位置 ports: - containerPort: 6379 volumeMounts: - mountPath: /data name: data - mountPath: /redis-master name: config volumes: - name: data emptyDir: {} - name: config configMap: name: redis-conf items: - key: redis.conf path: redis.conf 进入pod验证 kubectl exec -it redis -- redis-cli CONFIG GET appendonly Secret Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 Pod 的定义或者 容器镜像 中来说更加安全和灵活。 定义 kubectl create secret docker-registry my-docker \\ --docker-username=xxx \\ --docker-password=xxx \\ --docker-email=xxx@xxxx ##命令格式 kubectl create secret docker-registry regcred \\ --docker-server=\u003c你的镜像仓库服务器\u003e \\ --docker-username=\u003c你的用户名\u003e \\ --docker-password=\u003c你的密码\u003e \\ --docker-email=\u003c你的邮箱地址\u003e 使用 apiVersion: v1 kind: Pod metadata: name: private-nginx spec: containers: - name: private-nginx image: xxxxxxxx imagePullSecrets: - name: my-docker ","date":"2022-07-13","objectID":"/kubernetes/:6:7","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"安全机制 官网 ","date":"2022-07-13","objectID":"/kubernetes/:6:8","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"监控 Prometheus+Grafana ","date":"2022-07-13","objectID":"/kubernetes/:6:9","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"附录 ","date":"2022-07-13","objectID":"/kubernetes/:7:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"微服务javaDockerFile docker build -t loca-dup:1.0 . FROM openjdk:8-jdk LABEL maintainer=coderabbit #docker run -e PARAMS=\"--server.port 9090\" ENV PARAMS=\"--server.port=8080 --spring.profiles.active=prod --spring.cloud.nacos.discovery.server-addr=his-nacos.his:8848 --spring.cloud.nacos.config.server-addr=his-nacos.his:8848 --spring.cloud.nacos.config.namespace=prod --spring.cloud.nacos.config.file-extension=yml\" RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026\u0026 echo 'Asia/Shanghai' \u003e/etc/timezone COPY target/*.jar /app.jar EXPOSE 8080 # ENTRYPOINT [\"/bin/sh\",\"-c\",\"java -Dfile.encoding=utf8 -Djava.security.egd=file:/dev/./urandom -jar app.jar ${PARAMS}\"] $ docker login --username=xxxx registry.cn-hangzhou.aliyuncs.com #把本地镜像，改名，成符合阿里云名字规范的镜像。 $ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/镜像名:[镜像版本号] ## docker tag 393f2ccae8fb registry.cn-hangzhou.aliyuncs.com/jsh_aliyun/f-dup:1.2.6 $ docker push registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/镜像名:[镜像版本号] ## docker push registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-visual-monitor:v1 ","date":"2022-07-13","objectID":"/kubernetes/:8:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["工具"],"content":"FRP 内网穿透 ","date":"2022-05-29","objectID":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:0:0","tags":["frp"],"title":"FRP 内网穿透","uri":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["工具"],"content":"准备 一台拥有公网ip的服务器 ","date":"2022-05-29","objectID":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:0","tags":["frp"],"title":"FRP 内网穿透","uri":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["工具"],"content":"服务器端安装配置FRPS 下载文件 github地址 wget https://github.com/fatedier/frp/releases/download/v0.43.0/frp_0.43.0_linux_amd64.tar.gz 解压 tar -zxvf frp_0.43.0_linux_amd64.tar.gz 配置 frps.ini [common] # 端口 bind_port = 7000 # 密码token token = xxxxxxx 创建Systemctl后台启动 vim /lib/systemd/system/frps.service [Unit] Description=fraps service After=network.target syslog.target Wants=network.target [Service] Type=simple ExecStart=/root/frp/frps -c /root/frp/frps.ini # 根据实际情况修改 [Install] WantedBy=multi-user.target 启动服务设置随系统启动 //设置随系统启动 systemctl enable frps //启动 systemctl start frps //查看启动情况:查看进程 ps auxw ","date":"2022-05-29","objectID":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:2:0","tags":["frp"],"title":"FRP 内网穿透","uri":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["工具"],"content":"客户端安装配置FRPC 下载对应系统的文件 配置frpc.ini [common] //服务器ip server_addr = 123.57.48.176 //服务器端口 server_port = 7000 //密码 token = xxxxx //服务一 [mysql] type = tcp local_ip = 127.0.0.1 local_port = 3306 //映射到服务器的端口 remote_port = 9999 //服务二 不能重名 [mysql2] type = tcp local_ip = 127.0.0.1 local_port = xxxx remote_port = 9999 启动 ./frpc -c frpc.ini Mac 开机自启动 编写脚本 sudo vim /Library/LaunchDaemons/frpc.plist \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//EN http://www.apple.com/DTDs/PropertyList-1.0.dtd \u003e \u003cplist version=\"1.0\"\u003e \u003cdict\u003e \u003ckey\u003eLabel\u003c/key\u003e \u003cstring\u003efrpc\u003c/string\u003e \u003ckey\u003eProgramArguments\u003c/key\u003e \u003carray\u003e \u003cstring\u003e/Users/mr_j/frpc/frpc\u003c/string\u003e \u003cstring\u003e-c\u003c/string\u003e \u003cstring\u003e/Users/mr_j/frpc/frpc.ini\u003c/string\u003e \u003c/array\u003e \u003ckey\u003eKeepAlive\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eRunAtLoad\u003c/key\u003e \u003ctrue/\u003e \u003c/dict\u003e \u003c/plist\u003e 赋权并让生效 sudo chown root /Library/LaunchDaemons/frpc.plist sudo launchctl load -w /Library/LaunchDaemons/frpc.plist 取消自启动 sudo launchctl unload -w /Library/LaunchDaemons/frpc.plist ","date":"2022-05-29","objectID":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:3:0","tags":["frp"],"title":"FRP 内网穿透","uri":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["Spring","SpringCloud"],"content":"spring-cloud-stream 3.x 开发 ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:0:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"基本使用 ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:1:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"基本配置 依赖 implementation 'org.springframework.cloud:spring-cloud-stream:3.2.3' 配置 spring: rabbitmq: host: 127.0.0.1 port: 5672 username: username password: password ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:1:1","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"生产者 配置 注意：analysePdf-out-0，analysePdf发送消息，接收消息都需要使用 spring: cloud: stream: rabbit: bindings: analysePdf-out-0: producer: destination: analysePdf content-type: application/json bindings: analysePdf-out-0: destination: analysePdf 代码 @Autowired private StreamBridge streamBridge; public void sendMethod() { //与配置文件中相同 streamBridge.send(\"analysePdf-out-0\", \"pdf\"+i); } ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:1:2","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"消费者 配置 spring: cloud: stream: rabbit: bindings: analysePdf-in-0: consumer: destination: analysePdf content-type: application/json bindings: analysePdf-in-0: destination: analysePdf 代码 注意：方法名需要和配置中心中相同 @Configuration public class Test { @Bean(\"analysePdf\") //方法名与配置中相同 public Consumer\u003cString\u003e analysePdf() { return str -\u003e { System.out.println(\"analysePdf: \" + str); }; } } ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:1:3","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"消息分组(多实例下避免重复消费) 消费者配置：group: in，配置后同组消费者下只能消费一次 spring: cloud: stream: rabbit: bindings: analysePdf-in-0: consumer: destination: analysePdf content-type: application/json bindings: analysePdf-in-0: group: in destination: analysePdf ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:2:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"ack配置 消费者配置：acknowledge-mode: auto spring: cloud: stream: rabbit: bindings: analysePdf-in-0: consumer: destination: analysePdf content-type: application/json #ack模式 acknowledge-mode: auto #重试次数 max-attempts: 5 bindings: analysePdf-in-0: group: in destination: analysePdf ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:3:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"多消息使用 注意配置,其他配置重复一遍 spring: cloud: function: definition: 完整配置 spring: cloud: function: definition: analysePdf;jsh stream: rabbit: bindings: analysePdf-in-0: consumer: destination: analysePdf content-type: application/json #ack模式 acknowledge-mode: auto #重试次数 max-attempts: 5 analysePdf-out-0: producer: destination: analysePdf content-type: application/json jsh-in-0: consumer: destination: jsh content-type: application/json jsh-out-0: producer: destination: jsh content-type: application/json bindings: analysePdf-in-0: group: in destination: analysePdf analysePdf-out-0: destination: analysePdf jsh-in-0: group: in destination: jsh jsh-out-0: destination: jsh Spring Cloud Stream 官网 源码地址 ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:4:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring"],"content":"springboot自定义异步线程池 ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:0:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Spring"],"content":"自定义线程池 @Configuration @EnableAsync public class SyncConfiguration{ @Bean(name = \"asyncPoolTaskExecutor\") public ThreadPoolTaskExecutor executor() { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); //核心线程数 taskExecutor.setCorePoolSize(1); //线程池维护线程的最大数量,只有在缓冲队列满了之后才会申请超过核心线程数的线程 taskExecutor.setMaxPoolSize(2); //缓存队列 taskExecutor.setQueueCapacity(2); //许的空闲时间,当超过了核心线程出之外的线程在空闲时间到达之后会被销毁 taskExecutor.setKeepAliveSeconds(200); //异步方法内部线程名称 taskExecutor.setThreadNamePrefix(\"async-\"); /** * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略 * 通常有以下四种策略： * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） * ThreadPoolExecutor.CallerRunsPolicy：直接主线程执行 */ taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); taskExecutor.initialize(); return taskExecutor; } } ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:1:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Spring"],"content":"使用 在注解中添加bean名称 @Async(\"asyncPoolTaskExecutor\") public void doTask1() throws InterruptedException { long t1 = System.currentTimeMillis(); Thread.sleep(2000); long t2 = System.currentTimeMillis(); log.info(\"task1 cost {} ms\" , t2-t1); } ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Spring"],"content":"设置为Async默认线程池 继承AsyncConfigurer，重写getAsyncExecutor方法 @Configuration @EnableAsync public class SyncConfiguration implements AsyncConfigurer{ private final Logger log = LoggerFactory.getLogger(SyncConfiguration.class); @Bean(name = \"asyncPoolTaskExecutor\") public ThreadPoolTaskExecutor executor() { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); //核心线程数 taskExecutor.setCorePoolSize(1); //线程池维护线程的最大数量,只有在缓冲队列满了之后才会申请超过核心线程数的线程 taskExecutor.setMaxPoolSize(2); //缓存队列 taskExecutor.setQueueCapacity(2); //许的空闲时间,当超过了核心线程出之外的线程在空闲时间到达之后会被销毁 taskExecutor.setKeepAliveSeconds(200); //异步方法内部线程名称 taskExecutor.setThreadNamePrefix(\"async-\"); /** * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略 * 通常有以下四种策略： * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） * ThreadPoolExecutor.CallerRunsPolicy：直接主线程执行 */ taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); taskExecutor.initialize(); return taskExecutor; } /** * 指定默认线程池 */ @Override public Executor getAsyncExecutor() { return executor(); } @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return (ex, method, params) -\u003e log.error(\"线程池执行任务发送未知错误,执行方法：{}\",method.getName(),ex); } } ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Spring"],"content":"备注 如果使用AbortPolicy处理策略，可以增加异常处理器，捕获RejectedExecutionException异常处理 ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Java"],"content":"使用Enum和异常控制器 目的：避免定义各种异常类 基础：已经做了统一返回处理 Enum public enum ResultCodeEnum { /** * 成功 */ SUCCESS(200, \"操作成功\"), /** * 系统错误 */ ERROR(500, \"系统错误\"), /** * 操作失败 */ FAILED(101, \"操作失败\"), /** * 参数错误 */ PARAM_ERROR(103, \"参数错误\"), /** * 参数错误-已存在 */ INVALID_PARAM_EXIST(104, \"请求参数已存在\"), /** * 参数错误 */ INVALID_PARAM_EMPTY(105, \"请求参数为空\"), /** * 参数错误 */ PARAM_TYPE_MISMATCH(106, \"参数类型不匹配\"), /** * 参数错误 */ PARAM_VALID_ERROR(107, \"参数校验失败\"), /** * 参数错误 */ ILLEGAL_REQUEST(108, \"非法请求\"); public int code; public String msg; ResultCodeEnum(int code, String msg) { this.code = code; this.msg = msg; } public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } 自定义业务异常类 public class BusinessException extends RuntimeException { private int code; private String msg; public BusinessException() { this.code = ResultCodeEnum.FAILED.code; this.msg = ResultCodeEnum.FAILED.msg; } public BusinessException(String message) { this.code = ResultCodeEnum.FAILED.code; this.msg = message; } public BusinessException(ResultCodeEnum resultCodeEnum){ this.code = resultCodeEnum.code; this.msg = resultCodeEnum.msg; } public BusinessException(int code, String msg) { this.code = code; this.msg = msg; } public BusinessException(Throwable cause) { super(cause); } public BusinessException(String message, Throwable cause) { super(message, cause); } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public int getCode() { return code; } public void setCode(int code) { this.code = code; } } 异常控制器 @ControllerAdvice public class RestResultExceptionHandler { @ResponseBody @ExceptionHandler(value = RuntimeException.class) public RestResult\u003c?\u003e handleRunTimeException(RuntimeException e) { return RestResultUtils.failedWithMsg(500, e.getMessage()); } /** * 自定义业务异常-BusinessException */ @ResponseBody @ExceptionHandler(value = {BusinessException.class}) public AjaxResult handlerCustomException(BusinessException exception) { return AjaxResult.error(exception.getCode(), exception.getMsg()); } } ","date":"2022-03-18","objectID":"/%E4%BD%BF%E7%94%A8enum%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E5%99%A8/:0:0","tags":[],"title":"使用Enum和异常控制器","uri":"/%E4%BD%BF%E7%94%A8enum%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["Java"],"content":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:0:0","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"需求 无缝(通过配置，不改代码)切换外网模式和内网模式(阿里云和MINIO) 文件前端直传(需要后端签名)，节约自己服务器的网络资源 私有读写，如果需要向后端发起请求获取签名 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:1:0","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"实现 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:0","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"UML图 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:1","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"工厂模式实现(后端代码) 配置 oss: # 使用oss的模式 # 1. ALIYUN # 2. MINIO mode: ALIYUN # 上传目录，这里如果不想加，别的地方到处加 dir: test/ # 上传url过期时间 单位 s updateExpiryTime: 600 # 查看过期时间 单位 s downloadExpiryTime: 600 #阿里oss配置 aliyun: endpoint: keyid: keysecret: bucketname: #minio配置 minio: endpoint: keyid: keysecret: bucketName: 编写OSS接口，每一种oss模式都需要实现其所有方法 public interface OssInterface { /** * 文件上传 * @param file * @param objectName * @return */ String uploadFile(MultipartFile file, String objectName); /** * 判断文件是否存在 * @param objectName * @return */ boolean existFile(String objectName); /** * 获取上传签名 * @return */ OssRequestData getPolicy(String dir,String fileName); /** * 获取查看签名 */ String getExpiration(String objectName); } 编写实现类 AliOssService @Service public class AliOssService implements OssInterface { String endpoint = AliyunConstantPropertiesUtils.END_POINT; String accessKeyId = AliyunConstantPropertiesUtils.KEY_ID; String accessKeySecret = AliyunConstantPropertiesUtils.KEY_SECRET; String bucketName = AliyunConstantPropertiesUtils.BUCKET_NAME; /** * 文件上传 * * @param file * @return */ @Override public String uploadFile(MultipartFile file, String objectName) { OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { // 上传文件流。 InputStream inputStream = file.getInputStream(); //获取文件名称 //第一个参数 Bucket名称 //第二个参数 文件路径和文件名称 //第三个参数 文件输入流 ossClient.putObject(bucketName, objectName, inputStream); // 关闭OSSClient。 ossClient.shutdown(); //上传之后的文件路径返回 //需要手动拼接 return \"https://\" + bucketName + \".\" + endpoint + \"/\" + objectName; } catch (Exception e) { e.printStackTrace(); return null; } } /** * 判断文件是否存在 */ @Override public boolean existFile(String objectName) { // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); boolean found = ossClient.doesObjectExist(bucketName, objectName); ossClient.shutdown(); return found; } /** * 签名 */ @Override public OssRequestData getPolicy(String dir,String fileName){ fileName = UUID.randomUUID()+\"_\"+fileName; String host = \"https://\" + bucketName + \".\" + endpoint; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); OssRequestData ossRequestData =null; try { long expireEndTime = System.currentTimeMillis() + OssConstantPropertiesUtils.UPDATE_EXPIRY_TIME * 1000; Date expiration = new Date(expireEndTime); // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。 PolicyConditions policyConds = new PolicyConditions(); policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000); policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir+fileName); String postPolicy = ossClient.generatePostPolicy(expiration, policyConds); byte[] binaryData = postPolicy.getBytes(StandardCharsets.UTF_8); String encodedPolicy = BinaryUtil.toBase64String(binaryData); String postSignature = ossClient.calculatePostSignature(postPolicy); FormData formData = new FormData(accessKeyId,encodedPolicy,postSignature,dir,dir+fileName,fileName,String.valueOf(expireEndTime / 1000)); ossRequestData = new OssRequestData(host,\"file\",true,\"post\",formData); } catch (Exception e) { System.out.println(e.getMessage()); } finally { ossClient.shutdown(); } return ossRequestData; } /** * 获取签名授权访问 * @param objectName * @return */ @Override public String getExpiration(String objectName){ OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); Date expiration = new Date(System.currentTimeMillis() + OssConstantPropertiesUtils.DOWNLOAD_EXPIRY_TIME * 1000); URL url = ossClient.generatePresignedUrl(bucketName, objectName, expiration); ossClient.shutdown(); return url.toString(); } } MinIOOssService @Service public class MinIOOssService implements OssInterface { String endpoint = MinIOConstantPropertiesUtils.END_POINT; String accessKeyId = MinIOConstantPropertiesUtils.KEY_ID; String accessKeySecret = MinIOConstantPropertiesUtils.KEY_SECRET; String bucketName = MinIOConstantProperties","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:2","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"前端适配 \u003ctemplate\u003e \u003cdiv class=\"home\" style=\"height: 100%\"\u003e \u003cel-upload :action=\"123\" :data=\"dataObj\" :http-request=\"upload\" list-type=\"picture\" :multiple=\"false\" :file-list=\"fileList\" \u003e \u003cel-button size=\"small\" type=\"primary\"\u003e点击上传\u003c/el-button\u003e \u003c/el-upload\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import axios from 'axios' export default { name: 'Home', props: { value: String }, data() { return { fileList: [], } }, methods: { //向后端请求上传签名 upload(item) { //请求参数 let data; //文件 let file = item.file; axios.get(\"http://127.0.0.1:8081/getPolicy?fileName=\" + file.name).then(res =\u003e { res = res.data; //后端传递的请求参数 let formData = res.formData; //文件oss上的根路径+文件名 let key = formData.key; //判断是否需要formData if (res.withFormData) { data = new FormData(); for (let param in formData) { data.append(param, formData[param]) } data.append(res.fileFieldName, file); } else { data = file; } //存储 axios({ url: res.host, data: data, method: res.method, headers: { 'Content-Type': 'multipart/form-data' } }).then(res =\u003e { //向后端存储（伪代码）： /** * save({ * ... * url: this.dataObj.host + '/' + this.dataObj.key * ... * }) */ //前端使用： axios.get(\"http://127.0.0.1:8081/getExpiration?objectName=\" + key).then(res =\u003e { this.fileList.push({ name: file.name, url: res.data }) }) }) }); }, } } \u003c/script\u003e ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:3","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"关于签名直传 流程图 文件上传以及文件查看预览都是这个流程 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:4","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"项目地址 https://github.com/coderabbit214/parent-demo/tree/main/oss_demo ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:3:0","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Spring"],"content":"AOP 和 注解 结合使用 aop的切面可以定义为注解，用打印接口访问时间举例 注解 @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface CountTime { } aop @Component @Aspect @Slf4j public class CountTimeAspect { //定义切入点（也可以直接写在下边） @Pointcut(\"@annotation(com.coderabbit.utildemo.annotation.CountTime)\") public void countTime(){ } @Around(\"countTime()\") public Object doAround(ProceedingJoinPoint joinPoint) { Object object = null; try { long beginTime = System.currentTimeMillis(); object = joinPoint.proceed(); String serviceName = joinPoint.getSignature().getName(); String className = joinPoint.getSignature().getDeclaringTypeName(); log.info(\"\\nController Name:{}\\nService Name:{}\\n响应耗时{}\",className,serviceName,System.currentTimeMillis() - beginTime +\"ms\"); } catch (Throwable throwable) { throwable.printStackTrace(); } return object; } } ","date":"2021-12-21","objectID":"/aop%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/:0:0","tags":["AOP","注解"],"title":"AOP和注解结合使用","uri":"/aop%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/"},{"categories":["云原生"],"content":"Docker进阶 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:0:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"概述 基于Go 应用 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 优势 快速 响应式部署和扩展 同一硬件上运行更多工作负载 虚拟化技术和容器化技术比较 传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。 Docker容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟硬件。 每个容器都是相互隔离的，每个容器都有属于自己的文件系统，互不影响。 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:1:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"安装 mac,win 直接官网下载安装 下面为centos7 安装gcc yum -y install gcc yum -y install gcc-c++ 卸载旧版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 下载需要的安装包 yum install -y yum-utils 设置阿里云仓库（可以不设置，本人没有设置） yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #国外的地址 # 设置阿里云的Docker镜像仓库 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #国外的地址 更新yum索引 yum makecache fast 安装docker yum install docker-ce docker-ce-cli containerd.io ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"Docker常用命令 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"基础命令 docker version #查看docker的版本信息 docker info #查看docker的系统信息,包括镜像和容器的数量 docker 命令 --help #帮助命令(可查看可选的参数) docker COMMAND --help #启动docker systemctl start docker #查看状态 systemctl status docker ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:1","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"镜像命令 docker images 查看本地主机的所有镜像 docker images #查看本地主机的所有镜像 # 可选参数 -a/--all 列出所有镜像 -q/--quiet 只显示镜像的id docker search 搜索镜像 # 举例： docker search mysql #搜索收藏数大于3000的镜像 docker search mysql --filter=STARS=3000 docker pull 镜像名[:tag] 拉取镜像 分层下载，联合文件系统 docker pull mysql #如果不写tag默认就是latest docker pull mysql:5.7 #5.7版本 docker rmi 删除镜像 docker rmi -f 镜像id/REPOSITORY docker rmi -f $(docker images -aq) #删除所有 -f #强制 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:2","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"容器命令 docker run [可选参数] 启动容器 --name=\"名字\" #指定容器名字 -d #后台方式运行 -it #使用交互方式运行,进入容器查看内容 -p #指定容器的端口 ( -p ip:主机端口:容器端口 #配置主机端口映射到容器端口 -p 主机端口:容器端口 -p 容器端口 ) -P #随机指定端口(大写的P) 退出容器(使用-it方式启动) #停止并退出容器（后台方式运行则仅退出） exit #不停止容器退出 #Ctrl+P+Q docker ps 查看容器 docker ps # 默认列出正在运行的容器 -a # 列出所有容器的运行记录 -n=? # 显示最近创建的n个容器 -q # 只显示容器的编号 docker rm 删除容器 docker rm 容器id #删除指定的容器,不能删除正在运行的容器,强制删除使用 rm -f docker rm -f $(docker ps -aq) #删除所有的容器 docker ps -a -q|xargs docker rm #删除所有的容器 启动停止 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止当前运行的容器 docker kill 容器id #强制停止当前容器 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:3","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"常用命令 docker run -d 镜像名 后台启动 docker run -d centos # 问题：docker ps 发现centos停止了 # 常见问题：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 #nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了 docker logs 容器id 查看日志 docker logs --help docker logs -tf 容器id -t 跟踪 -f 带时间戳 docker logs --tail number 容器id #num为要显示的日志条数 docker top 容器id 查看容器中进程信息 docker top dbaa4ae1699 docker inspect 容器id 查看容器的元数据 # 可以看到启动时带的参数，网卡信息等 docker inspect dbaa4ae1699 进入正在运行的容器 # docker exec 进入容器后开启一个新的终端，可以在里面操作 docker exec -it c703b5b1911f /bin/bash # docker attach 进入容器正在执行的终端，不会启动新的进程 docker attach c703b5b1911f 拷贝操作 #拷贝容器的文件到主机中 docker cp 容器id:容器内路径 目的主机路径 #拷贝宿主机的文件到容器中 docker cp 目的主机路径 容器id:容器内路径 查看容器状态 docker stats 容器id ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:4","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"镜像 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"联合文件系统（分层） 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最終的 文件系统会包含所有底层的文件和目录 所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的项部！这一层就是我们通常说的容器层，容器之下的都叫镜像层！ ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:1","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"创建镜像命令(本地) # docker commit # -a 作者 # -m 提交信息 docker commit -a=\"coderabbit214\" -m=\"es have ik\" df6f751eddc4 elasticsearchik:6.5.4 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:2","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"容器数据卷 相当于数据同步，本机与容器中的文件相互同步 -v 主机目录:容器目录 举例： docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 容器删除后，本地依然保存 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"常用命令 创建数据卷 docker volume create my-vol 查看所有的数据卷 $ docker volume ls local my-vol 查看指定数据卷的信息 $ docker volume inspect my-vol 删除数据卷 docker volume rm … $ docker volume rm my-vol 删除容器之时删除相关的卷 $ docker rm -v ... ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:1","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"具名挂载和匿名挂载 匿名挂载，具名挂载，指定路径挂载的命令区别如下： -v 容器内路径 #匿名挂载（匿名挂载会在/var/lib/docker/volumes/目录下随机生成文件夹） -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:2","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"读写 指定数据卷映射的相关参数： ro —— readonly 只读。设置了只读则只能操作宿主机的路径，不能操作容器中的对应路径。 rw —– readwrite 可读可写 举例 docker run -d -P --name nginx -v juming-nginx:/etc/nginx:ro nginx docker run -d -P --name nginx -v juming-nginx:/etc/nginx:rw nginx ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:3","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"容器间数据同步实现 –volumes-from 过参数--volumes-from，设置容器2和容器1建立数据卷挂载关系 docker run -it --name 容器名称 --volumes-from 被同步数据容器 镜像id /bin/bash 容器间数据同步与本机和容器挂载卷相同，都是备份操作。 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:4","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"Dockerfile 用来构建docker镜像的脚本命令 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"初体验 新建文件 dockerfile01 FROM centos VOLUME [\"volume01\",\"volume02\"] CMD echo \"----end----\" CMD /bin/bash 使用命令构建镜像 docker build --name 01 -f dockerfile01 -t coderabbit214/centos:1.0 . 启动自己构建的容器(容器内跟路径下出现volume01、volume02目录) docker run -it 镜像id /bin/bash ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:1","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"指令 指令 说明 FROM 指定基础镜像 MAINTAINER 镜像是谁写的，姓名+邮箱 RUN 镜像构建的时候需要运行的命令 ADD 将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget WORKDIR 镜像的工作目录 VOLUME 挂载的目录 EXPOSE 保留端口配置 CMD 指定这个容器启动的时候要运行的命令（只有最后一个会生效） EMTRYPOINT 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD 当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令，触发指令 COPY 功能类似ADD，但是是不会自动解压文件，也不能访问网络资源 ENV 构建的时候设置环境变量 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:2","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"实战（制作tomcat并发布） 准备镜像文件tomcat压缩包 编写dockerfile文件，文件名使用官方命名：Dockerfile ，build的时候会默认寻找当前目录下的文件，不需要使用-f参数指定 FROM centos MAINTAINER coderabbit214\u003c1157237955@qq.com\u003e COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.56.tar.gz /usr/local/ RUN yum -y install vim RUN yum install -y java-1.8.0-openjdk-devel.x86_64 ENV MYPATH /usr/local WORKDIR $MYPATH ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.56 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.56 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.56/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.56/bin/logs/catalina.out 使用该Dockerfile构建镜像 docker build -t diytomcat:1.0 . 启动生成的镜像，构建Tomcat容器 docker run -d -p 8088:8080 --name diytomcat -v /home/dockerfile/tomcat/test:/usr/local/apache-tomcat-9.0.56/webapps/test diytomcat:1.0 打开网页查看正确 发布镜像到DockerHub 登陆：docker login -u 用户名 Push:docker push coderabbit214/diytomcat:1.0 用户名➕镜像名➕版本 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:3","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"本地存储和加载 docker commit docker commit -a \"作者\" -m \"描述\" 容器id xxx:latest(自定义新镜像名) docker save docker save 48b142d6d753 -o /Users/Mr_J/mytomcat.tar docker load docker load -i /Users/Mr_J/mytomcat.tar ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:4","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"docker网络 docker network 查看所有的docker网络 docker network ls Docker默认提供了四个网络模式，说明： bridge：容器默认的网络是桥接模式(自己搭建的网络默认也是使用桥接模式,启动容器默认也是使用桥接模式)。此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 none：不配置网络，容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。 host：容器和宿主机共享Network namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 container：创建的容器不会创建自己的网卡，配置自己的IP容器网络连通。容器和另外一个容器共享Network namespace（共享IP、端口范围）。 docker 创建容器默认使用桥接模式（在同一网段下，可以ping通） 举例： # 创建容器 docker run --name tomcat2 -p 8081:8080 -d tomcat:9.0 docker run --name tomcat1 -p 8080:8080 -d tomcat:9.0 # 查看ip（可以查看文件也可以安装ping命令） docker exec -it tomcat1 cat /etc/hosts 172.17.0.2 fca3c33ef5e3 docker exec -it tomcat2 cat /etc/hosts 172.17.0.3 f49de8901a1e # 使用ping（如果没有就先安装）命令查看是否可以连通 docker exec -it tomcat1 ping 172.17.0.3 # 可以连通 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:7:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"容器互联 –link --link的原理是在指定运行的容器上的/etc/hosts文件中添加容器名和ip地址的映射 举例： # 创建容器 连接2 docker run --name tomcat3 --link tomcat2 -p 8082:8080 -d tomcat:9.0 # 尝试ping docker exec -it tomcat3 ping tomcat2 可以ping通 但是反过来容器Tomcat02通过容器名Tomcat03直接ping容器Tomcat03是不行的 原因： 查看tomcat3的/etc/hosts 有host配置，所以可以ping通 查看tomcat2的/etc/hosts 没有host配置，所以不可以ping通 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:7:1","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"自定义网络（常用） 命令 docker network --help # 查看网络列表 docker network ls # 查看网络详细信息 docker inspect \u003c网络名称或者id\u003e # 创建网络 docker network create --help --driver bridge #指定bridge驱动程序来管理网络 --subnet 192.168.0.0/16 #指定网段的CIDR格式的子网 --gateway 192.168.0.1 #指定主子网的IPv4或IPv6网关 实例 # 创建网络 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet # 启动容器1 docker run --network mynet -d -P --name tomcat01 tomcat:8.0 # 启动容器2(后配置网络) docker run -d -P --name tomcat02 tomcat:8.0 docker network connect mynet tomcat02 # 配置网络 # 查看网络 docker inspect mynet 网络截图 Docker网络实战练习 Redis集群部署 通过以下脚本创建六个Redis 的配置信息： for port in $(seq 1 6); \\ do \\ mkdir -p redis/node-${port}/conf touch redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003eredis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 192.167.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done 创建六个容器 #第1个Redis容器 for port in $(seq 1 6); \\ do \\ docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\ -v /Users/Mr_J/redis/node-${port}/data:/data \\ -v /Users/Mr_J/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 192.167.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done 创建分片集群 redis-cli --cluster create 192.167.0.11:6379 192.167.0.12:6379 192.167.0.13:6379 192.167.0.14:6379 192.167.0.15:6379 192.167.0.16:6379 --cluster-replicas 1 查看集群信息 SpringBoot项目打包镜像 本地测试无误，打jar包 Dockerfile FROM java:8 COPY actuator-demo-0.0.1-SNAPSHOT.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] 启动 docker run -d -p 8080:8080 demo 测试 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:7:2","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"Docker Compose 容器编排 定义和运行多个容器 命令 docker-compose build #构建（重新构建）项目 docker-compose up #启动 docker-compose down #停止 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:0","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"三步骤 Dockerfile保证我们的项目在任何地方都可以运行。 docker-compose.yml文件编写 docker-compose up启动项目 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:1","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"安装 查看官网 Install Docker Compose | Docker Documentation ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:2","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"体验 Get started with Docker Compose | Docker Documentation 创建项目目录 mkdir composetest cd composetest 准备项目 app.py import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) requirements.txt flask redis 编写Dockerfile # syntax=docker/dockerfile:1 FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] 编写docker-compose.yml version: \"3.9\" services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 运行 docker-compose up 注意 docker生成两个镜像，启动了两个容器 网络规则：项目中的内容在同一个网络下 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:3","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"详解docker-compose.yml 版本对应Compose file | Docker Documentation 第三部分命令查询Compose file version 3 reference | Docker Documentation # 第一部分：版本 version: \"3.9\" # 第二部分：服务 services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" # 第三部分：其他 # 网络 # 卷 # 。。。 注意的命令 depends_on (注意依赖关系) version: \"3.9\" services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:4","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"开源项目 Quickstart: Compose and WordPress | Docker Documentation docker-compose.yml version: \"3.9\" services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - wordpress_data:/var/www/html ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} wordpress_data: {} 启动命令 docker-compose up -d ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:5","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["云原生"],"content":"微服务项目部署 编写项目 编写Dockerfile FROM java:8 COPY demo-0.0.1-SNAPSHOT.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] 编写docker-compose.yml version: '3.9' services: demo: build: . depends_on: - redis ports: - \"8080:8080\" redis: image: \"library/redis:alpine\" 启动 ","date":"2021-12-19","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:6","tags":["容器化"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["数据库"],"content":"MyCat ","date":"2021-11-14","objectID":"/mycat/:0:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"本次使用虚拟机 172.16.140.8：mycat 172.16.140.9：master1 172.16.140.10：slave1 172.16.140.11：master2 172.16.140.12：slave2 ","date":"2021-11-14","objectID":"/mycat/:1:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"作用 读写分离 数据分片：垂直拆分(分库)，水平拆分(分表) 多数据源 ","date":"2021-11-14","objectID":"/mycat/:2:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"安装配置 下载地址 解压 tar -zxvf software/Mycat-server-1.6.7.5-release-20200410174409-linux.tar.gz -C /usr/local/ ","date":"2021-11-14","objectID":"/mycat/:3:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"配置 server.xml schema.xml ","date":"2021-11-14","objectID":"/mycat/:3:1","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"启动 /usr/local/mycat/bin/mycat console 启动MyCat： ./mycat start 查看启动状态： ./mycat status 停止： ./mycat stop 重启： ./mycat restart ","date":"2021-11-14","objectID":"/mycat/:3:2","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"连接 mysql -umyCat -p123456 -h 172.16.140.8 -P 8066 ","date":"2021-11-14","objectID":"/mycat/:4:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"读写分离 ","date":"2021-11-14","objectID":"/mycat/:5:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"一主一从 主机配置（master1） 修改配置文件：vim /etc/my.cnf #主服务器唯一ID server-id=1 #启用二进制日志 log-bin=mysql-bin # 设置不要复制的数据库(可设置多个) binlog-ignore-db=mysql binlog-ignore-db=information_schema #设置需要复制的数据库 binlog-do-db=需要复制的主数据库名字 #设置logbin格式 binlog_format=MIXED #binlog日志文件 记得给mysql开启权限 log-bin=/data/mysql/mysql-bin.log #binlog过期清理时间 expire_logs_days=7 #binlog每个日志文件大小 max_binlog_size=100m #binlog缓存大小 binlog_cache_size=4m #最大binlog缓存大小 max_binlog_cache_size=512m logbin格式 STATEMENT:直接复制语句 问题：例如now()这种函数会导致数据不同 ROW:直接修改结果 问题：如果修改语句一次性修改一万条，由于性能原因会导致同步慢，日志膨胀 MIXED：会自动选择前两种 从机配置（slave1） 修改配置文件:vim /etc/my.cnf #从服务器唯一ID server-id=2 #启用中继日志 relay-log=mysql-relay 重启主机，从机mysql（防火墙要关闭） 在主机上建立帐户并授权 slave GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' IDENTIFIED BY 'Mm_123456'; #查询master的状态 show master status; #记录下File和Position的值 #执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化 在从机上配置需要复制的主机 #复制主机的命令 CHANGE MASTER TO MASTER_HOST='主机的IP地址', MASTER_USER='slave', MASTER_PASSWORD='123123', MASTER_LOG_FILE='mysql-bin.具体数字',MASTER_LOG_POS=具体值; #启动从服务器复制功能 start slave; #查看从服务器状态 show slave status; #下面两个参数都是Yes，则说明主从配置成功! # Slave_IO_Running: Yes # Slave_SQL_Running: Yes 如果配置错误检查Error 我遇到的错误 两个mysqluuid相同 解决 清除主从 stop slave ; reset master ; 删除其中一个的uuid，重启mysql 重新配置主从 测试 测试mycat，发现读也在writeHost 修改\u003cdataHost\u003e的balance属性，通过此属性配置读写分离的类型 balance=“0”, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上 balance=“1”，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从 模式(M1-\u003eS1，M2-\u003eS2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均衡 balance=“2”，所有读操作都随机的在 writeHost、readhost 上分发 balance=“3”，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力 测试读写分离 ","date":"2021-11-14","objectID":"/mycat/:5:1","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"双主双从 数据库配置 先清除原先一主一从的关系 两个master配置 master1 #主服务器唯一ID server-id=1 #启用二进制日志 log-bin=mysql-bin # 设置不要复制的数据库(可设置多个) binlog-ignore-db=mysql binlog-ignore-db=information_schema #设置需要复制的数据库 binlog-do-db=需要复制的主数据库名字 #设置logbin格式 binlog_format=MIXED # 在作为从数据库的时候，有写入操作也要更新二进制日志文件 log-slave-updates #防止主键冲突 #表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535 auto-increment-increment=2 # 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535 auto-increment-offset=1 master2 #主服务器唯一ID server-id=3 #启用二进制日志 log-bin=mysql-bin # 设置不要复制的数据库(可设置多个) binlog-ignore-db=mysql binlog-ignore-db=information_schema #设置需要复制的数据库 binlog-do-db=需要复制的主数据库名字 #设置logbin格式 binlog_format=MIXED # 在作为从数据库的时候，有写入操作也要更新二进制日志文件 log-slave-updates #防止主键冲突 #表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535 auto-increment-increment=2 # 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535 auto-increment-offset=2 双从机配置 slave1 修改配置文件:vim /etc/my.cnf #从服务器唯一ID server-id=2 #启用中继日志 relay-log=mysql-relay slave2 修改配置文件:vim /etc/my.cnf #从服务器唯一ID server-id=4 #启用中继日志 relay-log=mysql-relay 重启mysql 两个master建立salve账户 GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' IDENTIFIED BY 'Mm_123456'; 两个slave分别与两个master建立主从关系 两个master互相建立主从关系 关系图 MyCat schema.xml balance=“1”: 全部的readHost与stand by writeHost参与select语句的负载均衡。 writeType=“0”: 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个 writeType=“1”，所有写操作都随机的发送到配置的 writeHost，1.5 以后废弃不推荐 writeHost，重新启动后以切换后的为准，切换记录在配置文件中:dnindex.properties switchType=“1”: 1 默认值，自动切换。 -1 表示不自动切换 2 基于 MySQL 主从同步的状态决定是否切换。 \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE mycat:schema SYSTEM \"schema.dtd\"\u003e \u003cmycat:schema xmlns:mycat=\"http://io.mycat/\"\u003e \u003cschema name=\"TESTDB\" checkSQLschema=\"false\" sqlMaxLimit=\"100\" randomDataNode=\"dn1\" dataNode=\"dn1\"\u003e \u003c/schema\u003e \u003cdataNode name=\"dn1\" dataHost=\"host1\" database=\"testMyCat\" /\u003e \u003c!-- --\u003e \u003cdataHost name=\"host1\" maxCon=\"1000\" minCon=\"10\" balance=\"1\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"jdbc\" switchType=\"1\" slaveThreshold=\"100\"\u003e \u003cheartbeat\u003eselect user()\u003c/heartbeat\u003e \u003cwriteHost host=\"hostM1\" url=\"jdbc:mysql://172.16.140.9:3306\" user=\"root\" password=\"Mm_123456\"\u003e \u003creadHost host=\"hostS1\" url=\"jdbc:mysql://172.16.140.10:3306\" user=\"root\" password=\"Mm_123456\" /\u003e \u003c/writeHost\u003e \u003cwriteHost host=\"hostM2\" url=\"jdbc:mysql://172.16.140.11:3306\" user=\"root\" password=\"Mm_123456\"\u003e \u003creadHost host=\"hostS2\" url=\"jdbc:mysql://172.16.140.12:3306\" user=\"root\" password=\"Mm_123456\" /\u003e \u003c/writeHost\u003e \u003c/dataHost\u003e \u003c/mycat:schema\u003e 改完配置记得重启 测试 读写分离 关闭(master1)写入功能正常 ","date":"2021-11-14","objectID":"/mycat/:5:2","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["Java"],"content":"Java反射框架reflections ","date":"2021-10-30","objectID":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/:0:0","tags":["反射"],"title":"Java反射框架reflections","uri":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/"},{"categories":["Java"],"content":"前言 ​ 最近做项目的时候，需要实现一个需求客户要求获取每个接口的具体访问信息，导出到Excel，需要获取到swagger中注解的信息，刚开始想了两种实现方式，一种是请求swagger接口获取信息，另一种是通过反射直接获取，最后采用了反射，在网上浏览资料时发现了这个框架，比较简洁。 ","date":"2021-10-30","objectID":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/:1:0","tags":["反射"],"title":"Java反射框架reflections","uri":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/"},{"categories":["Java"],"content":"依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.reflections\u003c/groupId\u003e \u003cartifactId\u003ereflections\u003c/artifactId\u003e \u003cversion\u003e0.9.11\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-10-30","objectID":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/:2:0","tags":["反射"],"title":"Java反射框架reflections","uri":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/"},{"categories":["Java"],"content":"代码实例 /** * @Author: Mr_J * @Date: 2021/10/29 6:47 下午 */ @Component @Slf4j public class InterfaceStatisticsInitListener implements ApplicationListener\u003cContextRefreshedEvent\u003e { @Override public void onApplicationEvent(ContextRefreshedEvent event) { log.info(\"读取接口层信息开始\"); //构建 反射条件 根据需要添加 Reflections reflections = new Reflections( new ConfigurationBuilder(). //指定路径 setUrls(ClasspathHelper.forPackage(\"com.jsh.reflections.controller\")) .setScanners( //添加方法参数扫描 new MethodParameterScanner() //添加属性注解扫描 ,new FieldAnnotationsScanner() //添加子类扫描 ,new SubTypesScanner() //添加注解扫描 ,new TypeAnnotationsScanner() //添加方法注解扫描 ,new MethodAnnotationsScanner()) ); //根据注解获取类 Set\u003cClass\u003c?\u003e\u003e classes = reflections.getTypesAnnotatedWith(Api.class); classes.forEach(clazz -\u003e { //处理单个类 //反射 Method[] methods = clazz.getMethods(); for (Method method : methods) { ApiOperation annotation = method.getAnnotation(ApiOperation.class); //输出类上注解信息 if (annotation == null) { continue; } System.out.println(annotation.value()); String name = method.getName(); //输出方法名 System.out.println(name); } }); // 反射出子类 Set\u003cClass\u003c? extends TestController\u003e\u003e set = reflections.getSubTypesOf( TestController.class ) ; // 获取带有特定注解对应的方法 Set\u003cMethod\u003e methods = reflections.getMethodsAnnotatedWith( ApiOperation.class ) ; System.out.println(\"m\"+methods); // 获取带有特定注解对应的字段 Set\u003cField\u003e fields = reflections.getFieldsAnnotatedWith( Autowired.class ) ; System.out.println(\"f\"+fields); // 获取特定参数对应的方法 Set\u003cMethod\u003e someMethods = reflections.getMethodsMatchParams(long.class, int.class); System.out.println(\"s\"+someMethods); // 获取特定返回值的方法 Set\u003cMethod\u003e voidMethods = reflections.getMethodsReturn(void.class); System.out.println(\"v\"+voidMethods); //获取参数带有某个注解的方法 Set\u003cMethod\u003e pathParamMethods =reflections.getMethodsWithAnyParamAnnotated(RequestParam.class); System.out.println(\"p\"+pathParamMethods); } } ","date":"2021-10-30","objectID":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/:3:0","tags":["反射"],"title":"Java反射框架reflections","uri":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/"},{"categories":["Java"],"content":"Drools 规则引擎 规则引擎，全称为业务规则管理系统，英文名为BRMS(即Business Rule Management System)。规则引擎的主要思想是将应用程序中的业务决策部分分离出来，并使用预定义的语义模块编写业务决策（业务规则），由用户或开发者在需要时进行配置、管理。 ","date":"2021-10-21","objectID":"/drools/:0:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"优点 1、业务规则与系统代码分离，实现业务规则的集中管理 2、在不重启服务的情况下可随时对业务规则进行扩展和维护 3、可以动态修改业务规则，从而快速响应需求变更 4、规则引擎是相对独立的，只关心业务规则，使得业务分析人员也可以参与编辑、维护系统的业务规则 5、减少了硬编码业务规则的成本和风险 6、使用规则引擎提供的规则编辑工具，使复杂的业务规则实现变得的简单 ","date":"2021-10-21","objectID":"/drools/:1:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"应用场景 对于一些存在比较复杂的业务规则并且业务规则会频繁变动的系统比较适合使用规则引擎 ","date":"2021-10-21","objectID":"/drools/:2:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"初体验 ","date":"2021-10-21","objectID":"/drools/:3:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"spring方式 新建maven项目 pom \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-compiler\u003c/artifactId\u003e \u003cversion\u003e7.10.0.Final\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 测试 --\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e 根据drools要求创建resources/META-INF/kmodule.xml配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003ckmodule xmlns=\"http://www.drools.org/xsd/kmodule\"\u003e \u003c!-- name:指定kbase的名称，可以任意，但是需要唯一 packages:指定规则文件的目录，需要根据实际情况填写，否则无法加载到规则文件 default:指定当前kbase是否为默认 --\u003e \u003ckbase name=\"myKbase1\" packages=\"rules\" default=\"true\"\u003e \u003c!-- name:指定ksession名称，可以任意，但是需要唯一 default:指定当前session是否为默认 --\u003e \u003cksession name=\"ksession-rule\" default=\"true\"/\u003e \u003c/kbase\u003e \u003c/kmodule\u003e 创建实体类 /** * 订单 */ public class Order { private Double originalPrice;//订单原始价格，即优惠前价格 private Double realPrice;//订单真实价格，即优惠后价格 public String toString() { return \"Order{\" + \"originalPrice=\" + originalPrice + \", realPrice=\" + realPrice + '}'; } public Double getOriginalPrice() { return originalPrice; } public void setOriginalPrice(Double originalPrice) { this.originalPrice = originalPrice; } public Double getRealPrice() { return realPrice; } public void setRealPrice(Double realPrice) { this.realPrice = realPrice; } } 创建规则文件resources/rules/bookDiscount.drl //图书优惠规则 package book.discount import com.itheima.drools.entity.Order //规则一：所购图书总价在100元以下的没有优惠 rule \"book_discount_1\" when $order:Order(originalPrice \u003c 100) then $order.setRealPrice($order.getOriginalPrice()); System.out.println(\"成功匹配到规则一：所购图书总价在100元以下的没有优惠\"); end //规则二：所购图书总价在100到200元的优惠20元 rule \"book_discount_2\" when $order:Order(originalPrice \u003c 200 \u0026\u0026 originalPrice \u003e= 100) then $order.setRealPrice($order.getOriginalPrice() - 20); System.out.println(\"成功匹配到规则二：所购图书总价在100到200元的优惠20元\"); end //规则三：所购图书总价在200到300元的优惠50元 rule \"book_discount_3\" when $order:Order(originalPrice \u003c= 300 \u0026\u0026 originalPrice \u003e= 200) then $order.setRealPrice($order.getOriginalPrice() - 50); System.out.println(\"成功匹配到规则三：所购图书总价在200到300元的优惠50元\"); end //规则四：所购图书总价在300元以上的优惠100元 rule \"book_discount_4\" when $order:Order(originalPrice \u003e= 300) then $order.setRealPrice($order.getOriginalPrice() - 100); System.out.println(\"成功匹配到规则四：所购图书总价在300元以上的优惠100元\"); end 测试 @Test public void test1(){ KieServices kieServices = KieServices.Factory.get(); KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer(); //会话对象，用于和规则引擎交互 KieSession kieSession = kieClasspathContainer.newKieSession(); //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 Order order = new Order(); order.setOriginalPrice(210D); //将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配 kieSession.insert(order); //激活规则引擎，如果规则匹配成功则执行规则 kieSession.fireAllRules(); //关闭会话 kieSession.dispose(); System.out.println(\"优惠前原始价格：\" + order.getOriginalPrice() + \"，优惠后价格：\" + order.getRealPrice()); } //使用字符串 @Test public void test2(){ String myRule = \"//图书优惠规则\\n\" + \"package book.discount\\n\" + \"import com.jsh.droolsdemo.entity.Order\\n\" + \"\\n\" + \"//规则一：所购图书总价在100元以下的没有优惠\\n\" + \"rule \\\"book_discount_1\\\"\\n\" + \" when\\n\" + \" $order:Order(originalPrice \u003c 100)\\n\" + \" then\\n\" + \" $order.setRealPrice($order.getOriginalPrice());\\n\" + \" System.out.println(\\\"成功匹配到规则一：所购图书总价在100元以下的没有优惠\\\");\\n\" + \"end\\n\" + \"\\n\" + \"//规则二：所购图书总价在100到200元的优惠20元\\n\" + \"rule \\\"book_discount_2\\\"\\n\" + \" when\\n\" + \" $order:Order(originalPrice \u003c 200 \u0026\u0026 originalPrice \u003e= 100)\\n\" + \" then\\n\" + \" $order.setRealPrice($order.getOriginalPrice() - 20);\\n\" + \" System.out.println(\\\"成功匹配到规则二：所购图书总价在100到200元的优惠20元\\\");\\n\" + \"end\\n\" + \"\\n\" + \"//规则三：所购图书总价在200到300元的优惠50元\\n\" + \"rule \\\"book_discount_3\\\"\\n\" + \" when\\n\" + \" $order:Order(originalPrice \u003c= 300 \u0026\u0026 originalPrice \u003e= 200)\\n\" + \" then\\n\" + \" $order.setRealPrice($order.getOriginalPrice() - 50);\\n\" + \" System.out.println(\\\"成功匹配到规则三：所购图书总价在200到300元的优惠50元\\\");\\n\" + \"end\\n\" + \"\\n\" + \"//规则四：所购图书总价在300元以上的优惠100元\\n\" + \"rule \\\"book_discount_4\\\"\\n\" + \" when\\n\" + \" $order:Order(originalPrice \u003e= 300)\\n\" + \" then\\n\" + \" $order.setRealPrice($order.getOriginalPrice() - 100);\\n\" + \" System.out.println(\\\"成功匹配到规则四：所购图书总价在300元以上的优惠100元\\\");\\n","date":"2021-10-21","objectID":"/drools/:3:1","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"springboot方式 新建springboot项目 pom \u003cproperties\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003cdrools.version\u003e7.14.0.Final\u003c/drools.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003c!-- drools依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-core\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-compiler\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 决策表 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-decisiontables\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 模板 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-templates\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.kie\u003c/groupId\u003e \u003cartifactId\u003ekie-api\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e config @Configuration public class KiaSessionConfig { private static final String RULES_PATH = \"rules/\"; @Bean public KieFileSystem kieFileSystem() throws IOException { KieFileSystem kieFileSystem = getKieServices().newKieFileSystem(); for (Resource file : getRuleFiles()) { kieFileSystem.write(ResourceFactory.newClassPathResource(RULES_PATH + file.getFilename(), \"UTF-8\")); } return kieFileSystem; } private Resource[] getRuleFiles() throws IOException { ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver(); final Resource[] resources = resourcePatternResolver.getResources(\"classpath*:\" + RULES_PATH + \"**/*.*\"); return resources; } @Bean public KieContainer kieContainer() throws IOException { final KieRepository kieRepository = getKieServices().getRepository(); kieRepository.addKieModule(new KieModule() { @Override public ReleaseId getReleaseId() { return kieRepository.getDefaultReleaseId(); } }); KieBuilder kieBuilder = getKieServices().newKieBuilder(kieFileSystem()); kieBuilder.buildAll(); return getKieServices().newKieContainer(kieRepository.getDefaultReleaseId()); } private KieServices getKieServices() { return KieServices.Factory.get(); } @Bean public KieBase kieBase() throws IOException { return kieContainer().getKieBase(); } @Bean public KieSession kieSession() throws IOException { return kieContainer().newKieSession(); } } 创建实体类 /** * 订单 */ public class Order { private Double originalPrice;//订单原始价格，即优惠前价格 private Double realPrice;//订单真实价格，即优惠后价格 public String toString() { return \"Order{\" + \"originalPrice=\" + originalPrice + \", realPrice=\" + realPrice + '}'; } public Double getOriginalPrice() { return originalPrice; } public void setOriginalPrice(Double originalPrice) { this.originalPrice = originalPrice; } public Double getRealPrice() { return realPrice; } public void setRealPrice(Double realPrice) { this.realPrice = realPrice; } } 创建规则文件resources/rules/bookDiscount.drl //图书优惠规则 package book.discount import com.itheima.drools.entity.Order //规则一：所购图书总价在100元以下的没有优惠 rule \"book_discount_1\" when $order:Order(originalPrice \u003c 100) then $order.setRealPrice($order.getOriginalPrice()); System.out.println(\"成功匹配到规则一：所购图书总价在100元以下的没有优惠\"); end //规则二：所购图书总价在100到200元的优惠20元 rule \"book_discount_2\" when $order:Order(originalPrice \u003c 200 \u0026\u0026 originalPrice \u003e= 100) then $order.setRealPrice($order.getOriginalPrice() - 20); System.out.println(\"成功匹配到规则二：所购图书总价在100到200元的优惠20元\"); end //规则三：所购图书总价在200到300元的优惠50元 rule \"book_discount_3\" when $order:Order(originalPrice \u003c= 300 \u0026\u0026 originalPrice \u003e= 200) then $order.setRealPrice($order.getOriginalPrice() - 50); System.out.println(\"成功匹配到规则三：所购图书总价在200到300元的优惠50元\"); end //规则四：所购图书总价在300元以上的优惠100元 rule \"book_discount_4\" when $order:Order(originalPrice \u003e= 300) then $order.setRealPrice($order.getOriginalPrice() - 100); System.out.println(\"成功匹配到规则四：所购图书总价在300元以上的优惠100元\"); end 测试 @SpringBootTest class DroolsDemoApplicationTests2 { @Autowired private KieSession session; @Autowired private KieBase kieBase; @Test public void test1(){ //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 Order order = new Order(); order.setOriginalPrice","date":"2021-10-21","objectID":"/drools/:3:2","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"匹配规则 规则格式（举例） rule \"book_discount_1\" when $order:Order(originalPrice \u003c 100) then $order.setRealPrice($order.getOriginalPrice()); System.out.println(\"成功匹配到规则一：所购图书总价在100元以下的没有优惠\"); end When(匹配规则) 没有约束（只匹配类型） when Order() 条件约束 when Order(originalPrice \u003c 100) 匹配规则并绑定数据 when $order:Order(originalPrice \u003c 100) 可以多个类 @Test public void test2(){ //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 Cat cat = new Cat(); cat.setSex(0); Order order = new Order(); order.setOriginalPrice(99D); //将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配 session.insert(order); session.insert(cat); //激活规则引擎，如果规则匹配成功则执行规则 session.fireAllRules(); //关闭会话 session.dispose(); } when $order:Order(originalPrice \u003c 100) and $cat:Cat(sex == 0) ","date":"2021-10-21","objectID":"/drools/:4:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"约束 约束 描述 !. 使用此运算符可以以空安全的方式取消引用属性。!.运算符左侧的值不能为null（解释为!= null） [] 按List索引访问值或Map按键访问值 \u003c，\u003c=，\u003e，\u003e= 在具有自然顺序的属性上使用这些运算符 ==, != 在约束中使用这些运算符作为equals()和!equals()方法 \u0026\u0026，|| 组合关系条件 matches，not matches 使用这些运算符可以指示字段与指定的Java正则表达式匹配或不匹配 contains，not contains 使用这些运算符可以验证Array或字段是否包含或不包含指定值 memberOf，not memberOf 使用这些运算符可以验证字段是否为定义为变量Array的成员 soundslike 使用英语发音来验证单词是否具有与给定值几乎相同的声音（类似于该matches运算符） in，notin 使用这些运算符可以指定一个以上的可能值来匹配约束（复合值限制） from 取集合中的元素 例： 实体类 @Data public class Animal { private List\u003cCat\u003e cats; } @Data public class Cat { private int sex; private String name; } drl package com.jsh.animal import com.jsh.droolsdemo.entity.Animal import com.jsh.droolsdemo.entity.Cat rule \"from\" when $an : Animal() $p : Cat(sex != 3) from $an.cats then System.out.println($p); end 测试 //测试from @Test public void test3(){ //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 List\u003cCat\u003e cats = new ArrayList\u003c\u003e(); Cat cat = new Cat(); cat.setSex(0); cat.setName(\"11\"); Cat cat1 = new Cat(); cat1.setSex(0); cat1.setName(\"22\"); Cat cat2 = new Cat(); cat2.setSex(0); cat2.setName(\"33\"); Cat cat3 = new Cat(); cat3.setSex(0); cat3.setName(\"44\"); cats.add(cat); cats.add(cat1); cats.add(cat2); cats.add(cat3); Animal animal = new Animal(); animal.setCats(cats); session.insert(animal); //激活规则引擎，如果规则匹配成功则执行规则 session.fireAllRules(); //关闭会话 session.dispose(); } 输出 collect 获取集合 ","date":"2021-10-21","objectID":"/drools/:4:1","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"RHS动作 ","date":"2021-10-21","objectID":"/drools/:5:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"主要操作 动作 描述 set 给属性赋值 modify 将改变通知drolls引擎 update 将改变通知drolls引擎 insert 将新实事插入到drools引擎的工作 insertLogical insert增强版，需声明撤回事件，或待不在匹配条件后自动撤回 delete 删除实事 update Update用于将数据的更改更新到引擎，并通知引擎重新匹配该事实 rule \"update\" when $an : Cat(sex == 0) then System.out.println($an); $an.setSex(1); update($an) end rule \"update2\" when $an : Cat(sex == 1) then System.out.println($an); end 测试 // 测试update @Test public void test4(){ Cat cat = new Cat(); cat.setSex(0); session.insert(cat); //激活规则引擎，如果规则匹配成功则执行规则 session.fireAllRules(); //关闭会话 session.dispose(); } 输出 modify 和update功能一样 rule \"update\" when $an : Cat(sex == 0) then System.out.println($an); // $an.setSex(1); // update($an) modify($an){ setSex(1) } end ","date":"2021-10-21","objectID":"/drools/:5:1","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"核心算法Rete 拉丁语单词\"rete\"的意思是\"网络\"或\"网络\"。Rete 算法可分为两个部分：规则编译和运行时间执行。 原文链接 ","date":"2021-10-21","objectID":"/drools/:6:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"ReteNode 是所有对象进入网络的入口，然后进入到TypeNode ","date":"2021-10-21","objectID":"/drools/:6:1","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"ObjectTypeNode 是我们规则所用到的pojo，ObjectTypeNode就是类型检查，引擎只让匹配Object 类型的对象到达节点 ","date":"2021-10-21","objectID":"/drools/:6:2","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"AlphaNode Drools 通过散列法优化了从 ObjectTypeNode 到 AlphaNode 的传播。每次一个 AlphaNode 被加到一个 ObjectTypeNode 的时候，就以字面值（ literal value ）作为 key ，以 AlphaNode 作为 value 加入 HashMap 。当一个新的实例进入 ObjectTypeNode 的时候，不用传递到每一个 AlphaNode ，它可以直接从 HashMap 中获得正确的 AlphaNode ，避免了不必要的字面检查。 例如：Cheese （name＝”cheddar” ,strengh==”strong”) ","date":"2021-10-21","objectID":"/drools/:6:3","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"JoinNode 用来对2个对象进行对比、检查。约定JoinNode的2个输入称为左边和右边。左边通常是一个运算后的结果（LeftInputNodeAdapter），右边通常是一个ObjectTypeNode。 举例： rule when Cheese( $chedddar : name == \"cheddar\" ) $person : Person( favouriteCheese == $cheddar ) then System.out.println( $person.getName() + \" likes cheddar\" ); end rule when Cheese( $chedddar : name == \"cheddar\" ) $person : Person( favouriteCheese != $cheddar ) then System.out.println( $person.getName() + \" does not like cheddar\" ); end 这里就共用了一个Cheese( $chedddar : name == \"cheddar\" )的结果 ","date":"2021-10-21","objectID":"/drools/:6:4","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"问题 同一规则有多个或的判断条件，如何分组、指定优先级呢? 分组(如果传入的是列表，只会触发列表中的一个数据) activation-group(同一个组内只有一个会执行) agenda-group(同一个组内，要不都执行，要不都不执行) 优先级 salience：数值越大越先执行 规则的数量会影响Drools的执行效率? 不会 Rete算法是一种前向规则快速匹配算法，其匹配速度与规则数目无关 规则会在项目启动时创建rete网络 在运行时只会运行匹配的规则 用空间换时间 Drools的function、global属性的作用？能运用到什么场景？ global：定义全局变量 用于多个规则都需要使用的变量 规则内部使用的类无法得到的变量 function：定义方法（和java一样） 使用静态类对外赋值 如何指定特定规则运行？ 在fireAllRules中传入过滤器（AgendaFilter的子类） 如何动态管理规则？因为在实际业务中，规则条件极有可能发生变化。【思考题】 当存在大量的规则编写时，如何提高规则编写的效率。【开发问题】 通过规则分组，或者通过指标编号分组 Drools为什么快？核心算法及其原理是什么？【进阶】 Rete(拉丁语,英语:net)算法 原理： 通过规则条件生成了一个网络，每个规则条件是网络中的一个节点 rete可以被分为两部分：规则编译和运行时执行。规则编译是指根据规则集生成推理网络的过程，运行时执行指将数据送入推理网络进行筛选的过程 ","date":"2021-10-21","objectID":"/drools/:7:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"使用心得 如何调用外界的方法（类似放入需要规则判断的数据，在drools文件中可以调用方法） 在kieSession中放入类（java） kieSession.insert(); 声明类，调用方法（drools文件） //声明 $fs: financialServiceImpl() //使用（对别的类的参数进行判断） $fs.getcompAveBvSecuritvCode(参数...) 如何在Drools中对外（Java）写出。（使用静态方法） 声明及静态方法（java） public class MessageList { public static List\u003cString\u003e testList = new Vector\u003c\u003e(); public static void init(){ testList.clear(); } public static void add(Object result){ if (result != null) { if (result instanceof String) { testList.add((String) result); } } } } 调用方法进行操作(java) @Test public void test1(){ //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 Order order = new Order(); order.setOriginalPrice(59D); //将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配 Order order1 = new Order(); order1.setOriginalPrice(91D); MessageList.init(); session.insert(order); // session.fireAllRules(); session.insert(order1); //激活规则引擎，如果规则匹配成功则执行规则 session.fireAllRules(); //关闭会话 session.dispose(); System.out.println(\"优惠前原始价格：\" + order.getOriginalPrice() + \"，优惠后价格：\" + order.getRealPrice()); System.out.println(\"优惠前原始价格：\" + order1.getOriginalPrice() + \"，优惠后价格：\" + order1.getRealPrice()); for (String s : MessageList.testList) { System.out.println(s); } } drools //添加方法 function void setString(String s) { MessageList.add(s); } //规则一：所购图书总价在100元以下的没有优惠 rule \"book_discount_1\" when $order:Order(originalPrice \u003c 100) then $order.setRealPrice($order.getOriginalPrice() - 10); setString($order.getOriginalPrice().toString()); end 单条数据对应单个规则可以批量传入数据，如果对应多段规则必须分组单条传入 ","date":"2021-10-21","objectID":"/drools/:8:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"JUC ","date":"2021-10-06","objectID":"/juc/:1:0","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"什么是JUC 进程与线程 进程：计算机进行资源调度的基本单元（打开一个软件）。 线程：系统分配时间调度的基本单元。 线程的状态 新建 运行 阻塞 等待 超时等待 终止 wait和sleep (1) sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都 能调用。 (2) sleep 不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提 是当前线程占有锁(即代码要在 synchronized 中)。 (3) 它们都可以被 interrupted 方法中断。 并发和并行 **并发:**同一时刻多个线程在访问同一个资源，多个线程对一个点 **并行:**多项工作一起执行，之后再汇总 管程Monitor 就是说的锁 用户线程和守护线程 用户线程:平时用到的普通线程,自定义线程 守护线程:运行在后台,是一种特殊的线程,比如垃圾回收 当主线程结束后,用户线程还在运行,JVM存活 如果没有用户线程,都是守护线程,JVM结束 ","date":"2021-10-06","objectID":"/juc/:1:1","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"LOCK接口 多线程编程步骤 Synchronized synchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种: 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{} 括起来的代码，作用的对象是调用这个代码块的对象; 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用 的对象是调用这个方法的对象; 虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定 义的一部分，因此，synchronized 关键字不能被继承。如果在父类中的某个方 法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这 个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上 synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方 法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此， 子类的方法也就相当于同步了。 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的 所有对象; 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主 的对象是这个类的所有对象。 例子： //创建资源类 class Ticket{ //票数 private int number = 30; //操作方法：卖票 public synchronized void sale(){ //判断：是否有票 if (number\u003e0) { System.out.println(Thread.currentThread().getName()+\"::\"+number--+\"还剩\"+number); } } } ReetranLock可重入锁 可重入锁：一个走了才能再进一个 例子： class LTicket{ private int number = 30; //创建可重入锁 公平锁 private final ReentrantLock lock = new ReentrantLock(true); public void sale(){ lock.lock(); try { if (number\u003e0){ System.out.println(Thread.currentThread().getName()+\"::\"+number--+\"剩余：\"+number); } } finally { lock.unlock(); } } } 采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一 般来说，使用 Lock 必须在 try{}catch{}块中进行，并且将释放锁的操作放在 finally 块中进行，以保证锁一定被被释放，防止死锁的发生。 Lock和Synchronized的不同 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内 置的语言实现; synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现 象发生;而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很 可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁; Lock可以让等待锁的线程响应中断，而synchronized却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断; 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源 非常激烈时(即有大量线程同时竞争)，此时 Lock 的性能要远远优于 synchronized。 ","date":"2021-10-06","objectID":"/juc/:1:2","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"线程间通信 Synchronized package com.jsh.juc.sync; class Share { //初始值 private int number = 0; //+1的方法 public synchronized void add() throws InterruptedException { //判断 干活 通知 while (number != 0) { this.wait(); } //干活 number++; System.out.println(Thread.currentThread().getName() + \"::\" + number); //通知 this.notifyAll(); } //+1的方法 public synchronized void dno() throws InterruptedException { while (number == 0) { this.wait(); } number--; System.out.println(Thread.currentThread().getName() + \"::\" + number); this.notifyAll(); } } public class ThreadDemo { public static void main(String[] args) { Share sale = new Share(); new Thread(() -\u003e { for (int i = 0; i \u003c 40; i++) { try { sale.add(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"AA\").start(); new Thread(() -\u003e { for (int i = 0; i \u003c 40; i++) { try { sale.dno(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"BB\").start(); new Thread(() -\u003e { for (int i = 0; i \u003c 40; i++) { try { sale.add(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"CC\").start(); } } Lock class Share { //初始值 private int number = 0; //创建lock private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); //+1的方法 public void add() throws InterruptedException { //上锁 lock.lock(); try { //判断（使用while不使用if） while (number != 0) { //等待 condition.await(); } number++; System.out.println(Thread.currentThread().getName() + \"::\" + number); //通知 condition.signalAll(); } finally { //解锁 lock.unlock(); } } //-1的方法 public void dno() throws InterruptedException { //上锁 lock.lock(); try { while (number == 0) { //等待 condition.await(); } number--; System.out.println(Thread.currentThread().getName() + \"::\" + number); //通知 condition.signalAll(); } finally { //解锁 lock.unlock(); } } } public class ThreadDemo { public static void main(String[] args) { Share sale = new Share(); new Thread(() -\u003e { for (int i = 0; i \u003c 40; i++) { try { sale.add(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"AA\").start(); new Thread(() -\u003e { for (int i = 0; i \u003c 40; i++) { try { sale.dno(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"BB\").start(); new Thread(() -\u003e { for (int i = 0; i \u003c 40; i++) { try { sale.add(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"CC\").start(); } } 虚假唤醒问题 等待判断应该放在while中，不应该放在if中（if只能判断一次） ","date":"2021-10-06","objectID":"/juc/:1:3","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"线程间定制化通信 private Condition c3 = lock.newCondition(); 通知谁 调用谁的signal()方法 c3.signal(); /* 线程间定制化通知 */ //第一步 创建资源类 class ShareResource { //定义标志位 private int flag = 1;//1:aa,2:bb,3:cc //创建lock锁 private Lock lock = new ReentrantLock(); // 创建三个Condition private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); //打印5次，参数第几轮 public void print5(int loop) throws InterruptedException { //上锁 lock.lock(); try { //判断 while (flag != 1) { c1.await(); } //干活 for (int i = 0; i \u003c 5; i++) { System.out.println(Thread.currentThread().getName()+\"::\"+i+\"第几轮：\"+loop); } //通知 flag = 2; //通知c2 c2.signal(); }finally { lock.unlock(); } } //打印10次，参数第几轮 public void print10(int loop) throws InterruptedException { //上锁 lock.lock(); try { //判断 while (flag != 2) { c2.await(); } //干活 for (int i = 0; i \u003c 10; i++) { System.out.println(Thread.currentThread().getName()+\"::\"+i+\"第几轮：\"+loop); } //通知 flag = 3; c3.signal(); }finally { lock.unlock(); } } //打印15次，参数第几轮 public void print15(int loop) throws InterruptedException { //上锁 lock.lock(); try { //判断 while (flag != 3) { c3.await(); } //干活 for (int i = 0; i \u003c 15; i++) { System.out.println(Thread.currentThread().getName()+\"::\"+i+\"第几轮：\"+loop); } //通知 flag = 1; c1.signal(); }finally { lock.unlock(); } } } public class ThreadDemo3 { public static void main(String[] args) { ShareResource shareResource = new ShareResource(); new Thread(() -\u003e { try { for (int i = 0; i \u003c 5; i++) { shareResource.print5(i); } } catch (InterruptedException e) { e.printStackTrace(); } },\"aa\").start(); new Thread(() -\u003e { try { for (int i = 0; i \u003c 5; i++) { shareResource.print10(i); } } catch (InterruptedException e) { e.printStackTrace(); } },\"bb\").start(); new Thread(() -\u003e { try { for (int i = 0; i \u003c 5; i++) { shareResource.print15(i); } } catch (InterruptedException e) { e.printStackTrace(); } },\"cc\").start(); } } ","date":"2021-10-06","objectID":"/juc/:1:4","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"集合的线程安全 ArrayList,HashMap,HashSet线程不安全 ArrayList解决方法 Vector Collections CopyOnWriteArrayList 写时复制技术：并发读，独立写：每次写入的时候先复制一份，写入新内容后再合并 public class ArrayListSync { public static void main(String[] args) { // List\u003cString\u003e list = new ArrayList\u003c\u003e(); //1.Vector // List\u003cString\u003e list = new Vector\u003c\u003e(); //2.Collections // List\u003cString\u003e list = Collections.synchronizedList(new ArrayList\u003c\u003e()); //CopyOnWriteArrayList CopyOnWriteArrayList\u003cString\u003e list = new CopyOnWriteArrayList\u003c\u003e(); for (int i = 0; i \u003c 400; i++) { new Thread(()-\u003e{ list.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(list); }).start(); } } } HashSet解决方法 CopyOnWriteArraySet HashMap解决方法 ConcurrentHashMap ","date":"2021-10-06","objectID":"/juc/:1:5","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"多线程锁 锁的八种情况 synchronized实现同步的基础:Java中的每一个对象都可以作为锁具体表现为以下3种形式。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchonized括号里配置的对象 公平锁和非公平锁 多线程之间工作的平均 //创建lock锁 true：公平 false：非公平 private Lock lock = new ReentrantLock(true); 公平锁：效率低，平均 非公平锁：效率高，不平均 死锁 ","date":"2021-10-06","objectID":"/juc/:1:6","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"Callable Runnable Callable 返回值 无 有 异常 无 有 实现方法 run call 代码实现 package com.jsh.juc.callable; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; class MyThread implements Callable{ @Override public Object call() throws Exception { return 200; } } public class Demo1 { public static void main(String[] args) throws ExecutionException, InterruptedException { //方法一 //FutureTask 未来任务 FutureTask\u003cInteger\u003e futureTask1 = new FutureTask\u003c\u003e(new MyThread()); //方法二 //lam表达式 FutureTask\u003cInteger\u003e futureTask2 = new FutureTask\u003c\u003e(() -\u003e{ System.out.println(Thread.currentThread().getName()+\"2\"); return 1024; }); //创建线程 ，启动 new Thread(futureTask2,\"lucy\").start(); //线程是否结束 while (!futureTask2.isDone()) { System.out.println(\"wait。。。。。\"); } //第一次调用 计算 返回结果 System.out.println(futureTask2.get()); //第二次调用直接返回结果 System.out.println(futureTask2.get()); } } ","date":"2021-10-06","objectID":"/juc/:1:7","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"JUC辅助类 减少计数CountDownLatch 创建计数器CountDownLatch countDownLatch = new CountDownLatch(6); 计数-1countDownLatch.countDown(); 等待，当计数为0时继续countDownLatch.await(); public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { //计数器 CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i \u003c 7; i++) { new Thread(() -\u003e { System.out.println(Thread.currentThread().getName()+\"走了\"); //计数-1 countDownLatch.countDown(); },String.valueOf(i)).start(); } //等待 countDownLatch.await(); System.out.println(\"班长锁门\"); } } 循环栅栏CyclicBarrier 创建栅栏： CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-\u003e{ System.out.println(\"召唤神龙\"); }); 等待： cyclicBarrier.await(); public class CyclicBarrierDemo { public static void main(String[] args) { //循环栅栏 CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-\u003e{ System.out.println(\"召唤神龙\"); }); for (int i = 1; i \u003c= 7; i++) { new Thread(() -\u003e { try { System.out.println(Thread.currentThread().getName()+\"星龙珠被找到了\"); //等待 cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } },String.valueOf(i)).start(); } } } 信号灯Semaphore 创建：Semaphore semaphore = new Semaphore(3); 占领：semaphore.acquire(); 释放：semaphore.release(); /** * 信号灯 */ //模拟六辆汽车，停3个停车位 public class SemaphoreDemo { public static void main(String[] args) { //模拟三个车位 Semaphore semaphore = new Semaphore(3); //模拟6辆汽车 for (int i = 0; i \u003c 6; i++) { new Thread(()-\u003e{ try { //占车位 semaphore.acquire(); System.out.println(Thread.currentThread().getName()+\"抢到了车位\"); //设置随机停车时间 TimeUnit.SECONDS.sleep(new Random().nextInt(5)); System.out.println(Thread.currentThread().getName()+\"----------离开了车位\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { //释放车位 semaphore.release(); } },String.valueOf(i)).start(); } } } ","date":"2021-10-06","objectID":"/juc/:1:8","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"读写锁ReentrantReadWriteLock 读写锁概念 现实中有这样一种场景:对共享资源有读和写的操作，且写操作没有读操作那 么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以 应该允许多个线程同时读取共享资源;但是如果一个线程想去写这些共享资源， 就不应该允许其他线程对该资源进行读和写的操作了。 针对这种场景，JAVA 的并发包提供了读写锁 ReentrantReadWriteLock， 它表示两个锁，一个是读操作相关的锁，称为共享锁;一个是写相关的锁，称为排他锁 演示读写锁 //资源类 class MyCache { private volatile Map\u003cString, String\u003e map = new HashMap\u003c\u003e(); //创建读写锁对象 private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //放数据 public void put(String key, String value) { //添加写锁 readWriteLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + \"正在写数据\"); //暂停一会 TimeUnit.MICROSECONDS.sleep(300); //放数据 map.put(key, value); System.out.println(Thread.currentThread().getName() + \"写完了\" + key); } catch (InterruptedException e) { e.printStackTrace(); } finally { //释放锁 readWriteLock.writeLock().unlock(); } } //取数据 public String get(String key) { //添加读锁 readWriteLock.readLock().lock(); String res = null; try { System.out.println(Thread.currentThread().getName() + \"正在读数据\"); //暂停一会 TimeUnit.MICROSECONDS.sleep(300); //放数据 res = map.get(key); System.out.println(Thread.currentThread().getName() + \"读完了\" + key); } catch (InterruptedException e) { e.printStackTrace(); } finally { //释放锁 readWriteLock.readLock().unlock(); } return res; } } public class ReadWriteLockDemo { public static void main(String[] args) { MyCache myCache = new MyCache(); //创建线程 放数据 for (int i = 0; i \u003c 5; i++) { int finalI = i; new Thread(() -\u003e { myCache.put(finalI + \"\", finalI + \"\"); }, i + \"存\").start(); } //创建线程 取数据 for (int i = 0; i \u003c 5; i++) { int finalI = i; new Thread(() -\u003e { myCache.get(finalI + \"\"); }, i + \"取\").start(); } } } 读写锁演变 读写锁的降级 写锁-\u003e读锁 可以先写不释放锁 然后读 不可以先读不释放锁 然后写 ","date":"2021-10-06","objectID":"/juc/:1:9","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"阻塞队列BlockingQueue 分类 ArrayBlockingQueue(常用) 有界 LinkedBlockingQueue(常用) 有界 核心方法 实现 public class BlockingQueueDemo { public static void main(String[] args) throws InterruptedException { //创建阻塞队列 BlockingQueue\u003cString\u003e blockingQueue = new ArrayBlockingQueue\u003c\u003e(3); //第一组 System.out.println(blockingQueue.add(\"a\")); System.out.println(blockingQueue.add(\"b\")); System.out.println(blockingQueue.add(\"c\")); System.out.println(blockingQueue.element()); System.out.println(blockingQueue.add(\"x\")); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); //第二组 System.out.println(blockingQueue.offer(\"a\")); System.out.println(blockingQueue.offer(\"b\")); System.out.println(blockingQueue.offer(\"c\")); System.out.println(blockingQueue.offer(\"x\")); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); // 第三组 blockingQueue.put(\"a\"); blockingQueue.put(\"b\"); blockingQueue.put(\"c\"); blockingQueue.put(\"x\"); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); //第四组 System.out.println(blockingQueue.offer(\"a\")); System.out.println(blockingQueue.offer(\"b\")); System.out.println(blockingQueue.offer(\"c\")); System.out.println(blockingQueue.offer(\"a\", 3L, TimeUnit.SECONDS)); //第一组 System.out.println(blockingQueue.add(\"a\")); System.out.println(blockingQueue.add(\"b\")); System.out.println(blockingQueue.add(\"c\")); System.out.println(blockingQueue.element()); } } ","date":"2021-10-06","objectID":"/juc/:1:10","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"线程池ThreadPool 使用 三种都是创建ThreadPoolExecutor //演示线程池的三种常用分类 public class ThreadPoolDemo { public static void main(String[] args) { //一池五线程 ExecutorService threadPool1 = Executors.newFixedThreadPool(5); //一池一线程 ExecutorService threadPool2 = Executors.newSingleThreadExecutor(); //一池可扩容线程 ExecutorService threadPool3 = Executors.newCachedThreadPool(); //十个顾客请求 try { for (int i = 0; i \u003c 1000; i++) { //执行 threadPool3.execute(() -\u003e { System.out.println(Thread.currentThread().getName() + \" 办理业务\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool3.shutdown(); } } } ThreadPoolExecutor 线程池底层工作流程 在创建了线程池后，线程池中的线程数为零 当调用execute()方法添加一个请求任务时，线程池会做出如下判断: 2.1如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务; 2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入 队列; 2.3 如果这个时候队列满了且正在运行的线程数量还小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务; 2.4 如 果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程 池会启动饱和拒绝策略来执行。 当一个线程完成任务时，它会从队列中取下一个任务来执行 当一个线程无事可做超过一定的时间(keepAliveTime)时，线程会判断: 4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。 4.2 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。 拒绝策略 自定义线程池 public class MyThreadPool { public static void main(String[] args) { ThreadPoolExecutor threadPool = new ThreadPoolExecutor( 2, 5, 2L, TimeUnit.SECONDS, new ArrayBlockingQueue\u003c\u003e(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); //十个顾客请求 try { for (int i = 0; i \u003c 10; i++) { //执行 threadPool.execute(() -\u003e { System.out.println(Thread.currentThread().getName() + \" 办理业务\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); } } } ","date":"2021-10-06","objectID":"/juc/:1:11","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"线程池核心参数如何填写 n是服务器线程数 IO密集型：2n cpu密集型：n+1 ","date":"2021-10-06","objectID":"/juc/:1:12","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"Fork/Join分支合并框架 Fork/Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子 任务结果合并成最后的计算结果，并进行输出。 Fork:把一个复杂任务进行分拆，大事化小 Join:把分拆任务的结果进行合并 class Mytask extends RecursiveTask\u003cInteger\u003e { //拆分差值不超过10,计算10以内的运算 private static final Integer VALUE = 10; private int begin; //拆分开始值 private int end; //拆分结束值 private int result; //返回结果 public Mytask(int begin, int end) { this.begin = begin; this.end = end; } @Override protected Integer compute() { if ((end - begin) \u003c VALUE) { //相加 for (int i = begin; i \u003c= end; i++) { result += i; } } else {//进一步拆分 int middle = (begin + end) / 2; Mytask taskLeft = new Mytask(begin, middle); Mytask taskRight = new Mytask(middle+1, end); taskLeft.fork(); taskRight.fork(); result = taskLeft.join()+taskRight.join(); } return result; } } public class ForkJoinDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建MyTask对象 Mytask mytask = new Mytask(0,100); //创建分支合并池对象 ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask\u003cInteger\u003e submit = forkJoinPool.submit(mytask); //获取结果 Integer integer = submit.get(); System.out.println(integer); //关闭池对象 forkJoinPool.shutdown(); } } ","date":"2021-10-06","objectID":"/juc/:1:13","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Java"],"content":"异步回调CompletableFuture CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞， 可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可 以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。 简单实现 public class CompletableFutureDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { //异步调用 没有返回值 CompletableFuture\u003cVoid\u003e completableFuture1 = CompletableFuture.runAsync(()-\u003e{ System.out.println(Thread.currentThread().getName()+\"completableFuture1\"); }); completableFuture1.get(); //异步调用 有返回值 CompletableFuture\u003cInteger\u003e completableFuture2 = CompletableFuture.supplyAsync(()-\u003e{ System.out.println(Thread.currentThread().getName()+\"completableFuture2\"); //模拟异常 int a = 1/0; return 2; }); Integer integer = completableFuture2.whenComplete((t,u)-\u003e{ System.out.println(t); // 2：方法返回值 System.out.println(u); // null：异常信息 }).get(); System.out.println(integer); } } ","date":"2021-10-06","objectID":"/juc/:1:14","tags":["多线程"],"title":"JUC","uri":"/juc/"},{"categories":["Spring"],"content":"Springboot自动装配 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:0:0","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"Springboot自动装配 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:1:0","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"怎么给spring容器添加组件 原来的SSM使用xml文件 \u003cbean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"\u003e \u003cproperty name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/\u003e \u003cproperty name=\"url\" value=\"${jdbc.url}\"/\u003e \u003cproperty name=\"username\" value=\"${jdbc.username}\"/\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"/\u003e \u003c/bean\u003e Springboot 方式 @Configuration 等同于配置文件 参数：proxyBeanMethods: true单实例(别人依赖时使用) false多实例(别人不依赖时使用) @Bean 等同于原来的bean 把返回值放在spring容器中 默认单实例 @ConditionalOnBean(条件) 可以加在方法上和类上，满足条件后才会加载 @Import({class, class…}) 可以自动创建出这几个类型的组件，默认是全类名(包名➕类名) @ImportResource(“资源路径”) 解析xml文件到spring容器中 @ConfigurationProperties(“j j j”) 获取配置的变量 需要和一下两个注解结合使用 @Configuration 和@ConfigurationProperties在一起使用 @EnableConfigurationProperties(XXXProperties.class) 引用时使用 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:1:1","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"自动配置原理 SpringBootApplication @SpringBootConfiguration表示是一个配置类 @ComponentScan 包扫描 @EnableAutoConfiguration 重要 自动装配 @AutoConfigurationPackage @Import(AutoConfigurationPackages.Registrar.class) 利用Registrar给容器中导入一系列组件 将指定的（MainApplication）包下的所有组件倒入容器中 @Import(AutoConfigurationImportSelector.class) AutoConfigurationImportSelector.class 主要是这句获取容器中所有组件 List\u003cString\u003e configurations = getCandidateConfigurations(annotationMetadata, attributes); 一路找下去 最后到 这个方法扫描spring-boot-autoconfigure自动配置类 文件里边写死了springboot一启动就要加载的组件默认全部加载，最终会按需配置（@ConditionalXXX） ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:1:2","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"自定义starter starter:是一种开发场景，可以引入很多autoconfigure autoconfigure：自动装配 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:2:0","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"代码实现 starter 只需要引入autoconfigure即可 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.jsh\u003c/groupId\u003e \u003cartifactId\u003ejsh-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.jsh\u003c/groupId\u003e \u003cartifactId\u003ejsh-spring-boot-starter-autoconfigure\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e autoconfigure 编写XXXProperties引入配置的变量 @ConfigurationProperties(\"jsh\") public class JshProperties { private String prefix; private String suffix; public JshProperties() { } public JshProperties(String prefix, String suffix) { this.prefix = prefix; this.suffix = suffix; } public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } } 编写具体的业务或者配置 service /** * 默认不要放在容器中 */ public class HelloService { @Autowired JshProperties jshProperties; public String sayHello(String userName){ return jshProperties.getPrefix()+\":\"+userName+\":\"+jshProperties.getSuffix(); } } XXXAutoConfiguration @Configuration @EnableConfigurationProperties(JshProperties.class) //默认JshProperties放在容器中 public class JshServiceAutoConfiguration { @Bean @ConditionalOnMissingBean(HelloService.class) public HelloService helloService(){ return new HelloService(); } } META-INF spring.factories # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.jsh.auto.JshServiceAutoConfiguration ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:2:1","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"使用 引入依赖 配置 使用 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:2:2","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["中间件"],"content":"RocketMQ ","date":"2021-09-13","objectID":"/rocketmq/:0:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"应用场景 异步解藕 削峰填谷 消息分发 ","date":"2021-09-13","objectID":"/rocketmq/:1:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"环境搭建 上传rocketmq-all-4.4.0-bin-release.zip 到家目录 使用解压命令进行解压 unzip /usr/local/rocketmq-all-4.4.0-bin-release.zip 软件重命名 mv /usr/local/rocketmq-all-4.4.0-bin-release/ /usr/local/rocketmq-4.4/ 修改启动参数配置 JAVA_OPT=\"${JAVA_OPT} -server -Xms1g -Xmx1g -Xmn1g\" 两个文件 vi /usr/local/rocketmq-4.4/bin/runbroker.sh vi /usr/local/rocketmq-4.4/bin/runserver.sh 启动名字服务和代理服务 nohup sh /usr/local/rocketmq-4.4/bin/mqnamesrv \u0026 # -n localhost:9876 指定名称服务的地址, 类似于zk的地址 nohup sh /usr/local/rocketmq-4.4/bin/mqbroker -n localhost:9876 -c /usr/local/rocketmq-4.4/conf/broker.conf \u0026 检验是否启动正常 使用java的内置命令: jps 可以看到BrokerStartup和NamesrvStartup进程 使用Linux命令**: netstat-ntlp 可以看到9876的端口和10911的端口** 使用ps-ef |grep java 查看启动日志: tail -100f ~/logs/rocketmqlogs/namesrv.log tail -100f ~/logs/rocketmqlogs/broker.log 关闭RocketMQ # 1.关闭NameServer sh /usr/local/rocketmq-4.4/bin/mqshutdown namesrv # 2.关闭Broker sh /usr/local/rocketmq-4.4/bin/mqshutdown broker ","date":"2021-09-13","objectID":"/rocketmq/:2:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"编写sh脚本文件 启动(startRocketMQ.sh) # !/bin/bash echo '------------------rocketmq-nameServer-starter-------------------------' nohup sh /usr/local/rocketmq-4.4/bin/mqnamesrv \u0026 echo '------------------rocketmq-nameServer-started-------------------------' echo '------------------rocketmq-brokerServer-starter-----------------------' nohup sh /usr/local/rocketmq-4.4/bin/mqbroker -n localhost:9876 -c /usr/local/rocketmq-4.4/conf/broker.conf \u0026 echo '------------------rocketmq-brokerServer-started-----------------------' 关闭(stutdownRocketMQ.sh) # !/bin/bash echo '------------------rocketmq-nameServer-shutdown-------------------------' sh /usr/local/rocketmq-4.4/bin/mqshutdown namesrv echo '------------------rocketmq-nameServer-shutdowned-------------------------' echo '------------------rocketmq-brokerServer-shutdown-----------------------' sh /usr/local/rocketmq-4.4/bin/mqshutdown broker echo '------------------rocketmq-brokerServer-shutdowned-----------------------' ","date":"2021-09-13","objectID":"/rocketmq/:2:1","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"监控平台 使用jar nohup java -jar rocketmq-console-ng-1.0.1.jar \u0026 ","date":"2021-09-13","objectID":"/rocketmq/:3:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"SpringBoot集成 ","date":"2021-09-13","objectID":"/rocketmq/:4:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.rocketmq\u003c/groupId\u003e \u003cartifactId\u003erocketmq-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.0.3\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-09-13","objectID":"/rocketmq/:4:1","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"配置 生产者 rocketmq.name-server=127.0.0.1:9876 rocketmq.producer.group=my-group 消费者 rocketmq.name-server=127.0.0.1:9876 ","date":"2021-09-13","objectID":"/rocketmq/:4:2","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"编码 生产者 @RestController public class HelloController { @Autowired private RocketMQTemplate rocketMQTemplate; @RequestMapping(\"01-hello\") public String sendMsg(String message,String age) throws Exception{ //发送消息 SendResult sendResult = rocketMQTemplate.syncSend(\"01-boot:\", message); System.out.println(sendResult.getMsgId()); System.out.println(sendResult.getSendStatus()); return \"success\"; } } 消费者 @Component @RocketMQMessageListener( topic = \"01-boot\", consumerGroup = \"wolfcode-consumer\" ) public class HelloConsumer implements RocketMQListener\u003cMessageExt\u003e { @Override public void onMessage(MessageExt messageExt) { System.out.println(\"消费消息\"+messageExt); } } 发送消息方式(生产者) 发送类型 同步消息 SendResult sendResult = rocketMQTemplate.syncSend(\"020-boot\", msg); System.out.println(sendResult.getMsgId()); System.out.println(sendResult.getSendStatus()); 异步消息 rocketMQTemplate.asyncSend(\"020-boot\", msg, new SendCallback() { @Override public void onSuccess(SendResult sendResult) { System.out.println(sendResult.getMsgId()); System.out.println(sendResult.getSendStatus()); } @Override public void onException(Throwable throwable) { System.out.println(throwable); } }); 一次性消息 rocketMQTemplate.sendOneWay(\"020-boot\", msg); 发送时间 默认立即发送 延时发送 // 参数1:主题 2:消息 3:rocket发送最大允许时间 4:延时级别(18级) SendResult sendResult = rocketMQTemplate.syncSend(\"020-boot\", MessageBuilder.withPayload(msg).build(),100000,3); 消费模式(消费者) 以组为单位 默认为集群模式 集群模式(每组只有一个可以收到) @Component @RocketMQMessageListener( topic = \"020-boot\", messageModel = MessageModel.CLUSTERING, consumerGroup = \"wolfcode-consumer\" ) public class MqListenner implements RocketMQListener\u003cString\u003e { @Override public void onMessage(String s) { System.out.println(\"今天上映:\"+s); } } 广播模式(每组的所有消费者都可以收到) @Component @RocketMQMessageListener( topic = \"020-boot\", messageModel = MessageModel.BROADCASTING, consumerGroup = \"wolfcode-consumer\" ) public class MqListenner implements RocketMQListener\u003cString\u003e { @Override public void onMessage(String s) { System.out.println(\"今天上映:\"+s); } } 消息过滤 Tag标签模式 在发送的消息Topic:Tag 中间使用冒号隔开 生产者 @RequestMapping(\"/sendTagMsg\") public String sendTagMsg(String msg) { rocketMQTemplate.convertAndSend(\"020-boot:TagB\",msg); return \"success\"; } 消费者 @Component @RocketMQMessageListener( topic = \"020-boot\", selectorType = SelectorType.TAG, //接收TagB或TagA secretKey = \"TagB || TagA\", consumerGroup = \"wolfcode-consumer\" ) public class MqListenner implements RocketMQListener\u003cString\u003e { @Override public void onMessage(String s) { System.out.println(\"今天上映:\"+s); } } SQL92过滤 注意: 在使用SQL过滤的时候, 需要配置参数enablePropertyFilter=true 生产者 //Sql92过滤 @RequestMapping(\"/sendSQLMsg\") public String sendSQLMsg(int age,String msg) { Map\u003cString,Object\u003e map=new HashMap\u003c\u003e(); //用户自定义属性 map.put(\"age\", age); map.put(\"name\", \"hesj\"); //也可以设置系统属性 map.put(MessageConst.PROPERTY_KEYS,age); template.convertAndSend(\"02-RocketMQ-Top7\",msg,map); return \"success\"; } 消费者 @Component @RocketMQMessageListener( topic = \"02-RocketMQ-Top7\", messageModel = MessageModel.CLUSTERING, selectorType = SelectorType.SQL92, selectorExpression = \"age \u003e 16\", consumerGroup= \"wolfcode-consumer7\" ) public class MqListiner7 implements RocketMQListener\u003cString\u003e { @Override public void onMessage(String msg) { System.out.println(\"消费消息SQl92\"+msg); } } ​ ","date":"2021-09-13","objectID":"/rocketmq/:4:3","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["SpringCloud"],"content":"SpringCloud常用 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:0:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Nacos 注册服务中心 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:1:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"启动命令 //单机 sh startup.sh -m standalone ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:1:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"简介 为什么叫Nacos 前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service。 是什么 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Nacos: Dynamic Naming and Configuration Service Nacos就是注册中心＋配置中心的组合 -\u003e Nacos = Eureka+Config+Bus 核心功能点: 服务注册: Nacos Client会通过发送REST请求想Nacos Server注册自己的服务，提供自身的元数据，比如IP地址，端口等信息。Nacos Server接收到注册请求后，就会把这些元数据存储到一个双层的内存Map中。 服务心跳: 在服务注册后，Nacos Client会维护一个定时心跳来维持统治Nacos Server,说明服务一致处于可用状态，防止被剔除，默认5s发送一次心跳 服务同步: Nacos Server集群之间会相互同步服务实例，用来保证服务信息的一致性。 服务发现： 服务消费者(Nacos Client)在调用服务提供的服务时，会发送一个REST请求给Nacos Server,获取上面注册的服务清单，并且缓存在Nacos Client本地,同时会在Nacos Client本地开启一个定时任务拉取服务最新的注册表信息更新到本地缓存。 服务健康检查: Nacos Server 会开启一个定时任务来检查注册服务实例的健康情况，对于超过15s没有收到客户端心跳的实例会将他的healthy属性设置为false(客户端服务发现时不会发现)，如果某个实例超过30s没有收到心跳，直接剔除该实例(被剔除的实例如果恢复发送心跳则会重新注册) ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:1:2","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"搭建 pom \u003c!--nacos客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e yml（添加注册中心地址） spring: cloud: nacos: discovery: server-addr: localhost:8848 在主类上添加**@EnableDiscoveryClient**注解 @SpringBootApplication @EnableDiscoveryClient public class ProductServer { public static void main(String[] args) { SpringApplication.run(ProductServer.class,args); } } 查看nacos控制台出现服务 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:1:3","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"配置中心 Nacos Confifig入门 Nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则 说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。 在 Nacos Spring Cloud中,dataId的完整格式如下： ${prefix}-${spring-profile.active}.${file-extension} prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。 spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符 - 也将不存在，datald 的拼接格式变成${prefix}.${file-extension} file-exetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.file-extension来配置。目前只支持properties和yaml类型。 通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。 搭建nacos环境 在商品微服务中引入nacos的依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-config\u003c/artifactId\u003e \u003c/dependency\u003e 在微服务中添加nacos config的配置 注意:不能使用原来的application.yml作为配置文件，而是新建一个bootstrap.yml作为配置文件 配置文件优先级(由高到低): bootstrap.properties -\u003e bootstrap.yml -\u003e application.properties -\u003e application.yml spring: application: name: product-service cloud: nacos: config: server-addr: 127.0.0.1:8848 #nacos中心地址 file-extension: yaml # 配置文件格式 profiles: active: dev # 环境标识 在nacos中添加配置,然后把商品微服务application.yml配置复制到配置内容中. 注释本地的application.yam中的内容， 启动程序进行测试 如果依旧可以成功访问程序，说明我们nacos的配置中心功能已经实现 完整配置 DataID+Group+Namespace确定读取哪个配置文件 dataId的完整格式:${prefix}-${spring-profile.active}.${file-extension} spring: application: name: product-service cloud: nacos: config: server-addr: 127.0.0.1:8848 #nacos中心地址 file-extension: yaml # 配置文件格式 # namespace: # group: profiles: active: dev # 环境标识 动态刷新 在controller上加注解@RefreshScope 配置共享 同一微服务配置共享 只需要提取一个以 spring.application.name 命名的配置文件，然后将其所有环境的公共配置放在里面即可 不加「-开发环境」就可以 不同微服务配置共享 不同为服务之间实现配置共享的原理类似于文件引入，就是定义一个公共配置，然后在当前配置中引入。 在nacos中定义一个DataID为global-config.yaml的配置，用于所有微服务共享 globalConfig: global 修改bootstrap.yaml spring: application: name: product-service cloud: nacos: config: server-addr: 127.0.0.1:8848 #nacos中心地址 file-cextension: yaml # 配置文件格式 shared-configs: - data-id: global-config.yaml # 配置要引入的配置 refresh: true profiles: active: test # 环境标识 在NacosConfigController.java中新增一个方法 @RestController @RefreshScope public class NacosConfigController { @Value(\"${appConfig.name}\") private String appConfigName; @Value(\"${env}\") private String env; @Value(\"${globalConfig}\") private String globalConfig; @RequestMapping(\"/nacosConfig1\") public String nacosConfig(){ return \"远程信息:\"+appConfigName; } @RequestMapping(\"/nacosConfig2\") public String nacosConfig2(){ return \"公共配置:\"+appConfigName+\",环境配置信息:\"+env; } @RequestMapping(\"/nacosConfig3\") public String nacosConfig3(){ return \"全局配置:\"+globalConfig+\",公共配置:\"+appConfigName+\",环境配置信息:\"+env; } } 重启服务并测试. ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:1:4","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Nacos持久化 nacos-server-1.1.4\\nacos\\conf录下找到nacos-mysql.sql文件，执行脚本。 nacos-server-1.1.4\\nacos\\conf目录下找到application.properties，添加以下配置（按需修改对应值）。 spring.datasource.platform=mysql db.num=1 db.url.0=jdbc:mysql://localhost:3306/nacos_devtest?characterEncoding=utf8\u0026connectTimeout=1000\u0026socketTimeout=3000\u0026autoReconnect=true db.user=root db.password=1234 重启 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:1:5","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Nacos集群 必须持久化 配置cluster.conf # 三个服务器加端口 192.168.111.144:3333 192.168.111.144:4444 192.168.111.144:5555 分别启动三个nacos 配置nginx作为负载均衡器 upstream cluster{ server 127.0.0.1:3333; server 127.0.0.1:4444; server 127.0.0.1:5555; } server { listen 1111; server_name 127.0.0.1; location / { proxy_pass http://cluster; } } 启动2222 3333 4444 nginx 测试 测试通过nginx，访问nacos - http://127.0.0.1:1111/nacos/#/login 修改配置看是否会同步？会 让微服务cloudalibaba-provider-payment9002启动注册进nacos集群 - 修改配置文件 server: port: 9002 spring: application: name: nacos-payment-provider c1oud: nacos: discovery: #配置Nacos地址 #server-addr: Localhost:8848 #换成nginx的1111端口，做集群 server-addr: 192.168.111.144:1111 management: endpoints: web: exposure: inc1ude: '*' 启动微服务cloudalibaba-provider-payment9002 访问nacos，查看注册结果 总结 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:1:6","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Ribbon 负载均衡 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:2:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"配置负载均衡策略 com.netflix.loadbalancer.IRule , 具体的负载策略如下图所示: 策略名 策略描述 实现说明 AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例； 使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态 WeightedResponseTimeRule 根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。 一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权 RetryRule 对选定的负载均衡策略机上重试机制。 在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server RoundRobinRule 轮询方式轮询选择server 轮询index，选择index对应位置的server RandomRule 随机选择一个server 在index上随机，选择index对应位置的server BestAvailableRule 选择一个最小的并发请求的server 逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server ZoneAvoidanceRule(默认) 复合判断server所在区域的性能和server的可用性选择server 使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。 我们可以通过修改配置来调整Ribbon的负载均衡策略，在application.yml中增加如下配置: \u003c调用的服务名\u003e: # 调用的提供者的名称 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:2:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"OpenFeign 远程调用 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:3:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"简单使用 pom \u003c!--fegin组件--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e 启动类 @EnableFeignClients @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class OrderServer { public static void main(String[] args) { SpringApplication.run(OrderServer.class,args); } } 使用 直接复制对应微服务的controller 注意⚠️： 请求路径注意复制完整 每个参数都需要注解 @Component @FeignClient(value = \"cloud-payment-service\") public interface PaymentFeignService { /** * 方法的参数必须有注解 * @PathVariable 路径变量 * @RequestParam 参数 * @RequestBody 参数对象 * * @param pid * @return */ @GetMapping(value = \"/payment/get/{id}\") public CommonResult getPamentById(@PathVariable(\"id\")Long id); } ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:3:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"OpenFeign超时控制 OpenFeign默认等待1秒钟，超过后报错 yml配置 #设置feign客户端超时时间(OpenFeign默认支持ribbon)(单位：毫秒) ribbon: #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间 ReadTimeout: 5000 #指的是建立连接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:3:2","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"OpenFeign日志增强 配置日志bean NONE：默认的，不显示任何日志; BASIC：仅记录请求方法、URL、响应状态码及执行时间; HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息; FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。 package com.atguigu.springcloud.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FeignConfig { @Bean Logger.Level feignLoggerLevel() { //NONE：默认的，不显示任何日志; //BASIC：仅记录请求方法、URL、响应状态码及执行时间; //HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息; //FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。 return Logger.Level.FULL; } } YML文件里需要开启日志的Feign客户端 logging: level: # feign日志以什么级别监控哪个接口 com.lun.springcloud.service.PaymentFeignService: debug ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:3:3","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"集成Sentinel,服务降级处理 yaml配置 product-service: # 调用的提供者的名称 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 使用 ProductFeignApi @FeignClient(name = \"product-service\",fallback = ProductFeignFallBack.class) public interface ProductFeignApi { @RequestMapping(\"/product/{pid}\") public Product findByPid( @PathVariable(\"pid\") Long pid); } ProductFeignFallBack @Component public class ProductFeignFallBack implements ProductFeignApi { @Override public Product findByPid(Long pid) { Product product = new Product(); product.setPid(-1L); product.setPname(\"兜底数据\"); product.setPprice(0.0); return product; } } ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:3:4","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel 服务保护 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"订单微服务集成Sentinel 为微服务集成Sentinel非常简单, 只需要加入Sentinel的依赖即可 在shop-order-server项目的pom文件中添加如下依赖 \u003c!--sentinel组件--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-sentinel\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"安装Sentinel控制台 Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。 下载jar包 https://github.com/alibaba/Sentinel/releases 启动控制台 # 直接使用jar命令启动项目(控制台本身是一个SpringBoot项目) java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.0.jar 修改shop-order-server项目中的配置文件application.yml,新增如下配置: spring: cloud: sentinel: transport: port: 9999 #跟控制台交流的端口,随意指定一个未使用的端口即可 dashboard: localhost:8080 # 指定控制台服务的地址 通过浏览器访问localhost:8080 进入控制台 ( 默认用户名密码是 sentinel/sentinel ) 注意: 默认是没显示order-service的，需要访问几次接口，然后再刷新sentinel管控台才可以看到. ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:2","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"实现一个接口的限流 第一步: 簇点链路—\u003e流控 第二步: 在单机阈值填写一个数值，表示每秒上限的请求数 第三步:通过控制台快速频繁访问, 观察效果 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:3","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel容错的维度 流量控制：流量控制在网络传输中是一个常用的概念，它用于调整网络包的数据。任意时间到来的请求往往是 随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。 熔断降级：当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则 对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。 系统负载保护：Sentinel 同时提供系统维度的自适应保护能力。当系统负载较高的时候，如果还持续让 请求进入可能会导致系统崩溃，无法响应。在集群环境下，会把本应这台机器承载的流量转发到其 它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，Sentinel 提供了对应的保 护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请 求。 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:4","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel规则种类 Sentinel主要提供了这五种的流量控制，接下来我们每种都给同学们演示一下. ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:5","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel规则-流控 流控规则 流量控制，其原理是监控应用流量的QPS(每秒查询率) 或并发线程数等指标，当达到指定的阈值时 对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。 资源名：唯一名称，默认是请求路径，可自定义 针对来源：指定对哪个微服务进行限流，默认指default，意思是不区分来源，全部限制 阈值类型/单机阈值： QPS（每秒请求数量）: 当调用该接口的QPS达到阈值的时候，进行限流 线程数：当调用该接口的线程数达到阈值的时候，进行限流 是否集群：暂不需要集群 QPS流控 前面演示的QPS流控 线程数流控 删除掉之前的QPS流控，新增线程数流控 在Jmeter中新增线程 访问 localhost:8091/sentinel2 会发现已经被限流 流控模式 点击上面设置流控规则的编辑按钮，然后在编辑页面点击高级选项，会看到有流控模式一栏。 sentinel共有三种流控模式，分别是： 直接（默认）：接口达到限流条件时，开启限流 关联：当关联的资源达到限流条件时，开启限流 [适合做应用让步] 链路：当从某个接口过来的资源达到限流条件时，开启限流 直接流控模式 前面演示的案例就是这种. 关联流控模式 关联流控模式指的是，当指定接口关联的接口达到限流条件时，开启对指定接口开启限流。 场景:当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢. 在SentinelController.java中增加一个方法，重启订单服务 @RequestMapping(\"/sentinel3\") public String sentinel3(){ return \"sentinel3\"; } 配置限流规则, 将流控模式设置为关联，关联资源设置为的 /sentinel2 通过postman软件向/sentinel2连续发送请求，注意QPS一定要大于3 访问/sentinel3,会发现已经被限流 链路流控模式 链路流控模式指的是，当从某个接口过来的资源达到限流条件时，开启限流。 在shop-order-server项目的application.yml文件中新增如下配置: spring: cloud: sentinel: web-context-unify: false 在shop-order-server项目中新增TraceServiceImpl.java package cn.wolfcode.service.impl; @Service @Slf4j public class TraceServiceImpl { @SentinelResource(value = \"tranceService\") public void tranceService(){ log.info(\"调用tranceService方法\"); } } 在shop-order-server项目中新增TraceController.java package cn.wolfcode.controller; @RestController public class TraceController { @Autowired private TraceServiceImpl traceService; @RequestMapping(\"/trace1\") public String trace1(){ traceService.tranceService(); return \"trace1\"; } @RequestMapping(\"/trace2\") public String trace2(){ traceService.tranceService(); return \"trace2\"; } } 重新启动订单服务并添加链路流控规则 分别通过 /trace1 和 /trace2 访问, 发现/trace1没问题, /trace2的被限流了 流控效果 快速失败（默认）: 直接失败，抛出异常，不做任何额外的处理，是最简单的效果 Warm Up：它从开始阈值到最大QPS阈值会有一个缓冲阶段，一开始的阈值是最大QPS阈值的 1/3，然后慢慢增长，直到最大阈值，适用于将突然增大的流量转换为缓步增长的场景。 排队等待：让请求以均匀的速度通过，单机阈值为每秒通过数量，其余的排队等待； 它还会让设 置一个超时时间，当请求超过超时间时间还未处理，则会被丢弃。 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:6","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel规则-降级 降级规则就是设置当满足什么条件的时候，对服务进行降级。Sentinel提供了三个衡量条件： 慢调用比例: 选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。 异常比例: 当单位统计时长内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。 异常数：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。 慢调用比例案例 在shop-order-server项目中新增FallBackController.java类,代码如下: package cn.wolfcode.controller; @RestController @Slf4j public class FallBackController { @RequestMapping(\"/fallBack1\") public String fallBack1(){ try { log.info(\"fallBack1执行业务逻辑\"); //模拟业务耗时 TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return \"fallBack1\"; } } 新增降级规则: 上面配置表示，如果在1S之内,有【超过1个的请求】且这些请求中【响应时间\u003e最大RT】的【请求数量比例\u003e10%】，就会触发熔断，在接下来的10s之内都不会调用真实方法，直接走降级方法。 比如: 最大RT=900,比例阈值=0.1,熔断时长=10,最小请求数=10 情况1: 1秒内的有20个请求，只有10个请求响应时间\u003e900ms, 那慢调用比例=0.5，这种情况就会触发熔断 情况2: 1秒内的有20个请求，只有1个请求响应时间\u003e900ms, 那慢调用比例=0.05，这种情况不会触发熔断 情况3: 1秒内的有8个请求，只有6个请求响应时间\u003e900ms, 那慢调用比例=0.75，这种情况不会触发熔断，因为最小请求数这个条件没有满足. 注意: 我们做实验的时候把最小请求数设置为1，因为在1秒内，手动操作很难在1s内发两个请求过去，所以要做出效果,最好把最小请求数设置为1。 异常比例案例 在shop-order-server项目的FallBackController.java类新增fallBack2方法: int i=0; @RequestMapping(\"/fallBack2\") public String fallBack2(){ log.info(\"fallBack2执行业务逻辑\"); //模拟出现异常，异常比例为33% if(++i%3==0){ throw new RuntimeException(); } return \"fallBack2\"; } 新增降级规则: 上面配置表示，在1s之内，,有【超过3个的请求】，异常比例30%的情况下，触发熔断，熔断时长为10s. 异常数案例 在shop-order-server项目的FallBackController.java类新增fallBack3方法: @RequestMapping(\"/fallBack3\") public String fallBack3(String name){ log.info(\"fallBack3执行业务逻辑\"); if(\"wolfcode\".equals(name)){ throw new RuntimeException(); } return \"fallBack3\"; } 新增降级规则 上面配置表示，在1s之内，,有【超过3个的请求】，请求中超过2个请求出现异常就会触发熔断，熔断时长为10s ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:7","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel规则-热点 何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如： 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。 在shop-order-server项目中新增HotSpotController.java,代码如下: package cn.wolfcode.controller; @RestController @Slf4j public class HotSpotController { @RequestMapping(\"/hotSpot1\") @SentinelResource(value = \"hotSpot1\") public String hotSpot1(Long productId){ log.info(\"访问编号为:{}的商品\",productId); return \"hotSpot1\"; } } 注意:一定需要在请求方法上贴@SentinelResource直接，否则热点规则无效 新增热点规则: 在热点规则中编辑规则,在编辑之前一定要先访问一下/hotSpot1,不然参数规则无法新增. 新增参数规则: 点击保存，可以看到已经新增了参数规则. 访问localhost:8091/hotSpot?productId=1 访问会降级 访问localhost:8091/hotSpot?productId=2 访问不会降级 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:8","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel规则-授权 很多时候，我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问控制（黑白名单控制）的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。 在shop-order-server中新建RequestOriginParserDefinition.java,定义请求来源如何获取 @Component public class RequestOriginParserDefinition implements RequestOriginParser { @Override public String parseOrigin(HttpServletRequest request) { /** * 定义从请求的什么地方获取来源信息 * 比如我们可以要求所有的客户端需要在请求头中携带来源信息 */ String serviceName = request.getParameter(\"serviceName\"); return serviceName; } } 在shop-order-server中新建AuthController.java,代码如下: @RestController @Slf4j public class AuthController { @RequestMapping(\"/auth1\") public String auth1(String serviceName){ log.info(\"应用:{},访问接口\",serviceName); return \"auth1\"; } } 新增授权规则 访问测试 访问localhost:8091/auth1?serviceName=pc 不能访问 访问localhost:8091/auth1?serviceName=app 可以访问 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:9","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel规则-系统规则 系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。 系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。 系统规则支持以下的模式： Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load 作为启发指标，进行自适应系统保护。当系统 load 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。 CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:10","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel 自定义异常返回 当前面设定的规则没有满足是，我们可以自定义异常返回. FlowException 限流异常 DegradeException 降级异常 ParamFlowException 参数限流异常 AuthorityException 授权异常 SystemBlockException 系统负载异常 在shop-order-server项目中定义异常返回处理类 package cn.wolfcode.error; @Component public class ExceptionHandlerPage implements BlockExceptionHandler { @Override public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception { response.setContentType(\"application/json;charset=utf-8\"); ResultData data = null; if (e instanceof FlowException) { data = new ResultData(-1, \"接口被限流了\"); } else if (e instanceof DegradeException) { data = new ResultData(-2, \"接口被降级了\"); }else if (e instanceof ParamFlowException) { data = new ResultData(-3, \"参数限流异常\"); }else if (e instanceof AuthorityException) { data = new ResultData(-4, \"授权异常\"); }else if (e instanceof SystemBlockException) { data = new ResultData(-5, \"接口被降级了...\"); } response.getWriter().write(JSON.toJSONString(data)); } } @Data @AllArgsConstructor//全参构造 @NoArgsConstructor//无参构造 class ResultData { private int code; private String message; } ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:11","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"@SentinelResource的使用 在定义了资源点之后，我们可以通过Dashboard来设置限流和降级策略来对资源点进行保护。同时还能 通过@SentinelResource来指定出现异常时的处理策略。 @SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 其主要参数如下: 属性 作用 value 资源名称，必需项（不能为空） entryType entry 类型，可选项（默认为 EntryType.OUT） blockHandler/blockHandlerClass blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 fallback/fallbackClass fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求： 1. 返回值类型必须与原函数返回值类型一致； 2.方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。 3.fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 defaultFallback 默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求： 1. 返回值类型必须与原函数返回值类型一致； 2. 方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。 3. defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 exceptionsToIgnore 用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。 定义限流和降级后的处理方法 直接将限流和降级方法定义在方法中 package cn.wolfcode.controller; @RestController @Slf4j public class AnnoController { @RequestMapping(\"/anno1\") @SentinelResource(value = \"anno1\", blockHandler=\"anno1BlockHandler\", fallback = \"anno1Fallback\" ) public String anno1(String name){ if(\"wolfcode\".equals(name)){ throw new RuntimeException(); } return \"anno1\"; } public String anno1BlockHandler(String name,BlockException ex){ log.error(\"{}\", ex); return \"接口被限流或者降级了\"; } //Throwable时进入的方法 public String anno1Fallback(String name,Throwable throwable) { log.error(\"{}\", throwable); return \"接口发生异常了\"; } } ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:12","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sentinel规则持久化 推模式(基于文件) ​ 通过前面的讲解，我们已经知道，可以通过Dashboard来为每个Sentinel客户端设置各种各样的规 则，但是这里有一个问题，就是这些规则默认是存放在内存中，极不稳定，所以需要将其持久化。 ​ 本地文件数据源会定时轮询文件的变更，读取规则。这样我们既可以在应用本地直接修改文件来更 新规则，也可以通过 Sentinel 控制台推送规则。以本地文件数据源为例，推送过程如下图所示： 首先 Sentinel 控制台通过 API 将规则推送至客户端并更新到内存中，接着注册的写数据源会将新的 规则保存到本地的文件中。 编写处理类 package cn.wolfcode.sentinel; public class FilePersistence implements InitFunc { @Value(\"${spring.application.name}\") private String appcationName; @Override public void init() throws Exception { String ruleDir = System.getProperty(\"user.home\") + \"/sentinel-rules/\" + appcationName; String flowRulePath = ruleDir + \"/flow-rule.json\"; String degradeRulePath = ruleDir + \"/degrade-rule.json\"; String systemRulePath = ruleDir + \"/system-rule.json\"; String authorityRulePath = ruleDir + \"/authority-rule.json\"; String paramFlowRulePath = ruleDir + \"/param-flow-rule.json\"; this.mkdirIfNotExits(ruleDir); this.createFileIfNotExits(flowRulePath); this.createFileIfNotExits(degradeRulePath); this.createFileIfNotExits(systemRulePath); this.createFileIfNotExits(authorityRulePath); this.createFileIfNotExits(paramFlowRulePath); // 流控规则 ReadableDataSource\u003cString, List\u003cFlowRule\u003e\u003e flowRuleRDS = new FileRefreshableDataSource\u003c\u003e( flowRulePath, flowRuleListParser ); FlowRuleManager.register2Property(flowRuleRDS.getProperty()); WritableDataSource\u003cList\u003cFlowRule\u003e\u003e flowRuleWDS = new FileWritableDataSource\u003c\u003e( flowRulePath, this::encodeJson ); WritableDataSourceRegistry.registerFlowDataSource(flowRuleWDS); // 降级规则 ReadableDataSource\u003cString, List\u003cDegradeRule\u003e\u003e degradeRuleRDS = new FileRefreshableDataSource\u003c\u003e( degradeRulePath, degradeRuleListParser ); DegradeRuleManager.register2Property(degradeRuleRDS.getProperty()); WritableDataSource\u003cList\u003cDegradeRule\u003e\u003e degradeRuleWDS = new FileWritableDataSource\u003c\u003e( degradeRulePath, this::encodeJson ); WritableDataSourceRegistry.registerDegradeDataSource(degradeRuleWDS); // 系统规则 ReadableDataSource\u003cString, List\u003cSystemRule\u003e\u003e systemRuleRDS = new FileRefreshableDataSource\u003c\u003e( systemRulePath, systemRuleListParser ); SystemRuleManager.register2Property(systemRuleRDS.getProperty()); WritableDataSource\u003cList\u003cSystemRule\u003e\u003e systemRuleWDS = new FileWritableDataSource\u003c\u003e( systemRulePath, this::encodeJson ); WritableDataSourceRegistry.registerSystemDataSource(systemRuleWDS); // 授权规则 ReadableDataSource\u003cString, List\u003cAuthorityRule\u003e\u003e authorityRuleRDS = new FileRefreshableDataSource\u003c\u003e( authorityRulePath, authorityRuleListParser ); AuthorityRuleManager.register2Property(authorityRuleRDS.getProperty()); WritableDataSource\u003cList\u003cAuthorityRule\u003e\u003e authorityRuleWDS = new FileWritableDataSource\u003c\u003e( authorityRulePath, this::encodeJson ); WritableDataSourceRegistry.registerAuthorityDataSource(authorityRuleWDS); // 热点参数规则 ReadableDataSource\u003cString, List\u003cParamFlowRule\u003e\u003e paramFlowRuleRDS = new FileRefreshableDataSource\u003c\u003e( paramFlowRulePath, paramFlowRuleListParser ); ParamFlowRuleManager.register2Property(paramFlowRuleRDS.getProperty()); WritableDataSource\u003cList\u003cParamFlowRule\u003e\u003e paramFlowRuleWDS = new FileWritableDataSource\u003c\u003e( paramFlowRulePath, this::encodeJson ); ModifyParamFlowRulesCommandHandler.setWritableDataSource(paramFlowRuleWDS); } private Converter\u003cString, List\u003cFlowRule\u003e\u003e flowRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cFlowRule\u003e\u003e() { } ); private Converter\u003cString, List\u003cDegradeRule\u003e\u003e degradeRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cDegradeRule\u003e\u003e() { } ); private Converter\u003cString, List\u003cSystemRule\u003e\u003e systemRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cSystemRule\u003e\u003e() { } ); private Converter\u003cString, List\u003cAuthorityRule\u003e\u003e authorityRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cAuthorityRule\u003e\u003e() { } ); private Converter\u003cString, List\u003cParamFlowRule\u003e\u003e paramFlowRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cParamFlowRule\u003e\u003e() { } ); private void mkdirIfNotExits(String filePath) throws IOException { File file = new File(filePath); i","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:4:13","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Gateway 网关 三大核心概念 Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由； Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由； Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:5:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"模块搭建 新建模块 pom \u003c!--gateway网关--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--nacos客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e yaml server: port: 9000 spring: application: name: api-gateway cloud: nacos: discovery: server-addr: localhost:8848 gateway: discovery: locator: enabled: true # 让gateway可以发现nacos中的微服务 启动类 @SpringBootApplication @EnableDiscoveryClient public class ApiGatewayServer { public static void main(String[] args) { SpringApplication.run(ApiGatewayServer.class,args); } } 使用 http://ip地址:端口号/服务名/请求 例如： localhost:9000/order-service/sentinel2 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:5:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"路由 默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能（不写死一个地址）。 spring: application: name: api-gateway cloud: nacos: discovery: server-addr: localhost:8848 gateway: discovery: locator: enabled: true # 让gateway可以发现nacos中的微服务 routes: - id: product_route uri: lb://product-service #匹配后提供服务的路由地址 predicates: - Path=/product-serv/** filters: - StripPrefix=1 - id: order_route uri: lb://order-service predicates: - Path=/order-serv/** filters: - StripPrefix=1 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:5:2","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"断言 常用的Route Predicate Factory The After Route Predicate Factory The Before Route Predicate Factory The Between Route Predicate Factory The Cookie Route Predicate Factory The Header Route Predicate Factory The Host Route Predicate Factory The Method Route Predicate Factory The Path Route Predicate Factory The Query Route Predicate Factory The RemoteAddr Route Predicate Factory The weight Route Predicate Factory spring: application: name: api-gateway cloud: nacos: discovery: server-addr: localhost:8848 gateway: discovery: locator: enabled: true # 让gateway可以发现nacos中的微服务 routes: - id: product_route uri: lb://product-service #匹配后提供服务的路由地址 predicates: # - Header=X-Request-Id, \\d+ # - Cookie=username,zzyy # - After=2021-05-16T19:53:59.024+08:00[Asia/Shanghai] - Path=/product-serv/** # 断言，路径相匹配的进行路由 filters: - StripPrefix=1 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:5:3","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"过滤 StripPrefix=1 去除第一段路由 自定义局部过滤器 注意： 命名：xxxGatewayFilterFactory 使用：- xxx= 参数顺序 @Component public class TimeGatewayFilterFactory extends AbstractGatewayFilterFactory\u003cTimeGatewayFilterFactory.Config\u003e { private static final String BEGIN_TIME = \"beginTime\"; //构造函数 public TimeGatewayFilterFactory() { super(TimeGatewayFilterFactory.Config.class); } //读取配置文件中的参数 赋值到 配置类中 @Override public List\u003cString\u003e shortcutFieldOrder() { return Arrays.asList(\"show\",\"count\"); } @Override public GatewayFilter apply(Config config) { return new GatewayFilter() { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { if(!config.show){ return chain.filter(exchange); } exchange.getAttributes().put(BEGIN_TIME, System.currentTimeMillis()); /** * pre的逻辑 * chain.filter().then(Mono.fromRunable(()-\u003e{ * post的逻辑 * })) */ return chain.filter(exchange).then(Mono.fromRunnable(()-\u003e{ Long startTime = exchange.getAttribute(BEGIN_TIME); if (startTime != null) { System.out.println(exchange.getRequest().getURI() + \"请求耗时: \" + (System.currentTimeMillis() - startTime) + \"ms\"); } })); } }; } @Setter @Getter static class Config{ private boolean show; private int count; } } 全局过滤器 @Component public class AuthGlobalFilter implements GlobalFilter { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { String token = exchange.getRequest().getQueryParams().getFirst(\"token\"); if (StringUtils.isBlank(token)) { System.out.println(\"鉴权失败\"); exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } } ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:5:4","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"集成Sentinel实现网关限流 网关是所有请求的公共入口，所以可以在网关进行限流，而且限流的方式也很多，我们本次采用前 面学过的Sentinel组件来实现网关的限流。Sentinel支持对SpringCloud Gateway、Zuul等主流网关进 行限流。 从1.6.0版本开始，Sentinel提供了SpringCloud Gateway的适配模块，可以提供两种资源维度的限流： route维度：即在Spring配置文件中配置的路由条目，资源名为对应的routeId 自定义API维度：用户可以利用Sentinel提供的API来自定义一些API分组 网关集成Sentinel https://github.com/alibaba/Sentinel/wiki/网关限流 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.csp\u003c/groupId\u003e \u003cartifactId\u003esentinel-spring-cloud-gateway-adapter\u003c/artifactId\u003e \u003c/dependency\u003e 编写配置类 package cn.wolfcode.config; @Configuration public class GatewayConfiguration { private final List\u003cViewResolver\u003e viewResolvers; private final ServerCodecConfigurer serverCodecConfigurer; public GatewayConfiguration(ObjectProvider\u003cList\u003cViewResolver\u003e\u003e viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer) { this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList); this.serverCodecConfigurer = serverCodecConfigurer; } // 配置限流的异常处理器 @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() { // Register the block exception handler for Spring Cloud Gateway. return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer); } // 初始化一个限流的过滤器 @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public GlobalFilter sentinelGatewayFilter() { return new SentinelGatewayFilter(); } //增加对商品微服务的 限流 @PostConstruct private void initGatewayRules() { Set\u003cGatewayFlowRule\u003e rules = new HashSet\u003c\u003e(); rules.add(new GatewayFlowRule(\"product_route\") .setCount(3) .setIntervalSec(1) ); GatewayRuleManager.loadRules(rules); } } 重启网关服务并测试. 修改限流默认返回格式 在配置类GatewayConfiguration.java中添加如下配置 @PostConstruct public void initBlockHandlers() { BlockRequestHandler blockRequestHandler = new BlockRequestHandler() { public Mono\u003cServerResponse\u003e handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) { Map map = new HashMap\u003c\u003e(); map.put(\"code\", 0); map.put(\"message\", \"接口被限流了\"); return ServerResponse.status(HttpStatus.OK). contentType(MediaType.APPLICATION_JSON). body(BodyInserters.fromValue(map)); } }; GatewayCallbackManager.setBlockHandler(blockRequestHandler); } 重启并测试 自定义API分组 自定义API分组是一种更细粒度的限流规则定义 在shop-order-server项目中添加ApiController package cn.wolfcode.controller; @RestController @RequestMapping(\"/api\") public class ApiController { @RequestMapping(\"/hello\") public String api1(){ return \"api\"; } } 重启shop-order-server项目. 在api-gateway项目的配置GatewayConfiguration.java中添加如下配置: @PostConstruct private void initCustomizedApis() { Set\u003cApiDefinition\u003e definitions = new HashSet\u003c\u003e(); ApiDefinition api1 = new ApiDefinition(\"order_api\") .setPredicateItems(new HashSet\u003cApiPredicateItem\u003e() {{ add(new ApiPathPredicateItem().setPattern(\"/order-serv/api/**\"). setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX)); }}); definitions.add(api1); GatewayApiDefinitionManager.loadApiDefinitions(definitions); } @PostConstruct private void initGatewayRules() { Set\u003cGatewayFlowRule\u003e rules = new HashSet\u003c\u003e(); rules.add(new GatewayFlowRule(\"product_route\") .setCount(3) .setIntervalSec(1) ); rules.add(new GatewayFlowRule(\"order_api\"). setCount(1). setIntervalSec(1)); GatewayRuleManager.loadRules(rules); } 直接访问localhost:8091/api/hello 是不会发生限流的，访问localhost:9000/order-serv/api/hello 就会出现限流了. ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:5:5","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Sleuth+Zipkin 链路追踪 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:6:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"集成链路追踪组件Sleuth \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-sleuth\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:6:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Zipkin+Sleuth整合 下载Zipkin的jar包，在官网可以下载. 通过命令行，输入下面的命令启动ZipKin Server java -jar zipkin-server-2.22.1-exec.jar 通过浏览器访问 localhost:9411访问 添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zipkin\u003c/artifactId\u003e \u003c/dependency\u003e yaml spring: zipkin: base-url: http://127.0.0.1:9411/ #zipkin server的请求地址 discoveryClientEnabled: false #让nacos把它当成一个URL，而不要当做服务名 sleuth: sampler: probability: 1.0 #采样的百分比 调用接口后访问 localhost:9411查看 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:6:2","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"分布式调度 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:7:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Elastic-Job 搭建 需要zooker pom \u003cdependency\u003e \u003cgroupId\u003ecom.dangdang\u003c/groupId\u003e \u003cartifactId\u003eelastic-job-lite-spring\u003c/artifactId\u003e \u003cversion\u003e2.1.5\u003c/version\u003e \u003c/dependency\u003e yaml elasticjob: zookeeper-url: localhost:2181 group-name: elastic-job-group 注册中心配置类 @Configuration public class RegistryCenterConfig { @Bean(initMethod = \"init\") public CoordinatorRegistryCenter createRegistryCenter( @Value(\"${elasticjob.zookeeper-url}\") String zookeeperUrl, @Value(\"${elasticjob.group-name}\") String groupName) { //zk的配置 ZookeeperConfiguration zookeeperConfiguration = new ZookeeperConfiguration(zookeeperUrl, groupName); //设置zk超时时间 zookeeperConfiguration.setSessionTimeoutMilliseconds(100); //创建注册中心 return new ZookeeperRegistryCenter(zookeeperConfiguration); } } 任务调度抽取公共方法 public class ElasticJobLite { public static LiteJobConfiguration createJobConfiguration( //具体类 final Class\u003c? extends ElasticJob\u003e jobClass, //cron表达式 final String cron, //分片数量 final int shardingTotalCount, //分片表达式 final String shardingItemParameters, //job类型 DataflowJob[true] SimpleJob[false] boolean dataflowType ) { // 定义作业核心配置 JobCoreConfiguration.Builder jobCoreConfigurationBuilder = JobCoreConfiguration.newBuilder(jobClass.getSimpleName(), cron, shardingTotalCount); //分片 if (!StringUtils.isEmpty(shardingItemParameters)) { jobCoreConfigurationBuilder.shardingItemParameters(shardingItemParameters); } //初始化JobTypeConfiguration JobTypeConfiguration jobConfig; //DataflowJob[true] SimpleJob[false] if (dataflowType) { //定义Dataflow类型配置 jobConfig = new DataflowJobConfiguration(jobCoreConfigurationBuilder.build(), jobClass.getCanonicalName(), true); } else { // 定义SIMPLE类型配置 jobConfig = new SimpleJobConfiguration(jobCoreConfigurationBuilder.build(), jobClass.getCanonicalName()); } // 定义Lite作业根配置 return LiteJobConfiguration.newBuilder(jobConfig).overwrite(true).build(); } } 任务类 @Component public class MyElasticJob implements SimpleJob { public void execute(ShardingContext shardingContext) { System.out.println(\"定时任务开始====\u003e\"+new Date()); } } 配置使用 @Configuration public class ElasticJobConfig { @Autowired private CoordinatorRegistryCenter registryCenter; @Bean(initMethod = \"init\") public SpringJobScheduler initSimpleElasticJob(MyElasticJob myElasticJob) { SpringJobScheduler springJobScheduler = new SpringJobScheduler(myElasticJob, registryCenter, ElasticJobLite.createJobConfiguration( MyElasticJob.class, \"0/3 * * * * ?\", 1, null, false) ); return springJobScheduler; } } 分片 ​ 作业分片是指任务的分布式执行，需要将一个任务拆分为多个独立的任务项，然后由分布式的应用实例分别执行某一个或者几个分布项。 ​ 例如：Elastic-Job快速入门中文件备份的案例，现有两台服务器，每台服务器分别跑一个应用实例。为了快速执行作业，那么可以讲任务分成4片，每个应用实例都执行两片。作业遍历数据逻辑应为：实例1查找text和image类型文件执行备份，实例2查找radio和vedio类型文件执行备份。如果由于服务器拓容应用实例数量增加为4，则作业遍历数据的逻辑应为: 4个实例分别处理text,image,radio,video类型的文件。 ​ 可以看到，通过对任务的合理分片化，从而达到任务并行处理的效果. 分片项与业务处理解耦 ​ Elastic-Job并不直接提供数据处理的功能,框架只会将分片项分配至各个运行中的作业服务器，开发者需要自行处理分片项与真实数据的对应关系 最大限度利用资源 将分片项设置大于服务器的数据，最好是大于服务器倍数的数量，作业将会合理利用分布式资源，动态的分配分片项. ​ 例如: 3台服务器，分成10片，则分片项结果为服务器A=0,1,2;服务器B=3,4,5;服务器C=6,7,8,9.如果 服务器C奔溃，则分片项分配结果为服务器A=0,1,2,3,4;服务器B=5,6,7,8,9.在不丢失分片项的情况下，最大限度利用现有的资源提高吞吐量. 注： shardingContext.getShardingParameter() 获取分片信息 job @Component public class FileCustomElasticJob implements SimpleJob { @Autowired private FileCustomMapper fileCustomMapper; @Override public void execute(ShardingContext shardingContext) { doWork(shardingContext.getShardingParameter()); } private void doWork(String fileType){ List\u003cFileCustom\u003e fileList = fileCustomMapper.selecByType(fileType); System.out.println(\"类型为:\"+fileType+\",文件，需要备份个数:\"+fileList.size()); for(FileCustom fileCustom:fileList){ backUpFile(fileCustom); } } private void backUpFile(FileCustom fileCustom){ try { //模拟备份动作 TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"执行文件备份====\u003e\"+fileCustom); fileCustomMapper.changeState(fileCustom.getId(),1); } } 配置 @Configuration public class ElasticJobConfig { @Autowired private CoordinatorRegistryCenter registryCenter; @Bean(initMethod = \"init\") public SpringJobScheduler initFileCustomE","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:7:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Canal 数据同步 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:8:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"原理 模仿mysql主从的slave ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:8:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"准备 对于自建 MySQL , 需要先开启 Binlog 写入功能，配置 binlog-format 为 ROW 模式，my.cnf 中配置如下 [mysqld] log-bin=mysql-bin # 开启 binlog binlog-format=ROW # 选择 ROW 模式 server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 注意：针对阿里云 RDS for MySQL , 默认打开了 binlog , 并且账号默认具有 binlog dump 权限 , 不需要任何权限或者 binlog 设置,可以直接跳过这一步 授权 canal 链接 MySQL 账号具有作为 MySQL slave 的权限, 如果已有账户可直接 grant CREATE USER canal IDENTIFIED BY 'Canal_2021'; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%'; -- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ; FLUSH PRIVILEGES; 重启mysql //centos6 service mysqld restart //centos7 systemctl restart mysqld ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:8:2","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"启动 下载canal,我们使用的版本是1.1.4版本 https://github.com/alibaba/canal/releases/tag/canal-1.1.4 解压缩 mkdir /usr/local/canal tar -zxvf software/canal.deployer-1.1.4.tar.gz -C /usr/local/canal/ 解压完成后，进入 /tmp/canal 目录，可以看到如下结构 drwxr-xr-x 2 jianghang jianghang 136 2013-02-05 21:51 bin drwxr-xr-x 4 jianghang jianghang 160 2013-02-05 21:51 conf drwxr-xr-x 2 jianghang jianghang 1.3K 2013-02-05 21:51 lib drwxr-xr-x 2 jianghang jianghang 48 2013-02-05 21:29 logs 配置修改 vi /usr/local/canal/conf/example/instance.properties ## mysql serverId canal.instance.mysql.slaveId = 1234 #position info，需要改成自己的数据库信息 canal.instance.master.address = 127.0.0.1:3306 canal.instance.master.journal.name = canal.instance.master.position = canal.instance.master.timestamp = #canal.instance.standby.address = #canal.instance.standby.journal.name = #canal.instance.standby.position = #canal.instance.standby.timestamp = #username/password，需要改成自己的数据库信息 canal.instance.dbUsername = canal canal.instance.dbPassword = canal canal.instance.defaultDatabaseName = canal.instance.connectionCharset = UTF-8 #table regex canal.instance.filter.regex = .\\*\\\\\\\\..\\* canal.instance.connectionCharset 代表数据库的编码方式对应到 java 中的编码类型，比如 UTF-8，GBK , ISO-8859-1 如果系统是1个 cpu，需要将 canal.instance.parser.parallel 设置为 false 启动 sh /usr/local/canal/bin/startup.sh 查看 server 日志 tail -f -n 50 logs/canal/canal.log 2013-02-05 22:45:27.967 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## start the canal server. 2013-02-05 22:45:28.113 [main] INFO com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[10.1.29.120:11111] 2013-02-05 22:45:28.210 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## the canal server is running now ...... 查看 instance 的日志 tail -f -n 50 logs/example/example.log 2013-02-05 22:50:45.636 [main] INFO c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [canal.properties] 2013-02-05 22:50:45.641 [main] INFO c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [example/instance.properties] 2013-02-05 22:50:45.803 [main] INFO c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start CannalInstance for 1-example 2013-02-05 22:50:45.810 [main] INFO c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start successful.... 关闭 sh /usr/local/canal/bin/stop.sh 不能用 kill -9 进程 如果杀了, 需要删除 canal.pid 再次启动,就可以了 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:8:3","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"sh脚本 starCanal.sh # !/bin/bash echo '------------------canal-starter-------------------------' sh /usr/local/canal/bin/startup.sh echo '------------------canal-started-------------------------' shutdownCanal.sh # !/bin/bash echo '------------------canal-shutdown-------------------------' sh /usr/local/canal/bin/stop.sh echo '------------------canal-shutdowned-------------------------' ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:8:4","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"集成 1.首先启动Canal Server，具体部署参考给的文档 2.添加依赖 \u003cdependency\u003e \u003cgroupId\u003etop.javatool\u003c/groupId\u003e \u003cartifactId\u003ecanal-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.2.1-RELEASE\u003c/version\u003e \u003c/dependency\u003e 3.添加配置如下 canal: server: Canal服务部署的地址:11111 destination: example logging: level: root: info top: javatool: canal: client: client: AbstractCanalClient: error 4.添加Handler @Slf4j @Component @CanalTable(value = \"t_order_info\") public class OrderaInfoHandler implements EntryHandler\u003cOrderInfo\u003e { @Autowired private StringRedisTemplate redisTemplate; @Override public void insert( OrderInfo orderInfo) { log.info(\"当有数据插入的时候会触发这个方法\"); } @Override public void update(OrderInfo before, OrderInfo after) { log.info(\"当有数据更新的时候会触发这个方法\"); } @Override public void delete(OrderInfo orderInfo) { log.info(\"当有数据删除的时候会触发这个方法\"); } } 实体类 package cn.wolfcode.domain; import lombok.Getter; import lombok.Setter; import lombok.ToString; import javax.persistence.Column; import javax.persistence.Table; import java.io.Serializable; import java.math.BigDecimal; import java.util.Date; @Setter @Getter @Table(name = \"t_order_info\") @ToString public class OrderInfo implements Serializable { public static final Integer STATUS_ARREARAGE = 0;//未付款 public static final Integer STATUS_ACCOUNT_PAID = 1;//已付款 public static final Integer STATUS_CANCEL = 2;//手动取消订单 public static final Integer STATUS_TIMEOUT = 3;//超时取消订单 public static final Integer STATUS_REFUND = 4;//已退款 public static final Integer PAYTYPE_ONLINE = 0;//在线支付 public static final Integer PAYTYPE_INTERGRAL = 1;//积分支付 @Column(name = \"order_no\") private String orderNo;//订单编号 @Column(name = \"user_id\") private Long userId;//用户ID @Column(name = \"product_id\") private Long productId;//商品ID @Column(name = \"product_name\") private String productName;//商品名称 @Column(name = \"product_img\") private String productImg;//商品图片 @Column(name = \"product_count\") private Integer productCount;//商品总数 @Column(name = \"product_price\") private BigDecimal productPrice;//商品原价 @Column(name = \"seckill_price\") private BigDecimal seckillPrice;//秒杀价格 @Column(name = \"intergral\") private Long intergral;//消耗积分 @Column(name = \"status\") private Integer status = STATUS_ARREARAGE;//订单状态 @Column(name = \"create_date\") private Date createDate;//订单创建时间 @Column(name = \"seckill_date\") private Date seckillDate;//秒杀的日期 @Column(name = \"seckill_time\") private Integer seckillTime;// 秒杀场次 @Column(name = \"seckill_id\") private Long seckillId;//秒杀商品ID } ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:8:5","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Seata分布式事务 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:9:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Seata-At Seata主要由三个重要组件组成： TC：Transaction Coordinator 事务协调器，管理全局的分支事务的状态，用于全局性事务的提交 和回滚。 TM：Transaction Manager 事务管理器，用于开启、提交或者回滚全局事务。 RM：Resource Manager 资源管理器，用于分支事务上的资源管理，向TC注册分支事务，上报分 支事务的状态，接受TC的命令来提交或者回滚分支事务。 举例 程序中 Seata-AT模式的执行流程如下: A服务的TM向TC申请开启一个全局事务，TC就会创建一个全局事务并返回一个唯一的XID A服务的RM向TC注册分支事务，并及其纳入XID对应全局事务的管辖 A服务执行分支事务，向数据库做操作4. A服务开始远程调用B服务，此时XID会在微服务的调用链上传播 B服务的RM向TC注册分支事务，并将其纳入XID对应的全局事务的管辖 B服务执行分支事务，向数据库做操作 全局事务调用链处理完毕，TM根据有无异常向TC发起全局事务的提交或者回滚 TC协调其管辖之下的所有分支事务， 决定是否回滚 Seata-AT模式实现2PC与传统2PC的差别： 架构层次方面，传统2PC方案的 RM 实际上是在数据库层，RM本质上就是数据库自身，通过XA协议实现，而 Seata的RM是以jar包的形式作为中间件层部署在应用程序这一侧的。 两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率。 AT模式代码实现 分布式事务发起方只需要贴@GlobalTransactional注解即可 分支分布式事务贴上@Transactional即可 发起方 如果是远程调用需要判断返回值(关注是否做了统一异常处理以及统一返回类型)或者降级抛出异常 /** * show 订单积分支付 * @param orderNo 订单号 * @return 提示信息 */ @Override @GlobalTransactional @Transactional public String doIntergral(String orderNo) { //1.通过orderInfo 查询订单信息 从mysql中查询 OrderInfo orderInfo = orderInfoMapper.find(orderNo); //2.修改订单状态为已支付,支付类型为积分支付 orderInfoMapper.changePayStatus(orderNo, OrderInfo.STATUS_ACCOUNT_PAID, OrderInfo.PAYTYPE_INTERGRAL); //3.远程调用积分服务，修改用户的积分(减积分) OperateIntergralVo vo = new OperateIntergralVo(); vo.setPk(orderNo); vo.setValue(orderInfo.getIntergral()); vo.setInfo(\"积分消费\"); vo.setUserId(orderInfo.getUserId()); Result\u003cString\u003e stringResult = intergralFeign.remoteIntergralPay(vo); //远程失败两种情况 //1 远程发生异常 //2 远程服务宕机，服务降级 if (stringResult.getCode() == 500000 || StringUtils.isEmpty(stringResult)) { System.out.println(\"远程异常\"); throw new BusinessException(SeckillCodeMsg.INTERGRAL_SERVER_ERROR); } System.out.println(\"远程异常没判断出来\"); //4.支付日志 PayLog payLog = new PayLog(); payLog.setTradeNo(orderNo); payLog.setOutTradeNo(orderNo); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); payLog.setNotifyTime(simpleDateFormat.format(new Date())); payLog.setTotalAmount(orderInfo.getIntergral().toString()); payLog.setPayType(OrderInfo.PAYTYPE_INTERGRAL); payLogMapper.insert(payLog); return \"积分支付成功\"; } 分支 @Transactional public String intergralPay(OperateIntergralVo vo) { //1.添加日志 实现幂等性 AccountLog accountLog = new AccountLog(); accountLog.setPkValue(vo.getPk()); accountLog.setType(AccountLog.TYPE_DECR); accountLog.setAmount(vo.getValue()); accountLog.setGmtTime(new Date()); accountLog.setInfo(vo.getInfo()); accountLogMapper.insert(accountLog); // int a = 1/0; 模拟异常 //2.修改积分 usableIntegralMapper.addIntergral(vo.getUserId(), -vo.getValue()); return \"\"; } ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:9:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"Seata-TCC TCC模型图 异常处理 空回滚 Try方法未执行,Cancel执行了 出现原因: Try超时 分布式事务回滚，触发Cancel 解决方案: Cancel方法需要识别出是否执行Try方法,如果执行了就正常执行Cancel,如果没有就直接结束 增加事务日志表来实现这个功能. CREATE TABLE `account_transaction` ( `tx_id` varchar(100) NOT NULL COMMENT '事务Txid', `action_id` varchar(100) NOT NULL COMMENT '分支事务id', `gmt_create` datetime NOT NULL COMMENT '创建时间', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `user_id` varchar(100) NOT NULL COMMENT '账户Uid', `amount` varchar(100) NOT NULL COMMENT '变动金额', `type` varchar(100) NOT NULL DEFAULT '' COMMENT '变动类型', PRIMARY KEY (`tx_id`,`action_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 幂等 多次调用二阶段方法 出现原因: 网络异常 分支事务所在服务器宕机 解决方案: 做幂等性处理 CREATE TABLE `account_transaction` ( `tx_id` varchar(100) NOT NULL COMMENT '事务Txid', `action_id` varchar(100) NOT NULL COMMENT '分支事务id', `gmt_create` datetime NOT NULL COMMENT '创建时间', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `user_id` varchar(100) NOT NULL COMMENT '账户Uid', `amount` varchar(100) NOT NULL COMMENT '变动金额', `type` varchar(100) NOT NULL DEFAULT '' COMMENT '变动类型', `state` smallint(4) NOT NULL COMMENT '状态: 1.初始化 2.已提交 3.已回滚', PRIMARY KEY (`tx_id`,`action_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 防悬挂 Cancel比Try先执行 出现原因: Try超时(拥堵) 分布式事务回滚触发Cancel 要允许空回滚，但是要拒绝空回滚之后的Try方法. 解决方案: 在Try方法中, 如果根据全局事务ID能查询出数据出来,说明在try方法之前执行了空回滚，此时就不能进行try方法。否则就正常执行try方法. 异常处理流程图 Try方法 Comfirm方法 Cancel方法 TCC模式代码实现 分布式事务发起方只需要贴@GlobalTransactional注解即可 分支事务需要完成下面步骤: 在接口上贴上@LocalTCC和@TwoPhaseBusinessAction注解 发起方 @Override @GlobalTransactional @Transactional public String refund(String orderNo) { //1.通过orderInfo 查询订单信息 从mysql中查询 OrderInfo orderInfo = orderInfoMapper.find(orderNo); switch (orderInfo.getPayType()) { case OrderInfo.PAYTYPE_INTERGRAL: refoundIntergral(orderInfo); break; case OrderInfo.PAYTYPE_ONLINE: break; } return null; } /** * show 订单积分退货 * @param orderInfo 订单信息 */ private void refoundIntergral(OrderInfo orderInfo) { //1 增加退款日志 RefundLog refundLog = new RefundLog(); refundLog.setOutTradeNo(orderInfo.getOrderNo()); refundLog.setRefundAmount(orderInfo.getIntergral().toString()); refundLog.setRefundReason(\"不想要了\"); refundLog.setRefundType(orderInfo.getPayType()); refundLog.setRefundTime(new Date()); refundLogMapper.insert(refundLog); //2 订单状态 1\u003e\u003e4 orderInfoMapper.changeRefundStatus(orderInfo.getOrderNo(), OrderInfo.STATUS_REFUND); //3 远程调用积分服务 加积分 OperateIntergralVo vo = new OperateIntergralVo(); vo.setPk(orderInfo.getOrderNo()); vo.setValue(orderInfo.getIntergral()); vo.setInfo(\"积分退款\"); vo.setUserId(orderInfo.getUserId()); Result\u003cString\u003e stringResult = intergralFeign.remoteIntergralUnfundTry(vo); if (StringUtils.isEmpty(stringResult) || stringResult.getCode() == 500000) { throw new BusinessException(SeckillCodeMsg.INTERGRAL_SERVER_ERROR); } } 分支方 接口 @LocalTCC public interface IUsableIntegralService { /** * show TCC事务 * @param vo * @param context * @return */ @TwoPhaseBusinessAction(name = \"remoteIntergralUnfundTry\", commitMethod = \"incrIntergralCommit\", rollbackMethod = \"incrIntergralRollback\") String remoteIntergralUnfundTry(@BusinessActionContextParameter(paramName = \"operateIntergralVo\") OperateIntergralVo vo, BusinessActionContext context); String incrIntergralCommit(BusinessActionContext context); String incrIntergralRollback(BusinessActionContext context); } 实现类 @Service public class UsableIntegralServiceImpl implements IUsableIntegralService { @Resource private UsableIntegralMapper usableIntegralMapper; @Resource private AccountTransactionMapper accountTransactionMapper; @Resource private AccountLogMapper accountLogMapper; /** * TCC事务 退款 */ @Override public String remoteIntergralUnfundTry(@BusinessActionContextParameter(paramName = \"operateIntergralVo\") OperateIntergralVo vo, BusinessActionContext context) { //1查询事务信息 AccountTransaction accountTransactionReturn = accountTransactionMapper.get(context.getXid(), String.valueOf(context.getBranchId())); //2判断是否有信息 if (!StringUtils.isEmpty(accountTransactionReturn)) { //有 switch (accountTransactionReturn.getState()) { //try 幂等 case Acco","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:9:2","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"其他 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:10:0","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["SpringCloud"],"content":"单服务集群IDEA -Dserver.port=8001 ","date":"2021-09-04","objectID":"/springcloud%E5%B8%B8%E7%94%A8/:10:1","tags":["微服务","框架","整理"],"title":"SpringCloud常用","uri":"/springcloud%E5%B8%B8%E7%94%A8/"},{"categories":["运维"],"content":"gitlab私服搭建 ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:0:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"前期准备 ​ 安装的时候,使用桥接模式.方便后面使用. ​ 硬件配置,内存8G,系统centos7,网络桥接模式 安装centos7, ​ ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:1:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"修改为静态IP地址,验证网络是否可以连通 ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:2:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"安装gitlab 软件名称:gitlab-ce-13.1.11-ce.0.el7.x86_64.rpm 前期准备工作 1\\安装SSH协议 yum install -y curl policycoreutils-python openssh-server 2\\设置SSH服务开机自启动 systemctl enable sshd 3\\启动SSH服务 systemctl start sshd 4\\安装Postfix以发送通知邮件 yum -y install postfix 5\\将postfix服务设置成开机自启动 systemctl enable postfix 6\\启动postfix systemctl start postfix 7\\安装vim编辑器 yum install vim -y 安装gitlab rpm -ivh gitlab-ce-13.1.11-ce.0.el7.x86_64.rpm 修改配置文件 #编辑配置文件 vim /etc/gitlab/gitlab.rb #修改访问URL #格式：external_url 'http://ip:端口' external_url 'http://ip:8000' 重置Gitlab gitlab-ctl reconfigure 启动Gitlab gitlab-ctl restart 首次访问修改密码 ​ 访问：ip:8000/ ​ 密码设置为 7092890jiang ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:3:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"汉化 点击右上角 用户 –\u003esettings–\u003ePreferences -\u003e Localization -\u003e Language -\u003e 简体中文 ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:4:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"常见问题 502错误 如果出现502错误,优先增加内存. 1\\ 端口被占用 检查这个文件 /etc/gitlab/gitlab.rb external_url 'http://ip:8000' 修改后, ​ gitlab-ctl reconfigure ​ gitlab-ctl restart 2\\ 内存不足 ​ 1) 增加虚拟机内存 ​ 2) 开启交换分区swap 0-查看swap分区是否启动 cat /proc/swaps 1- 新建一个文件夹 mkdir /data 2-创建一个4G大小的交换分区 bs*count=4294971392(4G)； dd if=/dev/zero of=/data/swap bs=512 count=8388616 3-指定swap分区 mkswap /data/swap 4-查看内核参数vm.swappiness中的数值是否为0，如果为0则根据实际需要调整成60 查看： cat /proc/sys/vm/swappiness 设置： sysctl -w vm.swappiness=60 5-启动分区 swapon /data/swap echo “/data/swap swap swap defaults 0 0” \u003e\u003e /etc/fstab 6-再次查看分区是否启动 cat /proc/swaps 7-重启gitlab gitlab-ctl restart ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:5:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["数据库"],"content":"Mongodb ","date":"2021-08-23","objectID":"/mongodb/:0:0","tags":[],"title":"Mongodb","uri":"/mongodb/"},{"categories":["数据库"],"content":"安装配置 下载地址 解压在/usr/local/目录下 MongoDB(这里用MongoDB代替文件夹名字) 在MongoDB目录下新建data/db 和 log文件夹 在终端中输出 “open -e .bash_profile”，打开bash_profile文件 将安装目录的bin目录地址 “export PATH=${PATH}:/usr/local/mongoDB/bin” 添加到环境变量中，保存关闭 在终端中输入\"source .bash_profile\"使配置立即生效 在终端中输入 “mongod -version” 判断是否安装成功 ","date":"2021-08-23","objectID":"/mongodb/:1:0","tags":[],"title":"Mongodb","uri":"/mongodb/"},{"categories":["数据库"],"content":"启动 进入data和log所在目录命令行运行 –dbpath 指定为刚才创建好的data目录 –logpath 指定log存放位置 –logappend mongo在后台运行 sudo mongod --dbpath data/db --logpath log/mongod.log --logappend ","date":"2021-08-23","objectID":"/mongodb/:2:0","tags":[],"title":"Mongodb","uri":"/mongodb/"},{"categories":["数据库"],"content":"连接 新打开一个命令行 输入mongo连接 ","date":"2021-08-23","objectID":"/mongodb/:3:0","tags":[],"title":"Mongodb","uri":"/mongodb/"},{"categories":["数据库"],"content":"关闭 新打开一个命令行 连接mongo use admin; db.shutdownServer(); ","date":"2021-08-23","objectID":"/mongodb/:4:0","tags":[],"title":"Mongodb","uri":"/mongodb/"},{"categories":["数据库"],"content":"springboot集成 pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-mongodb\u003c/artifactId\u003e \u003c/dependency\u003e properties spring.data.mongodb.uri=mongodb://127.0.0.1:27017/wolf2w logging.level.org.springframework.data.mongodb.core=debug 继承Repository public interface StrategyCommnetRepository extends MongoRepository\u003cStrategyComment,String\u003e { } 使用 ","date":"2021-08-23","objectID":"/mongodb/:5:0","tags":[],"title":"Mongodb","uri":"/mongodb/"},{"categories":["数据库"],"content":"Elasticsearch ","date":"2021-08-14","objectID":"/elasticsearch/:0:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"课程目标 了解ES中的基本概念 掌握RESTFul操作ES的CRUD 掌握Spring Data Elasticsearch操作ES ","date":"2021-08-14","objectID":"/elasticsearch/:1:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"简介 Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 我们建立一个网站或应用程序，并要添加搜索功能，但是想要完成搜索工作的创建是非常困难的。我们希望搜索解决方案要运行速度快，我们希望能有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON通过HTTP来索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并扩展到数百台，我们要实时搜索，我们要简单的多用户，我们希望建立一个云的解决方案。因此我们利用Elasticsearch来解决所有这些问题及可能出现的更多其它问题。 ","date":"2021-08-14","objectID":"/elasticsearch/:2:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"安装和运行 该软件是基于Java编写的解压即用的软件，只需要有Java的运行环境即可，把压缩包解压后，进入到bin目录运行elasticsearch.bat，出现以下界面，表示成功启动服务器 浏览器输入：localhost:9200，看到浏览器输出服务器的信息，表示安装成功，可以使用了 注意：程序启动后有两个端口9200和9300，9200端口用于HTTP协议，基于RESTFul来使用，9300端口用于TCP协议，基于jar包来使用 ","date":"2021-08-14","objectID":"/elasticsearch/:3:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"后台启动 使用安装目录/bin/elasticsearch-service.bat程序可以把Elasticsearch安装后服务列表中，以后我们可以在服务列表来启动该程序，也可以设置成开机启动模式 注意：设置后台启动需要手动配置Java虚拟机的路径，使用命令elasticsearch-service.bat manager来配置 ","date":"2021-08-14","objectID":"/elasticsearch/:3:1","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"安装head插件 Elasticsearch默认的客户端工具是命令行形式的，操作起来不方便，也不直观看到数据的展示，所以我们需要去安装一个可视化插件，但是这些插件都是基于H5开发的，在谷歌的应用商店中找到elasticsearch-head插件，然后安装，使用该插件能比较直观的展示服务器中的数据 ","date":"2021-08-14","objectID":"/elasticsearch/:3:2","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"安装kibana 该软件也是解压即用的工具，用于管理和监控Elasticsearch的运作，同时内部包含了客户端工具，支持RESTFul操作Elasticsearch。解压后运行bin/kibana.bat，看到启动成功的端口号即可以使用浏览器来使用了 浏览器输入：http://localhost:5601 ","date":"2021-08-14","objectID":"/elasticsearch/:3:3","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"概念名词 ","date":"2021-08-14","objectID":"/elasticsearch/:4:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"数据存储图 注意：从Elasticsearch6开始一个索引里面只能有一个类型，后续计划删除类型这个概念，从ES6开始一般让索引名称和类型名称一致 ","date":"2021-08-14","objectID":"/elasticsearch/:4:1","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"主要组件 索引 ES将数据存储于一个或多个索引中，索引是具有类似特性的文档的集合。类比传统的关系型数据库领域来说，索引相当于SQL中的一个数据库，或者一个数据存储方案(schema)。索引由其名称(必须为全小写字符)进行标识，并通过引用此名称完成文档的创建、搜索、更新及删除操作。一个ES集群中可以按需创建任意数目的索引。 类型 类型是索引内部的逻辑分区(category/partition)，然而其意义完全取决于用户需求。因此，一个索引内部可定义一个或多个类型(type)。一般来说，类型就是为那些拥有相同的域的文档做的预定义。例如，在索引中，可以定义一个用于存储用户数据的类型，一个存储日志数据的类型，以及一个存储评论数据的类型。类比传统的关系型数据库领域来说，类型相当于表。 映射 Mapping,就是对索引库中索引的字段名称及其数据类型进行定义，类似于mysql中的表结构信息。不过es的mapping比数据库灵活很多，它可以动态识别字段。一般不需要指定mapping都可以，因为es会自动根据数据格式识别它的类型，如果你需要对某些字段添加特殊属性（如：定义使用其它分词器、是否分词、是否存储等），就必须手动添加mapping。 需要注意的是映射是不可修改的，一旦确定就不允许改动，在使用自动识别功能时，会以第一个存入的文档为参考来建立映射，后面存入的文档也必须符合该映射才能存入 文档 文档是Lucene索引和搜索的原子单位，它是包含了一个或多个域的容器，基于JSON格式进行表示。文档由一个或多个域组成，每个域拥有一个名字及一个或多个值，有多个值的域通常称为多值域。每个文档可以存储不同的域集，但同一类型下的文档至应该有某种程度上的相似之处。 ","date":"2021-08-14","objectID":"/elasticsearch/:4:2","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"分片和副本 ES的分片(shard)机制可将一个索引内部的数据分布地存储于多个节点，它通过将一个索引切分为多个底层物理的Lucene索引完成索引数据的分割存储功能，这每一个物理的Lucene索引称为一个分片(shard)。每个分片其内部都是一个全功能且独立的索引，因此可由集群中的任何主机存储。创建索引时，用户可指定其分片的数量，默认数量为5个。 Shard有两种类型：primary和replica，即主shard及副本shard。Primary shard用于文档存储，每个新的索引会自动创建5个Primary shard，当然此数量可在索引创建之前通过配置自行定义，不过，一旦创建完成，其Primary shard的数量将不可更改。Replica shard是Primary Shard的副本，用于冗余数据及提高搜索性能。每个Primary shard默认配置了一个Replica shard，但也可以配置多个，且其数量可动态更改。ES会根据需要自动增加或减少这些Replica shard的数量。 ","date":"2021-08-14","objectID":"/elasticsearch/:4:3","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"分词器 把文本内容按照标准进行切分，默认的是standard，该分词器按照单词切分，内容转变为小写，去掉标点，遇到每个中文字符都当成1个单词处理，后面会安装开源的中文分词器插件（ik） 感受分词器效果 先创建一个名叫shop_product的索引，然后再感受分词效果 PUT /shop_product 默认分词器： GET /shop_product/_analyze { \"text\":\"I am Groot\" } GET /shop_product/_analyze { \"text\":\"英特尔酷睿i7处理器\" } 结论：默认的分词器只能对英文正常分词，不能对中文正常分词 安装IK分词器 直接把压缩文件中的内容解压，然后放在elasticsearch/plugins下，然后重启即可 IK分词器： ik_smart：粗力度分词 ik_max_word：细力度分词 GET /shop_product/_analyze { \"text\":\"I am Groot\", \"analyzer\":\"ik_smart\" } GET /shop_product/_analyze { \"text\":\"英特尔酷睿i7处理器\", \"analyzer\":\"ik_smart\" } GET /shop_product/_analyze { \"text\":\"英特尔酷睿i7处理器\", \"analyzer\":\"ik_max_word\" } 结论：都能正常分词 拓展词库 最简单的方式就是找到IK插件中的config/main.dic文件，往里面添加新的词汇，然后重启服务器即可 ","date":"2021-08-14","objectID":"/elasticsearch/:4:4","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"倒排索引 ","date":"2021-08-14","objectID":"/elasticsearch/:4:5","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"基本操作（了解） ","date":"2021-08-14","objectID":"/elasticsearch/:5:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"索引操作 建表索引，相当于在是在建立数据库 建立索引 语法：PUT /索引名 在没有特殊设置的情况下，默认有5个分片，1个备份，也可以通过请求参数的方式来指定 参数格式： { \"settings\": { \"number_of_shards\": 5, //设置5个片区 \"number_of_replicas\": 1 //设置1个备份 } } 删除索引 语法：DELETE /索引名 ","date":"2021-08-14","objectID":"/elasticsearch/:5:1","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"映射操作 建立索引和映射 语法：PUT /索引名 { \"mappings\": { 类型名: { \"properties..0\": { 字段名: { \"type\": 字段类型, \"analyzer\": 分词器类型, \"search_analyzer\": 分词器类型, ... }, ... } } } } 字段类型：double / long / integer / text / keyword / date / binary 注意：text和keyword都是字符串类型，但是只有text类型的数据才能分词，字段的配置一旦确定就不能更改 映射的配置项有很多，我们可以根据需要只配置用得上的属性 查询映射 语法：GET /索引名/_mapping ","date":"2021-08-14","objectID":"/elasticsearch/:5:2","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"CRUD操作 ","date":"2021-08-14","objectID":"/elasticsearch/:6:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"文档操作 新增和替换文档 语法：PUT /索引名/类型名/文档ID { field1: value1, field2: value2, ... } 注意：当索引/类型/映射不存在时，会使用默认设置自动添加 ES中的数据一般是从别的数据库导入的，所以文档的ID会沿用原数据库中的ID 索引库中没有该ID对应的文档时则新增，拥有该ID对应的文档时则替换 需求1：新增一个文档 需求2：替换一个文档 每一个文档都内置以下字段 _index：所属索引 _type：所属类型 _id：文档ID _version：乐观锁版本号 _source：数据内容 查询文档 语法： 根据ID查询 -\u003e GET /索引名/类型名/文档ID 查询所有（基本查询语句） -\u003e GET /索引名/类型名/_search 需求1：根据文档ID查询一个文档 需求2：查询所有的文档 查询所有结果中包含以下字段 took：耗时 _shards.total：分片总数 hits.total：查询到的数量 hits.max_score：最大匹配度 hits.hits：查询到的结果 hits.hits._score：匹配度 删除文档 语法：DELETE /索引名/类型名/文档ID 注意：这里的删除并且不是真正意义上的删除，仅仅是清空文档内容而已，并且标记该文档的状态为删除 需求1：根据文档ID删除一个文档 需求2：替换刚刚删除的文档 ","date":"2021-08-14","objectID":"/elasticsearch/:6:1","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"高级查询 数据准备： PUT /shop_product { \"mappings\": { \"shop_product\": { \"properties\": { \"id\": { \"type\": \"integer\" }, \"title\":{ \"type\": \"text\", \"analyzer\": \"ik_smart\", \"search_analyzer\": \"ik_smart\" }, \"price\":{ \"type\": \"double\" }, \"intro\":{ \"type\": \"text\", \"analyzer\": \"ik_smart\", \"search_analyzer\": \"ik_smart\" }, \"brand\":{ \"type\": \"keyword\" } } } } } POST /shop_product/shop_product/_bulk {\"create\":{\"_id\": 1}} {\"id\":1,\"title\":\"Apple iPhone XR (A2108) 128GB 白色 移动联通电信4G手机 双卡双待\",\"price\":5299,\"intro\":\"【iPhoneXR限时特惠！】6.1英寸视网膜显示屏，A12仿生芯片，面容识别，无线充电，支持双卡！选【换修无忧版】获 AppleCare 原厂服务，享只换不修！更有快速换机、保值换新、轻松月付！\",\"brand\":\"Apple\"} {\"create\":{\"_id\": 2}} {\"id\":2,\"title\":\"Apple 2019款 Macbook Pro 13.3【带触控栏】八代i7 18G 256G RP645显卡 深空灰 苹果笔记本电脑 轻薄本 MUHN2CH/A\",\"price\":15299,\"intro\":\"【八月精选】Pro2019年新品上市送三重好礼，现在购买领满8000减400元优惠神劵，劵后更优惠！\",\"brand\":\"Apple\"} {\"create\":{\"_id\": 3}} {\"id\":3,\"title\":\"Apple iPad Air 3 2019年新款平板电脑 10.5英寸（64G WLAN版/A12芯片/Retina显示屏/MUUL2CH/A）金色\",\"price\":3788,\"intro\":\"8月尊享好礼！买iPad即送蓝牙耳机！领券立减！多款产品支持手写笔！【新一代iPad，总有一款适合你】选【换修无忧版】获 AppleCare 原厂服务，享只换不修！更有快速换机、保值换新、轻松月付！\",\"brand\":\"Apple\"} {\"create\":{\"_id\": 4}} {\"id\":4,\"title\":\"华为HUAWEI MateBook X Pro 2019款 英特尔酷睿i5 13.9英寸全面屏轻薄笔记本电脑(i5 8G 512G 3K 触控) 灰\",\"price\":7999,\"intro\":\"3K全面屏开启无界视野;轻薄设计灵动有型，HuaweiShare一碰传\",\"brand\":\"华为\"} {\"create\":{\"_id\": 5}} {\"id\":5,\"title\":\"华为 HUAWEI Mate20 X (5G) 7nm工艺5G旗舰芯片全面屏超大广角徕卡三摄8GB+256GB翡冷翠5G双模全网通手机\",\"price\":6199,\"intro\":\"【5G双模，支持SA/NSA网络，7.2英寸全景巨屏，石墨烯液冷散热】5G先驱，极速体验。\",\"brand\":\"华为\"} {\"create\":{\"_id\": 6}} {\"id\":6,\"title\":\"华为平板 M6 10.8英寸麒麟980影音娱乐平板电脑4GB+64GB WiFi（香槟金）\",\"price\":2299,\"intro\":\"【华为暑期购】8月2日-4日，M5青春版指定爆款型号优惠100元，AI语音控制\",\"brand\":\"华为\"} {\"create\":{\"_id\": 7}} {\"id\":7,\"title\":\"荣耀20 PRO DXOMARK全球第二高分 4800万四摄 双光学防抖 麒麟980 全网通4G 8GB+128GB 蓝水翡翠 拍照手机\",\"price\":3199,\"intro\":\"白条6期免息！麒麟980，4800万全焦段AI四摄！荣耀20系列2699起，4800万超广角AI四摄！\",\"brand\":\"荣耀\"} {\"create\":{\"_id\": 8}} {\"id\":8,\"title\":\"荣耀MagicBook Pro 16.1英寸全面屏轻薄性能笔记本电脑（酷睿i7 8G 512G MX250 IPS FHD 指纹解锁）冰河银\",\"price\":6199,\"intro\":\"16.1英寸无界全面屏金属轻薄本，100%sRGB色域，全高清IPS防眩光护眼屏，14小时长续航，指纹一健开机登录，魔法一碰传高速传输。\",\"brand\":\"荣耀\"} {\"create\":{\"_id\": 9}} {\"id\":9,\"title\":\"荣耀平板5 麒麟8核芯片 GT游戏加速 4G+128G 10.1英寸全高清屏影音平板电脑 WiFi版 冰川蓝\",\"price\":1549,\"intro\":\"【爆款平板推荐】哈曼卡顿专业调音，10.1英寸全高清大屏，双喇叭立体环绕音，配置多重护眼，值得拥有！\",\"brand\":\"荣耀\"} {\"create\":{\"_id\": 10}} {\"id\":10,\"title\":\"小米9 4800万超广角三摄 6GB+128GB全息幻彩蓝 骁龙855 全网通4G 双卡双待 水滴全面屏拍照智能游戏手机\",\"price\":2799,\"intro\":\"限时优惠200，成交价2799！索尼4800万广角微距三摄，屏下指纹解锁！\",\"brand\":\"小米\"} {\"create\":{\"_id\": 11}} {\"id\":11,\"title\":\"小米(MI)Pro 2019款 15.6英寸金属轻薄笔记本(第八代英特尔酷睿i7-8550U 16G 512GSSD MX250 2G独显) 深空灰\",\"price\":6899,\"intro\":\"【PCIE固态硬盘、72%NTSC高色域全高清屏】B面康宁玻璃覆盖、16G双通道大内存、第八代酷睿I7处理器、专业级调校MX150\",\"brand\":\"小米\"} {\"create\":{\"_id\": 12}} {\"id\":12,\"title\":\"联想(Lenovo)拯救者Y7000P 2019英特尔酷睿i7 15.6英寸游戏笔记本电脑(i7 9750H 16G 1T SSD GTX1660Ti 144Hz)\",\"price\":9299,\"intro\":\"超大1T固态，升级双通道16G内存一步到位，GTX1660Ti电竞级独显，英特尔9代i7H高性能处理器，144Hz电竞屏窄边框！\",\"brand\":\"联想\"} Elasticsearch基于JSON提供完整的查询DSL（Domain Specific Language：领域特定语言）来定义查询。 基本语法： GET /索引名/类型名/_search 一般都是需要配合查询参数来使用的，配合不同的参数有不同的查询效果 参数配置项可以参考博客：https://www.jianshu.com/p/6333940621ec ","date":"2021-08-14","objectID":"/elasticsearch/:7:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"结果排序 参数格式： { \"sort\": [ {field: 排序规则}, ... ] } 排序 GET /shop_product/shop_product/_search { \"sort\": [ { \"price\": { \"order\": \"desc\" } } ] } 排序规则： asc表示升序 desc:表示降序 没有配置排序的情况下，默认按照评分降序排列 ","date":"2021-08-14","objectID":"/elasticsearch/:7:1","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"分页查询 参数格式： { \"from\": start, \"size\": pageSize } 分页 从第几个开始 每页几个 GET /shop_product/shop_product/_search { \"from\": 2, \"size\": 4, \"sort\": [ { \"price\": { \"order\": \"desc\" } } ] } 需求1：查询所有文档按照价格降序排列 需求2：分页查询文档按照价格降序排列，显示第2页，每页显示3个 ","date":"2021-08-14","objectID":"/elasticsearch/:7:2","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"检索查询 参数格式： { \"query\": { 检索方式: {field: value} } } 检索查询 全文检索 需求1：查询商品标题中符合\"游戏 手机\"的字样的商品 GET /shop_product/shop_product/_search { \"query\": { \"match\": { \"title\": \"游戏 手机\" } } } 检索查询 精准匹配 需求2：查询商品价格等于15299的商品 GET /shop_product/shop_product/_search { \"query\": { \"term\": { \"price\": 15299 } } } 检索查询 范围检索 需求3：查询商品价格在5000~10000之间商品，按照价格升序排列 GET /shop_product/shop_product/_search { \"query\": { \"range\": { \"price\": { \"gte\": 5000, \"lte\": 10000 } } }, \"sort\": [ { \"price\": { \"order\": \"asc\" } } ] } 检索方式： term表示精确匹配，value值不会被分词器拆分，按照倒排索引匹配 match表示全文检索，value值会被分词器拆分，然后去倒排索引中匹配 range表示范围检索，其value值是一个对象，如{ \"range\": {field: {比较规则: value, ...}} } 比较规则有gt / gte / lt / lte 等 注意：term和match都能用在数值和字符上，range用在数值上 需求1：查询商品标题中符合\"游戏 手机\"的字样的商品 需求2：查询商品价格等于15299的商品 需求3：查询商品价格在5000~10000之间商品，按照价格升序排列 ","date":"2021-08-14","objectID":"/elasticsearch/:7:3","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"关键字查询 参数格式： { \"query\": { \"multi_match\": { \"query\": value, \"fields\": [field1, field2, ...] } } } 关键字查询 需求1：查询商品标题或简介中符合\"蓝牙 指纹 双卡\"的字样的商品 GET /shop_product/shop_product/_search { \"query\": { \"multi_match\": { \"query\": \"蓝牙 指纹 双卡\", \"fields\": [\"title\", \"intro\"] } } } multi_match：表示在多个字段间做检索，只要其中一个字段满足条件就能查询出来，多用在字段上 需求1：查询商品标题或简介中符合\"蓝牙 指纹 双卡\"的字样的商品 ","date":"2021-08-14","objectID":"/elasticsearch/:7:4","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"高亮显示 参数格式： { \"query\": { ... }, \"highlight\": { \"fields\": { field1: {}, field2: {}, ... }, \"pre_tags\": 开始标签, \"post_tags\" 结束标签 } } 高亮显示 需求1：查询商品标题或简介中符合\"蓝牙 指纹 双卡\"的字样的商品，并且高亮显示 GET /shop_product/shop_product/_search { \"query\": { \"multi_match\": { \"query\": \"蓝牙 指纹 双卡\", \"fields\": [\"title\", \"intro\"] } }, \"highlight\": { \"fields\": { \"title\": {}, \"intro\": {} }, \"pre_tags\":\"\u003ch1\u003e\", \"post_tags\":\"\u003c/h1\u003e\" } } highlight：表示高亮显示，需要在fields中配置哪些字段中检索到该内容需要高亮显示 必须配合检索(term / match)一起使用 需求1：查询商品标题或简介中符合\"蓝牙 指纹 双卡\"的字样的商品，并且高亮显示 ","date":"2021-08-14","objectID":"/elasticsearch/:7:5","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"逻辑查询 参数格式： { \"query\": { \"bool\": { 逻辑规则: [ {检索方式: {field: value}}, ... ], ... } } } 逻辑查询 需求1：查询商品标题中符合\"i7\"的字样并且价格大于7000的商品 GET /shop_product/shop_product/_search { \"query\": { \"bool\": { \"must\": [ {\"match\": { \"title\": \"i7\" }}, {\"range\": { \"price\": { \"gt\": 7000 } }} ] } } } 逻辑查询 需求2：查询商品标题中符合\"pro\"的字样或者价格在1000~3000的商品 GET /shop_product/shop_product/_search { \"query\": { \"bool\": { \"should\": [ {\"match\": { \"title\": \"pro\" }}, {\"range\": { \"price\": { \"gte\": 1000, \"lte\": 3000 } }} ] } } } 逻辑规则：must / should / must_not，相当于and / or / not 需求1：查询商品标题中符合\"i7\"的字样并且价格大于7000的商品 需求2：查询商品标题中符合\"pro\"的字样或者价格在1000~3000的商品 ","date":"2021-08-14","objectID":"/elasticsearch/:7:6","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"过滤查询 参数格式： { \"query\": { \"bool\": { \"filter\": [ { 检索方式: { field: value } }， ... ] } } } 过滤查询 不评分 GET /shop_product/shop_product/_search { \"query\": { \"bool\": { \"filter\": [ {\"match\": { \"title\": \"pro\" }} ] } } } 从效果上讲过滤查询和检索查询能做一样的效果 区别在于过滤查询不评分，结果能缓存，检索查询要评分，结果不缓存 一般是不会直接使用过滤查询，都是在检索了一定数据的基础上再使用 关于filter的更多认知推荐大家读这篇博客：https://blog.csdn.net/laoyang360/article/details/80468757 ","date":"2021-08-14","objectID":"/elasticsearch/:7:7","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"分组查询 参数格式： { \"size\": 0, \"aggs\": { 自定义分组字段: { \"terms\": { \"field\": 分组字段, \"order\": {自定义统计字段:排序规则}, \"size\": 10 //默认显示10组 }, \"aggs\": { //分组后的统计查询，相当于MySQL分组函数查询 自定义统计字段: { 分组运算: { \"field\": 统计字段 } } } } } } 分组查询 需求1：按照品牌分组，统计各品牌的数量 GET /shop_product/shop_product/_search { \"size\": 0, \"aggs\": { \"brand_group\": { \"terms\": { \"field\": \"brand\", \"order\": {\"brand_group\":\"desc\"}, \"size\": 10 }, \"aggs\": { \"brand_group\": { \"value_count\": { \"field\": \"id\" } } } } } } 分组查询 需求2：按照品牌分组，统计各品牌的平均价格 GET /shop_product/shop_product/_search { \"size\": 0, \"aggs\": { \"brand_group\": { \"terms\": { \"field\": \"brand\", \"order\": {\"brand_group\":\"desc\"}, \"size\": 10 }, \"aggs\": { \"brand_group\": { \"avg\": { \"field\": \"price\" } } } } } } 分组查询 需求3：按照品牌分组，统计各品牌的价格数据 GET /shop_product/shop_product/_search { \"size\": 0, \"aggs\": { \"brand_group_aggs\": { \"terms\": { \"field\": \"brand\", \"order\": {\"brand_group_aggs.count\":\"desc\"}, \"size\": 10 }, \"aggs\": { \"brand_group_aggs\": { \"stats\": { \"field\": \"price\" } } } } } } 分组运算：avg / sum / min / max / value_count / stats(执行以上所有功能的) 注意：这里是size=0其目的是为了不要显示hit内容，专注点放在观察分组上 需求1：按照品牌分组，统计各品牌的数量 需求2：按照品牌分组，统计各品牌的平均价格 需求3：按照品牌分组，统计各品牌的价格数据 ","date":"2021-08-14","objectID":"/elasticsearch/:7:8","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"批处理（了解） 当需要集中的批量处理文档时，如果依然使用传统的操作单个API的方式，将会浪费大量网络资源，Elasticsearch为了提高操作的性能，专门提供了批处理的API ","date":"2021-08-14","objectID":"/elasticsearch/:8:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"mget批量查询 语法： GET /索引名/类型/_mget { \"docs\": [ {\"_id\": 文档ID}, ... ] } ","date":"2021-08-14","objectID":"/elasticsearch/:8:1","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"bulk批量增删改 语法： POST /索引名/类型/_bulk {动作:{\"_id\": 文档ID}} {...} {动作:{\"_id\": 文档ID}} {...} 动作：create / update / delete，其中delete只有1行JSON，其他操作都是有2行JSON，并且JSON不能格式化，如果是update动作，它的数据需要加个key为doc 如： {\"update\": {\"_id\": xx}} {\"doc\": {\"xx\":xx, \"xx\":xx}} ","date":"2021-08-14","objectID":"/elasticsearch/:8:2","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"Spring Data Elasticsearch ","date":"2021-08-14","objectID":"/elasticsearch/:9:0","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"准备环境 导入依赖 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.1.3.RELEASE\u003c/version\u003e \u003c/parent\u003e \u003cproperties\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--SpringBoot整合Spring Data Elasticsearch的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-elasticsearch\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-beanutils\u003c/groupId\u003e \u003cartifactId\u003ecommons-beanutils\u003c/artifactId\u003e \u003cversion\u003e1.8.3\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 编写domain /** @Document：配置操作哪个索引下的哪个类型 @Id：标记文档ID字段 @Field：配置映射信息，如：分词器 */ @Getter@Setter@ToString @NoArgsConstructor @AllArgsConstructor @Document(indexName=\"shop_product\", type=\"shop_product\") public class Product { @Id private String id; @Field(analyzer=\"ik_max_word\",searchAnalyzer=\"ik_max_word\", type=FieldType.Text) private String title; private Integer price; @Field(analyzer=\"ik_max_word\",searchAnalyzer=\"ik_max_word\", type=FieldType.Text) private String intro; @Field(type=FieldType.Keyword) private String brand; } 配置连接信息 #application.properties # 配置集群名称，名称写错会连不上服务器，默认elasticsearch spring.data.elasticsearch.cluster-name=elasticsearch # 配置集群节点 spring.data.elasticsearch.cluster-nodes=localhost:9300 ","date":"2021-08-14","objectID":"/elasticsearch/:9:1","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"ElasticsearchRepository 该接口是框架封装的用于操作Elastsearch的高级接口，只要我们自己的写个接口去继承该接口就能直接对Elasticsearch进行CRUD操作 /** 泛型1：domain的类型 泛型2：文档主键类型 该接口直接该给Spring，底层会使用JDK代理的方式创建对象，交给容器管理 */ @Repository public interface ProductESRepository extends ElasticsearchRepository\u003cProduct, String\u003e { // 符合Spring Data规范的高级查询方法 } ","date":"2021-08-14","objectID":"/elasticsearch/:9:2","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"完成CRUD+分页+排序 ","date":"2021-08-14","objectID":"/elasticsearch/:9:3","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"组件介绍 ElasticsearchRepository：框架封装的用于便捷完成常用操作的工具接口 ElasticsearchTemplate：框架封装的用于便捷操作Elasticsearch的模板类 NativeSearchQueryBuilder：用于生成查询条件的构建器，需要去封装各种查询条件 QueryBuilder：该接口表示一个查询条件，其对象可以通过QueryBuilders工具类中的方法快速生成各种条件 boolQuery()：生成bool条件，相当于 \"bool\": { } matchQuery()：生成match条件，相当于 \"match\": { } rangeQuery()：生成range条件，相当于 \"range\": { } AbstractAggregationBuilder：用于生成分组查询的构建器，其对象通过AggregationBuilders工具类生成 Pageable：表示分页参数，对象通过PageRequest.of(页数, 容量)获取 SortBuilder：排序构建器，对象通过SortBuilders.fieldSort(字段).order(规则)获取 ","date":"2021-08-14","objectID":"/elasticsearch/:9:4","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"ElasticsearchTemplate 该模板类，封装了便捷操作Elasticsearch的模板方法，包括 索引 / 映射 / CRUD 等底层操作和高级操作，该对象用起来会略微复杂些，尤其是对于查询，还需要把查询到的结果自己封装对象 //该对象已经由SpringBoot完成自动配置，直接注入即可 @Autowired private ElasticsearchTemplate template; 一般情况下，ElasticsearchTemplate和ElasticsearchRepository是分工合作的，ElasticsearchRepository已经能完成绝大部分的功能，如果遇到复杂的查询则要使用ElasticsearchTemplate，如多字段分组、高亮显示等 ","date":"2021-08-14","objectID":"/elasticsearch/:9:5","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"实例代码 @Autowired private ElasticsearchTemplate template; @Autowired private ProductESRepository repository; // 新增或者覆盖一个文档 @Test public void testSaveOrUpdate() throws Exception { // 索引库中不存在则新增，存在则覆盖 Product p = new Product(\"13\", \"华为手环 B5（Android 运动手环）\", 999, \"高清彩屏 腕上蓝牙耳机 心率检测 来电消息提醒\", \"华为\"); repostitory.save(p); } // 删除一个文档 @Test public void testDelete() throws Exception { repostitory.deleteById(\"13\"); } // 根据ID查询一个文档 @Test public void testGet() throws Exception { Optional\u003cProduct\u003e optional = repostitory.findById(\"1\"); optional.ifPresent(System.out::println); } // 查询所有文档 @Test public void testList() throws Exception { Iterable\u003cProduct\u003e iter = repostitory.findAll(); iter.forEach(System.out::println); } // 分页查询文档按照价格降序排列，显示第2页，每页显示3个 @Test public void testQuery1() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); // 设置分页信息 builder.withPageable(PageRequest.of(1, 3)); // 设置排序信息 builder.withSort(SortBuilders.fieldSort(\"price\").order(SortOrder.DESC)); Page\u003cProduct\u003e page = repostitory.search(builder.build()); System.out.println(page.getTotalElements()); //总记录数 System.out.println(page.getTotalPages()); //总页数 page.forEach(System.out::println); } // 查询商品标题中符合\"游戏 手机\"的字样的商品 @Test public void testQuery2() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery( QueryBuilders.matchQuery(\"title\", \"游戏 手机\") ); Page\u003cProduct\u003e page = repostitory.search(builder.build()); page.forEach(System.out::println); } // 查询商品价格等于15299的商品 @Test public void testQuery3() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery( QueryBuilders.termQuery(\"price\", 15299) ); Page\u003cProduct\u003e page = repostitory.search(builder.build()); page.forEach(System.out::println); } // 查询商品价格在5000~9000之间商品，按照价格升序排列 @Test public void testQuery4() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery( QueryBuilders.rangeQuery(\"price\") .gte(5000).lte(9000) ); builder.withSort(SortBuilders.fieldSort(\"price\").order(SortOrder.ASC)); Page\u003cProduct\u003e page = repostitory.search(builder.build()); page.forEach(System.out::println); } // 查询商品标题或简介中符合\"蓝牙 指纹 双卡\"的字样的商品 @Test public void testQuery5() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery( QueryBuilders.multiMatchQuery(\"蓝牙 指纹 双卡\", \"title\", \"intro\") ); Page\u003cProduct\u003e page = repostitory.search(builder.build()); page.forEach(System.out::println); } // 查询商品标题中符合\"i7\"的字样并且价格大于7000的商品 @Test public void testQuery6() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery( QueryBuilders.boolQuery() .must(QueryBuilders.matchQuery(\"title\", \"i7\")) .must(QueryBuilders.rangeQuery(\"price\").gt(7000)) ); Page\u003cProduct\u003e page = repostitory.search(builder.build()); page.forEach(System.out::println); } // 查询商品标题中符合\"pro\"的字样或者价格在1000~3000的商品 @Test public void testQuery7() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery( QueryBuilders.boolQuery() .should(QueryBuilders.matchQuery(\"title\", \"pro\")) .should(QueryBuilders.rangeQuery(\"price\").gte(1000).lte(3000)) ); Page\u003cProduct\u003e page = repostitory.search(builder.build()); page.forEach(System.out::println); } // 按照品牌分组，统计各品牌的数量 @Test public void testQuery8() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.addAggregation( AggregationBuilders.terms(\"groupByBrand\").field(\"brand\") ); AggregatedPage\u003cProduct\u003e page = (AggregatedPage\u003cProduct\u003e) repostitory.search(builder.build()); // 获取自定义的分组字段 StringTerms brand = (StringTerms) page.getAggregation(\"groupByBrand\"); brand.getBuckets().forEach(bucket -\u003e System.out.println(bucket.getDocCount())); } // 按照品牌分组，统计各品牌的平均价格 @Test public void testQuery9() throws Exception { NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.addAggregation( AggregationBuilders.terms(\"groupByBrand\").field(\"b","date":"2021-08-14","objectID":"/elasticsearch/:9:6","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["数据库"],"content":"springboot2.3.x以上配置 配置关系对应 pom相同 配置 ## 旧版本以spring.data.elasticsearch.开头;访问地址配置不用声明访问协议,监听es的tcp端口 #spring.data.elasticsearch.cluster-nodes=localhost:9300 #spring.data.elasticsearch.cluster-name=elasticsearch ## 新版本以spring.elasticsearch.rest.开头;访问地址配置需要声明访问协议,直接监听es访问端口 spring.elasticsearch.rest.uris=http://localhost:9200 spring.elasticsearch.rest.username=elasticsearch 使用 旧版的核心访问对象是ElasticsearchTemplate；新版的核心访问对象是ElasticsearchRestTemplate； 实体类没有类型 // @Document指定当前类是索引对象。indexName:索引名称;shards:创建索引时的分片数;replicas:创建索引时的备份数 @Document(indexName = \"book_\", shards = 5, replicas = 1) ","date":"2021-08-14","objectID":"/elasticsearch/:9:7","tags":["中间件"],"title":"Elasticsearch","uri":"/elasticsearch/"},{"categories":["云原生"],"content":"阿里云相关 ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B8%E5%85%B3/:0:0","tags":["云原生"],"title":"阿里云相关","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B8%E5%85%B3/"},{"categories":["云原生"],"content":"短信服务 pom \u003cdependencies\u003e \u003c!-- 阿里云短信依赖 --\u003e \u003c!-- json转换工具 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 阿里云短信依赖核心库 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e controller @RestController @RequestMapping(\"/edumsm/msm\") @CrossOrigin public class MsmController { @Autowired private MsmService msmService; @Autowired private RedisTemplate\u003cString,String\u003e redisTemplate; //发送短信的方法 @GetMapping(\"send/{phone}\") public R sendMsm(@PathVariable(\"phone\") String phone) { //从redis中获取验证码，如果获取到直接返回 String code = redisTemplate.opsForValue().get(phone); if (!StringUtils.isEmpty(code)) { return R.ok(); } //如果redis获取不到，进行阿里云发送 //生成随机值，传递阿里云进行发送 code = RandomUtil.getSixBitRandom(); Map\u003cString,Object\u003e param = new HashMap\u003c\u003e(); param.put(\"code\",code); //调用service进行短信发送 boolean isSend = msmService.send(param,phone); if (isSend) { //发送成功，把发送成功方法放在redis中 //设置有效时间 redisTemplate.opsForValue().set(phone,code,5, TimeUnit.MINUTES); return R.ok(); } else { return R.error().message(\"发送短信错误\"); } } } service @Service public class MsmServiceImpl implements MsmService { //发送短信的方法 @Override public boolean send(Map\u003cString, Object\u003e param, String phone) { if(StringUtils.isEmpty(phone)) return false; //修改阿里云参数 regionld accessKeyId secret DefaultProfile profile = DefaultProfile.getProfile(\"default\",\"key\",\"secret\"); IAcsClient client = new DefaultAcsClient(profile); //设置相关固定参数 CommonRequest request = new CommonRequest(); request.setMethod(MethodType.POST); request.setDomain(\"dysmsapi.aliyuncs.com\"); request.setVersion(\"2017-05-25\"); request.setAction(\"SendSms\"); //设置发送相关参数 //手机号 request.putQueryParameter(\"PhoneNumbers\",phone); //签名名称 request.putQueryParameter(\"SignName\",\"value\"); //模板code request.putQueryParameter(\"TemplateCode\",\"value\"); //设置验证码 需要转换为JSON request.putQueryParameter(\"TemplateParam\", JSONObject.toJSONString(param)); //发送 try { CommonResponse commonResponse = client.getCommonResponse(request); boolean success = commonResponse.getHttpResponse().isSuccess(); return success; } catch (ClientException e) { e.printStackTrace(); return false; } } } ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B8%E5%85%B3/:1:0","tags":["云原生"],"title":"阿里云相关","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B8%E5%85%B3/"},{"categories":["云原生"],"content":"OSS pom \u003cdependencies\u003e \u003c!-- 阿里云oss依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun.oss\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-oss\u003c/artifactId\u003e \u003cversion\u003e3.5.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 配置文件 aliyun: oss: file: endpoint: \u003cyourEndpoint\u003e keyid: \u003cyourKeyid\u003e keysecret: \u003cyourKeysecret\u003e #bucke可以在控制台创建 也可以使用java代码创建 bucketname: \u003cyourBucketname\u003e 创建常量，读取配置文件内容 //使用InitializingBean接口 当项目启动afterPropertiesSet方法自动执行 @Component public class ConstantPropertiesUtils implements InitializingBean { //读取配置文件内容 @Value(\"${aliyun.oss.file.endpoint}\") private String endpoint; @Value(\"${aliyun.oss.file.keyid}\") private String keyId; @Value(\"${aliyun.oss.file.keysecret}\") private String keySecret; @Value(\"${aliyun.oss.file.bucketname}\") private String bucketName; //定义公开静态常量 public static String END_POINT; public static String KEY_ID; public static String KEY_SECRET; public static String BUCKET_NAME; @Override public void afterPropertiesSet() throws Exception { END_POINT = endpoint; KEY_ID = keyId; KEY_SECRET = keySecret; BUCKET_NAME = bucketName; } } controller @RestController @RequestMapping(\"/eduoss/fileoss\") @CrossOrigin public class OssController { @Autowired private OssService ossService; //上传头像方法 @PostMapping(\"uploadOssFile\") public R uploadOssFile(MultipartFile file) { //获取上传文件 MultipartFile String url = ossService.uploadFileAvatar(file); return R.ok().data(\"url\",url); } } service @Service public class OssServiceImpl implements OssService { @Override public String uploadFileAvatar(MultipartFile file) { // Endpoint以杭州为例，其它Region请按实际情况填写。 String endpoint = ConstantPropertiesUtils.END_POINT; // 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。 String accessKeyId = ConstantPropertiesUtils.KEY_ID; String accessKeySecret = ConstantPropertiesUtils.KEY_SECRET; String bucketName = ConstantPropertiesUtils.BUCKET_NAME; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { // 上传文件流。 InputStream inputStream = file.getInputStream(); //获取文件名称 String fileName = file.getOriginalFilename(); //1.在文件名称中添加随机唯一值 String uuid = UUID.randomUUID().toString().replaceAll(\"-\",\"\"); fileName = uuid+fileName; //2.把文件按照年月日进行分类 //获取当前日期 Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat(\"yyyy/MM/dd\"); String time = format.format(date); //拼接 fileName = time+\"/\"+fileName; //第一个参数 Bucket名称 //第二个参数 文件路径和文件名称 //第三个参数 文件输入流 ossClient.putObject(bucketName, fileName, inputStream); // 关闭OSSClient。 ossClient.shutdown(); //上传之后的文件路径返回 //需要手动拼接 return \"https://\"+bucketName+\".\"+endpoint+\"/\"+fileName; } catch (Exception e) { e.printStackTrace(); return null; } } } ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B8%E5%85%B3/:2:0","tags":["云原生"],"title":"阿里云相关","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B8%E5%85%B3/"},{"categories":["云原生"],"content":"视频点播 pom \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun.oss\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-oss\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-vod\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-vod-upload\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.json\u003c/groupId\u003e \u003cartifactId\u003ejson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.google.code.gson\u003c/groupId\u003e \u003cartifactId\u003egson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejoda-time\u003c/groupId\u003e \u003cartifactId\u003ejoda-time\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 配置 #阿里云vod aliyun: oss: file: keyid: keyid keysecret: keysecret #文件大小设置 spring: servlet: multipart: max-file-size: 1024MB max-request-size: 1024MB 文件上传 controller @Autowired private VodService vodService; //上传视频到阿里云的方法 @PostMapping(\"uploadAlyiVideo\") public R uploadAlyiVideo(MultipartFile file) { String videoId = vodService.uploadVideoAly(file); return R.ok().data(\"videoId\",videoId); } service @Service public class VodServiceImpl implements VodService { @Override public String uploadVideoAly(MultipartFile file) { try { //fileName上传文件原始名称 String fileName = file.getOriginalFilename(); //title上传文件显示名称 String title = fileName.substring(0,fileName.lastIndexOf(\".\")); //inputStream上传文件输入流 InputStream inputStream = file.getInputStream(); UploadStreamRequest request = new UploadStreamRequest(ConstantVodUtils.KEY_ID, ConstantVodUtils.KEY_SECRET, title, fileName, inputStream); UploadVideoImpl uploader = new UploadVideoImpl(); UploadStreamResponse response = uploader.uploadStream(request); //获取视频id return response.getVideoId(); } catch (IOException e) { e.printStackTrace(); return null; } } } 删除 //根据视频id删除视频 @DeleteMapping(\"removeAlyVideo/{id}\") public R removeAlyVideo(@PathVariable String id) { try { //初始化对象 DefaultAcsClient defaultAcsClient = InitVodCilent.initVodClient(ConstantVodUtils.KEY_ID, ConstantVodUtils.KEY_SECRET); //创建删除视频request对象 DeleteVideoRequest request = new DeleteVideoRequest(); //向request中设置id request.setVideoIds(id); defaultAcsClient.getAcsResponse(request); return R.ok(); } catch (ClientException e) { e.printStackTrace(); throw new GuliException(20001,\"删除失败\"); } } 获取凭证 播放 controller //根据视频id获取视频凭证 @GetMapping(\"getPlayAuth/{id}\") public R getPlayAuth(@PathVariable String id) throws ClientException { //根据视频id获取视频凭证 //创建初始化对象 DefaultAcsClient defaultAcsClient = InitVodCilent.initVodClient(ConstantVodUtils.KEY_ID, ConstantVodUtils.KEY_SECRET); //创建获取视频地址request和response GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse(); //向request对象里面设置视频id request.setVideoId(id); //调用初始化对象里面的方法，传递request，获取视频凭证 response = defaultAcsClient.getAcsResponse(request); //获取凭证 String playAuth = response.getPlayAuth(); return R.ok().data(\"playAuth\",playAuth); } api/vod.js import request from '@/utils/request' export default { getPlayAuth(vid) { return request({ url: `/eduvod/video/getPlayAuth/${vid}`, method: 'get' }) } } player/_vid.vue \u003ctemplate\u003e \u003cdiv\u003e \u003c!-- 阿里云视频播放器样式 --\u003e \u003clink rel=\"stylesheet\" href=\"https://g.alicdn.com/de/prismplayer/2.8.1/skins/default/aliplayer-min.css\" \u003e \u003c!-- 阿里云视频播放器脚本 --\u003e \u003cscript charset=\"utf-8\" type=\"text/javascript\" src=\"https://g.alicdn.com/de/prismplayer/2.8.1/aliplayer-min.js\" /\u003e \u003c!-- 定义播放器dom --\u003e \u003cdiv id=\"J_prismPlayer\" class=\"prism-player\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import vod from '@/api/vod' export default { layout: 'video',//应用video布局 asyncData({ params, error }) { return vod.getPlayAuth(params.vid) .then(response =\u003e { return { playAuth: response.data.data.playAuth, vid: params.vid } }) }, mounted() { //页面渲染之后 created new Aliplayer({ id: 'J_prismPlayer', vid: this.vid, // 视频id playauth: this.playAuth, // 播放凭证 encryptType: '1'","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B8%E5%85%B3/:3:0","tags":["云原生"],"title":"阿里云相关","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"SpringBoot常用 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:0:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"配置 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:1:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"数据库 spring.datasource.url=jdbc:mysql://localhost:3306/wolf2w?characterEncoding=utf8\u0026useSSL=false\u0026serverTimezone=UTC\u0026rewriteBatchedStatements=true spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:1:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"mybatis日志 logging.level.com.jsh.trip.mapper=trace ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:1:2","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"统一JSON返回 import lombok.Data; import java.util.HashMap; import java.util.Map; //统一返回结果的类 @Data public class R { private Boolean success; private Integer code; private String msg; private Map\u003cString, Object\u003e data = new HashMap\u003cString, Object\u003e(); //构造方法私有化 private R(){} //链式编程 //成功静态方法 public static R ok(){ R r = new R(); r.setSuccess(true); r.setCode(ResultCode.SUCCESS); r.setMsg(\"成功\"); return r; } //失败静态方法 public static R error(){ R r = new R(); r.setSuccess(false); r.setCode(ResultCode.ERROR); r.setMsg(\"失败\"); return r; } public R success(Boolean success){ this.setSuccess(success); return this; } public R msg(String message){ this.setMsg(message); return this; } public R code(Integer code){ this.setCode(code); return this; } public R data(String key, Object value){ this.data.put(key, value); return this; } public R data(Map\u003cString, Object\u003e map) { this.setData(map); return this; } } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:2:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"返回code public interface ResultCode { public static Integer SUCCESS = 200;//成功 public static Integer ERROR = 500;//失败 } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:2:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"异常处理 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:3:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"自定义运行时异常 与统一异常处理相结合,编程过程中使用断言方式，如果不符合预期就抛出异常，统一异常处理后返回给前端 @Setter @Getter @AllArgsConstructor @NoArgsConstructor public class UtilException extends RuntimeException{ private String msg; } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:3:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"统一异常处理 @ControllerAdvice public class CommonExceptionAdvice { @ExceptionHandler(UtilException.class) @ResponseBody public R UtilExceptionhandler(UtilException e, HttpServletResponse resp){ e.printStackTrace(); resp.setContentType(\"application/json;charset=UTF-8\"); return R.error().msg(e.getMsg()); } @ExceptionHandler(RuntimeException.class) @ResponseBody public R runtimeExceptionHandler(RuntimeException e, HttpServletResponse resp){ e.printStackTrace(); resp.setContentType(\"application/json;charset=UTF-8\"); return R.error(); } } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:3:2","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"跨域问题 域名，端口号，协议一个不相同就会产生 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:4:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"单一解决 @CrossOrigin ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:4:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"全局解决 @Configuration public class MvcConfig implements WebMvcConfigurer { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurer() { @Override //重写父类提供的跨域请求处理的接口 public void addCorsMappings(CorsRegistry registry) { //添加映射路径 registry.addMapping(\"/**\") //放行哪些原始域 .allowedOrigins(\"*\") //是否发送Cookie信息 .allowCredentials(true) //放行哪些原始域(请求方式) .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\") //放行哪些原始域(头部信息) .allowedHeaders(\"*\") //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息） .exposedHeaders(\"Header1\", \"Header2\"); } }; } } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:4:2","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"单点登录 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:5:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"cookie+redis 登录 前端请求 $(\"#_j_login_form\").ajaxSubmit({ url:domainUrl +\"/users/login\", type:\"POST\", success:function (data) { if(data.code == 200){ var map = data.data; var token = map.token; //后续后端获取当前登录用户信息 var user = map.user; //前端页面需要显示用户信息 //localStorage 客户端技术可以在浏览器窗口存储数据, 数据操作是永久 //cookie 客户端技术可以在浏览器窗口存储数据, 特点有时效性 //参数1:cookie的key值, 参数2: cookie的value值, 参数3: 有效时间, 单位天 Cookies.set('user', JSON.stringify(user), { expires: 1/48,path:'/'}); Cookies.set('token', token, { expires: 1/48,path:'/'}); //document.referrer 上一个请求路径 var url = document.referrer ? document.referrer : \"/\"; if(url.indexOf(\"regist.html\") \u003e -1 || url.indexOf(\"login.html\") \u003e -1){ url = \"/\"; } window.location.href = url }else{ popup(data.msg); } } }) controller @PostMapping(\"/login\") public R login(String username,String password){ //判断用户名密码 Userinfo userinfo = userinfoService.login(username, password); //存储token String token = userinfoRedisService.setToken(userinfo); return R.ok().data(\"user\",userinfo).data(\"token\",token); } userinfoService public Userinfo login(String username, String password) { QueryWrapper\u003cUserinfo\u003e queryWrapper = new QueryWrapper\u003c\u003e(); queryWrapper.eq(\"phone\",username); queryWrapper.eq(\"password\",password); Userinfo userinfo = baseMapper.selectOne(queryWrapper); if (userinfo == null) { //统一异常返回处理 throw new UtilException(\"用户名或密码错误\"); } return userinfo; } userinfoRedisService public String setToken(Userinfo userinfo) { //生成token String token = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); //生成key String key = RedisKeys.USER_LOGIN_TOKEN.join(token); //用户信息作为value String value = JSON.toJSONString(userinfo); //存储到redis中 template.opsForValue().set(key, value, RedisKeys.USER_LOGIN_TOKEN.getTime(), TimeUnit.SECONDS); return token; } 生成key的类 @Getter public enum RedisKeys { REGIST_VERIFY_CODE(\"regist_verify_code\", Consts.VERIFY_CODE_TIME*60L), USER_LOGIN_TOKEN(\"user_login_token\", Consts.USER_INFO_TOKEN_TIME*60L), STRATEGY_STATIS_VO(\"user_login_token\", -1L); private String prefix; private Long time;//有效时间 private RedisKeys(String prefix, Long time){ this.prefix = prefix; this.time = time; } //拼接一个key public String join(String... values){ StringBuffer sb = new StringBuffer(); sb.append(this.prefix); for (String value : values) { sb.append(\":\"); sb.append(value); } return sb.toString(); } } 资源认证(访问时判断是否登录) 前端进行请求时都会带上token，否则就是未登录 业务处理 编写自定义注解，如果有这个注解则表示需要登录才能访问，也就是需要token正确 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface RequireLogin { } 拦截器CheckLoginInterceptor public class CheckLoginInterceptor implements HandlerInterceptor { @Resource private IUserinfoRedisService userinfoRedisService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.刷新用户redis存储的时间 2.获取用户信息 String token = request.getHeader(\"token\"); Userinfo userinfo = userinfoRedisService.getUserByToken(token); //动态资源（controller） 这种情况都是handler是handlerMethod的实例 if (!(handler instanceof HandlerMethod)) { return true; } HandlerMethod handlerMethod = (HandlerMethod) handler; RequireLogin methodAnnotation = handlerMethod.getMethodAnnotation(RequireLogin.class); if (methodAnnotation == null) { return true; } if (userinfo == null) { throw new LoginException(\"请先登录!\"); } return true; } } userinfoRedisService public Userinfo getUserByToken(String token) { if (!StringUtils.hasLength(token)) { return null; } String key = RedisKeys.USER_LOGIN_TOKEN.join(token); Boolean aBoolean = template.hasKey(key); if (aBoolean) { String s = template.opsForValue().get(key); Userinfo userinfo = JSON.parseObject(s, Userinfo.class); //延时 template.expire(key,RedisKeys.USER_LOGIN_TOKEN.getTime(), TimeUnit.SECONDS); return userinfo; } return null; } 注册配置拦截器 @Configuration public class MvcConfig implements WebMvcConfigurer { //注册拦截器 @Bean public CheckLoginInterceptor checkLoginInterceptor(){ return new CheckLoginInterceptor(); } //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { registr","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:5:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"自动参数注入HandlerMethodArgumentResolver 目的举例：实现用户对controller请求时自动获取到当前登录人的信息(避免每次去请求redis获取) 编写具体的ArgumentResolver 实现HandlerMethodArgumentResolver public class UserInfoArgumentResolver implements HandlerMethodArgumentResolver { @Resource private IUserinfoRedisService userinfoRedisService; /** * 判断满足条件的参数 * 返回值 true和false * 如果返回值为true则进行参数的处理 */ @Override public boolean supportsParameter(MethodParameter methodParameter) { return methodParameter.getParameterType() == Userinfo.class; } /** * 对参数进行处理 并返回 */ @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception { HttpServletRequest nativeRequest = nativeWebRequest.getNativeRequest(HttpServletRequest.class); String token = nativeRequest.getHeader(\"token\"); return userinfoRedisService.getUserByToken(token); } } 配置使其生效 此时就可以使用 @Configuration public class MvcConfig implements WebMvcConfigurer { ... @Bean public UserInfoArgumentResolver userInfoArgumentResolver(){ return new UserInfoArgumentResolver(); } @Override public void addArgumentResolvers(List\u003cHandlerMethodArgumentResolver\u003e resolvers) { resolvers.add(userInfoArgumentResolver()); } ... } 为了判断是否需要参数的自动注入 （使用注解方式判断） 新建注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface RequireLogin { } 修改HandlerMethodArgumentResolver 修改supportsParameter 方法 public class UserInfoArgumentResolver implements HandlerMethodArgumentResolver { @Resource private IUserinfoRedisService userinfoRedisService; /** * 用于指定当前解析器解析的参互类型 */ @Override public boolean supportsParameter(MethodParameter methodParameter) { return methodParameter.getParameterType() == Userinfo.class \u0026\u0026 methodParameter.hasParameterAnnotation(UserParam.class); } @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception { HttpServletRequest nativeRequest = nativeWebRequest.getNativeRequest(HttpServletRequest.class); String token = nativeRequest.getHeader(\"token\"); return userinfoRedisService.getUserByToken(token); } 使用 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:6:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"使用springboot容器生命周期进行redis初始化 ApplicationListener ContextRefreshedEvent 泛型决定监听器执行的时机 @Component @Slf4j public class RedisDataInitListener implements ApplicationListener\u003cContextRefreshedEvent\u003e { @Resource private IStrategyService strategyService; @Resource private IStrategyStatisVORedisService strategyStatisVORedisService; @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) { log.info(\"RedisStrategy初始化开始\"); List\u003cStrategy\u003e strategyList = strategyService.list(); for (Strategy strategy : strategyList) { if (strategyStatisVORedisService.isVoExist(strategy.getId())) { continue; } StrategyStatisVO vo = new StrategyStatisVO(); BeanUtils.copyProperties(strategy,vo); vo.setStrategyId(strategy.getId()); strategyStatisVORedisService.setStrategyVo(vo); } log.info(\"RedisStrategy初始化结束\"); } } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:7:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"Redis开发模式 # 启动 redis-server # 带配置文件启动 redis-server ./redis.conf # 配置后台启动，且端口是 1123 redis-server ./redis.conf --daemonize yes --port 1123 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:8:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"开发顺序 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:8:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"目录 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:8:2","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"配置 pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e properties spring.redis.host=127.0.0.1 spring.redis.port=6379 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:8:3","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"使用 预热(使用springboot生命周期监听，springboot启动完毕后执行) @Component @Slf4j public class RedisDataInitListener implements ApplicationListener\u003cContextRefreshedEvent\u003e { @Resource private IStrategyService strategyService; @Resource private IStrategyStatisVORedisService strategyStatisVORedisService; @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) { log.info(\"RedisStrategy初始化开始\"); List\u003cStrategy\u003e strategyList = strategyService.list(); for (Strategy strategy : strategyList) { if (strategyStatisVORedisService.isVoExist(strategy.getId())) { continue; } StrategyStatisVO vo = new StrategyStatisVO(); BeanUtils.copyProperties(strategy,vo); vo.setStrategyId(strategy.getId()); strategyStatisVORedisService.setStrategyVo(vo); } log.info(\"RedisStrategy初始化结束\"); } } 中间使用 @Resource private StringRedisTemplate template; @Override public void savePhoneCode(String phone, String code) { String key = RedisKeys.REGIST_VERIFY_CODE.join(phone); template.opsForValue().set(key, code, RedisKeys.REGIST_VERIFY_CODE.getTime(), TimeUnit.SECONDS); } @Override public String getPhoneCode(String phone) { String key = RedisKeys.REGIST_VERIFY_CODE.join(phone); return template.opsForValue().get(key); } 落地(持久化) 采用定时方法 @Component @Slf4j public class RedisDataPersistenceJob { @Resource private IStrategyStatisVORedisService strategyStatisVORedisService; @Resource private IStrategyService strategyService; @Scheduled(cron = \"0 0 2 * * ?\") public void doWork() { //redis持久化 ， 将redis中的vo对象拿出 ， 存储到mysql log.info(\"redis-----\u003e\u003emysql vo对象持久化开始\"); List\u003cStrategyStatisVO\u003e strategyStatisVOList = strategyStatisVORedisService.queryVoByPattern(\"*\"); for (StrategyStatisVO vo : strategyStatisVOList) { strategyService.updateStatisVO(vo); } log.info(\"redis-----\u003e\u003emysql vo对象持久化结束\"); } } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:8:4","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"key的设计 @Getter public enum RedisKeys { REGIST_VERIFY_CODE(\"regist_verify_code\", Consts.VERIFY_CODE_TIME*60L), USER_LOGIN_TOKEN(\"user_login_token\", Consts.USER_INFO_TOKEN_TIME*60L), STRATEGY_STATIS_VO(\"startegy_statis_vo\", -1L), USER_STRATEGY_FAVOR(\"user_startegy_favor\", -1L), STRATEGY_THUMB(\"startegy_thumb\",-1L); private String prefix; private Long time;//有效时间 private RedisKeys(String prefix, Long time){ this.prefix = prefix; this.time = time; } //拼接一个key public String join(String... values){ StringBuffer sb = new StringBuffer(); sb.append(this.prefix); for (String value : values) { sb.append(\":\"); sb.append(value); } return sb.toString(); } } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:8:5","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"Mongodb开发模式 进入data和log所在目录命令行运行 –dbpath 指定为刚才创建好的data目录 –logpath 指定log存放位置 –logappend mongo在后台运行 sudo mongod --dbpath data/db --logpath log/mongod.log --logappend 预热和持久化 参考redis ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:9:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"目录 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:9:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"配置 pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-mongodb\u003c/artifactId\u003e \u003c/dependency\u003e properties spring.data.mongodb.uri=mongodb://127.0.0.1:27017/wolf2w logging.level.org.springframework.data.mongodb.core=debug ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:9:2","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"使用 两种方式 //自己编写 @Resource private StrategyCommnetRepository strategyCommnetRepository; //系统定义 @Resource private MongoTemplate template; 定义实体类 //例子 import org.springframework.data.annotation.Id; import org.springframework.data.mongodb.core.mapping.Document; /** * 攻略评论 */ @Setter @Getter @Document(\"strategy_comment\") @ToString public class StrategyComment implements Serializable { @Id private String id; //id private Long strategyId; //攻略(明细)id private String strategyTitle; //攻略标题 private Long userId; //用户id private String nickname; //用户名 private String city; private int level; private String headImgUrl; //头像 private Date createTime; //创建时间 private String content; //评论内容 private int thumbupnum; //点赞数 private List\u003cString\u003e thumbuplist = new ArrayList\u003c\u003e(); } Repository 声明Repository接口 继承MongoRepository接口 传入泛型\u003c实体对象类型,主键类型\u003e // 例子 public interface StrategyCommnetRepository extends MongoRepository\u003cStrategyComment,String\u003e { } service @Service public class StrategyComnetServiceImpl implements IStrategyCommentService { @Resource private StrategyCommnetRepository strategyCommnetRepository; @Resource private MongoTemplate template; @Override public void save(StrategyComment comment) { comment.setId(null); strategyCommnetRepository.save(comment); } @Override public Page\u003cStrategyComment\u003e queryPage(StrategyCommentQuery qo) { //查询对象 Query query = new Query(); if (qo.getStrategyId() != null) { //用于设置查询条件 query.addCriteria(Criteria.where(\"strategyId\").is(qo.getStrategyId())); } //查询总条数 long count = template.count(query, StrategyComment.class); if (count == 0) { return Page.empty(); } //设置分页条件 页数从0开始计算 PageRequest pageRequest = PageRequest.of(qo.getCurrentPage() - 1, qo.getPageSize()); query.with(pageRequest); //查询 List\u003cStrategyComment\u003e strategyComments = template.find(query, StrategyComment.class); //组装page return new PageImpl\u003c\u003e(strategyComments, pageRequest, count); } } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:9:3","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"elasticsearch开发模式 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:10:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"目录 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:10:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"配置 pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-elasticsearch\u003c/artifactId\u003e \u003c/dependency\u003e properties spring.data.elasticsearch.cluster-name=elasticsearch spring.data.elasticsearch.cluster-nodes=localhost:9300 spring.data.elasticsearch.repositories.enabled=true ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:10:2","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"使用 准备阶段 实体类 import org.springframework.data.annotation.Id; import org.springframework.data.elasticsearch.annotations.Document; import org.springframework.data.elasticsearch.annotations.Field; import org.springframework.data.elasticsearch.annotations.FieldType; /** * 攻略搜索对象 */ @Getter @Setter @Document(indexName=\"wolf2w_strategy\",type=\"strategy\") public class StrategyEs implements Serializable { public static final String INDEX_NAME = \"wolf2w_strategy\"; public static final String TYPE_NAME = \"strategy\"; //@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ） @Id @Field(store=true, index = false,type = FieldType.Long) private Long id; //id @Field(index=true,analyzer=\"ik_max_word\",store=true,searchAnalyzer=\"ik_max_word\",type = FieldType.Text) private String title; //攻略标题 @Field(index=true,analyzer=\"ik_max_word\",store=true,searchAnalyzer=\"ik_max_word\",type = FieldType.Text) private String subTitle; //攻略标题 @Field(index=true,analyzer=\"ik_max_word\",store=true,searchAnalyzer=\"ik_max_word\",type = FieldType.Text) private String summary; //攻略简介 } Repository public interface StrategyEsRepository extends ElasticsearchRepository\u003cStrategyEs, Long\u003e { } service @Service public class StrategyEsService implements IStrategyEsService { //自定义 @Autowired private StrategyEsRepository repository; //系统1定义 @Resource private ElasticsearchTemplate template; @Override public void save(StrategyEs es) { repository.save(es); } } 预热(初始化) //初始化服务 @GetMapping(\"/dataInit\") public String dataInit() { //攻略 List\u003cStrategy\u003e sts = strategyService.list(); for (Strategy st : sts) { StrategyEs es = new StrategyEs(); BeanUtils.copyProperties(st, es); strategyEsService.save(es); } List\u003cTravel\u003e travels = travelService.list(); for (Travel travel : travels) { TravelEs es = new TravelEs(); BeanUtils.copyProperties(travel, es); travelEsService.save(es); } List\u003cDestination\u003e destinations = destinationService.list(); for (Destination dest : destinations) { DestinationEs es = new DestinationEs(); BeanUtils.copyProperties(dest, es); destinationEsService.save(es); } List\u003cUserinfo\u003e users = userinfoService.list(); for (Userinfo user : users) { UserInfoEs es = new UserInfoEs(); BeanUtils.copyProperties(user, es); userInfoEsService.save(es); } return \"ok\"; } 中间查询使用 用高亮检索举例 controller @GetMapping(\"/q\") public R search(@ModelAttribute(\"qo\") SearchQueryObject qo) throws UnsupportedEncodingException { //qo中有两个关键值 type(查询类型，攻略，游记，城市，用户，所有)和keyword qo.setKeyword(URLDecoder.decode(qo.getKeyword(), \"utf8\")); switch (qo.getType()) { case SearchQueryObject.TYPE_DEST: return this.searchDest(qo); case SearchQueryObject.TYPE_STRATEGY: return this.searchStartegy(qo); case SearchQueryObject.TYPE_USER: return this.searchUser(qo); case SearchQueryObject.TYPE_TRAVEL: return this.searchTravel(qo); default: return this.searchAll(qo); } } private R searchAll(SearchQueryObject qo) { SearchResultVo vo = new SearchResultVo(); Page\u003cUserinfo\u003e userinfoPage = searchService.searchWithHighLight(UserInfoEs.INDEX_NAME, UserInfoEs.TYPE_NAME, Userinfo.class, qo, \"info\", \"city\"); Page\u003cStrategy\u003e strategyPage = searchService.searchWithHighLight(StrategyEs.INDEX_NAME, StrategyEs.TYPE_NAME, Strategy.class, qo, \"title\", \"subTitle\", \"summary\"); Page\u003cTravel\u003e travelPage = searchService.searchWithHighLight(TravelEs.INDEX_NAME, TravelEs.TYPE_NAME, Travel.class, qo, \"title\", \"summary\"); for (Travel travel : travelPage) { Userinfo userinfo = userinfoService.getById(travel.getAuthorId()); travel.setAuthor(userinfo); } Page\u003cDestination\u003e destinationPage = searchService.searchWithHighLight(DestinationEs.INDEX_NAME, DestinationEs.TYPE_NAME, Destination.class, qo, \"name\", \"info\", \"summary\"); vo.setStrategys(strategyPage.getContent()); vo.setTravels(travelPage.getContent()); vo.setUsers(userinfoPage.getContent()); vo.setDests(destinationPage.getContent()); return R.ok().data(\"result\", vo).data(\"qo\", qo); } private R searchTravel(SearchQueryObject qo) { Page\u003cTravel\u003e page = searchService.searchWithHighLight(TravelEs.INDEX_NAME, TravelEs.TYPE_NAME, Travel.class,","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:10:3","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"mysql优化 ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:11:0","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["Spring"],"content":"对于查询需要计算的操作 查询的数据生成一个新表，然后用定时任务进行更新(添加statis_time字段)，之后每次查询只取最新时间的 举例： 存储 @Component @Slf4j public class StrategyRankStatisJob { @Resource private IStrategyService strategyService; @Resource private IStrategyRankService strategyRankService; @Scheduled(cron = \"0 0 2 * * ?\") public void doWork() { List\u003cStrategy\u003e hotList = queryData(null, \"viewnum+replynum\"); List\u003cStrategy\u003e abroadList = queryData(1, \"thumbsupnum+replynum\"); List\u003cStrategy\u003e chinaList = queryData(0, \"thumbsupnum+replynum\"); Date date = new Date(); List\u003cStrategyRank\u003e ranks = new ArrayList\u003c\u003e(); ranks.addAll(parseData(hotList, date, StrategyRank.TYPE_HOT)); ranks.addAll(parseData(abroadList, date, StrategyRank.TYPE_ABROAD)); ranks.addAll(parseData(chinaList, date, StrategyRank.TYPE_CHINA)); strategyRankService.saveBatch(ranks); } private List\u003cStrategy\u003e queryData(Integer isabroad, String columnSql) { QueryWrapper\u003cStrategy\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.eq(isabroad != null, \"isabroad\", isabroad) .orderByDesc(columnSql).last(\"limit 10\"); return strategyService.list(wrapper); } private List\u003cStrategyRank\u003e parseData(List\u003cStrategy\u003e list, Date date, Integer type) { List\u003cStrategyRank\u003e strategyRankList = new ArrayList\u003c\u003e(); for (Strategy strategy : list) { StrategyRank strategyRank = new StrategyRank(); strategyRank.setDestId(strategy.getDestId()); strategyRank.setDestName(strategy.getDestName()); strategyRank.setStrategyId(strategy.getId()); strategyRank.setStrategyTitle(strategy.getTitle()); strategyRank.setStatisTime(date); if (type.equals(StrategyRank.TYPE_HOT)) { strategyRank.setType(StrategyRank.TYPE_HOT); strategyRank.setStatisnum((long) (strategy.getViewnum() + strategy.getReplynum())); } else if (type.equals(StrategyRank.TYPE_ABROAD)) { strategyRank.setType(StrategyRank.TYPE_ABROAD); strategyRank.setStatisnum((long) (strategy.getThumbsupnum() + strategy.getReplynum())); } else if (type.equals(StrategyRank.TYPE_CHINA)) { strategyRank.setType(StrategyRank.TYPE_CHINA); strategyRank.setStatisnum((long) (strategy.getThumbsupnum() + strategy.getReplynum())); } strategyRankList.add(strategyRank); } return strategyRankList; } } 查询 @Override public List\u003cStrategyRank\u003e qyeryBytype(Integer type) { QueryWrapper\u003cStrategyRank\u003e strategyRankQueryWrapper = new QueryWrapper\u003c\u003e(); strategyRankQueryWrapper.eq(\"type\",type) .inSql(\"statis_time\",\"select max(statis_time) from strategy_rank\") .orderByDesc(\"statisnum\") .last(\"limit 10\"); return baseMapper.selectList(strategyRankQueryWrapper); } ","date":"2021-08-14","objectID":"/springboot%E5%B8%B8%E7%94%A8/:11:1","tags":["框架","整理"],"title":"SpringBoot常用","uri":"/springboot%E5%B8%B8%E7%94%A8/"},{"categories":["运维"],"content":"前后端分离项目部署 ","date":"2021-08-07","objectID":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/:0:0","tags":[],"title":"前后端分离项目部署","uri":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"环境准备 三个centos7操作系统 192.168.11.15（前端，mysql，redis） 192.168.11.16（java服务） 192.168.11.23（java服务） Mysql 开放访问权限 redis 修改配置文件 开放访问 bind 127.0.0.1 ::1 0.0.0.0 protected-mode no ","date":"2021-08-07","objectID":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/:0:1","tags":[],"title":"前后端分离项目部署","uri":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"后端部署 开放对应端口 查询指定端口是否已开 firewall-cmd --query-port=8080/tcp 添加指定需要开放的端口： firewall-cmd --add-port=8080/tcp --permanent 重载入添加的端口： firewall-cmd --reload 查询指定端口是否开启成功： firewall-cmd --query-port=8080/tcp jar包部署 java -jar xxx.jar //后台运行 nohup java -jar xxx.jar ","date":"2021-08-07","objectID":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/:0:2","tags":[],"title":"前后端分离项目部署","uri":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"前端 静态文件准备 安装依赖 npm install 打包生成dist文件夹 npm run build nginx配置 静态文件夹地址 location请求转发 upstream配置 http { ... upstream ruoyi{ server 192.168.11.16:8080; server 192.168.11.23:8080; } server { listen 80; server_name localhost; location / { root /Users/mr_j/Desktop/dist; index index.html index.htm; } location /prod-api/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://ruoyi/; } ... } ... } 启动 ","date":"2021-08-07","objectID":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/:0:3","tags":[],"title":"前后端分离项目部署","uri":"/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"categories":["Spring"],"content":"Mybatis-Plus ","date":"2021-08-05","objectID":"/mybatis-plus/:0:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"一.配置 pom.xml \u003c!-- mybatisPlus--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.0.5\u003c/version\u003e \u003c/dependency\u003e \u003c!-- lombok用来简化实例 需要安装lombok插件--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e application.properties #数据库配置 spring.datasource.url=jdbc:mysql://localhost:3306/testdata spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=123456 ","date":"2021-08-05","objectID":"/mybatis-plus/:1:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"二.编写代码 ","date":"2021-08-05","objectID":"/mybatis-plus/:2:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"1.实体类 使用Lombok简化代码 @Data public class User { private Long id; private String name; private Integer age; private String email; } ","date":"2021-08-05","objectID":"/mybatis-plus/:2:1","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"2.数据库 CREATE TABLE USER ( id BIGINT(20) NOT NULL COMMENT '主键ID', NAME VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); INSERT INTO USER (id, NAME, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); ","date":"2021-08-05","objectID":"/mybatis-plus/:2:2","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"3.mapper 需要继承：BaseMapper\u003c实体\u003e package com.jsh.mybatisplus.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.jsh.mybatisplus.entity.User; import org.springframework.stereotype.Repository; @Repository public interface UserMapper extends BaseMapper\u003cUser\u003e { } ","date":"2021-08-05","objectID":"/mybatis-plus/:2:3","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"三.整体测试代码 package com.jsh.mybatisplus; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.jsh.mybatisplus.entity.User; import com.jsh.mybatisplus.mapper.UserMapper; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.Arrays; import java.util.HashMap; import java.util.List; @SpringBootTest public class MybatisplusApplicationTests { // 测试mybatisPlus @Autowired private UserMapper userMapper; // 查询user表所有数据 @Test public void testSelectList() { List\u003cUser\u003e userList = userMapper.selectList(null); System.out.println(userList); } // 添加操作 @Test public void testInsert(){ User user = new User(); user.setName(\"GG1\"); user.setAge(20); user.setEmail(\"1157237955@qq.cmm\"); int insert = userMapper.insert(user); System.out.println(insert); } // 修改操作 @Test public void testUpdate() { User user = new User(); user.setId(1288368399486828545L); user.setName(\"P\"); userMapper.updateById(user); } // 测试乐观锁 @Test public void OptimisticLocker() { //根据id查询数据 User user = userMapper.selectById(1288368399486828545L); user.setName(\"P\"); userMapper.updateById(user); } // 多个id批量查询 @Test public void testSelectDemo1() { List\u003cUser\u003e userList = userMapper.selectBatchIds(Arrays.asList(1L,2L,3L)); System.out.println(userList); } // 根据条件查询(map) @Test public void testDeleteByMap() { HashMap\u003cString, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"name\", \"Helen\"); map.put(\"age\", 18); List\u003cUser\u003e userList = userMapper.selectByMap(map); System.out.println(userList); } // 分页查询 @Test public void testSelectPage() { //1.创建page对象 //两个参数：当前页，每页显示数据 Page\u003cUser\u003e page = new Page\u003c\u003e(1,3); //调用mp分页查询方法:底层封装（把分页的所有数据封装到page中） userMapper.selectPage(page,null); //通过page对象获取分页数据 System.out.println(page.getCurrent());//当前页 System.out.println(page.getRecords());//每页数据的list集合 System.out.println(page.getSize());//每页显示记录数 System.out.println(page.getTotal());//总记录数 System.out.println(page.getPages());//总页数 System.out.println(page.hasNext());//是否有下一页 System.out.println(page.hasPrevious());//是否有上一页 } //删除操作 物理删除 @Test public void testDelete() { int result = userMapper.deleteById(1288412637062803457L); System.out.println(result); } //批量删除 @Test public void testDeleteBatchIds() { int result = userMapper.deleteBatchIds(Arrays.asList(2,1,3)); System.out.println(result); } //复杂条件查询 构建条件 @Test public void testQueryWapper(){ //创建QueryWrapper对象 QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper\u003c\u003e(); //通过QueryWrapper设置条件 //ge(大于等于),gt(大于),le(小于等于),lt(小于) // queryWrapper.gt(\"age\",20); //eq(等于),ne(不等于) // queryWrapper.eq(\"name\",\"GG\"); //between(查询区间 包括临界值) // queryWrapper.between(\"age\",20,30); //like(模糊查询) // queryWrapper.like(\"name\",\"G\"); //orderByDesc(排序) // queryWrapper.orderByDesc(\"id\"); //last(在sql语句后拼接) // queryWrapper.last(\"limit 1\"); //select(指定要查询的列) queryWrapper.select(\"id\",\"name\"); userMapper.selectList(queryWrapper); } } ","date":"2021-08-05","objectID":"/mybatis-plus/:3:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"四.配置日志 application.properties #mybatis日志 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl ","date":"2021-08-05","objectID":"/mybatis-plus/:4:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"五.主键策略 // 主键生成策略 /** * AUTO：自动生长 * INPUT：手动输入设置 * NONE：没有策略 * UUID：随即唯一的值 * * mybatisPlus自带策略：（不写会默认识别） * ID_WORKER：生成19位值，数字类型使用这种策略，例如long * ID_WORKER_STR：生成19位值，字符串类型使用这种策略 */ @TableId(type = IdType.ID_WORKER) private Long id; ","date":"2021-08-05","objectID":"/mybatis-plus/:5:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"六.自动填充 数据库表中添加自动填充字段 在User表中添加datetime类型的新的字段 create_time、update_time 实体上添加注解 //creat_time 添加时 INSERT @TableField(fill = FieldFill.INSERT) private Date createTime; //update_time 添加和修改时 INSERT_UPDATE @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime; 实现元对象处理器接口(不要忘记添加 @Component 注解) package com.jsh.mybatisplus.handler; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Component public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { //三个参数：修改的参数名，修改的值，metaObject this.setFieldValByName(\"createTime\",new Date(),metaObject); this.setFieldValByName(\"updateTime\",new Date(),metaObject); } @Override public void updateFill(MetaObject metaObject) { this.setFieldValByName(\"updateTime\",new Date(),metaObject); } } ","date":"2021-08-05","objectID":"/mybatis-plus/:6:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"七.乐观锁 主要适用场景：当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新 乐观锁实现方式： 取出记录时，获取当前version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 数据库中添加version字段 实体类添加version字段 并添加 @Version 注解 //版本号 @Version @TableField(fill = FieldFill.INSERT) private Integer version; 元对象处理器接口添加version的insert默认值 @Override public void insertFill(MetaObject metaObject) { ...... this.setFieldValByName(\"version\", 1, metaObject); } 在MpConfig(用于配置)中注册 Bean @Configuration @MapperScan(\"com.jsh.mybatisplus.mapper\") public class MpConfig { //乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor(){ return new OptimisticLockerInterceptor(); } } 测试 测试后分析打印的sql语句，将version的数值进行了加1操作 // 测试乐观锁 @Test public void OptimisticLocker() { //根据id查询数据 User user = userMapper.selectById(1288368399486828545L); user.setName(\"P\"); userMapper.updateById(user); } ","date":"2021-08-05","objectID":"/mybatis-plus/:7:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"八.分页查询 MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能 配置分页插件 @Configuration @MapperScan(\"com.jsh.mybatisplus.mapper\") public class MpConfig { //分页插件 @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } } 测试 最终通过page对象获取相关数据 // 分页查询 @Test public void testSelectPage() { //1.创建page对象 //两个参数：当前页，每页显示数据 Page\u003cUser\u003e page = new Page\u003c\u003e(1,3); //调用mp分页查询方法:底层封装（把分页的所有数据封装到page中） userMapper.selectPage(page,null); //通过page对象获取分页数据 System.out.println(page.getCurrent());//当前页 System.out.println(page.getRecords());//每页数据的list集合 System.out.println(page.getSize());//每页显示记录数 System.out.println(page.getTotal());//总记录数 System.out.println(page.getPages());//总页数 System.out.println(page.hasNext());//是否有下一页 System.out.println(page.hasPrevious());//是否有上一页 } ","date":"2021-08-05","objectID":"/mybatis-plus/:8:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"九.逻辑删除 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除数据 逻辑删除：假删除，将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍 旧能看到此条数据记录 数据库中添加 deleted字段 实体类添加deleted 字段 //逻辑删除标识符 @TableLogic @TableField(fill = FieldFill.INSERT) private Integer deleted; 元对象处理器接口添加deleted的insert默认值 public void insertFill(MetaObject metaObject) { ...... this.setFieldValByName(\"deleted\", 0, metaObject); } application.properties #mybatis逻辑删除标志定义 默认是0和1 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 在 MyConfig 中注册 Bean @Configuration @MapperScan(\"com.jsh.mybatisplus.mapper\") public class MpConfig { //逻辑删除插件 mybatis-Plus版本3.3.0以后不需要 @Bean public ISqlInjector iSqlInjector() { return new LogicSqlInjector(); } } 测试 测试后发现，数据并没有被删除，deleted字段的值由0变成了1 测试后分析打印的sql语句，是一条update 注意：被删除数据的deleted 字段的值必须是 0，才能被选取出来执行逻辑删除的操作 @Test public void testDelete() { int result = userMapper.deleteById(1288412637062803457L); System.out.println(result); } 测试逻辑删除后的查询 MyBatis Plus中查询操作也会自动添加逻辑删除字段的判断 测试后分析打印的sql语句，包含 WHERE deleted=0 SELECT id,name,age,email,create_time,update_time,deleted FROM user WHERE deleted=0 /** * 测试 逻辑删除后的查询： * 不包括被逻辑删除的记录 */ @Test public void testLogicDeleteSelect() { User user = new User(); List\u003cUser\u003e users = userMapper.selectList(null); users.forEach(System.out::println); } ","date":"2021-08-05","objectID":"/mybatis-plus/:9:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"十.性能分析 在 MyConfig 中注册 Bean @Configuration @MapperScan(\"com.jsh.mybatisplus.mapper\") public class MpConfig { /** * sql执行性能分析插件 * 开发环境使用，线上不推荐，maxTime:最大执行时常 * * 三种环境 * dev:开发环境 * test:测试环境 * prod:生产环境 */ @Bean @Profile({\"dev\",\"test\"})//设置 dev test 环境开启 public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(500);//ms,超过500ms sql语句不执行 performanceInterceptor.setFormat(true);//格式化日志 return performanceInterceptor; } } Spring Boot 中设置dev环境 #环境设置 spring.profiles.active=dev ","date":"2021-08-05","objectID":"/mybatis-plus/:10:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"十一.条件查询(QueryWrapper) @SpringBootTest public class MybatisplusApplicationTests { // 测试mybatisPlus @Autowired private UserMapper userMapper; //复杂条件查询 构建条件 @Test public void testQueryWapper(){ //创建QueryWrapper对象 QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper\u003c\u003e(); //通过QueryWrapper设置条件 //ge(大于等于),gt(大于),le(小于等于),lt(小于) // queryWrapper.gt(\"age\",20); //eq(等于),ne(不等于) // queryWrapper.eq(\"name\",\"GG\"); //between(查询区间 包括临界值) // queryWrapper.between(\"age\",20,30); //like(模糊查询) // queryWrapper.like(\"name\",\"G\"); //orderByDesc(排序) // queryWrapper.orderByDesc(\"id\"); //last(在sql语句后拼接) // queryWrapper.last(\"limit 1\"); //select(指定要查询的列) queryWrapper.select(\"id\",\"name\"); userMapper.selectList(queryWrapper); } } ","date":"2021-08-05","objectID":"/mybatis-plus/:11:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"十二.代码生成 Mybatisplus3.0.3往下 package com.jsh.template; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.GlobalConfig; import com.baomidou.mybatisplus.generator.config.PackageConfig; import com.baomidou.mybatisplus.generator.config.StrategyConfig; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import org.junit.Test; /** * @author * @since 2018/12/13 */ public class CodeGenerator { @Test public void run() { // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(\"E:\\\\JAVA存储\\\\项目\\\\前后端总结\\\\template\" + \"/src/main/java\"); gc.setAuthor(\"testjava\"); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(false); //重新生成时文件是否覆盖 //UserServie gc.setServiceName(\"%sService\"); //去掉Service接口的首字母I gc.setIdType(IdType.ID_WORKER_STR); //主键策略 3.3.0以后需要更改 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/template?serverTimezone=GMT%2B8\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); //包 com.guli.eduservice pc.setParent(\"com.jsh\"); pc.setModuleName(\"template\"); //模块名 //包 com.atguigu.eduservice.controller pc.setController(\"controller\"); pc.setEntity(\"entity\"); pc.setService(\"service\"); pc.setMapper(\"mapper\"); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"role\");//表名，可以加入多张表 用\",\"隔开 strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setTablePrefix(pc.getModuleName() + \"_\"); //生成实体时去掉\"_\"变成大写 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); } } 3.0.3往上 pom \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-generator\u003c/artifactId\u003e \u003cversion\u003e3.4.1\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 模板引擎 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.velocity\u003c/groupId\u003e \u003cartifactId\u003evelocity-engine-core\u003c/artifactId\u003e \u003cversion\u003e2.0\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-08-05","objectID":"/mybatis-plus/:12:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"十三.查询与实体类不对应的数据 QueryWrapper\u003cStrategyCatalog\u003e strategyCatalogQueryWrapper = new QueryWrapper\u003c\u003e(); strategyCatalogQueryWrapper.groupBy(\"dest_name\").select(\"dest_name\",\"group_concat(name) as names\",\"group_concat(id) as ids\"); List\u003cMap\u003cString, Object\u003e\u003e maps = baseMapper.selectMaps(strategyCatalogQueryWrapper); //通过map的key去拿值 for (Map\u003cString, Object\u003e map : maps) { String destName = map.get(\"dest_name\").toString(); String names = map.get(\"names\").toString(); String ids = map.get(\"ids\").toString(); } ","date":"2021-08-05","objectID":"/mybatis-plus/:13:0","tags":["框架"],"title":"Mybatis-Plus","uri":"/mybatis-plus/"},{"categories":["Spring"],"content":"SSM相关 ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:0:0","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"项目结构 projectname src main java resources mvc.xml applicationContext.xml db.properties mybatis-config.xml log4j.properties shiro.xml shiro-ehcache.xml generatorConfig.xml webapp WEB_INF views web.xml css … test ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:0:1","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"项目搭建 ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:1:0","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"pom.xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecn.wolfcode\u003c/groupId\u003e \u003cartifactId\u003ewolfcar\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003cspring.version\u003e5.0.8.RELEASE\u003c/spring.version\u003e \u003cshiro.version\u003e1.5.2\u003c/shiro.version\u003e \u003c/properties\u003e \u003cpackaging\u003ewar\u003c/packaging\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- aop--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.8.13\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-test\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e1.1.19\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.45\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.4.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e1.3.1\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 分页--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper\u003c/artifactId\u003e \u003cversion\u003e5.1.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.25\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.0.1\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.16.22\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- 将freemarker等第三方库整合进Spring应用上下文的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context-support\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- freemaker--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.freemarker\u003c/groupId\u003e \u003cartifactId\u003efreemarker\u003c/artifactId\u003e \u003cversion\u003e2.3.30\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.6\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 核心--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-core\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 的 Web 模块--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-web\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 和 Spring 集成--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-spring\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 底层使用的 ehcache 缓存--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-ehcache\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 依赖的日志包--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-logging\u003c/groupId\u003e \u003cartifactId\u003ecommons-logging\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 依赖的工具包--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e \u003c!--Freemarker 的 shiro 标签库--\u003e \u003cdependency\u003e \u003cgroupId\u003enet.mingsoft\u003c/groupId\u003e \u003cartifactId\u003eshiro-freemarker-tags\u003c/artifactId\u003e \u003cversion\u003e1.0.1\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-all\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.ali","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:1:1","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"web.xml配置 \u003cweb-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"\u003e \u003cfilter\u003e \u003cfilter-name\u003echaracterEncodingFilter\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003echaracterEncodingFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:mvc.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003cmultipart-config\u003e \u003cmax-file-size\u003e1024000\u003c/max-file-size\u003e \u003cmax-request-size\u003e1024000\u003c/max-request-size\u003e \u003c/multipart-config\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c!-- shiro 配置 --\u003e \u003cfilter\u003e \u003cfilter-name\u003eshiroFilter\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.DelegatingFilterProxy\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eshiroFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:1:2","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"mvc.xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!-- 注解扫描 --\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.controller\"/\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.advice\"/\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.service\"/\u003e \u003c!-- 处理静态资源 使用默认的Servlet来响应静态文件 --\u003e \u003cmvc:default-servlet-handler/\u003e \u003cmvc:annotation-driven/\u003e \u003cimport resource=\"classpath:shiro.xml\"/\u003e \u003cimport resource=\"classpath:applicationContext.xml\"/\u003e \u003c!-- 不使用commons-fileupload时 --\u003e \u003c!-- \u003cbean class=\"org.springframework.web.multipart.support.StandardServletMultipartResolver\"\u003e--\u003e \u003c!-- \u003c/bean\u003e--\u003e \u003c!--文件上传解析器 id必须是multipartResolver--\u003e \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e \u003c!--最大上传文件大小 10M--\u003e \u003cproperty name=\"maxUploadSize\" value=\"#{1024*1024*10}\"/\u003e \u003c/bean\u003e \u003c!-- 注册 FreeMarker 配置类 --\u003e \u003cbean class=\"cn.wolfcode.wolfcar.config.MyFreemarkerConfiger\"\u003e \u003c!-- 配置 FreeMarker 的文件编码 --\u003e \u003cproperty name=\"defaultEncoding\" value=\"UTF-8\" /\u003e \u003c!-- 配置 FreeMarker 寻找模板的路径 --\u003e \u003cproperty name=\"templateLoaderPath\" value=\"/WEB-INF/views/\" /\u003e \u003cproperty name=\"freemarkerSettings\"\u003e \u003cprops\u003e \u003c!-- 兼容模式 ，配了后不需要另外处理空值问题，时间格式除外 --\u003e \u003cprop key=\"classic_compatible\"\u003etrue\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 注册 FreeMarker 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"\u003e \u003c!-- 是否把session中的attribute复制到模板的属性集中，可以使用FreeMarker的表达式来访问并显示--\u003e \u003cproperty name=\"exposeSessionAttributes\" value=\"true\" /\u003e \u003c!-- 配置逻辑视图自动添加的后缀名 --\u003e \u003cproperty name=\"suffix\" value=\".ftl\" /\u003e \u003c!-- 配置响应头中 Content-Type 的指 --\u003e \u003cproperty name=\"contentType\" value=\"text/html;charset=UTF-8\" /\u003e \u003c/bean\u003e \u003c/beans\u003e freemaker配置类 config.MyFreemarkerConfiger package cn.wolfcode.wolfcar.config; import com.jagregory.shiro.freemarker.ShiroTags; import freemarker.template.Configuration; import freemarker.template.TemplateException; import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer; import java.io.IOException; public class MyFreemarkerConfiger extends FreeMarkerConfigurer { @Override public void afterPropertiesSet() throws IOException, TemplateException { //继承之前的属性配置，这步不能省 super.afterPropertiesSet(); Configuration cfg = this.getConfiguration(); cfg.setSharedVariable(\"shiro\", new ShiroTags());//注册shiro 标签 } } ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:1:3","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"applicationContext.xml配置 注意修改包 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"\u003e \u003ccontext:property-placeholder location=\"classpath:db.properties\"/\u003e \u003c!-- 数据源 --\u003e \u003cbean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"\u003e \u003cproperty name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/\u003e \u003cproperty name=\"url\" value=\"${jdbc.url}\"/\u003e \u003cproperty name=\"username\" value=\"${jdbc.username}\"/\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"/\u003e \u003c/bean\u003e \u003c!-- 数据库链接 --\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003c!-- 数据源 --\u003e \u003cproperty name=\"dataSource\" ref=\"druidDataSource\"/\u003e \u003c!-- 配置mapper中实体类别名 --\u003e \u003cproperty name=\"typeAliasesPackage\" value=\"cn.wolfcode.wolfcar.domain\"/\u003e \u003c!-- mybatis配置 --\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003c!-- 将pageHelper配置到sqlsessionfactory --\u003e \u003cproperty name=\"plugins\"\u003e \u003carray\u003e \u003cbean class=\"com.github.pagehelper.PageInterceptor\"\u003e \u003cproperty name=\"properties\"\u003e \u003c!--使用下面的方式配置参数，一行配置一个，下面配的是合理化分页 --\u003e \u003cvalue\u003e reasonable=true \u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/array\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 扫描mapper接口 注入spring --\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"basePackage\" value=\"cn.wolfcode.wolfcar.mapper\"/\u003e \u003c/bean\u003e \u003c!-- 开启事务注解配置 --\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"druidDataSource\"/\u003e \u003c/bean\u003e \u003ctx:annotation-driven transaction-manager=\"transactionManager\"/\u003e \u003c/beans\u003e db.properties jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/wolfcar?characterEncoding=utf8 jdbc.username=root jdbc.password=123456 mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003csettings\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003csetting name=\"aggressiveLazyLoading\" value=\"false\"/\u003e \u003csetting name=\"lazyLoadTriggerMethods\" value=\"clone\"/\u003e \u003c/settings\u003e \u003c/configuration\u003e ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:1:4","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"shirt.xml 配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.realm\"\u003e\u003c/context:component-scan\u003e \u003c!-- aop自动代理 --\u003e \u003cbean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\" depends-on=\"lifecycleBeanPostProcessor\" /\u003e \u003c!-- 管理shiro生命周期 --\u003e \u003cbean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"\u003e\u003c/bean\u003e \u003c!-- 安全管理器 --\u003e \u003cbean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"\u003e \u003cproperty name=\"securityManager\" ref=\"securityManager\"/\u003e \u003c/bean\u003e \u003c!--指定当前需要使用的凭证匹配器--\u003e \u003cbean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"\u003e \u003c!-- 指定加密算法 --\u003e \u003cproperty name=\"hashAlgorithmName\" value=\"MD5\"/\u003e \u003c/bean\u003e \u003cbean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"\u003e \u003c!--引用指定的安全管理器--\u003e \u003cproperty name=\"securityManager\" ref=\"securityManager\"/\u003e \u003c!--shiro默认的登录地址是/login.jsp 现在要指定我们自己的登录页面地址--\u003e \u003cproperty name=\"loginUrl\" value=\"/login.html\"/\u003e \u003cproperty name=\"successUrl\" value=\"/employee/list\"\u003e\u003c/property\u003e \u003c!--路径对应的规则--\u003e \u003cproperty name=\"filterChainDefinitions\"\u003e \u003cvalue\u003e /index.htm=anon /employee/login=anon /css/**=anon /img/**=anon /js/**=anon /**=authc \u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"\u003e \u003c!--注册自定义数据源--\u003e \u003cproperty name=\"realm\" ref=\"myRealm\"\u003e\u003c/property\u003e \u003c!--注册缓存管理器--\u003e \u003cproperty name=\"cacheManager\" ref=\"cacheManager\"/\u003e \u003c/bean\u003e \u003c!-- 缓存管理器 --\u003e \u003cbean id=\"cacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"\u003e \u003c!-- 设置配置文件 --\u003e \u003cproperty name=\"cacheManagerConfigFile\" value=\"classpath:shiro-ehcache.xml\"/\u003e \u003c/bean\u003e \u003c/beans\u003e shiro 配置类（认证 授权） package cn.wolfcode.wolfcar.realm; import cn.wolfcode.wolfcar.domain.Employee; import cn.wolfcode.wolfcar.service.IEmployeeService; import cn.wolfcode.wolfcar.service.IPermissionService; import cn.wolfcode.wolfcar.service.IRoleService; import org.apache.shiro.authc.*; import org.apache.shiro.authc.credential.CredentialsMatcher; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.apache.shiro.util.ByteSource; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import javax.annotation.Resource; import java.util.List; @Component public class MyRealm extends AuthorizingRealm{ @Resource private IEmployeeService employeeService; @Resource private IRoleService roleService; @Resource private IPermissionService permissionService; @Autowired public void setCredentialsMatcher(CredentialsMatcher credentialsMatcher) { super.setCredentialsMatcher(credentialsMatcher); } @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { //获取当前的主体对象 Employee employee = (Employee) principals.getPrimaryPrincipal(); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); if(employee.isAdmin()){ info.addRole(\"admin\"); info.addStringPermission(\"*:*\"); return info; } //获取当前用户的角色 List\u003cString\u003e rolesnlist = roleService.getRoleSnByEmployeeId(employee.getId()); //获取当前用户的权限 List\u003cString\u003e permissionList = permissionService.getPermissionExpressionByEmployeeId(employee.getId()); //给当前用户添加角色和权限（授权） info.addRoles(rolesnlist); info.addStringPermissions(permissionList); return info; } //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { UsernamePasswordToken ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:1:5","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"log4j.properties # Global logging configuration log4j.rootLogger=ERROR, stdout log4j.logger.cn.wolfcode.wolfcar.mapper=TRACE # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:1:6","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"generatorConfig.xml mybatis逆向工程 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003c!-- 配置生成器 --\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"mysql\" defaultModelType=\"hierarchical\" targetRuntime=\"MyBatis3Simple\"\u003e \u003c!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --\u003e \u003cproperty name=\"autoDelimitKeywords\" value=\"false\" /\u003e \u003c!-- 生成的Java文件的编码 --\u003e \u003cproperty name=\"javaFileEncoding\" value=\"UTF-8\" /\u003e \u003c!-- 格式化java代码 --\u003e \u003cproperty name=\"javaFormatter\" value=\"org.mybatis.generator.api.dom.DefaultJavaFormatter\" /\u003e \u003c!-- 格式化XML代码 --\u003e \u003cproperty name=\"xmlFormatter\" value=\"org.mybatis.generator.api.dom.DefaultXmlFormatter\" /\u003e \u003c!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --\u003e \u003cproperty name=\"beginningDelimiter\" value=\"`\" /\u003e \u003cproperty name=\"endingDelimiter\" value=\"`\" /\u003e \u003ccommentGenerator\u003e \u003cproperty name=\"suppressDate\" value=\"true\" /\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\" /\u003e \u003c/commentGenerator\u003e \u003c!-- 必须要有的，使用这个配置链接数据库 @TODO:是否可以扩展 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql:///wolfcar\" userId=\"root\" password=\"123456\"\u003e \u003c!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --\u003e \u003c/jdbcConnection\u003e \u003c!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --\u003e \u003cjavaTypeResolver type=\"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl\"\u003e \u003c!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale\u003e0;length\u003e18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length\u003c5：使用Short； --\u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\" /\u003e \u003c/javaTypeResolver\u003e \u003c!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --\u003e \u003cjavaModelGenerator targetPackage=\"cn.wolfcode.wolfcar.domain\" targetProject=\"src/main/java\"\u003e \u003c!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --\u003e \u003cproperty name=\"constructorBased\" value=\"false\" /\u003e \u003c!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --\u003e \u003cproperty name=\"immutable\" value=\"false\" /\u003e \u003c!-- 设置是否在getter方法中，对String类型字段调用trim()方法 \u003cproperty name=\"trimStrings\" value=\"true\" /\u003e --\u003e \u003c/javaModelGenerator\u003e \u003c!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --\u003e \u003csqlMapGenerator targetPackage=\"cn.wolfcode.wolfcar.mapper\" targetProject=\"src/main/resources\"\u003e \u003c!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/sqlMapGenerator\u003e \u003c!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --\u003e \u003cjavaClientGenerator targetPackage=\"cn.wolfcode.wolfcar.mapper\" type=\"XMLMAPPER\" targetProject=\"src/main/java\"\u003e \u003c!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 \u003cproperty name=\"rootInterface\" value=\"\"/\u003e --\u003e \u003c/javaClientGenerator\u003e \u003ctable tableName=\"consumption_item\"\u003e \u003cproperty name=\"useActualColumnNames\" value=\"true\"/\u003e \u003cproperty name=\"constructorBased\" value=\"false\" /\u003e \u003cgeneratedKey column=\"id\" sqlStatement=\"JDBC\" /\u003e \u003c/table\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:1:7","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"分解 ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:0","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"一.FreeMarker pom \u003c!-- 将freemarker等第三方库整合进Spring应用上下文的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context-support\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- freemaker--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.freemarker\u003c/groupId\u003e \u003cartifactId\u003efreemarker\u003c/artifactId\u003e \u003cversion\u003e2.3.30\u003c/version\u003e \u003c/dependency\u003e mvc配置视图解析器 \u003c!-- 注册 FreeMarker 配置类 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\"\u003e \u003c!-- 配置 FreeMarker 的文件编码 --\u003e \u003cproperty name=\"defaultEncoding\" value=\"UTF-8\" /\u003e \u003c!-- 配置 FreeMarker 寻找模板的路径 --\u003e \u003cproperty name=\"templateLoaderPath\" value=\"/WEB-INF/views/\" /\u003e \u003cproperty name=\"freemarkerSettings\"\u003e \u003cprops\u003e \u003c!-- 兼容模式 ，配了后不需要另外处理空值问题，时间格式除外 --\u003e \u003cprop key=\"classic_compatible\"\u003etrue\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 注册 FreeMarker 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"\u003e \u003c!-- 是否把session中的attribute复制到模板的属性集中，可以使用FreeMarker的表达式来访问并显示--\u003e \u003cproperty name=\"exposeSessionAttributes\" value=\"true\" /\u003e \u003c!-- 配置逻辑视图自动添加的后缀名 --\u003e \u003cproperty name=\"suffix\" value=\".ftl\" /\u003e \u003c!-- 配置响应头中 Content-Type 的指 --\u003e \u003cproperty name=\"contentType\" value=\"text/html;charset=UTF-8\" /\u003e \u003c/bean\u003e 添加配置 例如配置shiro标签 配置类 package cn.wolfcode.wolfcar.config; import com.jagregory.shiro.freemarker.ShiroTags; import freemarker.template.Configuration; import freemarker.template.TemplateException; import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer; import java.io.IOException; public class MyFreemarkerConfiger extends FreeMarkerConfigurer { @Override public void afterPropertiesSet() throws IOException, TemplateException { //继承之前的属性配置，这步不能省 super.afterPropertiesSet(); Configuration cfg = this.getConfiguration(); cfg.setSharedVariable(\"shiro\", new ShiroTags());//注册shiro 标签 } } mvc视图解析器修改 \u003c!-- 注册 FreeMarker 配置类 --\u003e \u003cbean class=\"cn.wolfcode.wolfcar.config.MyFreemarkerConfiger\"\u003e \u003c!-- 配置 FreeMarker 的文件编码 --\u003e \u003cproperty name=\"defaultEncoding\" value=\"UTF-8\" /\u003e \u003c!-- 配置 FreeMarker 寻找模板的路径 --\u003e \u003cproperty name=\"templateLoaderPath\" value=\"/WEB-INF/views/\" /\u003e \u003cproperty name=\"freemarkerSettings\"\u003e \u003cprops\u003e \u003c!-- 兼容模式 ，配了后不需要另外处理空值问题，时间格式除外 --\u003e \u003cprop key=\"classic_compatible\"\u003etrue\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e 常用标签 判空：全扩起来加！ 例如：value=\"${(qo.startDate?string(‘yyyy-MM-dd’))!}\" 指令：其实就是指 ftl 的标签，这些标签一般以符号#开头 include指令 在当前模板文件中引入另一个模板文件 \u003c!--freemarker引入模板文件 之前已经配置了模板路径为/WEB-INF/views/ 这里就不需要写了 --\u003e \u003c#include \"/common/link.ftl\" \u003e assign指令 使用该指令可以在当前模板中创建一个新的变量， 或者替换一个已经存在的变量 创建变量 currentMenu并赋值： \u003c#assign currentMenu=\"department\"/\u003e 可使用${}获取该变量 ${currentMenu} list指令 用于循环遍历序列 \u003c#list pageInfo.list as department\u003e \u003ctr\u003e \u003ctd\u003e${department_index+1}\u003c/td\u003e \u003ctd\u003e${department.name}\u003c/td\u003e \u003ctd\u003e${department.sn}\u003c/td\u003e \u003c/tr\u003e \u003c#/list\u003e 注释：FreeMarker的注释和 HTML 的注释相似，但是它用\u003c#–和–\u003e来分隔的。任何介于这两个分隔符（包含分隔符本身）之间内容会被 FreeMarker 忽略，不会显示到页面，一般用来注释有freemarker指令相关的代码。 \u003c#-- \u003ctd\u003e${department.name}\u003c/td\u003e --\u003e if指令 用于条件判断 \u003c#if condition\u003e ... \u003c#elseif condition2\u003e ... \u003c#elseif condition3\u003e ... \u003c#else\u003e ... \u003c/#if\u003e condition : 将被计算成布尔值的表达式 elseif 和 else 是可选的 ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:1","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"二.分页插件 前端 \u003cdiv style=\"text-align: center;\"\u003e \u003cul id=\"pagination\" class=\"pagination\"\u003e\u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e //分页 $(function(){ $(\"#pagination\").twbsPagination({ totalPages: ${result.pages} || 1, startPage: ${result.pageNum} || 1, visiblePages:5, first:\"首页\", prev:\"上页\", next:\"下页\", last:\"尾页\", initiateStartPageClick:false, onPageClick:function(event,page){ $(\"#currentPage\").val(page); $(\"#searchForm\").submit(); } }); }) \u003c/script\u003e 后端 pom \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper\u003c/artifactId\u003e \u003cversion\u003e5.1.2\u003c/version\u003e \u003c/dependency\u003e xml配置 \u003c!-- 数据库链接 --\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003c!-- 将pageHelper配置到sqlsessionfactory --\u003e \u003cproperty name=\"plugins\"\u003e \u003carray\u003e \u003cbean class=\"com.github.pagehelper.PageInterceptor\"\u003e \u003cproperty name=\"properties\"\u003e \u003c!--使用下面的方式配置参数，一行配置一个，下面配的是合理化分页 --\u003e \u003cvalue\u003e reasonable=true \u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/array\u003e \u003c/property\u003e \u003c/bean\u003e 实现代码 package cn.wolfcode.wolfcar.query; import lombok.*; @Setter @Getter @NoArgsConstructor @AllArgsConstructor @ToString public class QueryObject { private int currentPage = 1; private int pageSize = 10; } public PageInfo\u003cDepartment\u003e query(QueryObject qo) { //使用分页插件,传入当前页,每页显示数量 PageHelper.startPage(qo.getCurrentPage(), qo.getPageSize()); List\u003cDepartment\u003e departments = departmentMapper.selectForList(qo); return new PageInfo(departments); } ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:2","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"三.Bootstrap 模态框 代码去https://v5.bootcss.com/ $('#模态框的id').modal('show'); //官方文档中表示通过该方法即可弹出模态框 //关闭模态框 $(\"#模态框的id\").modal(\"hide\"); ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:3","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"四.sweetalert2 弹出框插件 引入插件 \u003clink rel=\"stylesheet\" href=\"/js/plugins/sweetalert2/sweetalert2.min.css\"\u003e \u003cscript src=\"/js/plugins/sweetalert2/sweetalert2.min.js\"\u003e\u003c/script\u003e 使用插件（如何配置看官方文档） $(function(){ Swal.fire({ title: 'Are you sure?', text: \"You won't be able to revert this!\", icon: 'warning', showCancelButton: true, confirmButtonColor: '#3085d6', cancelButtonColor: '#d33', confirmButtonText: 'Yes, delete it!' }).then((result) =\u003e { if (result.value) { //点击确认按钮后做的事情 Swal.fire( 'Deleted!', 'Yrour file has been deleted.', 'success' ) } }) }) ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:4","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"五.表单验证插件 引入插件 \u003c!--引入验证插件的样式文件--\u003e \u003clink rel=\"stylesheet\" href=\"/js/plugins/bootstrap-validator/css/bootstrapValidator.min.css\"/\u003e \u003c!--引入验证插件的js文件--\u003e \u003cscript type=\"text/javascript\" src=\"/js/plugins/bootstrap-validator/js/bootstrapValidator.min.js\"\u003e\u003c/script\u003e \u003c!--中文语言库--\u003e \u003cscript type=\"text/javascript\" src=\"/js/plugins/bootstrap-validator/js/language/zh_CN.js\"\u003e\u003c/script\u003e 使用插件 $(\"#editForm\").bootstrapValidator({ feedbackIcons: { //图标 valid: 'glyphicon glyphicon-ok', invalid: 'glyphicon glyphicon-remove', validating: 'glyphicon glyphicon-refresh' }, fields:{ //配置要验证的字段 username:{ validators:{ //验证的规则 notEmpty:{ //不能为空 message:\"用户名必填\" //错误时的提示信息 }, stringLength: { //字符串的长度范围 min: 1, max: 5 } } }, password:{ validators:{ notEmpty:{ //不能为空 message:\"密码必填\" //错误时的提示信息 }, } }, repassword:{ validators:{ notEmpty:{ //不能为空 message:\"密码必填\" //错误时的提示信息 }, identical: {//两个字段的值必须相同 field: 'password', message: '两次输入的密码必须相同' }, } }, email: { validators: { emailAddress: {} //邮箱格式 } }, age:{ validators: { between: { //数字的范围 min: 18, max: 60 } } } } }).on('success.form.bv', function() { //表单所有数据验证通过后执行里面的代码 //提交异步表单 $(\"#editForm\").ajaxSubmit(function() { }) }); ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:5","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"六.POI操作excel poi中关于excel的概念 Workbook（对应为一个excel） Sheet（excel中的表） Row（表中的行） Column（表中的列） Cell（表中的单元格，由行号和列号组成） pom \u003cdependency\u003e \u003cgroupId\u003eorg.apache.poi\u003c/groupId\u003e \u003cartifactId\u003epoi\u003c/artifactId\u003e \u003cversion\u003e4.1.2\u003c/version\u003e \u003c/dependency\u003e controller //导出 @RequestMapping(\"/exportXls\") public void exportXls(HttpServletResponse response) throws Exception { //文件下载的响应头（让浏览器访问资源的的时候以下载的方式打开） response.setHeader(\"Content-Disposition\",\"attachment;filename=employee.xls\"); //创建excel文件 Workbook wb = employeeService.exportXls(); //把excel的数据输出给浏览器 wb.write(response.getOutputStream()); } //导入 @RequestMapping(\"/importXls\") @ResponseBody public JsonResult importXls(MultipartFile file) throws Exception { employeeService.importXls(file); return new JsonResult(); } service //导出 public Workbook exportXls() { //创建excel文件 Workbook wb = new HSSFWorkbook(); //创建sheet Sheet sheet = wb.createSheet(\"员工名单\"); //标题行 Row row = sheet.createRow(0); //设置内容到单元格中 row.createCell(0).setCellValue(\"姓名\"); row.createCell(1).setCellValue(\"邮箱\"); row.createCell(2).setCellValue(\"年龄\"); //查询员工数据 List\u003cEmployee\u003e employees = employeeMapper.selectAll(); for (int i = 0; i \u003c employees.size(); i++) { Employee employee = employees.get(i); //创建行(每个员工就是一行) row = sheet.createRow(i+1); //设置内容到单元格中 row.createCell(0).setCellValue(employee.getName()); row.createCell(1).setCellValue(employee.getEmail()); row.createCell(2).setCellValue(employee.getAge()); } return wb; } //导入 public void importXls(MultipartFile file) throws Exception { //把接收到的文件以excel的方式去读取并操作 Workbook wb = new HSSFWorkbook(file.getInputStream()); //读取第一页 Sheet sheet = wb.getSheetAt(0); //获取最后一行的索引 int lastRowNum = sheet.getLastRowNum(); //从索引为1的行数开始读(忽略标题行) for (int i = 1; i \u003c= lastRowNum; i++) { //获取行数据 Row row = sheet.getRow(i); String name = row.getCell(0).getStringCellValue(); //判断如果用户名是空，就不再往下读 if(!StringUtils.hasLength(name.trim())){ return; } Employee employee = new Employee(); employee.setName(name); employee.setEmail(row.getCell(1).getStringCellValue()); if(cell.getCellType() == CellType.NUMERIC){ //获取数值类型的单元格内容 double cellValue = row.getCell(2).getNumericCellValue(); employee.setAge((int)cellValue); }else{ //获取文本格式的单元格内容 String age = row.getCell(2).getStringCellValue(); employee.setAge(Integer.valueOf(age)); } //设置默认密码1 employee.setPassword(\"1\"); //调用保存方法 this.save(employee,null); } } ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:6","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"七.统一异常处理 @ControllerAdvice @ExceptionHandler(Exception.class) 异常处理的类必须加到ioc容器中 package cn.wolfcode.wolfcar.advice; import cn.wolfcode.wolfcar.result.JSonResult; import com.alibaba.fastjson.JSON; import org.apache.shiro.authc.IncorrectCredentialsException; import org.apache.shiro.authc.UnknownAccountException; import org.apache.shiro.authz.AuthorizationException; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.method.HandlerMethod; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @ControllerAdvice public class MyControllerAdvice { @ExceptionHandler(AuthorizationException.class) public String func(AuthorizationException e, HttpServletResponse response, HandlerMethod handlerMethod) throws IOException { e.printStackTrace();; ResponseBody methodAnnotation = handlerMethod.getMethodAnnotation(ResponseBody.class); if (methodAnnotation == null) { return \"common/nopermission\"; } else { response.setContentType(\"application/json;charset=utf-8\"); JSonResult jSonResult = JSonResult.error(\"没有权限\"); response.getWriter().write(JSON.toJSONString(jSonResult)); return null; } } @ExceptionHandler(UnknownAccountException.class) public String unknownAccountExceptionHandler(AuthorizationException e, HttpServletResponse resp) throws IOException { e.printStackTrace(); resp.setContentType(\"application/json;charset=utf-8\"); JSonResult jsonreslut = JSonResult.error(\"无此用户\"); resp.getWriter().write(JSON.toJSONString(jsonreslut)); return null; } @ExceptionHandler(IncorrectCredentialsException.class) public String incorrectCredentialsExceptionHandler(AuthorizationException e, HttpServletResponse resp) throws IOException { e.printStackTrace(); resp.setContentType(\"application/json;charset=utf-8\"); JSonResult jsonreslut = JSonResult.error(\"密码错误\"); resp.getWriter().write(JSON.toJSONString(jsonreslut)); return null; } @ExceptionHandler(Exception.class) public String exceptionHandler(AuthorizationException e, HttpServletResponse resp, HandlerMethod handlerMethod) throws IOException { e.printStackTrace(); ResponseBody ann = handlerMethod.getMethodAnnotation(ResponseBody.class); if(ann == null){ return \"common/error\"; }else{ resp.setContentType(\"application/json;charset=utf-8\"); JSonResult jsonreslut = JSonResult.error(\"系统错误，请联系管理员\"); resp.getWriter().write(JSON.toJSONString(jsonreslut)); return null; } } } ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:7","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"八.shiro ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:8","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":" Subject（用户）： 访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体； Subject 一词是一个专业术语，其基本意思是“当前的操作用户”。 在程序任意位置可使用：Subject currentUser = SecurityUtils.getSubject() 获取到subject主体对象，类似 Employee user = UserContext.getUser() SecurityManager（安全管理器）：它是 shiro 功能实现的核心，负责与后边介绍的其他组件(认证器/授权器/缓存控制器)进行交互，实现 subject 委托的各种功能。有点类似于SpringMVC 中的 DispatcherServlet 前端控制器，负责进行分发调度。 Realms（数据源）： Realm 充当了 Shiro 与应用安全数据间的“桥梁”或者“连接器”。；可以把Realm 看成 DataSource，即安全数据源。执行认证（登录）和授权（访问控制）时，Shiro 会从应用配置的 Realm 中查找相关的比对数据。以确认用户是否合法，操作是否合理。 Authenticator（认证器）： 用于认证，从 Realm 数据源取得数据之后进行执行认证流程处理。 Authorizer（授权器）：用户访问控制授权，决定用户是否拥有执行指定操作的权限。 SessionManager （会话管理器）：Shiro 与生俱来就支持会话管理，这在安全类框架中都是独一无二的功能。即便不存在 web 容器环境，shiro 都可以使用自己的会话管理机制，提供相同的会话 API。 CacheManager （缓存管理器）：用于缓存认证授权信息等。 Cryptography（加密组件）： Shiro 提供了一个用于加密解密的工具包。 认证-授权 在RBAC基础上 用户（Employee）：角色施加的主体；用户通过拥有某个或多个角色以得到对应的权限。 角色（Role）：表示一组权限的集合。 权限（Permission）：一个资源代表一个权限，是否能访问该资源，就是看是否有该权限。 pom \u003cproperties\u003e \u003cshiro.version\u003e1.5.2\u003c/shiro.version\u003e \u003c/properties\u003e \u003c!--shiro 核心--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-core\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 的 Web 模块--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-web\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 和 Spring 集成--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-spring\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 底层使用的 ehcache 缓存--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-ehcache\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 依赖的日志包--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-logging\u003c/groupId\u003e \u003cartifactId\u003ecommons-logging\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 依赖的工具包--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e \u003c!--Freemarker 的 shiro 标签库--\u003e \u003cdependency\u003e \u003cgroupId\u003enet.mingsoft\u003c/groupId\u003e \u003cartifactId\u003eshiro-freemarker-tags\u003c/artifactId\u003e \u003cversion\u003e1.0.1\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-all\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 配置 代理过滤器 因为真正的shiroFilter需要注入很多复杂的对象，而web.xml中只能配置字符串或数字的参数，是不能满足的，因此我们会把shiroFilter交给 Spring 进行管理，通过spring的xml文件来配置。 \u003cfilter\u003e \u003cfilter-name\u003eshiroFilter\u003c/filter-name\u003e \u003cfilter-class\u003e org.springframework.web.filter.DelegatingFilterProxy \u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eshiroFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e 编写单独的shiro配置 shiro.xml 并在 mvc.xml中引入 shiro.xml anon: 匿名过滤器，即不需要登录即可访问；一般用于静态资源过滤； 示例 /static/**=anon authc: 表示需要认证(登录)才能使用; 示例 /**=authc ***roles:***角色授权过滤器，验证用户是否拥有资源角色； 示例 /admin/*=roles[admin] ***perms:***权限授权过滤器，验证用户是否拥有资源权限； 示例 /employee/input=perms[“user:update”] ***logout:***注销过滤器 示例 /logout=logout \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.realm\"\u003e\u003c/context:component-scan\u003e \u003c!-- aop自动代理 --\u003e \u003cbean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\" depends-on=\"lifecycleBeanPostProcessor\" /\u003e \u003c!-- 管理shiro生命周期 --\u003e \u003cbean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"\u003e\u003c/bean\u003e \u003c!-- 安全管理器 --\u003e \u003cbean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"\u003e \u003cproperty name=\"securityManager\" ref=\"securityManager\"/\u003e \u003c/bean\u003e \u003cbean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"\u003e \u003c!--引用指定的安全管理器--\u003e \u003cproperty name=\"securityManager\" ref=\"security","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:9","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"九.文件上传下载commons-fileupload 准备 添加文件上传依赖 \u003c!--fileupload--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-fileupload\u003c/groupId\u003e \u003cartifactId\u003ecommons-fileupload\u003c/artifactId\u003e \u003cversion\u003e1.3.1\u003c/version\u003e \u003c/dependency\u003e 添加文件上传解析器 \u003c!--文件上传解析器 id必须是multipartResolver--\u003e \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e \u003c!--最大上传文件大小 10M--\u003e \u003cproperty name=\"maxUploadSize\" value=\"#{1024*1024*10}\"/\u003e \u003c/bean\u003e 上传 @RequestMapping(\"/saveOrUpdate\") public String saveOrUpdate(MultipartFile file, Business business, HttpServletRequest request) throws IOException, IllegalAccessException { //判断有无上传文件 if (file.getSize() != 0) { //删除旧文件 if (business.getId() != null) { String license_img = business.getLicense_img(); //获取当前项目路径 String realPath = request.getServletContext().getRealPath(\"/\"); File oldFile = new File(realPath+license_img); oldFile.delete(); } //处理图片名称 String originalFilename = file.getOriginalFilename(); String date = DateUtil.format(new Date(), \"yyyyMMddHHmmss\"); String s1 = RandomUtil.randomNumbers(5); String[] split = originalFilename.split(\"\\\\.\"); String s = split[split.length-1]; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(date); stringBuffer.append(s1); stringBuffer.append(\".\"); stringBuffer.append(s); String filename = stringBuffer.toString(); //处理地址 String realPath = request.getServletContext().getRealPath(\"/img/\"); //建立文件 File file1 = new File(realPath,filename); //文件传输 FileOutputStream fileOutputStream = new FileOutputStream(file1); InputStream inputStream = file.getInputStream(); byte[] bytes = new byte[100]; int len = 0; while ((len = inputStream.read(bytes)) != -1) { fileOutputStream.write(bytes,0,len); } fileOutputStream.close(); //存储 business.setLicense_img(\"/img/\"+filename); } //处理乱码问题 CharaUtil.convert(business,Business.class); if (business.getId() == null) { BusinessService.insert(business); } else { BusinessService.updateByPrimaryKey(business); } return \"redirect:/business/list\"; } 下载 @RequestMapping(value = \"/download\") public void download(HttpServletRequest request, HttpServletResponse response)throws IOException { //模拟文件，myfile.txt为需要下载的文件 String filename = \"aaa\"; String path = \"D:\\\\file\" + \"\\\\\" + filename; //获取输入流 InputStream bis = new BufferedInputStream(new FileInputStream(newFile(path))); //转码，免得文件名中文乱码 filename = URLEncoder.encode(filename, \"UTF-8\");//设置文件下载头 response.addHeader(\"Content-Disposition\", \"attachment;filename=\" + filename); //1.设置文件ContentType类型，这样设置，会自动判断下载文件类型 response.setContentType(\"multipart/form-data\"); BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream()); int len = 0; while ((len = bis.read()) != -1) { out.write(len); out.flush(); } out.close(); } ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:10","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"十.统一返回JSON @Setter @Getter public class JSonResult\u003cT\u003e { private int code; private String msg; private boolean success; private T data; public static \u003cT\u003e JSonResult success(T data) { JSonResult jSonResult = new JSonResult(); jSonResult.setSuccess(true); jSonResult.setData(data); return jSonResult; } public static \u003cT\u003e JSonResult error(String msg){ JSonResult jsonResult = new JSonResult(); jsonResult.setSuccess(false); jsonResult.setMsg(msg); return jsonResult; } } ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:11","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"十一.枚举解决状态问题 枚举类 public enum AppointmentStatusEnum { PEND(0,\"待确认\"), PERFORM(1,\"履行中\"), CONSUME(2,\"消费中\"), FINISH(3,\"归档\"), FAILURE(4,\"废弃\"); private String name; private Integer value; AppointmentStatusEnum(Integer value,String name) { this.value = value; this.name =name; } public static String getName(Integer value) { AppointmentStatusEnum[] valus = values(); for (AppointmentStatusEnum appointmentStatusEnum : valus) { if (appointmentStatusEnum.value.equals(value)) { return appointmentStatusEnum.name; } } return null; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getValue() { return value; } public void setValue(Integer value) { this.value = value; } } 使用 实体类使用 public String getStatusName() { String name = AppointmentStatusEnum.getName(this.status); return name; } 获取所有值 AppointmentStatusEnum[] values = AppointmentStatusEnum.values(); model.addAttribute(\"statuses\", values); ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:12","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["Spring"],"content":"十二.json转换问题 工具类(自写)反射 package cn.wolfcode.wolfcar.util; import cn.hutool.core.date.DateUtil; import com.alibaba.fastjson.JSON; import java.lang.reflect.Field; import java.util.Date; import java.util.HashMap; import java.util.Map; public class JsonUtil { public static String Convert(Object obj,Class clzz) throws IllegalAccessException { Map\u003cString,Object\u003e map = new HashMap\u003c\u003e(); Field[] fields = clzz.getDeclaredFields(); for (Field field:fields) { field.setAccessible(true); Object o = field.get(obj); map.put(field.getName(),o); } return JSON.toJSONString(map); } public static String Convert(Object obj, Class clzz, String format) throws IllegalAccessException { Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(); Field[] fields = clzz.getDeclaredFields(); for (Field field : fields) { field.setAccessible(true); if(field.getType().equals(Date.class)){ String sdate = DateUtil.format((Date) field.get(obj), format); map.put(field.getName(), sdate); } else map.put(field.getName(), field.get(obj)); } return JSON.toJSONString(map); } } 实体类使用 package cn.wolfcode.wolfcar.domain; import cn.wolfcode.wolfcar.myenum.AppointmentStatusEnum; import cn.wolfcode.wolfcar.util.JsonUtil; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.format.annotation.DateTimeFormat; import java.util.Date; @Data @AllArgsConstructor @NoArgsConstructor public class Appointment { private Long id; private String ano; private Integer status; // private Long category_id; private SystemDictionaryItem category; private String info; private String contact_tel; private String contact_name; // private Long business_id; private Business business; private Date create_time; @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm\") private Date appointment_time; public String getStatusName() { String name = AppointmentStatusEnum.getName(this.status); return name; } public String getJson() throws IllegalAccessException { return JsonUtil.Convert(this,Appointment.class,\"yyyy-MM-dd HH:mm\"); } } 前端使用 \u003ca href=\"javascript:void(0);\" data-json='${tmp.json}' class=\"btn btn-info btn-xs btn-input btnedit\" \u003e \u003cspan class=\"glyphicon glyphicon-pencil\"\u003e\u003c/span\u003e 编辑 \u003c/a\u003e $(\".btnedit\").click(function (){ var json = $(this).data(\"json\"); $(\"#business\").val(json.business.id); $(\"input[name=appointment_time]\").val(json.appointment_time); $(\"#category\").val(json.category.id); $(\"input[id=contact_name]\").val(json.contact_name); $(\"input[id=contact_tel]\").val(json.contact_tel); $(\"textarea[name=info]\").html(json.info); $(\"input[name=id]\").val(json.id); $(\"#editModal\").modal(\"show\"); }); ","date":"2021-07-26","objectID":"/ssm%E7%9B%B8%E5%85%B3/:2:13","tags":["框架","整理"],"title":"SSM相关","uri":"/ssm%E7%9B%B8%E5%85%B3/"},{"categories":["前端"],"content":"JQuery常见问题 ","date":"2021-07-24","objectID":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":["JQuery"],"title":"JQuery常见问题","uri":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["前端"],"content":"选择 select 框中选中的项 $(\"#categoryItem option:selected\") \u003cselect class=\"form-control\" id=\"payType\" name=\"payType.id\"\u003e \u003coption value=\"\"\u003e请选择结算类型\u003c/option\u003e \u003c#list zhifuleixing as tmp\u003e \u003coption value=\"${tmp.id}\"\u003e${tmp.title}\u003c/option\u003e \u003c/#list\u003e \u003c/select\u003e \u003c#-- select选择狂数据回显 --\u003e \u003cscript\u003e $(\"select[name='business.id']\").val(${consumption.business.id}) \u003c/script\u003e \u003cscript\u003e var categoryItem_val = $(\"#categoryItem option:selected\").val(); \u003c/script\u003e ","date":"2021-07-24","objectID":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:1","tags":["JQuery"],"title":"JQuery常见问题","uri":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["前端"],"content":"选择列表前面 选中的项 $(\".itemdeletecbclass:checked\") \u003cdiv class=\"table-responsive mailbox-messages\"\u003e \u003ctable class=\"table table-hover table-striped\"\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e\u003cinput type=\"checkbox\"\u003e\u003c/th\u003e \u003cth\u003e业务大类\u003c/th\u003e \u003cth\u003e业务小类\u003c/th\u003e \u003cth\u003e结算类型\u003c/th\u003e \u003cth\u003e消费金额(元)\u003c/th\u003e \u003cth\u003e优惠金额(元)\u003c/th\u003e \u003cth\u003e实收金额(元)\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody id=\"titembody\"\u003e \u003c#-- \u003ctr\u003e--\u003e \u003c#-- \u003ctd\u003e\u003cinput class='itemdeletecbclass' type=\"checkbox\"\u003e\u003c/td\u003e--\u003e \u003c#-- \u003ctd\u003e售卖\u003c/td\u003e--\u003e \u003c#-- \u003ctd\u003e二手车\u003c/td\u003e--\u003e \u003c#-- \u003ctd\u003e服务费\u003c/td\u003e--\u003e \u003c#-- \u003ctd\u003e5,480.00\u003c/td\u003e--\u003e \u003c#-- \u003ctd\u003e159.86\u003c/td\u003e--\u003e \u003c#-- \u003ctd\u003e5,320.14\u003c/td\u003e--\u003e \u003c#-- \u003c/tr\u003e--\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e总消费金额:\u003cspan id=\"amountspan\"\u003e0\u003c/span\u003e元\u003c/th\u003e \u003cth\u003e总优惠金额:\u003cspan id=\"disaccountamountspan\"\u003e0\u003c/span\u003e元\u003c/th\u003e \u003cth\u003e总实收金额:\u003cspan id=\"abc\"\u003e0\u003c/span\u003e元\u003c/th\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e \u003c/div\u003e \u003cscript\u003e $(\".itemdeletecbclass:checked\").parent().parent().remove(); \u003c/script\u003e ","date":"2021-07-24","objectID":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:2","tags":["JQuery"],"title":"JQuery常见问题","uri":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["前端"],"content":"将字符串转换为JSON对象 JSON.parse('${groupItemListJSON}') ","date":"2021-07-24","objectID":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:3","tags":["JQuery"],"title":"JQuery常见问题","uri":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["前端"],"content":"从一个select移到另一个select（相互移动） \u003cscript\u003e function moveSelected(src, dest){ $(\".\"+dest).append( $(\".\"+src+\"\u003eoption:selected\")); } function moveAll(src, dest){ $(\".\"+dest).append( $(\".\"+src+\"\u003eoption\")); } \u003c/script\u003e \u003cselect multiple class=\"form-control allPermissions\" size=\"15\"\u003e \u003c#list permissions as itm\u003e \u003coption value=\"${itm.id}\"\u003e${itm.name}\u003c/option\u003e \u003c/#list\u003e \u003c/select\u003e \u003cdiv class=\"col-sm-1\" style=\"margin-top: 60px;\" align=\"center\"\u003e \u003cdiv\u003e \u003ca type=\"button\" class=\"btn btn-primary\" style=\"margin-top: 10px\" title=\"右移动\" onclick=\"moveSelected('allPermissions', 'selfPermissions')\"\u003e \u003cspan class=\"glyphicon glyphicon-menu-right\"\u003e\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e \u003cdiv\u003e \u003ca type=\"button\" class=\"btn btn-primary \" style=\"margin-top: 10px\" title=\"左移动\" onclick=\"moveSelected('selfPermissions', 'allPermissions')\"\u003e \u003cspan class=\"glyphicon glyphicon-menu-left\"\u003e\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e \u003cdiv\u003e \u003ca type=\"button\" class=\"btn btn-primary \" style=\"margin-top: 10px\" title=\"全右移动\" onclick=\"moveAll('allPermissions', 'selfPermissions')\"\u003e \u003cspan class=\"glyphicon glyphicon-forward\"\u003e\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e \u003cdiv\u003e \u003ca type=\"button\" class=\"btn btn-primary \" style=\"margin-top: 10px\" title=\"全左移动\" onclick=\"moveAll('selfPermissions', 'allPermissions')\"\u003e \u003cspan class=\"glyphicon glyphicon-backward\"\u003e\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003cselect multiple class=\"form-control selfPermissions\" size=\"15\" name=\"ids\"\u003e \u003c#list permissions1 as itm\u003e \u003coption value=\"${itm.id}\"\u003e${itm.name}\u003c/option\u003e \u003c/#list\u003e \u003c/select\u003e 去重 var $options = $(\".selfPermissions\u003eoption\"); var arr= []; $options.each(function (i,that) { arr.push($(that).val()); }) $(\".allPermissions\u003eoption\").each(function (i,that) { if (arr.indexOf($(that).val())\u003e=0) { $(that).remove(); } }) }) ","date":"2021-07-24","objectID":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:4","tags":["JQuery"],"title":"JQuery常见问题","uri":"/jquery%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["SpringCloud"],"content":"springcloud2020 seata Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。 多数据库事务 分布式事务处理过程的一ID+三组件模型： Transaction ID XID 全局唯一的事务ID 三组件概念 TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。 TM (Transaction Manager) - 事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。 RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。 ","date":"2021-05-29","objectID":"/springcloud2020-seata/:0:0","tags":["微服务","框架"],"title":"springcloud2020 seata","uri":"/springcloud2020-seata/"},{"categories":["SpringCloud"],"content":"安装配置1.4 下载https://github.com/seata/seata/releases ","date":"2021-05-29","objectID":"/springcloud2020-seata/:1:0","tags":["微服务","框架"],"title":"springcloud2020 seata","uri":"/springcloud2020-seata/"},{"categories":["SpringCloud"],"content":"服务安装 registry.conf修改注册中心和配置中心为nacos registry { # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = \"nacos\" nacos { application = \"seata-server\" serverAddr = \"127.0.0.1:8848\" group = \"SEATA_GROUP\" namespace = \"\" cluster = \"default\" username = \"nacos\" password = \"nacos\" } } config { # file、nacos 、apollo、zk、consul、etcd3 type = \"nacos\" nacos { serverAddr = \"127.0.0.1:8848\" namespace = \"\" group = \"SEATA_GROUP\" username = \"nacos\" password = \"nacos\" dataId = \"seataServer.properties\" } } file.conf修改 store { ## store mode: file、db、redis mode = \"db\" ## database store property db { ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp)/HikariDataSource(hikari) etc. datasource = \"druid\" ## mysql/oracle/postgresql/h2/oceanbase etc. dbType = \"mysql\" driverClassName = \"com.mysql.cj.jdbc.Driver\" url = \"jdbc:mysql://127.0.0.1:3307/seata?serverTimezone=Asia/Shanghai\u0026useUnicode=true\u0026characterEncoding=utf8\u0026useSSL=true\" user = \"root\" password = \"123456\" minConn = 5 maxConn = 100 globalTable = \"global_table\" branchTable = \"branch_table\" lockTable = \"lock_table\" queryLimit = 100 maxWait = 5000 } } 创建数据库seata CREATE TABLE IF NOT EXISTS `global_table` ( `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `status` TINYINT NOT NULL, `application_id` VARCHAR(32), `transaction_service_group` VARCHAR(32), `transaction_name` VARCHAR(128), `timeout` INT, `begin_time` BIGINT, `application_data` VARCHAR(2000), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`xid`), KEY `idx_gmt_modified_status` (`gmt_modified`, `status`), KEY `idx_transaction_id` (`transaction_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; -- the table to store BranchSession data CREATE TABLE IF NOT EXISTS `branch_table` ( `branch_id` BIGINT NOT NULL, `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `resource_group_id` VARCHAR(32), `resource_id` VARCHAR(256), `branch_type` VARCHAR(8), `status` TINYINT, `client_id` VARCHAR(64), `application_data` VARCHAR(2000), `gmt_create` DATETIME(6), `gmt_modified` DATETIME(6), PRIMARY KEY (`branch_id`), KEY `idx_xid` (`xid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; -- the table to store lock data CREATE TABLE IF NOT EXISTS `lock_table` ( `row_key` VARCHAR(128) NOT NULL, `xid` VARCHAR(128), `transaction_id` BIGINT, `branch_id` BIGINT NOT NULL, `resource_id` VARCHAR(256), `table_name` VARCHAR(32), `pk` VARCHAR(36), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`row_key`), KEY `idx_branch_id` (`branch_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; 启动 nacos中查看服务是否注册成功 ","date":"2021-05-29","objectID":"/springcloud2020-seata/:1:1","tags":["微服务","框架"],"title":"springcloud2020 seata","uri":"/springcloud2020-seata/"},{"categories":["SpringCloud"],"content":"nacos配置 进入seata/conf目录下，创建一个nacos-config.sh文件： # touch nacos-config.sh 将https://github.com/seata/seata/blob/develop/script/config-center/nacos/nacos-config.sh的内容编辑进如nacos-config.sh 然后到seata目录创建config.txt，注意跟nacos-config.sh不在同一个目录 # touch config.txt 将如下内容写入： service.vgroupMapping.my_test_tx_group=default service.default.grouplist=127.0.0.1:8091 service.enableDegrade=false service.disableGlobalTransaction=false store.mode=db store.db.datasource=druid store.db.dbType=mysql store.db.driverClassName=com.mysql.cj.jdbc.Driver store.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true store.db.user=username store.db.password=password store.db.minConn=5 store.db.maxConn=30 store.db.globalTable=global_table store.db.branchTable=branch_table store.db.queryLimit=100 store.db.lockTable=lock_table store.db.maxWait=5000 最后再执行导入：seata/conf # sh nacos-config.sh 127.0.0.1 导入之后，可以在nacos看到配置信息 ","date":"2021-05-29","objectID":"/springcloud2020-seata/:1:2","tags":["微服务","框架"],"title":"springcloud2020 seata","uri":"/springcloud2020-seata/"},{"categories":["SpringCloud"],"content":"安装配置0.9 下载https://github.com/seata/seata/releases file.conf service模块 service { ##fsp_tx_group是自定义的 vgroup_mapping.my.test.tx_group=\"fsp_tx_group\" default.grouplist = \"127.0.0.1:8091\" enableDegrade = false disable = false max.commitretry.timeout= \"-1\" max.ollbackretry.timeout= \"-1\" } store模块 ## transaction log store store { ## store mode: file, db ## 改成db mode = \"db\" ## file store file { dir = \"sessionStore\" # branch session size, if exceeded first try compress lockkey, still exceeded throws exceptions max-branch-session-size = 16384 # globe session size, if exceeded throws exceptions max-global-session-size = 512 # file buffer size, if exceeded allocate new buffer file-write-buffer-cache-size = 16384 # when recover batch read size session.reload.read_size= 100 # async, sync flush-disk-mode = async } # database store db { ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = \"dbcp\" ## mysql/oracle/h2/oceanbase etc. ## 配置数据源 db-type = \"mysql\" driver-class-name = \"com.mysql.jdbc.Driver\" url = \"jdbc:mysql://127.0.0.1:3306/seata\" user = \"root\" password = \"你自己密码\" min-conn= 1 max-conn = 3 global.table = \"global_table\" branch.table = \"branch_table\" lock-table = \"lock_table\" query-limit = 100 } } mysql新建库seata（sql文件在下载包里） registry.conf registry { # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa # 改用为nacos type = \"nacos\" nacos { ## 加端口号 serverAddr = \"localhost:8848\" namespace = \"\" cluster = \"default\" } ... } ","date":"2021-05-29","objectID":"/springcloud2020-seata/:2:0","tags":["微服务","框架"],"title":"springcloud2020 seata","uri":"/springcloud2020-seata/"},{"categories":["SpringCloud"],"content":"编码 注意：file.conf ​ registry.conf ","date":"2021-05-29","objectID":"/springcloud2020-seata/:3:0","tags":["微服务","框架"],"title":"springcloud2020 seata","uri":"/springcloud2020-seata/"},{"categories":["SpringCloud"],"content":"使用 @GlobalTransactional(name = “fsp-create-order”,rollbackFor = Exception.class) package com.atguigu.springcloud.service.impl; import com.atguigu.springcloud.dao.OrderDao; import com.atguigu.springcloud.entity.Order; import com.atguigu.springcloud.service.AccountService; import com.atguigu.springcloud.service.OrderService; import com.atguigu.springcloud.service.StorageService; import io.seata.spring.annotation.GlobalTransactional; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; @Service @Slf4j public class OrderServiceImpl implements OrderService { @Resource private OrderDao orderDao; @Resource private StorageService storageService; @Resource private AccountService accountService; /** * 创建订单-\u003e调用库存服务扣减库存-\u003e调用账户服务扣减账户余额-\u003e修改订单状态 * 简单说：下订单-\u003e扣库存-\u003e减余额-\u003e改状态 */ @Override @GlobalTransactional(name = \"fsp-create-order\",rollbackFor = Exception.class) public void create(Order order) { log.info(\"-----\u003e开始新建订单\"); //1 新建订单 orderDao.create(order); //2 扣减库存 log.info(\"-----\u003e订单微服务开始调用库存，做扣减Count\"); storageService.decrease(order.getProductId(),order.getCount()); log.info(\"-----\u003e订单微服务开始调用库存，做扣减end\"); //3 扣减账户 log.info(\"-----\u003e订单微服务开始调用账户，做扣减Money\"); accountService.decrease(order.getUserId(),order.getMoney()); log.info(\"-----\u003e订单微服务开始调用账户，做扣减end\"); //4 修改订单状态，从零到1,1代表已经完成 log.info(\"-----\u003e修改订单状态开始\"); orderDao.update(order.getUserId(),0); log.info(\"-----\u003e修改订单状态结束\"); log.info(\"-----\u003e下订单结束了，O(∩_∩)O哈哈~\"); } } ​ ","date":"2021-05-29","objectID":"/springcloud2020-seata/:4:0","tags":["微服务","框架"],"title":"springcloud2020 seata","uri":"/springcloud2020-seata/"},{"categories":["SpringCloud"],"content":"未解决问题 1.4版本配置出错 ","date":"2021-05-29","objectID":"/springcloud2020-seata/:5:0","tags":["微服务","框架"],"title":"springcloud2020 seata","uri":"/springcloud2020-seata/"},{"categories":["SpringCloud"],"content":"springcloud2020 Sentinel Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:0:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"安装运行 服务使用中的各种问题： 服务雪崩 服务降级 服务熔断 服务限流 Sentinel 分为两个部分： 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。 安装步骤： 下载 https://github.com/alibaba/Sentinel/releases 下载jar包直接运行 命令 前提 java8环境 8080端口不能被占用 命令 java -jar sentinel-dashboard-版本.jar 访问Sentinel管理界面 localhost:8080 登录账号密码均为sentinel ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:1:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel初始化监控 新建cloudalibaba-sentinel-service8401 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloudalibaba-sentinel-service8401\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.csp\u003c/groupId\u003e \u003cartifactId\u003esentinel-datasource-nacos\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--SpringCloud ailibaba sentinel --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-sentinel\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--openfeign--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件+actuator --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.hutool\u003c/groupId\u003e \u003cartifactId\u003ehutool-all\u003c/artifactId\u003e \u003cversion\u003e4.6.3\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 8401 spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 sentinel: transport: dashboard: localhost:8080 #配置Sentinel dashboard地址 port: 8719 management: endpoints: web: exposure: include: '*' feign: sentinel: enabled: true # 激活Sentinel对Feign的支持 主启动 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient @SpringBootApplication public class MainApp8401 { public static void main(String[] args) { SpringApplication.run(MainApp8401.class, args); } } 业务类FlowLimitController package com.atguigu.springcloud.controller; import com.alibaba.csp.sentinel.annotation.SentinelResource; import com.alibaba.csp.sentinel.slots.block.BlockException; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.util.concurrent.TimeUnit; @RestController @Slf4j public class FlowLimitController { @GetMapping(\"/testA\") public String testA() { return \"------testA\"; } @GetMapping(\"/testB\") public String testB() { log.info(Thread.currentThread().getName()+\"\\t\"+\"...testB\"); return \"------testB\"; } } 启动nacos 启动Sentinel8080java -jar sentinel-dashboard-1.7.0.jar 启动微服务8401 查看sentienl控制台 刚启动，空空如也，啥都没有 Sentinel采用的懒加载说明 执行一次访问即可 http://localhost:8401/testA http://localhost:8401/testB 效果 - sentinel8080正在监控微服务8401 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:2:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel流控规则简介 资源名：唯一名称，默认请求路径。 针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。 阈值类型/单机阈值： QPS(每秒钟的请求数量)︰当调用该API的QPS达到阈值的时候，进行限流。 线程数：当调用该API的线程数达到阈值的时候，进行限流。 是否集群：不需要集群。 流控模式： 直接：API达到限流条件时，直接限流。 关联：当关联的资源达到阈值时，就限流自己。 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【API级别的针对来源】。 流控效果： 快速失败：直接失败，抛异常。 Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值。 排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:3:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel流控-QPS直接失败(太多了就记一个) 直接 -\u003e 快速失败（系统默认） 配置及说明 表示1秒钟内查询1次就是OK，若超过次数1，就直接-\u003e快速失败，报默认错误 测试 快速多次点击访问http://localhost:8401/testA 结果 返回页面 Blocked by Sentinel (flow limiting) ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:3:1","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel降级简介 熔断降级概述 除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。 现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。 RT（平均响应时间，秒级） 平均响应时间 超出阈值 且 在时间窗口内通过的请求\u003e=5，两个条件同时满足后触发降级。 窗口期过后关闭断路器。 RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt=XXXX才能生效）。 异常比列（秒级） QPS \u003e= 5且异常比例（秒级统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 。 异常数(分钟级) 异常数(分钟统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高)，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。 当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。 Sentinei的断路器是没有类似Hystrix半开状态的。(Sentinei 1.8.0 已有半开状态) 半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:4:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel降级-RT(太多了就记一个) 是什么？ 平均响应时间(DEGRADE_GRADE_RT)：当1s内持续进入5个请求，对应时刻的平均响应时间（秒级）均超过阈值（ count，以ms为单位），那么在接下的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地熔断(抛出DegradeException )。注意Sentinel 默认统计的RT上限是4900 ms，超出此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项-Dcsp.sentinel.statistic.max.rt=xxx来配置。 注意：Sentinel 1.7.0才有平均响应时间（DEGRADE_GRADE_RT），Sentinel 1.8.0的没有这项，取而代之的是慢调用比例 (SLOW_REQUEST_RATIO)。 慢调用比例 (SLOW_REQUEST_RATIO)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。 测试 代码 @RestController @Slf4j public class FlowLimitController { ... @GetMapping(\"/testD\") public String testD() { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"testD 测试RT\"); } } 配置 jmeter压测 线程数10 无限循环 结论 按照上述配置，永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了后续我停止jmeter，没有这么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK。 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:4:1","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel热点key 何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如： 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效 承上启下复习start 兜底方法，分为系统默认和客户自定义，两种 之前的case，限流出问题后，都是用sentinel系统默认的提示: Blocked by Sentinel (flow limiting) 我们能不能自定？类似hystrix，某个方法出问题了，就找对应的兜底降级方法? 结论 - 从HystrixCommand到@SentinelResource @RestController @Slf4j public class FlowLimitController { ... @GetMapping(\"/testHotKey\") @SentinelResource(value = \"testHotKey\",blockHandler/*兜底方法*/ = \"deal_testHotKey\") public String testHotKey(@RequestParam(value = \"p1\",required = false) String p1, @RequestParam(value = \"p2\",required = false) String p2) { //int age = 10/0; return \"------testHotKey\"; } /*兜底方法*/ public String deal_testHotKey (String p1, String p2, BlockException exception) { return \"------deal_testHotKey,o(╥﹏╥)o\"; //sentinel系统默认的提示：Blocked by Sentinel (flow limiting) } } 配置 一 @SentinelResource(value = “testHotKey”) 异常打到了前台用户界面看到，不友好 二 @SentinelResource(value = “testHotKey”, blockHandler = “dealHandler_testHotKey”) 方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理 异常用了我们自己定义的兜底方法 测试 error http://localhost:8401/testHotKey?p1=abc http://localhost:8401/testHotKey?p1=abc\u0026p2=33 right http://localhost:8401/testHotKey?p2=abc ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:5:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"参数例外项 普通 - 超过1秒钟一个后，达到阈值1后马上被限流 我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样 特例 - 假如当p1的值等于5时，它的阈值可以达到200 测试 right - http://localhost:8401/testHotKey?p1=5 error - http://localhost:8401/testHotKey?p1=3 当p1等于5的时候，阈值变为200 当p1不等于5的时候，阈值就是平常的1 前提条件 - 热点参数的注意点，参数必须是基本类型或者String 其它 在方法体抛异常 @RestController @Slf4j public class FlowLimitController { ... @GetMapping(\"/testHotKey\") @SentinelResource(value = \"testHotKey\",blockHandler/*兜底方法*/ = \"deal_testHotKey\") public String testHotKey(@RequestParam(value = \"p1\",required = false) String p1, @RequestParam(value = \"p2\",required = false) String p2) { int age = 10/0;//\u003c----------------------------会抛异常的地方 return \"------testHotKey\"; } /*兜底方法*/ public String deal_testHotKey (String p1, String p2, BlockException exception) { return \"------deal_testHotKey,o(╥﹏╥)o\"; //sentinel系统默认的提示：Blocked by Sentinel (flow limiting) } } 将会抛出Spring Boot 2的默认异常页面，而不是兜底方法。 @SentinelResource - 处理的是sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理; RuntimeException int age = 10/0，这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管 总结 - @SentinelResource主管配置出错，运行出错该走异常走异常 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:5:1","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel系统规则 Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。 系统规则 系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。 系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。 系统规则支持以下的模式： Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。 CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:6:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"SentinelResource配置 @SentinelResource(value = “customerBlockHandler”, blockHandlerClass = CustomerBlockHandler.class,//\u003c——– 自定义限流处理类 blockHandler = “handlerException2”)//\u003c———–自定义限流处理方法 @SentinelResource( value = \"fallback\", fallback = \"handlerFallback\",//fallback只负责业务异常 blockHandler = \"blockHandler\",//blockHandler只负责sentinel控制台配置违规 exceptionsToIgnore = {IllegalArgumentException.class}) //exceptionsToIgnore，忽略指定异常，即这些异常不用兜底方法处理。和fallback配合使用 package com.atguigu.springcloud.controller; import com.alibaba.csp.sentinel.annotation.SentinelResource; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import com.atguigu.springcloud.handler.CustomerBlockHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class RateLimitController { @GetMapping(\"/byResource\") @SentinelResource(value = \"byResource\",blockHandler = \"handleException\") public CommonResult byResource() { return new CommonResult(200,\"按资源名称限流测试OK\",new Payment(2020L,\"serial001\")); } public CommonResult handleException(BlockException exception) { return new CommonResult(444,exception.getClass().getCanonicalName()+\"\\t 服务不可用\"); } @GetMapping(\"/rateLimit/byUrl\") // @SentinelResource(value = \"byUrl\") public CommonResult byUrl() { return new CommonResult(200,\"按url限流测试OK\",new Payment(2020L,\"serial002\")); } @GetMapping(\"/rateLimit/customerBlockHandler\") @SentinelResource(value = \"customerBlockHandler\", blockHandlerClass = CustomerBlockHandler.class,//\u003c-------- 自定义限流处理类 blockHandler = \"handlerException2\")//\u003c-----------自定义限流处理方法 public CommonResult customerBlockHandler() { return new CommonResult(200,\"按客戶自定义\",new Payment(2020L,\"serial003\")); } } 总结： value ： sentinel资源名称 blockHandlerClass ：指定服务降级的处理类 blockHandler ： 指定服务降级的处理类中的处理方法 fallback ： 业务异常兜底方法 exceptionsToIgnore：忽略指定异常 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:7:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel服务熔断Ribbon环境 启动nacos和sentinel 提供者9003/9004 消费者84 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:8:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"提供者9003/9004 新建cloudalibaba-provider-payment9003/9004，两个一样的做法 POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloudalibaba-provider-payment9003\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 9003 spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址 management: endpoints: web: exposure: include: '*' 启动类 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class PaymentMain9003 { public static void main(String[] args) { SpringApplication.run(PaymentMain9003.class, args); } } 业务类 import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; @RestController public class PaymentController { @Value(\"${server.port}\") private String serverPort; //模拟数据库 public static HashMap\u003cLong,Payment\u003e hashMap = new HashMap\u003c\u003e(); static { hashMap.put(1L,new Payment(1L,\"28a8c1e3bc2742d8848569891fb42181\")); hashMap.put(2L,new Payment(2L,\"bba8c1e3bc2742d8848569891ac32182\")); hashMap.put(3L,new Payment(3L,\"6ua8c1e3bc2742d8848569891xt92183\")); } @GetMapping(value = \"/paymentSQL/{id}\") public CommonResult\u003cPayment\u003e paymentSQL(@PathVariable(\"id\") Long id) { Payment payment = hashMap.get(id); CommonResult\u003cPayment\u003e result = new CommonResult(200,\"from mysql,serverPort: \"+serverPort,payment); return result; } } ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:8:1","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"消费者84 cloudalibaba-consumer-nacos-order84 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloudalibaba-consumer-nacos-order84\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud openfeign --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--SpringCloud ailibaba sentinel --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-sentinel\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 84 spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 port: 8719 #消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者) service-url: nacos-user-service: http://nacos-payment-provider # 激活Sentinel对Feign的支持 feign: sentinel: enabled: true 启动类 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.openfeign.EnableFeignClients; @EnableDiscoveryClient @SpringBootApplication @EnableFeignClients public class OrderNacosMain84 { public static void main(String[] args) { SpringApplication.run(OrderNacosMain84.class, args); } } 业务类ApplicationContextConfig import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced public RestTemplate getRestTemplate() { return new RestTemplate(); } } CircleBreakerController import com.alibaba.csp.sentinel.annotation.SentinelResource; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.atguigu.springcloud.alibaba.service.PaymentService; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import javax.annotation.Resource; @RestController @Slf4j public class CircleBreakerController { public static final String SERVICE_URL","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:8:2","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel服务熔断OpenFeign 修改84模块 84消费者调用提供者9003 Feign组件一般是消费侧 pom \u003c!--SpringCloud openfeign --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e yml # 激活Sentinel对Feign的支持 feign: sentinel: enabled: true 业务类 带@Feignclient注解的业务接口，fallback = PaymentFallbackService.class import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @FeignClient(value = \"nacos-payment-provider\",fallback = PaymentFallbackService.class) public interface PaymentService { @GetMapping(value = \"/paymentSQL/{id}\") public CommonResult\u003cPayment\u003e paymentSQL(@PathVariable(\"id\") Long id); } import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import org.springframework.stereotype.Component; @Component public class PaymentFallbackService implements PaymentService { @Override public CommonResult\u003cPayment\u003e paymentSQL(Long id) { return new CommonResult\u003c\u003e(44444,\"服务降级返回,---PaymentFallbackService\",new Payment(id,\"errorSerial\")); } } controller @RestController @Slf4j public class CircleBreakerController { ... //==================OpenFeign @Resource private PaymentService paymentService; @GetMapping(value = \"/consumer/paymentSQL/{id}\") public CommonResult\u003cPayment\u003e paymentSQL(@PathVariable(\"id\") Long id) { return paymentService.paymentSQL(id); } } 主启动 import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient @SpringBootApplication @EnableFeignClients//\u003c------------------------ public class OrderNacosMain84 { public static void main(String[] args) { SpringApplication.run(OrderNacosMain84.class, args); } } 测试 - http://localhost:84/consumer/paymentSQL/1 测试84调用9003，此时故意关闭9003微服务提供者，84消费侧自动降级，不会被耗死。 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:9:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"Sentinel持久化规则（有点鸡肋） 是什么 一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。 怎么玩 将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。 步骤 修改cloudalibaba-sentinel-service8401 POM \u003c!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.csp\u003c/groupId\u003e \u003cartifactId\u003esentinel-datasource-nacos\u003c/artifactId\u003e \u003c/dependency\u003e YML server: port: 8401 spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 sentinel: transport: dashboard: localhost:8080 #配置Sentinel dashboard地址 port: 8719 datasource: #\u003c---------------------------关注点，添加Nacos数据源配置 ds1: nacos: server-addr: localhost:8848 dataId: cloudalibaba-sentinel-service groupId: DEFAULT_GROUP data-type: json rule-type: flow management: endpoints: web: exposure: include: '*' feign: sentinel: enabled: true # 激活Sentinel对Feign的支持 添加Nacos业务规则配置 配置内容解析 [{ \"resource\": \"/rateLimit/byUrl\", \"IimitApp\": \"default\", \"grade\": 1, \"count\": 1, \"strategy\": 0, \"controlBehavior\": 0, \"clusterMode\": false }] resource：资源名称； limitApp：来源应用； grade：阈值类型，0表示线程数, 1表示QPS； count：单机阈值； strategy：流控模式，0表示直接，1表示关联，2表示链路； controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待； clusterMode：是否集群。 启动8401后刷新sentinel发现业务规则有了 快速访问测试接口 - http://localhost:8401/rateLimit/byUrl - 页面返回Blocked by Sentinel (flow limiting) 停止8401再看sentinel - 停机后发现流控规则没有了 重新启动8401再看sentinel 乍一看还是没有，稍等一会儿 多次调用 - http://localhost:8401/rateLimit/byUrl 重新配置出现了，持久化验证通过 ","date":"2021-05-27","objectID":"/springcloud2020-sentinel/:10:0","tags":["微服务","框架"],"title":"springcloud2020 Sentinel","uri":"/springcloud2020-sentinel/"},{"categories":["SpringCloud"],"content":"springcloud2020 nacos ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:0:0","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"简介 为什么叫Nacos 前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service。 是什么 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Nacos: Dynamic Naming and Configuration Service Nacos就是注册中心＋配置中心的组合 -\u003e Nacos = Eureka+Config+Bus 能干嘛 替代Eureka做服务注册中心 替代Config做服务配置中心 ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:1:0","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos之服务提供者注册9001 9002 新建Module - cloudalibaba-provider-payment9001 pom 父pom \u003c!--spring cloud alibaba 2.1.0.RELEASE--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.2.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e 子pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloudalibaba-provider-payment9001\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 9001 spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址 management: endpoints: web: exposure: include: '*' 主启动 @EnableDiscoveryClient package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient @SpringBootApplication public class PaymentMain9001 { public static void main(String[] args) { SpringApplication.run(PaymentMain9001.class, args); } } 业务类controller package com.atguigu.springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class PaymentController { @Value(\"${server.port}\") private String serverPort; @GetMapping(value = \"/payment/nacos/{id}\") public String getPayment(@PathVariable(\"id\") Integer id) { return \"nacos registry, serverPort: \"+ serverPort+\"\\t id\"+id; } } 测试 nacos控制台显示 http://localhost:9001/payment/nacos/1 为了演示负载均衡 搭建9002 ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:2:0","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos之服务消费者注册和负载 83 新建Module - cloudalibaba-consumer-nacos-order83 pom 为什么nacos支持负载均衡？因为spring-cloud-starter-alibaba-nacos-discovery内含netflix-ribbon包。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloudalibaba-consumer-nacos-order83\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--openfeign--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 83 spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 #消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者) service-url: nacos-user-service: http://nacos-payment-provider 启动类 package springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.openfeign.EnableFeignClients; @EnableDiscoveryClient @SpringBootApplication @EnableFeignClients public class OrderNacosMain83 { public static void main(String[] args) { SpringApplication.run(OrderNacosMain83.class, args); } } 业务类 service package springcloud.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @Component @FeignClient(value = \"nacos-payment-provider\") public interface OrderService { @GetMapping(value = \"/payment/nacos/{id}\") public String getPayment(@PathVariable(\"id\") Integer id); } controller package springcloud.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import springcloud.service.OrderService; import javax.annotation.Resource; @RestController @Slf4j public class OrderNacosController { // @Resource // private RestTemplate restTemplate; @Autowired private OrderService orderService; @Value(\"${service-url.nacos-user-service}\") private String serverURL; @GetMapping(value = \"/consumer/payment/nacos/{id}\") public String paymentInfo(@PathVariable(\"id\") Long id) { return orderService.getPayment(Math.toIntExact(id)); } } 测试 启动nacos控制台 http://localhost:83/Eonsumer/payment/nac","date":"2021-05-24","objectID":"/springcloud2020-nacos/:3:0","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos和CAP nacos可以切换ap cp —般来说，如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring cloud和Dubbo服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例。 如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持注册持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。 切换命令： curl -X PUT '$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode\u0026value=CP ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:4:0","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos之服务配置中心 ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:5:0","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"基础配置3377 建module cloudalibaba-config-nacos-client3377 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloudalibaba-config-nacos-client3377\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--nacos-config--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-config\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--nacos-discovery--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--web + actuator--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--一般基础配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml bootstrap # nacos配置 server: port: 3377 spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 # group: TEST_GROUP # namespace: abf23dd4-f61a-470a-bb92-34b6879f5438 # ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension} # nacos-config-client-dev.yaml application spring: profiles: active: dev # 表示开发环境 # active: test # 表示测试环境 #active: prod # 表示生产环境 # active: info 主启动 package springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class NacosConfigClientMain3377 { public static void main(String[] args) { SpringApplication.run(NacosConfigClientMain3377.class,args); } } 业务类 package springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RefreshScope //支持Nacos的动态刷新功能。 public class ConfigClientController { @Value(\"${config.info}\") private String configInfo; @GetMapping(\"/config/info\") public String getConfigInfo() { return configInfo; } } 在Nacos中添加配置信息 Nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则 说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。 在 Nacos Spring Cloud中,dataId的完整格式如下： ${prefix}-${spring-profile.active}.${file-extension} prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。 spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符 - 也将不存在，datald 的拼接格式变成${prefix}.${file-extension} file-exetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.file-extension来配置。目前只支持properties和yaml类型。 通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。 配置 测试 调用接口查看配置信息 - http://localhost:3377/config/info 自带动态刷新 修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。 ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:5:1","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos之命名空间分组和DataID三者关系 实际开发中，通常一个系统会准备 dev开发环境 test测试环境 prod生产环境。 如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢? 一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…那怎么对这些微服务配置进行管理呢? Namespace+Group+Data lD三者关系？为什么这么设计？ 是什么 类似Java里面的package名和类名最外层的namespace是可以用于区分部署环境的，Group和DatalD逻辑上区分两个目标对象。 三者情况 默认情况：Namespace=public，Group=DEFAULT_GROUP，默认Cluster是DEFAULT acos默认的Namespace是public，Namespace主要用来实现隔离。 比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。 Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去 Service就是微服务:一个Service可以包含多个Cluster (集群)，Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。 Instance，就是微服务的实例。 ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:5:2","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos之DataID配置 指定spring.profile.active和配置文件的DatalD来使不同环境下读取不同的配置 默认空间+默认分组+新建dev和test两个DatalD 通过spring.profile.active属性就能进行多环境下配置文件的读取 测试 http://localhost:3377/config/info 配置是什么就加载什么 test/dev ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:5:3","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos之Group分组方案 通过Group实现环境区分 新建配置 bootstrap+application 在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST GROUP ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:5:4","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos之Namespace空间方案 新建dev/test的Namespace 回到服务管理-服务列表查看 按照域名配置填写 yml # nacos配置 server: port: 3377 spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 group: TEST_GROUP namespace: abf23dd4-f61a-470a-bb92-34b6879f5438 # ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension} # nacos-config-client-dev.yaml ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:5:5","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"总而言之 DataID+Group+Namespace确定读取哪个配置文件 ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:5:6","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"nacos持久化 nacos-server-1.1.4\\nacos\\conf录下找到nacos-mysql.sql文件，执行脚本。 nacos-server-1.1.4\\nacos\\conf目录下找到application.properties，添加以下配置（按需修改对应值）。 spring.datasource.platform=mysql db.num=1 db.url.0=jdbc:mysql://localhost:3306/nacos_devtest?characterEncoding=utf8\u0026connectTimeout=1000\u0026socketTimeout=3000\u0026autoReconnect=true db.user=root db.password=1234 重启 ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:6:0","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["SpringCloud"],"content":"Nacos集群 必须持久化 配置cluster.conf # 三个服务器加端口 192.168.111.144:3333 192.168.111.144:4444 192.168.111.144:5555 分别启动三个nacos 配置nginx作为负载均衡器 upstream cluster{ server 127.0.0.1:3333; server 127.0.0.1:4444; server 127.0.0.1:5555; } server { listen 1111; server_name 127.0.0.1; location / { proxy_pass http://cluster; } } 启动2222 3333 4444 nginx 测试 测试通过nginx，访问nacos - http://127.0.0.1:1111/nacos/#/login 修改配置看是否会同步？会 让微服务cloudalibaba-provider-payment9002启动注册进nacos集群 - 修改配置文件 server: port: 9002 spring: application: name: nacos-payment-provider c1oud: nacos: discovery: #配置Nacos地址 #server-addr: Localhost:8848 #换成nginx的1111端口，做集群 server-addr: 192.168.111.144:1111 management: endpoints: web: exposure: inc1ude: '*' 启动微服务cloudalibaba-provider-payment9002 访问nacos，查看注册结果 总结 ","date":"2021-05-24","objectID":"/springcloud2020-nacos/:7:0","tags":["微服务","框架"],"title":"springcloud2020 nacos","uri":"/springcloud2020-nacos/"},{"categories":["中间件"],"content":"mac 下 nginx安装配置 安装 brew install nginx 相关命令 # 启动 sudo nginx # 停止 sudo nginx -s stop # 重启 sudo nginx -s reload 修改配置 vim /usr/local/etc/nginx/nginx.conf 查看服务器（默认端口8080） http://localhost:8080/ ","date":"2021-05-24","objectID":"/mac-%E4%B8%8B-nginx%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:0:0","tags":["服务器","安装"],"title":"mac下nginx安装配置","uri":"/mac-%E4%B8%8B-nginx%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["中间件"],"content":"Mac 下 nacos安装使用 下载安装包 在bin目录下 -m 模式 standalone 单机测试模式 # 启动 sh startup.sh -m standalone # 关闭 sh shutdown.sh 网页登录 http://127.0.0.1:8848/nacos/#/login 默认账号：nacos 默认密码：nacos ","date":"2021-05-23","objectID":"/mac-%E4%B8%8B-nacos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/:0:0","tags":["微服务","安装"],"title":"Mac下nacos安装使用","uri":"/mac-%E4%B8%8B-nacos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"},{"categories":["SpringCloud"],"content":"springcloud2020 Sleuth之zipkin 微服务调用跟踪 ","date":"2021-05-22","objectID":"/springcloud2020-sleuth%E4%B9%8Bzipkin/:0:0","tags":["微服务","框架"],"title":"springcloud2020 Sleuth之zipkin","uri":"/springcloud2020-sleuth%E4%B9%8Bzipkin/"},{"categories":["SpringCloud"],"content":"Sleuth之zipkin搭建安装 zipkin SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可 https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/ zipkin-server-2.12.9-exec.jar 运行 java -jar zipkin-server-2.12.9-exec.jar 控制台 http://localhost:9411/zipkin/ ","date":"2021-05-22","objectID":"/springcloud2020-sleuth%E4%B9%8Bzipkin/:1:0","tags":["微服务","框架"],"title":"springcloud2020 Sleuth之zipkin","uri":"/springcloud2020-sleuth%E4%B9%8Bzipkin/"},{"categories":["SpringCloud"],"content":"Sleuth链路监控实现 为了简单 在cloud-consumer-order80和cloud-provider-payment8001上修改 8001 pom \u003c!--包含了sleuth+zipkin--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zipkin\u003c/artifactId\u003e \u003c/dependency\u003e yml spring: application: name: cloud-payment-service #服务名称 zipkin: #\u003c-------------------------------------关键 base-url: http://localhost:9411 sleuth: #\u003c-------------------------------------关键 sampler: #采样率值介于 0 到 1 之间，1 则表示全部采集 一般设置0.5 probability: 1 datasource: type: com.alibaba.druid.pool.DruidDataSource #当前数据源操作类型 driver-class-name: com.mysql.cj.jdbc.Driver url: username: password: 业务类PaymentController @RestController @Slf4j public class PaymentController { ... @GetMapping(\"/payment/zipkin\") public String paymentZipkin() { return \"hi ,i'am paymentzipkin server fall back，welcome to here, O(∩_∩)O哈哈~\"; } } 80 pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zipkin\u003c/artifactId\u003e \u003c/dependency\u003e yml spring: application: name: cloud-order-service zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 业务类PaymentController public static final String PAYMENT_URL = \"http://CLOUD-PAYMENT-SERVICE\"; // ====================\u003e zipkin+sleuth @GetMapping(\"/consumer/payment/zipkin\") public String paymentZipkin() { String result = restTemplate.getForObject(PAYMENT_URL+\"/payment/zipkin/\", String.class); return result; } 测试 依次启动eureka7001/8001/80 - 80调用8001几次测试下 打开浏览器访问: http://localhost:9411 查看调用记录 ","date":"2021-05-22","objectID":"/springcloud2020-sleuth%E4%B9%8Bzipkin/:2:0","tags":["微服务","框架"],"title":"springcloud2020 Sleuth之zipkin","uri":"/springcloud2020-sleuth%E4%B9%8Bzipkin/"},{"categories":["SpringCloud"],"content":"springcloud2020 Stream 驱动RabbitMQ、 Kafka消息中间件的统一解决方法 ","date":"2021-05-22","objectID":"/springcloud2020-stream/:0:0","tags":["微服务","框架"],"title":"springcloud2020 Stream","uri":"/springcloud2020-stream/"},{"categories":["SpringCloud"],"content":"简介 Binder - 很方便的连接中间件，屏蔽差异。 Channel - 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置。 Source和Sink - 简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。 编码API和常用注解 组成 说明 Middleware 中间件，目前只支持RabbitMQ和Kafka Binder Binder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic,RabbitMQ的exchange)，这些都可以通过配置文件来实现 @Input 注解标识输入通道，通过该输乎通道接收到的消息进入应用程序 @Output 注解标识输出通道，发布的消息将通过该通道离开应用程序 @StreamListener 监听队列，用于消费者的队列的消息接收 @EnableBinding 指信道channel和exchange绑定在一起 准备： RabbitMQ环境 工程中新建三个子模块： cloud-stream-rabbitmq-provider8801，作为生产者进行发消息模块 cloud-stream-rabbitmq-consumer8802，作为消息接收模块 cloud-stream-rabbitmq-consumer8803，作为消息接收模块 ","date":"2021-05-22","objectID":"/springcloud2020-stream/:1:0","tags":["微服务","框架"],"title":"springcloud2020 Stream","uri":"/springcloud2020-stream/"},{"categories":["SpringCloud"],"content":"Stream消息驱动之生产者 新建cloud-stream-rabbitmq-provider8801 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-stream-rabbitmq-provider8801\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-stream-rabbit\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--基础配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e YML server: port: 8801 spring: application: name: cloud-stream-provider cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: send-8801.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 主启动 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class StreamMQMain8801 { public static void main(String[] args) { SpringApplication.run(StreamMQMain8801.class,args); } } 业务类 发送消息接口 package com.atguigu.springcloud.service; public interface IMessageProvider { public String send(); } 发送消息接口实现类 @EnableBinding(Source.class)//定义消息的推送管道 定义输入 输出 @Resource private MessageChannel output; // 消息发送管道 output.send(MessageBuilder.withPayload(serial).build()); 发送 package com.atguigu.springcloud.service.impl; import com.atguigu.springcloud.service.IMessageProvider; import org.springframework.cloud.stream.annotation.EnableBinding; import org.springframework.cloud.stream.messaging.Source; import org.springframework.integration.support.MessageBuilder; import org.springframework.messaging.MessageChannel; import javax.annotation.Resource; import java.util.UUID; @EnableBinding(Source.class)//定义消息的推送管道 public class MessageProviderImpl implements IMessageProvider { @Resource private MessageChannel output;//消息发送的管道 @Override public String send() { String serial = UUID.randomUUID().toString(); output.send(MessageBuilder.withPayload(serial).build()); System.out.println(\"serial:\"+serial); return serial; } } Controller package com.atguigu.springcloud.controller; import com.atguigu.springcloud.service.IMessageProvider; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController public class SendMessageController { @Resource private IMessagePro","date":"2021-05-22","objectID":"/springcloud2020-stream/:2:0","tags":["微服务","框架"],"title":"springcloud2020 Stream","uri":"/springcloud2020-stream/"},{"categories":["SpringCloud"],"content":"Stream消息驱动之消费者 新建 cloud-stream-rabbitmq-consumer8802 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-stream-rabbitmq-consumer8802\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-stream-rabbit\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--基础配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 8802 spring: application: name: cloud-stream-consumer cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 group: A_GROUP eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: receive-8802.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 主启动 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class StreamMQMain8802 { public static void main(String[] args) { SpringApplication.run(StreamMQMain8802.class,args); } } 业务类 @EnableBinding(Sink.class) 定义输入 输出 package com.atguigu.springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.stream.annotation.EnableBinding; import org.springframework.cloud.stream.annotation.StreamListener; import org.springframework.cloud.stream.messaging.Sink; import org.springframework.messaging.Message; import org.springframework.stereotype.Controller; @Controller @EnableBinding(Sink.class) public class ReceiveMessageListenerController { @Value(\"${server.port}\") private String serverPort; @StreamListener(Sink.INPUT) public void input(Message\u003cString\u003e message) { System.out.println(\"消费者1号,-----\u003e接受到的消息: \"+message.getPayload()+\"\\t port: \"+serverPort); } } 测试 启动EurekaMain7001 启动StreamMQMain8801 启动StreamMQMain8802 8801发送8802接收消息 ","date":"2021-05-22","objectID":"/springcloud2020-stream/:3:0","tags":["微服务","框架"],"title":"springcloud2020 Stream","uri":"/springcloud2020-stream/"},{"categories":["SpringCloud"],"content":"Stream之消息重复消费 依照8802，克隆出来一份运行8803 - cloud-stream-rabbitmq-consumer8803。 启动 RabbitMQ 服务注册 - 8801 消息生产 - 8801 消息消费 - 8802 消息消费 - 8802 运行后有两个问题 有重复消费问题 消息持久化问题 消费 http://localhost:8801/sendMessage 目前是8802/8803同时都收到了，存在重复消费问题 如何解决：分组和持久化属性group（重要） ","date":"2021-05-22","objectID":"/springcloud2020-stream/:4:0","tags":["微服务","框架"],"title":"springcloud2020 Stream","uri":"/springcloud2020-stream/"},{"categories":["SpringCloud"],"content":"Stream之group解决消息重复消费 增加 yml配置 使消费者分组 每组只有一个接收 操作 spring: application: name: cloud-stream-provider cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 group: A_Group #\u003c----------------------------------------关键 ","date":"2021-05-22","objectID":"/springcloud2020-stream/:4:1","tags":["微服务","框架"],"title":"springcloud2020 Stream","uri":"/springcloud2020-stream/"},{"categories":["SpringCloud"],"content":"消息持久化解决 删除8002分组 测试： 先启动8802，无分组属性配置，后台没有打出来消息。 再启动8803，有分组属性配置，后台打出来了MQ上的消息。(消息持久化体现) ","date":"2021-05-22","objectID":"/springcloud2020-stream/:4:2","tags":["微服务","框架"],"title":"springcloud2020 Stream","uri":"/springcloud2020-stream/"},{"categories":["SpringCloud"],"content":"springcloud2020 Bus消息总线 分布式自动刷新配置功能 ","date":"2021-05-21","objectID":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/:0:0","tags":["微服务","框架"],"title":"springcloud2020 Bus消息总线","uri":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"},{"categories":["SpringCloud"],"content":"环境准备 ","date":"2021-05-21","objectID":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/:1:0","tags":["微服务","框架"],"title":"springcloud2020 Bus消息总线","uri":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"},{"categories":["SpringCloud"],"content":"必须先具备良好的RabbitMQ环境 可以打开网页端控制台 ","date":"2021-05-21","objectID":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/:1:1","tags":["微服务","框架"],"title":"springcloud2020 Bus消息总线","uri":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"},{"categories":["SpringCloud"],"content":"新建3366 建cloud-config-client-3366 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-config-client-3366\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--添加消息总线RabbitMQ支持--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amap\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-config\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml（bootstrap） server: port: 3366 spring: application: name: config-client cloud: #Config客户端配置 config: label: master #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #rabbitmq相关配置\u003c-------------------------- rabbitmq: host: localhost port: 5672 username: guest password: guest #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka # 暴露监控端点 management: endpoints: web: exposure: include: \"*\" 主启动 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @EnableEurekaClient @SpringBootApplication public class ConfigClientMain3366 { public static void main(String[] args) { SpringApplication.run(ConfigClientMain3366.class,args); } } controller package com.atguigu.springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RefreshScope public class ConfigClientController { @Value(\"${config.info}\") private String configInfo; @Value(\"${server.port}\") private String serverPort; @GetMapping(\"/configInfo\") public String getConfigInfo() { return configInfo+serverPort; } } ","date":"2021-05-21","objectID":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/:1:2","tags":["微服务","框架"],"title":"springcloud2020 Bus消息总线","uri":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"},{"categories":["SpringCloud"],"content":"设计思想 利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置 ","date":"2021-05-21","objectID":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/:2:0","tags":["微服务","框架"],"title":"springcloud2020 Bus消息总线","uri":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"},{"categories":["SpringCloud"],"content":"Bus动态刷新全局广播配置实现 3344修改 pom \u003c!--添加消息总线RabbitNQ支持--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amap\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg-springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e yml server: port: 3344 spring: application: name: cloud-config-center #注册进Eureka服务器的微服务名 cloud: config: server: git: uri: https://gitee.com/coderabbit214/springcloud-config.git #GitHub上面的git仓库名字 ####搜索目录 search-paths: - springcloud-config ####读取分支 label: master #rabbitmq相关配置\u003c-------------------------- rabbitmq: host: localhost port: 5672 username: guest password: guest ##rabbitmq相关配置,暴露bus刷新配置的端点\u003c-------------------------- management: endpoints: #暴露bus刷新配置的端点 web: exposure: include: 'bus-refresh' #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka 3355修改 pom \u003c!--添加消息总线RabbitNQ支持--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amap\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg-springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e yml server: port: 3355 spring: application: name: config-client cloud: #Config客户端配置 config: label: master #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #rabbitmq相关配置\u003c-------------------------- rabbitmq: host: localhost port: 5672 username: guest password: guest #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka # 暴露监控端点 management: endpoints: web: exposure: include: \"*\" 3366 pom \u003c!--添加消息总线RabbitNQ支持--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amap\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg-springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e yml server: port: 3366 spring: application: name: config-client cloud: #Config客户端配置 config: label: master #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #rabbitmq相关配置\u003c-------------------------- rabbitmq: host: localhost port: 5672 username: guest password: guest #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka # 暴露监控端点 management: endpoints: web: exposure: include: \"*\" 测试 启动 EurekaMain7001 ConfigcenterMain3344 ConfigclientMain3355 ConfigclicntMain3366 运维工程师 修改Github上配置文件内容，增加版本号 发送POST请求 curl -X POST \"http://localhost:3344/actuator/bus-refresh\" —次发送，处处生效 配置中心 http://localhost:3344/config-dev.yml 客户端 http://localhost:3355/configlnfo http://localhost:3366/configInfo 获取配置信息，发现都已经刷新了 —次修改，广播通知，处处生效 ","date":"2021-05-21","objectID":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/:3:0","tags":["微服务","框架"],"title":"springcloud2020 Bus消息总线","uri":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"},{"categories":["SpringCloud"],"content":"Bus动态刷新定点通知 不想全部通知，只想定点通知 例： 只通知3355 不通知3366 运行 我们这里以刷新运行在3355端口上的config-client（配置文件中设定的应用名称）为例，只通知3355，不通知3366 curl -X POST \"http://localhost:3344/actuator/bus-refresh/config-client:3355 ","date":"2021-05-21","objectID":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/:4:0","tags":["微服务","框架"],"title":"springcloud2020 Bus消息总线","uri":"/springcloud2020-bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"},{"categories":["中间件"],"content":"Mac 下 RabbitMQ安装 安装brew 安装RabbitMQ brew install rabbitmq 启动 # 启动 brew services start rabbitmq # 当前窗口启动 rabbitmq-server 进入控制台: http://localhost:15672/ 账号密码 guest,guest ","date":"2021-05-20","objectID":"/mac-%E4%B8%8B-rabbitmq%E5%AE%89%E8%A3%85/:0:0","tags":["消息队列","安装"],"title":"Mac 下 RabbitMQ安装","uri":"/mac-%E4%B8%8B-rabbitmq%E5%AE%89%E8%A3%85/"},{"categories":["SpringCloud"],"content":"springcloud2020 Config分布式配置中心 ","date":"2021-05-20","objectID":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:0:0","tags":["微服务","框架"],"title":"springcloud2020 Config分布式配置中心","uri":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["SpringCloud"],"content":"分布式配置中心 分布式系统面临的配置问题 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。 SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.…… ","date":"2021-05-20","objectID":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:1:0","tags":["微服务","框架"],"title":"springcloud2020 Config分布式配置中心","uri":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["SpringCloud"],"content":"Config配置总控中心搭建 在GitHub上新建一个名为springcloud-config的仓库。 我这里使用gitee codeRabbit214/springcloud-config - 码云 - 开源中国 (gitee.com) 拉到本地写入三个文件上传 config-dev.yml config: info: \"master branch,springcloud-config/config-dev.yml version=7 config-prod.yml config: info: \"master branch,springcloud-config/config-prod.yml version=1\" config-test.yml config: info: \"master branch,springcloud-config/config-test.yml version=1\" 新建cloud-config-center-3344模块 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-config-center-3344\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-config-server\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e YML server: port: 3344 spring: application: name: cloud-config-center #注册进Eureka服务器的微服务名 cloud: config: server: git: uri: https://gitee.com/coderabbit214/springcloud-config.git #GitHub上面的git仓库名字 ####搜索目录 search-paths: - springcloud-config ####读取分支 label: master #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka 启动类 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.config.server.EnableConfigServer; @SpringBootApplication @EnableConfigServer public class ConfigCenterMain3344 { public static void main(String[] args) { SpringApplication.run(ConfigCenterMain3344.class, args); } } 测试 启动3344 浏览器访问localhost:3344/master/config-dev.yml 页面返回 config: info: \"master branch,springcloud-config/config-dev.yml version=7\" 配置读取规则 重要配置细节总结 /{name}-{profiles}.yml /{label}-{name}-{profiles}.yml label：分支(branch) name：服务名 profiles：环境(dev/test/prod) /{label}/{application}-{profile}.yml（推荐） /{application}-{profile}.yml /{application}/{profile}[/{label}] ","date":"2021-05-20","objectID":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:2:0","tags":["微服务","框架"],"title":"springcloud2020 Config分布式配置中心","uri":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["SpringCloud"],"content":"Config客户端配置与测试 新建cloud-config-client-3355 POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-config-client-3355\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-config\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e bootstrap.yml applicaiton.yml是用户级的资源配置项 bootstrap.yml是系统级的，优先级更加高 server: port: 3355 spring: application: name: config-client cloud: #Config客户端配置 config: label: master #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka 主启动 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @EnableEurekaClient @SpringBootApplication public class ConfigClientMain3355 { public static void main(String[] args) { SpringApplication.run(ConfigClientMain3355.class, args); } } 业务类 package com.atguigu.springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class ConfigClientController { @Value(\"${config.info}\") private String configInfo; @GetMapping(\"/configInfo\") public String getConfigInfo() { return configInfo; } } 测试 启动 7001 3344 3355 访问127.0.0.1:3355/configInfo 得到返回值 ","date":"2021-05-20","objectID":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:3:0","tags":["微服务","框架"],"title":"springcloud2020 Config分布式配置中心","uri":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["SpringCloud"],"content":"Config动态刷新之手动版 避免每次更新配置都要重启客户端微服务3355 修改3355 pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e yml # 暴露监控端点 management: endpoints: web: exposure: include: \"*\" @RefreshScope业务类Controller修改 import org.springframework.cloud.context.config.annotation.RefreshScope; ... @RestController @RefreshScope//\u003c----- public class ConfigClientController { ... } 在gitee上修改配置文件 127.0.0.1:3355/configInfo未发生改变 原因 需要刷新 刷新生效 curl -X POST \"http://localhost:3355/actuator/refresh\" ​ ","date":"2021-05-20","objectID":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/:4:0","tags":["微服务","框架"],"title":"springcloud2020 Config分布式配置中心","uri":"/springcloud2020-config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"categories":["SpringCloud"],"content":"springcloud2020 gateway 服务网关 SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。 作用 方向代理 鉴权 流量控制 熔断 日志监控 ","date":"2021-05-19","objectID":"/springcloud2020-gateway/:0:0","tags":["微服务","框架"],"title":"springcloud2020 gateway","uri":"/springcloud2020-gateway/"},{"categories":["SpringCloud"],"content":"GateWay非阻塞异步模型 SpringCloud Gateway具有如下特性 基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建； 动态路由：能够匹配任何请求属性； 可以对路由指定Predicate (断言)和Filter(过滤器)； 集成Hystrix的断路器功能； 集成Spring Cloud 服务发现功能； 易于编写的Predicate (断言)和Filter (过滤器)； 请求限流功能； 支持路径重写。 SpringCloud Gateway与Zuul的区别 在SpringCloud Finchley正式版之前，Spring Cloud推荐的网关是Netflix提供的Zuul。 Zuul 1.x，是一个基于阻塞I/O的API Gateway。 Zuul 1.x基于Servlet 2.5使用阻塞架构它不支持任何长连接(如WebSocket)Zuul的设计模式和Nginx较像，每次I/О操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身会有第-次加载较慢的情况，使得Zuul的性能相对较差。 Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul .x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试,Spring Cloud Gateway的RPS(每秒请求数)是Zuul的1.6倍。 Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot2之上，使用非阻塞API。 Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验 Gateway模型 WebFlux是什么？官方文档 传统的Web框架，比如说: Struts2，SpringMVC等都是基于Servlet APl与Servlet容器基础之上运行的。 但是在Servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程(Spring 5必须让你使用Java 8)。 Spring WebFlux是Spring 5.0 引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet APl，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。 ","date":"2021-05-19","objectID":"/springcloud2020-gateway/:1:0","tags":["微服务","框架"],"title":"springcloud2020 gateway","uri":"/springcloud2020-gateway/"},{"categories":["SpringCloud"],"content":"Gateway工作流程 三大核心概念 Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由； Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由； Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。 ","date":"2021-05-19","objectID":"/springcloud2020-gateway/:2:0","tags":["微服务","框架"],"title":"springcloud2020 gateway","uri":"/springcloud2020-gateway/"},{"categories":["SpringCloud"],"content":"Gateway9527搭建 新建 cloud-gateway-gateway9527 模块 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-gateway-gateway9527\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--gateway--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--eureka-client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c!--一般基础配置类--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003eali-maven\u003c/id\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/project\u003e yml server: port: 9527 spring: application: name: cloud-gateway eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 register-with-eureka: true fetch-registry: true service-url: defaultZone: http://eureka7001.com:7001/eureka 主启动 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class GateWayMain9527 { public static void main(String[] args) { SpringApplication.run(GateWayMain9527.class, args); } } 路由映射yml spring: application: name: cloud-gateway #############################新增网关配置########################### cloud: gateway: routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 # uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: # - Header=X-Request-Id, \\d+ # - Cookie=username,zzyy # - After=2021-05-16T19:53:59.024+08:00[Asia/Shanghai] - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 # uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由 #################################################################### 测试 启动7001 启动8001-cloud-provider-payment8001 启动9527网关 访问说明 添加网关前 - http://localhost:8001/payment/get/1 添加网关后 - http://localhost:9527/payment/get/1 两者访问成功，返回相同结果 ","date":"2021-05-19","objectID":"/springcloud2020-gateway/:3:0","tags":["微服务","框架"],"title":"springcloud2020 gateway","uri":"/springcloud2020-gateway/"},{"categories":["SpringCloud"],"content":"Gateway配置路由的两种方式Route yml配置 看上一部分 代码中注入RouteLocator的Bean package com.atguigu.springcloud.config; import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class GateWayConfig { @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder){ RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route(\"path_route_atguigu\", r -\u003e r.path(\"/guonei\").uri(\"http://news.baidu.com/guonei\")).build(); routes.route(\"path_route_atguigu1\", r -\u003e r.path(\"/game\").uri(\"http://news.baidu.com/game\")).build(); return routes.build(); } } 测试 浏览器输入http://localhost:9527/guonei，返回http://news.baidu.com/guonei相同的页面。 ","date":"2021-05-19","objectID":"/springcloud2020-gateway/:3:1","tags":["微服务","框架"],"title":"springcloud2020 gateway","uri":"/springcloud2020-gateway/"},{"categories":["SpringCloud"],"content":"GateWay配置动态路由 默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能（不写死一个地址）。 9527yml更改 spring: application: name: cloud-gateway #############################新增网关配置########################### cloud: gateway: routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由 #################################################################### 测试 成功 ","date":"2021-05-19","objectID":"/springcloud2020-gateway/:3:2","tags":["微服务","框架"],"title":"springcloud2020 gateway","uri":"/springcloud2020-gateway/"},{"categories":["SpringCloud"],"content":"GateWay常用的Predicate(断言) 常用的Route Predicate Factory The After Route Predicate Factory The Before Route Predicate Factory The Between Route Predicate Factory The Cookie Route Predicate Factory The Header Route Predicate Factory The Host Route Predicate Factory The Method Route Predicate Factory The Path Route Predicate Factory The Query Route Predicate Factory The RemoteAddr Route Predicate Factory The weight Route Predicate Factory cloud: gateway: routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: # - Header=X-Request-Id, \\d+ # - Cookie=username,zzyy # - After=2021-05-16T19:53:59.024+08:00[Asia/Shanghai] - Path=/payment/get/** # 断言，路径相匹配的进行路由 获取时间戳 import java.time.ZonedDateTime; public class Test { public static void main(String[] args) { ZonedDateTime zonedDateTime = ZonedDateTime.now();//默认时区 System.out.println(zonedDateTime); } } header cookie 举一反三 ","date":"2021-05-19","objectID":"/springcloud2020-gateway/:3:3","tags":["微服务","框架"],"title":"springcloud2020 gateway","uri":"/springcloud2020-gateway/"},{"categories":["SpringCloud"],"content":"GateWay的Filter(过滤) 自定义 GateWay9527项目添加MyLogGateWayFilter类： package com.atguigu.springcloud.filter; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.http.HttpStatus; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import java.util.Date; @Component @Slf4j public class MyLogGateWayFilter implements GlobalFilter, Ordered { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { log.info(\"全局过滤器\"+new Date()); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if (uname == null) { log.info(\"用户名为空，非法用户\"); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } @Override public int getOrder() { return 0; } } 测试 localhost:9527/payment/get/1?uname=1正常 localhost:9527/payment/get/1失败 ","date":"2021-05-19","objectID":"/springcloud2020-gateway/:3:4","tags":["微服务","框架"],"title":"springcloud2020 gateway","uri":"/springcloud2020-gateway/"},{"categories":["SpringCloud"],"content":"springcloud2020 Eureka 么是服务治理 Spring Cloud封装了Netflix 公司开发的Eureka模块来实现服务治理 在传统的RPC远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。 什么是服务注册与发现 Eureka采用了CS的设计架构，Eureka Sever作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。 在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何RPC远程框架中，都会有一个注册中心存放服务地址相关信息(接口地址) Eureka包含两个组件:Eureka Server和Eureka Client Eureka Server提供服务注册服务 各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。 EurekaClient通过注册中心进行访问 它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒) ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:0:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"1.服务端安装 创建cloud-eureka-server7001的module pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-eureka-server7001\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--eureka-server--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-server\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c!--boot web actuator--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 图像监控--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--一般通用配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 7001 eureka: instance: hostname: locathost #eureka服务端的实例名称 client: #false表示不向注册中心注册自己。 register-with-eureka: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 启动类 @EnableEurekaServer package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class,args); } } 启动 浏览器输入http://localhost:7001/进入pring Eureka服务主页 ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:1:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"2.支付微服务8001入驻进EurekaServer 修改cloud-provider-payment8001 pom \u003c!-- eureka-client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e yml eureka: client: #表示是否将自己注册进Eurekaserver默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true #入住到哪里 那个主机的那个端口 service-url: defaultZone: http://localhost:7001/eureka 主启动 @EnableEurekaClient package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class,args); } } 测试 ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:2:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"3.订单微服务80入驻进EurekaServer pom \u003c!-- eureka-client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e yml 注意添加服务名称 server: port: 80 spring: application: name: cloud-order-service eureka: client: #表示是否将自己注册进Eurekaserver默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true #入住到哪里 那个主机的那个端口 service-url: defaultZone: http://localhost:7001/eureka 主启动 @EnableEurekaClient package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class OrderMain80 { public static void main(String[] args) { SpringApplication.run(OrderMain80.class,args); } } 测试 Eureka集群环境构建 ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:3:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"1.环境构建 按照7001创建cloud-eureka-server7002工程 修改本机etc\\hosts文件 模拟两台机器 127.0.0.1 eureka7001.com 127.0.0.1 eureka7002.com 修改cloud-eureka-server7001配置文件 hostname defaultZone server: port: 7001 eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: #false表示不向注册中心注册自己。 register-with-eureka: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。 defaultZone: http://eureka7002.com:7002/eureka/ 修改cloud-eureka-server7002配置文件 server: port: 7002 eureka: instance: hostname: eureka7002.com #eureka服务端的实例名称 client: #false表示不向注册中心注册自己。 register-with-eureka: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。 defaultZone: http://eureka7001.com:7001/eureka/ 启动7001和7002 ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:4:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"2.微服务注册进Eureka集群 支付服务8001微服务，订单服务80微服务 将它们的配置文件的eureka.client.service-url.defaultZone进行修改 eureka: client: #表示是否将自己注册进Eurekaserver默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true #入住到哪里 那个主机的那个端口 service-url: defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka # defaultZone: http://localhost:7001/eureka ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:5:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"3.支付微服务集群配置 新建cloud-provider-payment8002 模拟多台机器 改POM 写YML - 端口8002 主启动 业务类 修改8001/8002的Controller，添加serverPort(目的是为了查看80端口调用哪个微服务) package com.atguigu.springcloud.controller; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import com.atguigu.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.*; @RestController @Slf4j @RequestMapping(\"/payment\") public class PaymentController { @Autowired private PaymentService paymentService; @Value(\"${server.port}\") private String serverPort; @PostMapping(value = \"/create\") public CommonResult create(@RequestBody Payment payment){ int result = paymentService.create(payment); log.info(\"结果：\"+ result); if (result \u003e 0){ return new CommonResult(200,\"插入成功\"+serverPort,result); } return new CommonResult(444,\"插入错误\",null); } @GetMapping(value = \"/get/{id}\") public CommonResult getPamentById(@PathVariable(\"id\")Long id){ Payment paymentById = paymentService.getPaymentById(id); log.info(\"结果：\"+ paymentById); if (paymentById != null){ return new CommonResult(200,\"查询成功\"+serverPort,paymentById); } return new CommonResult(444,\"没有对应记录\"+id,null); } } 负载均衡 80controller 订单服务访问地址不能写死 注意： public static final String PAYMENT_URL = “http://CLOUD-PAYMENT-SERVICE”; package com.atguigu.springcloud.controller; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import org.springframework.web.client.RestTemplate; @RestController @Slf4j public class PaymentController { public static final String PAYMENT_URL = \"http://CLOUD-PAYMENT-SERVICE\"; // public static final String PAYMENT_URL = \"http://localhost:8001\"; @Autowired private RestTemplate restTemplate; @PostMapping(\"/consumer/payment/create\") public CommonResult\u003cPayment\u003e create(Payment payment){ return restTemplate.postForObject(PAYMENT_URL+\"/payment/create\",payment,CommonResult.class); } @GetMapping(\"/consumer/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id){ return restTemplate.getForObject(PAYMENT_URL+\"/payment/get/\"+id,CommonResult.class); } } 修改配置 使用@LoadBalanced注解赋予RestTemplate负载均衡的能力 @LoadBalanced package com.atguigu.springcloud.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced public RestTemplate getRestTemplate(){ return new RestTemplate(); } } 负载均衡效果达到，8001/8002端口交替出现 ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:6:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"4.actuator微服务信息完善 修改服务名称 显示ip 修改cloud-provider-payment8001，cloud-provider-payment8002 yml 俩个都需要修改 instance-id: payment8001 instance-id: payment8002 eureka: ... instance: instance-id: payment8001 #自定义微服务名称 prefer-ip-address: true #显示ip 好像不设置也会显示 ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:7:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"5.服务发现Discovery 对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息 修改cloud-provider-payment8001的Controller package com.atguigu.springcloud.controller; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import com.atguigu.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @Slf4j @RequestMapping(\"/payment\") public class PaymentController { ... @Autowired private DiscoveryClient discoveryClient; ... @GetMapping(\"/discovery\") public Object discovery(){ List\u003cString\u003e services = discoveryClient.getServices();//所有微服务名称 for (String service:services) { log.info(service); } List\u003cServiceInstance\u003e instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\");//此微服务名称下的 所有微服务名称 for (ServiceInstance instance:instances) { log.info(instance.getServiceId()+\"\\t\"+instance.getHost()+\"\\t\"+instance.getPort()+\"\\t\"+instance.getUri()); } return this.discoveryClient; } } 8001启动类 @EnableDiscoveryClient注解 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient @EnableDiscoveryClient public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class,args); } } ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:8:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"6. Eureka自我保护 现象 解释 某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。 如何禁止自我保护 7001yml eureka: ... server: #关闭自我保护机制，保证不可用服务被及时踢除 enable-self-preservation: false eviction-interval-timer-in-ms: 2000 客户端（8001）相应设置yml eureka: ... instance: instance-id: payment8001 prefer-ip-address: true #心跳检测与续约时间 #开发时没置小些，保证服务关闭后注册中心能即使剔除服务 #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒) lease-renewal-interval-in-seconds: 1 #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务 lease-expiration-duration-in-seconds: 2 停更说明 停更 ","date":"2021-05-13","objectID":"/springcloud2020-eureka/:9:0","tags":["微服务","框架"],"title":"springcloud2020 Eureka","uri":"/springcloud2020-eureka/"},{"categories":["SpringCloud"],"content":"springcloud2020 Hystrix 介绍 概述 分布式系统面临的问题 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。 服务雪崩 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”. 对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。 所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。 Hystrix是什么 Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。 “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝)，向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。 能做什么 服务降级 服务熔断 服务限流 接近实对的监控 服务降级 服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback 哪些情况会出发降级 程序运行导常 超时 服务熔断触发服务降级 线程池/信号量打满也会导致服务降级 ","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:0:0","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"Hystrix支付微服务构建 以此module为根基平台 建cloud-provider-hygtrix-payment8001 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-provider-hygtrix-payment8001\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--hystrix--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-hystrix\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--eureka client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--web--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 8001 spring: application: name: cloud-provider-hystrix-payment eureka: client: register-with-eureka: true fetch-registry: true service-url: #defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka defaultZone: http://eureka7001.com:7001/eureka 启动类 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class PaymentHystrixMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentHystrixMain8001.class, args); } } service package com.atguigu.springcloud.service; import org.springframework.stereotype.Service; import java.util.concurrent.TimeUnit; @Service public class PaymentService { public String paymentInfo_OK(Integer id) { return \"线程池: \"+Thread.currentThread().getName()+\" paymentInfo_OK,id: \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"; } public String paymentInfo_TimeOut(Integer id) { try { TimeUnit.MILLISECONDS.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } return \"线程池: \"+Thread.currentThread().getName()+\" id: \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\" 耗时(秒): 3\"; } } controller package com.atguigu.springcloud.controller; import com.atguigu.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; /** */ @RestController @Slf4j public class PaymentController { @Resource private PaymentService paymentService; @Value(\"${server.port}\") private String serverPort; @GetMapping(\"/payment/hystrix/ok/{id}\") public String paymentInfo_OK(@PathVariable(\"id\") Integer id) { String result = paymentService.paymentInfo_OK(id); log.info(\"*****result: \"+result); return result; } @GetMapping(\"/payment/hystrix/timeout/{id}\") public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) { String result = paymentService.paymentInfo_TimeOut(id); log.info(\"*****result: \"+r","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:1:0","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"JMeter高并发压测后卡顿 Jmeter压测结论 上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢。 ","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:2:0","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"订单微服务 建 cloud-consumer-feign-hystrix-order80 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-consumer-feign-hystrix-order80\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--openfeign--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--hystrix--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-hystrix\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--eureka client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--web--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--一般基础通用配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 80 eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/ 启动类 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; /** */ @SpringBootApplication @EnableFeignClients public class OrderHystrixMain80 { public static void main(String[] args) { SpringApplication.run(OrderHystrixMain80.class,args); } } service package com.atguigu.springcloud.service; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; /** */ @Component @FeignClient(value = \"cloud-provider-hystrix-payment\") public interface PaymentHystrixService { @GetMapping(\"/payment/hystrix/ok/{id}\") public String paymentInfo_OK(@PathVariable(\"id\") Integer id); @GetMapping(\"/payment/hystrix/timeout/{id}\") public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id); } controller package com.atguigu.springcloud.controller; import com.atguigu.springcloud.service.PaymentHystrixService; import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties; import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController @Slf4j @DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\") public class OrderHystirxController { @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(\"/consumer/payment/hystrix/ok/{id}\") public String paymentInfo_OK(@PathVariable(\"id\") Integer id) { String result = paymentHystrixService.paymentInfo_OK(id); return result; } @GetMapping(\"/consumer/payment/hystrix/timeout","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:3:0","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"降级容错解决的维度要求 超时导致服务器变慢(转圈) - 超时不再等待 出错(宕机或程序运行出错) - 出错要有兜底 解决： 对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级。 对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级。 对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，自己处理降级。 ","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:4:0","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"Hystrix之服务降级支付侧fallback @HystrixCommand @EnableCircuitBreaker ","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:5:0","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"8001提供服务者自我降级 降级配置 - @HystrixCommand 8001先从自身找问题 设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback。 8001fallback 业务类启用 - @HystrixCommand报异常后如何处理 —旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法 service package com.atguigu.springcloud.service; import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty; import org.springframework.stereotype.Service; import java.util.concurrent.TimeUnit; @Service public class PaymentService { public String paymentInfo_OK(Integer id) { return \"线程池: \"+Thread.currentThread().getName()+\" paymentInfo_OK,id: \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"; } @HystrixCommand( fallbackMethod = \"paymentInfo_TimeOutHandler\", commandProperties = { @HystrixProperty( name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"5000\" ) }) public String paymentInfo_TimeOut(Integer id) { // int age = 10/0; try { TimeUnit.MILLISECONDS.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } return \"线程池: \"+Thread.currentThread().getName()+\" id: \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\" 耗时(秒): 3\"; } public String paymentInfo_TimeOutHandler(Integer id) { return \"线程池: \"+Thread.currentThread().getName()+\" 8001系统繁忙或者运行报错，请稍后再试,id: \"+id+\"\\t\"+\"o(╥﹏╥)o\"; } } 主启动类激活 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient @EnableCircuitBreaker// public class PaymentHystrixMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentHystrixMain8001.class, args); } } ","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:5:1","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"80客户端降级 yml server: port: 80 eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/ #开启 feign: hystrix: enabled: true 主启动 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.hystrix.EnableHystrix; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableFeignClients @EnableHystrix//添加到此处 public class OrderHystrixMain80{ public static void main(String[] args){ SpringApplication.run(OrderHystrixMain80.class,args); } } 业务类controller package com.atguigu.springcloud.controller; import com.atguigu.springcloud.service.PaymentHystrixService; import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties; import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController @Slf4j @DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\") public class OrderHystirxController { @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(\"/consumer/payment/hystrix/ok/{id}\") public String paymentInfo_OK(@PathVariable(\"id\") Integer id) { String result = paymentHystrixService.paymentInfo_OK(id); return result; } @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\") @HystrixCommand( fallbackMethod = \"paymentTimeOutFallbackMethod\", commandProperties = { @HystrixProperty( name=\"execution.isolation.thread.timeoutInMilliseconds\", value=\"1500\" ) }) public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) { int age = 10/0; String result = paymentHystrixService.paymentInfo_TimeOut(id); return result; } //善后方法 public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id){ return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\"; } } ","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:5:2","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"Hystrix之全局服务降级DefaultProperties 目前问题1 每个业务方法对应一个兜底的方法，代码膨胀 controller 解决方法 每个类配置一个公用的兜底方法 在类上添加注解DefaultProperties 在方法上添加注解@HystrixCommand 不写参数 写了就是单独的 package com.atguigu.springcloud.controller; import com.atguigu.springcloud.service.PaymentHystrixService; import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties; import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController @Slf4j @DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\") public class OrderHystirxController { @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(\"/consumer/payment/hystrix/ok/{id}\") public String paymentInfo_OK(@PathVariable(\"id\") Integer id) { String result = paymentHystrixService.paymentInfo_OK(id); return result; } @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\") // @HystrixCommand( // fallbackMethod = \"paymentTimeOutFallbackMethod\", // commandProperties = { // @HystrixProperty( // name=\"execution.isolation.thread.timeoutInMilliseconds\", // value=\"1500\" // ) // }) @HystrixCommand public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) { int age = 10/0; String result = paymentHystrixService.paymentInfo_TimeOut(id); return result; } //善后方法 public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id){ return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\"; } //下面是全局fallback public String payment_Global_FallbackMethod(){ return \"Global异常处理信息，请稍后再试，全局\"; } } ","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:5:3","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"Hystrix之通配服务降级FeignFallback 统一和自定义的分开，代码混乱 服务降级，客户端去调用服务端，碰上服务端宕机或关闭 本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦 未来我们要面对的异常 运行 超时 宕机 修改cloud-consumer-feign-hystrix-order80 service 新建PaymentFallbackService类 实现 PaymentHystrixService接口 package com.atguigu.springcloud.service; import org.springframework.stereotype.Component; @Component public class PaymentFallbackService implements PaymentHystrixService{ @Override public String paymentInfo_OK(Integer id) { return \"--- PaymentFallbackService --- fallback --- paymentInfo_OK\"; } @Override public String paymentInfo_TimeOut(Integer id) { return \"--- PaymentFallbackService --- fallback --- paymentInfo_TimeOut\"; } } 修改 PaymentHystrixService接口 package com.atguigu.springcloud.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; /** */ @Component @FeignClient(value = \"cloud-provider-hystrix-payment\",fallback = PaymentFallbackService.class) public interface PaymentHystrixService { @GetMapping(\"/payment/hystrix/ok/{id}\") public String paymentInfo_OK(@PathVariable(\"id\") Integer id); @GetMapping(\"/payment/hystrix/timeout/{id}\") public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id); } 测试 单个eureka先启动7001 PaymentHystrixMain8001启动 正常访问测试 - http://localhost/consumer/payment/hystrix/ok/1 故意关闭微服务8001 客户端自己调用提示 - 此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。 服务熔断 断路器，相当于保险丝。 熔断机制概述 熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。 在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand。 修改 cloud-provider-hystrix-payment8001 service @Service public class PaymentService{ ... //=====服务熔断 @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = { @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),// 是否开启断路器 @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),// 请求次数 @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"), // 时间窗口期 @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"),// 失败率达到多少后跳闸 }) public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id) { if(id \u003c 0) { throw new RuntimeException(\"******id 不能负数\"); } String serialNumber = IdUtil.simpleUUID(); return Thread.currentThread().getName()+\"\\t\"+\"调用成功，流水号: \" + serialNumber; } public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id) { return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~ id: \" +id; } } controller @RestController @Slf4j public class PaymentController { @Resource private PaymentService paymentService; ... //====服务熔断 @GetMapping(\"/payment/circuit/{id}\") public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id) { String result = paymentService.paymentCircuitBreaker(id); log.info(\"****result: \"+result); return result; } } 测试 正确 - http://localhost:8001/payment/circuit/1 错误 - http://localhost:8001/payment/circuit/-1 多次错误，再来次正确，但错误得显示 重点测试 - 多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行 所有配置 @HystrixCommand(fallbackMethod = \"fallbackMethod\", groupKey = \"strGroupCommand\", commandKey = \"strCommand\", threadPoolKey = \"strThreadPool\", commandProperties = { // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离 @HystrixProperty(name = \"execution.isolation.strategy\", value = \"THREAD\"), // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数） @HystrixProperty(name = \"execution.isolation.semaphore.maxConcurrentRequests\", value = \"10\"), // 配置命令执行的超时时间 @HystrixProperty(name = \"execution.isolation.thread.timeoutinMilliseconds\", value = \"10\"), // 是否启用超时时间 @HystrixProperty(name = \"execution.timeout.enabled\", value = \"true\"), // 执行超时的时候是否中断 @HystrixProperty(name = \"execution.isolation.thread.interruptOnTimeout\", value = \"true\"), // 执行被取消的时候是否中断 @HystrixProperty(name = \"execution.isolation.thread.interrupt","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:5:4","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"实战 新版本Hystrix需要在主启动类PaymentHystrixMain8001（被监控的启动类）中指定监控路径 package com.atguigu.springcloud; import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.context.annotation.Bean; @SpringBootApplication @EnableEurekaClient @EnableCircuitBreaker public class PaymentHystrixMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentHystrixMain8001.class, args); } /** *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑 *ServletRegistrationBean因为springboot的默认路径不是\"/hystrix.stream\"， *只要在自己的项目里配置上下面的servlet就可以了 *否则，Unable to connect to Command Metric Stream 404 */ @Bean public ServletRegistrationBean getServlet() { HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(\"/hystrix.stream\"); registrationBean.setName(\"HystrixMetricsStreamServlet\"); return registrationBean; } } 9001监控8001 - 填写监控地址 - http://localhost:8001/hystrix.stream 到 http://localhost:9001/hystrix页面的输入框。 ","date":"2021-05-13","objectID":"/springcloud2020-hystrix/:6:0","tags":["微服务","框架"],"title":"springcloud2020 Hystrix","uri":"/springcloud2020-hystrix/"},{"categories":["SpringCloud"],"content":"springcloud2020 OpenFeign Feign可以与Eureka和Ribbon组合使用以支持负载均衡 ","date":"2021-05-10","objectID":"/springcloud2020-openfeign/:0:0","tags":["微服务","框架"],"title":"springcloud2020 OpenFeign","uri":"/springcloud2020-openfeign/"},{"categories":["SpringCloud"],"content":"OpenFeign服务调用 新建cloud-consumer-feign-order80 POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-consumer-feign-order80\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--openfeign--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--eureka client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--web--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--一般基础通用配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 80 spring: application: name: cloud-order-service eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ 主启动 @EnableFeignClients package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableFeignClients public class OrderFeignMain80 { public static void main(String[] args) { SpringApplication.run(OrderFeignMain80.class, args); } } 业务类service 直接复制对应微服务的controller 注意⚠️： 请求路径注意复制完整 package com.atguigu.springcloud.service; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @Component @FeignClient(value = \"cloud-payment-service\") public interface PaymentFeignService { @GetMapping(value = \"/payment/get/{id}\") public CommonResult getPamentById(@PathVariable(\"id\")Long id); } controller package com.atguigu.springcloud.controller; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import com.atguigu.springcloud.service.PaymentFeignService; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController @Slf4j public class OrderFeignController { @Resource private PaymentFeignService paymentFeignService; @GetMapping(value = \"/consumer/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id) { return paymentFeignService.getPamentById(id); } } ","date":"2021-05-10","objectID":"/springcloud2020-openfeign/:1:0","tags":["微服务","框架"],"title":"springcloud2020 OpenFeign","uri":"/springcloud2020-openfeign/"},{"categories":["SpringCloud"],"content":"OpenFeign超时控制 OpenFeign默认等待1秒钟，超过后报错 yml配置 #设置feign客户端超时时间(OpenFeign默认支持ribbon)(单位：毫秒) ribbon: #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间 ReadTimeout: 5000 #指的是建立连接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 ","date":"2021-05-10","objectID":"/springcloud2020-openfeign/:2:0","tags":["微服务","框架"],"title":"springcloud2020 OpenFeign","uri":"/springcloud2020-openfeign/"},{"categories":["SpringCloud"],"content":"OpenFeign日志增强 配置日志bean NONE：默认的，不显示任何日志; BASIC：仅记录请求方法、URL、响应状态码及执行时间; HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息; FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。 package com.atguigu.springcloud.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FeignConfig { @Bean Logger.Level feignLoggerLevel() { //NONE：默认的，不显示任何日志; //BASIC：仅记录请求方法、URL、响应状态码及执行时间; //HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息; //FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。 return Logger.Level.FULL; } } YML文件里需要开启日志的Feign客户端 logging: level: # feign日志以什么级别监控哪个接口 com.lun.springcloud.service.PaymentFeignService: debug ","date":"2021-05-10","objectID":"/springcloud2020-openfeign/:3:0","tags":["微服务","框架"],"title":"springcloud2020 OpenFeign","uri":"/springcloud2020-openfeign/"},{"categories":["SpringCloud"],"content":"springcloud2020 三个注册中心异同点(CAP理论) 组件名 语言CAP 服务健康检查 对外暴露接口 Spring Cloud集成 Eureka Java AP 可配支持 HTTP Consul Go CP 支持 HTTP/DNS Zookeeper Java CP 支持客户端 已集成 CAP： C：Consistency (强一致性) A：Availability (可用性) P：Partition tolerance （分区容错性) 最多只能同时较好的满足两个。 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求。 因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类: CA - 单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 ","date":"2021-05-06","objectID":"/springcloud2020-%E4%B8%89%E4%B8%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%BC%82%E5%90%8C%E7%82%B9cap%E7%90%86%E8%AE%BA/:0:0","tags":["微服务","框架"],"title":"springcloud2020 三个注册中心异同点(CAP理论)","uri":"/springcloud2020-%E4%B8%89%E4%B8%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%BC%82%E5%90%8C%E7%82%B9cap%E7%90%86%E8%AE%BA/"},{"categories":["SpringCloud"],"content":"springcloud2020 Consul 微服务服务注册配置中心 ","date":"2021-05-05","objectID":"/springcloud2020-consul/:0:0","tags":["微服务","框架"],"title":"springcloud2020 Consul","uri":"/springcloud2020-consul/"},{"categories":["SpringCloud"],"content":"1.安装配置（mac） 下载 解压 将文件放置在 /usr/local/bin 目录下 检测安装情况 consul --version ","date":"2021-05-05","objectID":"/springcloud2020-consul/:1:0","tags":["微服务","框架"],"title":"springcloud2020 Consul","uri":"/springcloud2020-consul/"},{"categories":["SpringCloud"],"content":"2.相关命令 - 前台启动 - 浏览器访问:http://localhost:8500 - ctrl + c 即可关闭 consul consul agent -dev ","date":"2021-05-05","objectID":"/springcloud2020-consul/:2:0","tags":["微服务","框架"],"title":"springcloud2020 Consul","uri":"/springcloud2020-consul/"},{"categories":["SpringCloud"],"content":"3.服务提供者注册进Consul 建module cloud-providerconsul-payment8006 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-providerconsul-payment8006\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c!--SpringCloud consul-server --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-consul-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.hutool\u003c/groupId\u003e \u003cartifactId\u003ehutool-all\u003c/artifactId\u003e \u003cversion\u003eRELEASE\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.hutool\u003c/groupId\u003e \u003cartifactId\u003ehutool-all\u003c/artifactId\u003e \u003cversion\u003eRELEASE\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml ###consul服务端口号 server: port: 8006 spring: application: name: consul-provider-payment ####consul注册中心地址 cloud: consul: host: localhost port: 8500 discovery: #hostname: 127.0.0.1 service-name: ${spring.application.name} 启动类 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class PaymentMain8006 { public static void main(String[] args) { SpringApplication.run(PaymentMain8006.class, args); } } 业务类 package com.atguigu.springcloud.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.UUID; @RestController @Slf4j public class PaymentController { @Value(\"${server.port}\") private String serverPort; @RequestMapping(value = \"/payment/consul\") public String paymentConsul() { return \"springcloud with consul: \"+serverPort+\"\\t \"+ UUID.randomUUID().toString(); } } 测试 启动后 在网站上看到服务名称 测试controller ","date":"2021-05-05","objectID":"/springcloud2020-consul/:3:0","tags":["微服务","框架"],"title":"springcloud2020 Consul","uri":"/springcloud2020-consul/"},{"categories":["SpringCloud"],"content":"4.服务消费者注册进Consul 建module cloud-consumerconsul-order80 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-consumerconsul-order80\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud consul-server --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-consul-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml ###consul服务端口号 server: port: 80 spring: application: name: cloud-consumer-order ####consul注册中心地址 cloud: consul: host: localhost port: 8500 discovery: #hostname: 127.0.0.1 service-name: ${spring.application.name} 启动类 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务 public class OrderConsulMain80 { public static void main(String[] args) { SpringApplication.run(OrderConsulMain80.class, args); } } 配置RestTemplate package com.atguigu.springcloud.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced public RestTemplate getRestTemplate(){ return new RestTemplate(); } } controller package com.atguigu.springcloud.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import javax.annotation.Resource; @RestController @Slf4j public class OrderConsulController { public static final String INVOKE_URL = \"http://consul-provider-payment\"; @Resource private RestTemplate restTemplate; @GetMapping(value = \"/consumer/payment/consul\") public String paymentInfo() { String result = restTemplate.getForObject(INVOKE_URL+\"/payment/consul\",String.class); return result; } } 测试 运行consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80 http://localhost:8500/ 主页会显示出consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80三服务。 访问测试地址 - http://localhost/consumer/payment/consul ","date":"2021-05-05","objectID":"/springcloud2020-consul/:4:0","tags":["微服务","框架"],"title":"springcloud2020 Consul","uri":"/springcloud2020-consul/"},{"categories":["SpringCloud"],"content":"springcloud2020 cloud-consumer-order80 消费者 ","date":"2021-05-04","objectID":"/springcloud2020-cloud-consumer-order80-%E6%B6%88%E8%B4%B9%E8%80%85/:0:0","tags":["微服务","框架"],"title":"springcloud2020 cloud-consumer-order80 消费者","uri":"/springcloud2020-cloud-consumer-order80-%E6%B6%88%E8%B4%B9%E8%80%85/"},{"categories":["SpringCloud"],"content":"1.创建 建立module \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-consumer-order80\u003c/artifactId\u003e pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-consumer-order80\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e yml server: port: 80 主启动 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class OrderMain80 { public static void main(String[] args) { SpringApplication.run(OrderMain80.class,args); } } ","date":"2021-05-04","objectID":"/springcloud2020-cloud-consumer-order80-%E6%B6%88%E8%B4%B9%E8%80%85/:1:0","tags":["微服务","框架"],"title":"springcloud2020 cloud-consumer-order80 消费者","uri":"/springcloud2020-cloud-consumer-order80-%E6%B6%88%E8%B4%B9%E8%80%85/"},{"categories":["SpringCloud"],"content":"2.业务 entities cloud-provider-payment8001 中复制粘贴 Payment.java CommonResult.java RestTemplate RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集 使用： 使用restTemplate访问restful接口非常的简单粗暴无脑。 (url, requestMap, ResponseBean.class)这三个参数分别代表。 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。 RestTemplate配置 package com.atguigu.springcloud.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean public RestTemplate getRestTemplate(){ return new RestTemplate(); } } RestTemplate使用 controller package com.atguigu.springcloud.controller; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import org.springframework.web.client.RestTemplate; @RestController @Slf4j public class PaymentController { public static final String PAYMENT_URL = \"http://localhost:8001\"; @Autowired private RestTemplate restTemplate; @PostMapping(\"/consumer/payment/create\") public CommonResult\u003cPayment\u003e create(Payment payment){ return restTemplate.postForObject(PAYMENT_URL+\"/payment/create\",payment,CommonResult.class); } @GetMapping(\"/consumer/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id){ return restTemplate.getForObject(PAYMENT_URL+\"/payment/get/\"+id,CommonResult.class); } } 测试出现问题 问题：create方法无法保存信息（数据传输无法接收） 解决：在cloud-provider-payment8001工程的PaymentController中create添加@RequestBody注解。 package com.atguigu.springcloud.controller; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import com.atguigu.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; @RestController @Slf4j @RequestMapping(\"/payment\") public class PaymentController { @Autowired private PaymentService paymentService; @PostMapping(value = \"/create\") public CommonResult create(@RequestBody Payment payment){ int result = paymentService.create(payment); log.info(\"结果：\"+ result); if (result \u003e 0){ return new CommonResult(200,\"插入成功\",result); } return new CommonResult(444,\"插入错误\",null); } @GetMapping(value = \"/get/{id}\") public CommonResult getPamentById(@PathVariable(\"id\")Long id){ Payment paymentById = paymentService.getPaymentById(id); log.info(\"结果：\"+ paymentById); if (paymentById != null){ return new CommonResult(200,\"查询成功\",paymentById); } return new CommonResult(444,\"没有对应记录\"+id,null); } } 代码重构（重复了entities） ","date":"2021-05-04","objectID":"/springcloud2020-cloud-consumer-order80-%E6%B6%88%E8%B4%B9%E8%80%85/:2:0","tags":["微服务","框架"],"title":"springcloud2020 cloud-consumer-order80 消费者","uri":"/springcloud2020-cloud-consumer-order80-%E6%B6%88%E8%B4%B9%E8%80%85/"},{"categories":["SpringCloud"],"content":"1.新建cloud-api-commons 建立module pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.hutool\u003c/groupId\u003e \u003cartifactId\u003ehutool-all\u003c/artifactId\u003e \u003cversion\u003e5.1.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e entities 将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移至cloud-api-commons工程下 初始化cloud-api-commons maven clean install 订单80和支付8001分别改造 将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移除 引入cloud-api-commons依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.lun.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-05-04","objectID":"/springcloud2020-cloud-consumer-order80-%E6%B6%88%E8%B4%B9%E8%80%85/:3:0","tags":["微服务","框架"],"title":"springcloud2020 cloud-consumer-order80 消费者","uri":"/springcloud2020-cloud-consumer-order80-%E6%B6%88%E8%B4%B9%E8%80%85/"},{"categories":["SpringCloud"],"content":"springcloud2020 cloud-provider-payment8001模块 ","date":"2021-05-03","objectID":"/springcloud2020-cloud-provider-payment8001%E6%A8%A1%E5%9D%97/:1:0","tags":["微服务","框架"],"title":"springcloud2020  cloud-provider-payment8001模块","uri":"/springcloud2020-cloud-provider-payment8001%E6%A8%A1%E5%9D%97/"},{"categories":["SpringCloud"],"content":"1.创建 建model name：cloud-provider-payment8001 改pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-provider-payment8001\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 写yml server: port: 8001 spring: application: name: cloud-payment-service #服务名称 datasource: type: com.alibaba.druid.pool.DruidDataSource #当前数据源操作类型 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://locahost:3306/cloud?characterEncoding=utf8\u0026useSSL=false\u0026serverTimezone=UTC\u0026rewriteBatchedStatements=true username: password: mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.atguigu.springcloud.entities #所有entity别名所在包 主启动 package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class,args); } } ","date":"2021-05-03","objectID":"/springcloud2020-cloud-provider-payment8001%E6%A8%A1%E5%9D%97/:2:0","tags":["微服务","框架"],"title":"springcloud2020  cloud-provider-payment8001模块","uri":"/springcloud2020-cloud-provider-payment8001%E6%A8%A1%E5%9D%97/"},{"categories":["SpringCloud"],"content":"2.业务 数据库 create table payment( id bigint(20) not null auto_increment primary key comment 'id', serial varchar(200) default '' ) entities package com.atguigu.springcloud.entities; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; @Data @AllArgsConstructor @NoArgsConstructor public class Payment implements Serializable { private long id; private String serial; } 前后端分离 封装 package com.atguigu.springcloud.entities; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class CommonResult\u003cT\u003e { //code + 说明 private Integer code; private String message; private T data; public CommonResult(Integer code,String message) { this(code,message,null); } } dao dao package com.atguigu.springcloud.dao; import com.atguigu.springcloud.entities.Payment; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; @Mapper public interface PaymentDao { //add public int create(Payment payment); //select public Payment getPaymentById(@Param(\"id\") Long id); } mapper(resources/mapper/PaymentMapper.xml) \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" \u003e \u003cmapper namespace=\"com.atguigu.springcloud.dao.PaymentDao\"\u003e \u003cresultMap id=\"BaseResultMap\" type=\"Payment\"\u003e \u003cid column=\"id\" property=\"id\" jdbcType=\"BIGINT\"/\u003e \u003cid column=\"serial\" property=\"serial\" jdbcType=\"VARCHAR\"/\u003e \u003c/resultMap\u003e \u003c!-- useGeneratedKeys=\"true\" keyProperty=\"id\" 获取自动生成的主键值 --\u003e \u003cinsert id=\"create\" parameterType=\"Payment\" useGeneratedKeys=\"true\" keyProperty=\"id\"\u003e insert into payment(serial) values(#{serial}); \u003c/insert\u003e \u003cselect id=\"getPaymentById\" parameterType=\"Long\" resultMap=\"BaseResultMap\"\u003e select * from payment where id=#{id}; \u003c/select\u003e \u003c/mapper\u003e yml配置 mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.atguigu.springcloud.entities #所有entity别名所在包 Service 接口 package com.atguigu.springcloud.service; import com.atguigu.springcloud.entities.Payment; public interface PaymentService { //add public int create(Payment payment); //select public Payment getPaymentById(Long id); } 实现类 package com.atguigu.springcloud.service.impl; import com.atguigu.springcloud.dao.PaymentDao; import com.atguigu.springcloud.entities.Payment; import com.atguigu.springcloud.service.PaymentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class PaymentServiceImpl implements PaymentService { @Autowired private PaymentDao paymentDao; @Override public int create(Payment payment) { int i = paymentDao.create(payment); return i; } @Override public Payment getPaymentById(Long id) { Payment payment = paymentDao.getPaymentById(id); return payment; } } controller package com.atguigu.springcloud.controller; import com.atguigu.springcloud.entities.CommonResult; import com.atguigu.springcloud.entities.Payment; import com.atguigu.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; @RestController @Slf4j @RequestMapping(\"/payment\") public class PaymentController { @Autowired private PaymentService paymentService; @PostMapping(value = \"/create\") public CommonResult create(Payment payment){ int result = paymentService.create(payment); log.info(\"结果：\"+ result); if (result \u003e 0){ return new CommonResult(200,\"插入成功\",result); } return new CommonResult(444,\"插入错误\",null); } @GetMapping(value = \"/get/{id}\") public CommonResult getPamentById(@PathVariable(\"id\")Long id){ Payment paymentById = paymentService.getPaymentById(id); log.info(\"结果：\"+ paymentById); if (paymentById != null){ return new CommonResult(200,\"查询成功\",paymentById); } return new CommonResult(444,\"没有对应记录\"+id,null); } } ","date":"2021-05-03","objectID":"/springcloud2020-cloud-provider-payment8001%E6%A8%A1%E5%9D%97/:3:0","tags":["微服务","框架"],"title":"springcloud2020  cloud-provider-payment8001模块","uri":"/springcloud2020-cloud-provider-payment8001%E6%A8%A1%E5%9D%97/"},{"categories":["SpringCloud"],"content":"springcloud2020 父工程建立 ","date":"2021-05-03","objectID":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/:0:0","tags":["微服务","框架"],"title":"springcloud2020 父工程建立","uri":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/"},{"categories":["SpringCloud"],"content":"0.版本约束 cloud:Hoxton.SR1 boot:2.2.2.RELEASE cloud alibaba:2.1.0.RELEASE java：java8 Maven 3.5以上 Mysql:5.7以上 ","date":"2021-05-03","objectID":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/:1:0","tags":["微服务","框架"],"title":"springcloud2020 父工程建立","uri":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/"},{"categories":["SpringCloud"],"content":"1.基本参数 \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e ","date":"2021-05-03","objectID":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/:2:0","tags":["微服务","框架"],"title":"springcloud2020 父工程建立","uri":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/"},{"categories":["SpringCloud"],"content":"2.idea配置 编码 注解激活生效 ","date":"2021-05-03","objectID":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/:3:0","tags":["微服务","框架"],"title":"springcloud2020 父工程建立","uri":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/"},{"categories":["SpringCloud"],"content":"3.pom 注意： pom dependencyManagement 和 dependencies区别 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.atguigu.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud2020\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003c!--统一管理jar包和版本--\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003cjunit.version\u003e4.12\u003c/junit.version\u003e \u003clog4j.version\u003e1.2.17\u003c/log4j.version\u003e \u003clombok.version\u003e1.16.18\u003c/lombok.version\u003e \u003cmysql.version\u003e8.0.18\u003c/mysql.version\u003e \u003cdruid.verison\u003e1.1.16\u003c/druid.verison\u003e \u003cmybatis.spring.boot.verison\u003e1.3.0\u003c/mybatis.spring.boot.verison\u003e \u003c/properties\u003e \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003c!--spring boot 2.2.2--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.2.2.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud Hoxton.SR1--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-dependencies\u003c/artifactId\u003e \u003cversion\u003eHoxton.SR1\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud alibaba 2.1.0.RELEASE--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.2.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- MySql --\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e${mysql.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- Druid --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${druid.verison}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- mybatis-springboot整合 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${mybatis.spring.boot.verison}\u003c/version\u003e \u003c/dependency\u003e \u003c!--lombok--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e${lombok.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e${junit.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- log4j --\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e${log4j.version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cfork\u003etrue\u003c/fork\u003e \u003caddResources\u003etrue\u003c/addResources\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e ","date":"2021-05-03","objectID":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/:4:0","tags":["微服务","框架"],"title":"springcloud2020 父工程建立","uri":"/springcloud2020-%E7%88%B6%E5%B7%A5%E7%A8%8B%E5%BB%BA%E7%AB%8B/"},{"categories":["数据库"],"content":"mac下redis安装配置 ","date":"2021-05-02","objectID":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:0:0","tags":["安装"],"title":"mac下redis安装配置","uri":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"1.下载Redis官网 ","date":"2021-05-02","objectID":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:0","tags":["安装"],"title":"mac下redis安装配置","uri":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"2.放在可靠位置 例如：/usr/local/ ","date":"2021-05-02","objectID":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:0","tags":["安装"],"title":"mac下redis安装配置","uri":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"3.编译 cd /usr/local/redis sudo make test sudo make isntall ","date":"2021-05-02","objectID":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:3:0","tags":["安装"],"title":"mac下redis安装配置","uri":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"4.运行 redis-server ","date":"2021-05-02","objectID":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:4:0","tags":["安装"],"title":"mac下redis安装配置","uri":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"5.其他命令 - 停止redis server服务 redis-cli shutdown - 启动redis客户端 redis-cli ","date":"2021-05-02","objectID":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:0","tags":["安装"],"title":"mac下redis安装配置","uri":"/mac%E4%B8%8Bredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"Typora使用Custom Command上传图片配置 ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:0:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"1.使用 node 安装 PicGo-Core sudo npm install -g picgo ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:1:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"2.使用 picgo 命令安装 gitee-uploader 插件 picgo install gitee-uploader ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:2:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"3.配置 Typroa 上传服务设定 上传服务：Custom Command 命令：[your node path] [your picgo path] upload 例：/usr/local/bin/node /usr/local/lib/node_modules/picgo/bin/picgo upload ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:3:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"4.配置文件 以阿里云为例 位置：/Users/\u003cUserName\u003e/.picgo/config.json { \"picBed\": { \"uploader\": \"aliyun\", \"current\": \"aliyun\", \"transformer\": \"path\", \"aliyun\": { \"accessKeyId\": \"\", \"accessKeySecret\": \"\", \"bucket\": \"\", // 存储空间名 \"area\": \"\", // 存储区域代号 \"path\": \"\", // 自定义存储路径 \"customUrl\": \"\", // 自定义域名，注意要加 http://或者 https:// \"options\": \"\" // 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+ } }, \"picgoPlugins\": {} } ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:4:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"5.配置时间戳重命名文件 安装插件 picgo install super-prefix 配置/Users/\u003cUserName\u003e/.picgo/config.json { \"picBed\": { ··· } }, \"picgoPlugins\": { \"picgo-plugin-super-prefix\": true, \"picgo-plugin-gitee-uploader\": true }, \"picgo-plugin-super-prefix\": { \"prefixFormat\": \"YYYY/MM/DD/\", \"fileFormat\": \"YYYYMMDD-HHmmss\" } } ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:5:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"使用docker搭建开发环境记录 docker start 容器名 docker stop 容器名 docker restart 容器名 docker run = docker create + docker start ","date":"2021-04-29","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/:0:0","tags":["docker","容器化"],"title":"使用docker搭建开发环境记录","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":"mysql # 拉取镜像 docker pull mysql:5.7 # 创建实例并启动 # -p 映射端口 # --name 名称 # -v 映射文件 # -e MYSQL_ROOT_PASSWORD mysql密码 # -d 后台运行并运行 docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 # 进入容器 docker exec -it mysql /bin/bash # 退出容器 exit # 配置my.conf ## 1.在容器外编辑配置文件 vi /mydata/mysql/conf/my.cnf [client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] init_connect='SET conllation_connection = utf8_unicode_ci' init_connect='SET NAMES utf8' character-set-server=utf8 collation-server=utf8_unicode_ci skip-character-set-client-handshake skip-name-resolve ## 2. 重启mysql容器 docker restart mysql ## 3. 进入mysql容器验证 docker exec -it mysql /bin/bash cat /etc/mysql/my.cnf ","date":"2021-04-29","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/:0:1","tags":["docker","容器化"],"title":"使用docker搭建开发环境记录","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":"Redis # 拉取镜像 docker pull redis # 配置文件 本地：/mydata/redis/data/redis.conf 提前准备好 主要配置 bind 127.0.0.1 #注释掉这部分，使redis可以外部访问 daemonize no#用守护线程的方式启动 requirepass 你的密码#给redis设置密码 appendonly yes#redis持久化　默认是no tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300 # 创建实例并启动 docker run -p 6379:6379 --name redis -v /mydata/redis/data/redis.conf:/etc/redis/redis.conf -v /mydata/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes ","date":"2021-04-29","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/:0:2","tags":["docker","容器化"],"title":"使用docker搭建开发环境记录","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":"Rabbitmq # 拉取镜像management带控制台 docker pull rabbitmq:management # 创建实例并启动 docker run -d --hostname my-rabbit --name rabbit -v /mydata/rabbitmq:/var/lib/rabbitmq -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=Mm_123456 -p 15672:15672 -p 5672:5672 rabbitmq:management ","date":"2021-04-29","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/:0:3","tags":["docker","容器化"],"title":"使用docker搭建开发环境记录","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":"mongo # 拉取镜像 docker pull mongo # 创建实例并启动 docker run -p 27017:27017 -v /mydata/mongo:/data/db --name mongodb -d mongo ","date":"2021-04-29","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/:0:4","tags":["docker","容器化"],"title":"使用docker搭建开发环境记录","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":"elasticsearch # 拉取镜像 docker pull elasticsearch:7.7.0 # 创建实例并启动 docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -d elasticsearch:7.7.0 docker run -d --name elasticsearch -e \"ES_JAVA_OPTS=-Xms256m -Xmx256m\" -e \"discovery.type=single-node\" -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -p 9200:9200 -p 9300:9300 elasticsearch:7.7.0 ","date":"2021-04-29","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/:0:5","tags":["docker","容器化"],"title":"使用docker搭建开发环境记录","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"设计模式-享元模式 运用共享技术来有效地支持大量细粒度对象的复用 ","date":"2021-01-17","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"享元模式的结构与实现 享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。 内部状态指对象共享出来的信息，存储在享元信息内部，并且不回随环境的改变而改变； 外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享。 比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。 享元模式的本质是缓存共享对象，降低内存消耗。 1. 模式的结构 享元模式的主要角色有如下。 抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 其中： UnsharedConcreteFlyweight 是非享元角色，里面包含了非共享的外部状态信息 info； Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入； ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口； FlyweightFactory 是享元工厂角色，它是关键字 key 来管理具体享元； 客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。 ","date":"2021-01-17","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 package com.designPattern.flyweightPattern; import java.util.HashMap; /** * 享元模式 * 运用共享技术来有效地支持大量细粒度对象的复用 * * 在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。 * 创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。 * * 例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、 * 交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能 * 把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。 */ public class FlyweightPattern { public static void main(String[] args) { FlyweightFactory factory = new FlyweightFactory(); Flyweight f01 = factory.getFlyweight(\"a\"); Flyweight f02 = factory.getFlyweight(\"a\"); Flyweight f03 = factory.getFlyweight(\"a\"); Flyweight f11 = factory.getFlyweight(\"b\"); Flyweight f12 = factory.getFlyweight(\"b\"); System.out.println(f01 == f11); System.out.println(f01 == f02); f01.operation(new UnsharedConcreteFlyweight(\"第1次调用a。\")); f02.operation(new UnsharedConcreteFlyweight(\"第2次调用a。\")); f03.operation(new UnsharedConcreteFlyweight(\"第3次调用a。\")); f11.operation(new UnsharedConcreteFlyweight(\"第1次调用b。\")); f12.operation(new UnsharedConcreteFlyweight(\"第2次调用b。\")); } } //非享元角色 class UnsharedConcreteFlyweight { private String info; UnsharedConcreteFlyweight(String info) { this.info = info; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } //抽象享元角色 interface Flyweight { void operation(UnsharedConcreteFlyweight state); } //具体享元角色 class ConcreteFlyweight implements Flyweight { private String key; ConcreteFlyweight(String key) { this.key = key; System.out.println(\"具体享元\" + key + \"被创建！\"); } public void operation(UnsharedConcreteFlyweight outState) { System.out.print(\"具体享元\" + key + \"被调用，\"); System.out.println(\"非享元信息是:\" + outState.getInfo()); } } //享元工厂角色 class FlyweightFactory { private HashMap\u003cString, Flyweight\u003e flyweights = new HashMap\u003c\u003e(); public Flyweight getFlyweight(String key) { Flyweight flyweight = flyweights.get(key); if (flyweight != null) { System.out.println(\"具体享元\" + key + \"已经存在，被成功获取！\"); } else { flyweight = new ConcreteFlyweight(key); flyweights.put(key, flyweight); } return flyweight; } } ","date":"2021-01-17","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"输出结果 参考文档 ","date":"2021-01-17","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式-享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"随笔-设计模式-简单工厂 学习标准规范类 package org.jsh.newinstance; public interface ICourse { void learn(); } 学习html类 package org.jsh.newinstance; public class HtmlCourse implements ICourse{ @Override public void learn() { System.out.println(\"html\"); } } 学习Java类 package org.jsh.newinstance; public class JavaCourse implements ICourse{ @Override public void learn() { System.out.println(\"java\"); } } 学习代工厂（Factory） package org.jsh.factory; import org.jsh.newinstance.HtmlCourse; import org.jsh.newinstance.ICourse; import org.jsh.newinstance.JavaCourse; public class CourseFactory { // 根据名字获取 public static ICourse getCourse(String name) { if(name.equals(\"java\")) { return new JavaCourse(); }else { return new HtmlCourse(); } } } 演示 public void learn(String name) { ICourse course = CourseFactory.getCourse(name); course.learn(); } ","date":"2021-01-17","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/:0:0","tags":["设计模式"],"title":"设计模式-简单工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"},{"categories":["Java"],"content":"设计模式-外观模式 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例） ","date":"2021-01-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-外观模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 package com.designPattern.facadePattern; /** * 外观模式 * 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例） */ public class FacadePattern { public static void main(String[] args) { Computer computer = new Computer(); computer.startup(); computer.shutdown(); } } class CPU { public void startup(){ System.out.println(\"cpu startup!\"); } public void shutdown(){ System.out.println(\"cpu shutdown!\"); } } class Memory { public void startup(){ System.out.println(\"memory startup!\"); } public void shutdown(){ System.out.println(\"memory shutdown!\"); } } class Disk { public void startup(){ System.out.println(\"disk startup!\"); } public void shutdown(){ System.out.println(\"disk shutdown!\"); } } class Computer { private CPU cpu; private Memory memory; private Disk disk; public Computer(){ cpu = new CPU(); memory = new Memory(); disk = new Disk(); } public void startup(){ System.out.println(\"start the computer!\"); cpu.startup(); memory.startup(); disk.startup(); System.out.println(\"start computer finished!\"); } public void shutdown(){ System.out.println(\"begin to close the computer!\"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(\"computer closed!\"); } } 运行结果 ","date":"2021-01-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-外观模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-组合模式 将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树 ","date":"2021-01-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 package com.designPattern.compositePattern; import java.util.ArrayList; import java.util.List; /** * 组合模式 * 类似树结构 * 将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树 */ public class CompositePattern { public static void main(String[] args) { TreeNode treeNode = new TreeNode(\"hhh\"); TreeNode treeNode1 = new TreeNode(\"hhh\"); treeNode.add(treeNode1); System.out.println(treeNode); } } class TreeNode { private String name; private TreeNode parent; private List\u003cTreeNode\u003e children = new ArrayList\u003c\u003e(); public TreeNode(String name){ this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public TreeNode getParent() { return parent; } public void setParent(TreeNode parent) { this.parent = parent; } //添加孩子节点 public void add(TreeNode node){ children.add(node); } //删除孩子节点 public void remove(TreeNode node){ children.remove(node); } //获取孩子节点 public List\u003cTreeNode\u003e getChildren() { return children; } @Override public String toString() { return \"TreeNode{\" + \"name='\" + name + '\\'' + \", parent=\" + parent + \", children=\" + children + '}'; } } 运行结果 ","date":"2021-01-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-代理模式 代理模式就是多一个代理类出来，替原对象进行一些操作 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 package com.designPattern.proxyPattern; /** * 代理模式 * 代理模式就是多一个代理类出来，替原对象进行一些操作 * 代理模式的应用场景： * 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： * 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 * * 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 * * 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ */ public class ProxyPattern { public static void main(String[] args) { Sourceable sourceable = new Proxy(); sourceable.method(); } } interface Sourceable { void method(); } class Source implements Sourceable { @Override public void method() { System.out.println(\"the original method!\"); } } //代理类 class Proxy implements Sourceable { private Source source; public Proxy() { this.source = new Source(); } @Override public void method() { before(); source.method(); atfer(); } private void atfer() { System.out.println(\"after proxy!\"); } private void before() { System.out.println(\"before proxy!\"); } } 输出 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代理模式的应用场景 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-桥接模式 处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-桥接模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"问题 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-桥接模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"解决 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-桥接模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 创建电脑品牌 // 创建电脑牌子 class Lenovo implements Brand { @Override public void sale() { System.out.println(\"出售联想\"); } } class Dell implements Brand { @Override public void sale() { System.out.println(\"出售戴尔\"); } } // 新增牌子是十分方便的 class Shenzhou implements Brand { @Override public void sale() { System.out.println(\"出售神州\"); } } 创建电脑以及类型 class Computer { protected Brand brand; public Computer(Brand b) { this.brand = b; } public void sale(){ brand.sale(); } } // 创建电脑类型 class Desktop extends Computer { public Desktop(Brand b) { super(b); } @Override public void sale() { super.sale(); System.out.println(\"出售台式电脑\"); } } class Laptop extends Computer { public Laptop(Brand b) { super(b); } @Override public void sale() { super.sale(); System.out.println(\"出售笔记本\"); } } 使用 public class BridgePattern { public static void main(String[] args) { Computer computer = new Desktop(new Dell()); computer.sale(); } } ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式-桥接模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"完整代码 package com.designPattern.bridgePattern; /** * 桥接模式 * 处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。 */ public class BridgePattern { public static void main(String[] args) { Computer computer = new Desktop(new Dell()); computer.sale(); } } //创建电脑接口 interface Brand { void sale(); } // 创建电脑牌子 class Lenovo implements Brand { @Override public void sale() { System.out.println(\"出售联想\"); } } class Dell implements Brand { @Override public void sale() { System.out.println(\"出售戴尔\"); } } // 新增牌子是十分方便的 class Shenzhou implements Brand { @Override public void sale() { System.out.println(\"出售神州\"); } } class Computer { protected Brand brand; public Computer(Brand b) { this.brand = b; } public void sale(){ brand.sale(); } } // 创建电脑类型 class Desktop extends Computer { public Desktop(Brand b) { super(b); } @Override public void sale() { super.sale(); System.out.println(\"出售台式电脑\"); } } class Laptop extends Computer { public Laptop(Brand b) { super(b); } @Override public void sale() { super.sale(); System.out.println(\"出售笔记本\"); } } ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"设计模式-桥接模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-装饰模式 装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能 package com.designPattern.decoratorPattern; /** * 装饰模式 * 装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例 */ public class DecoratorPattern { public static void main(String[] args) { Sourceable sourceable = new Source(); Decorator decorator = new Decorator(sourceable); decorator.method(); } } //Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能 interface Sourceable { void method(); } class Source implements Sourceable { @Override public void method() { System.out.println(\"Source\"); } } class Decorator implements Sourceable { Sourceable source; Decorator(Sourceable source){ this.source = source; } @Override public void method() { System.out.println(\"before\"); source.method(); System.out.println(\"after\"); } } 输出 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"装饰器模式的应用场景 1、需要扩展一个类的功能。 2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点：产生过多相似的对象，不易排错！ ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-适配器模式 把一个接口转换成用户希望的另一个接口，使的原本不兼容而不能一起工作的类可以一起工作。 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-适配器模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"何时使用 系统需要使用现有的类，而此类的接口不符合系统的需要。 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-适配器模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"图 我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。 我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。 我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。 AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo 类使用 AudioPlayer 类来播放各种格式。 ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-适配器模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 package com.designPattern.adapterPattern; /** * 适配器模式 * 把一个接口转换成用户希望的另一个接口，使的原本不兼容而不能一起工作的类可以一起工作。 */ public class AdapterPattern { public static void main(String[] args) { MediaPlayer mediaPlayer = new AudioPlayer(); mediaPlayer.play(\"mp4\",\"111\"); } } //创建播放器接口 interface MediaPlayer{ void play(String audioType, String fileName); } //创建高级播放器接口 interface AdvancedMediaPlayer { void playVlc(String fileName); void playMp4(String fileName); } //实现高级播放器接口 class VlcMediaPlayer implements AdvancedMediaPlayer { @Override public void playVlc(String fileName) { System.out.println(\"playVlc\"+fileName); } @Override public void playMp4(String fileName) { } } class Mp4MediaPlayer implements AdvancedMediaPlayer { @Override public void playVlc(String fileName) { } @Override public void playMp4(String fileName) { System.out.println(\"playMp4\"+fileName); } } //创建实现了 MediaPlayer 接口的适配器类 class MediaAdapter implements MediaPlayer{ AdvancedMediaPlayer advancedMediaPlayer; MediaAdapter(String audioType){ if(audioType.equalsIgnoreCase(\"vlc\") ){ advancedMediaPlayer = new VlcMediaPlayer(); } else if (audioType.equalsIgnoreCase(\"mp4\")){ advancedMediaPlayer = new Mp4MediaPlayer(); } } @Override public void play(String audioType, String fileName) { if(audioType.equalsIgnoreCase(\"vlc\")){ advancedMediaPlayer.playVlc(fileName); }else if(audioType.equalsIgnoreCase(\"mp4\")){ advancedMediaPlayer.playMp4(fileName); } } } //创建实现了 MediaPlayer 接口的实体类 class AudioPlayer implements MediaPlayer { MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) { //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase(\"mp3\")){ System.out.println(\"Playing mp3 file. Name: \"+ fileName); } //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase(\"vlc\") || audioType.equalsIgnoreCase(\"mp4\")){ mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); } else{ System.out.println(\"Invalid media. \"+ audioType + \" format not supported\"); } } } ","date":"2021-01-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式-适配器模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"vue-cli3使用ECharts5 创建vue3项目 安装echarts依赖 npm install echarts --save 在页面使用(按需引入) ECharts5中找到需要使用的图表 页面代码 标签： \u003cdiv ref=\"map\" style=\"width: 100%; height: 100%; margin: 0 auto\"\u003e js // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(this.$refs.map); 引入依赖 复制官网依赖 myChart.setOption({…. 复制官网option \u003ctemplate\u003e \u003cdiv class=\"hello\"\u003e \u003cdiv ref=\"map\" style=\"width: 100%; height: 100%; margin: 0 auto\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import * as echarts from 'echarts/index.blank'; import 'echarts/lib/component/title'; import 'echarts/lib/component/toolbox'; import 'echarts/lib/component/tooltip'; import 'echarts/lib/component/legend'; import 'echarts/lib/chart/pie'; import 'zrender/lib/canvas/canvas'; export default { name: \"hello\", data() { return { msg: \"Welcome to Your Vue.js App\", }; }, mounted() { this.drawLine(); }, methods: { drawLine() { // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(this.$refs.map); // 绘制图表 myChart.setOption({ title: { text: \"南丁格尔玫瑰图\", subtext: \"纯属虚构\", left: \"center\", }, tooltip: { trigger: \"item\", formatter: \"{a} \u003cbr/\u003e{b} : {c} ({d}%)\", }, legend: { left: \"center\", top: \"bottom\", data: [ \"rose1\", \"rose2\", \"rose3\", \"rose4\", \"rose5\", \"rose6\", \"rose7\", \"rose8\", ], }, toolbox: { show: true, feature: { mark: { show: true }, dataView: { show: true, readOnly: false }, restore: { show: true }, saveAsImage: { show: true }, }, }, series: [ { name: \"半径模式\", type: \"pie\", radius: [20, 140], center: [\"25%\", \"50%\"], roseType: \"radius\", itemStyle: { borderRadius: 5, }, label: { show: false, }, emphasis: { label: { show: true, }, }, data: [ { value: 40, name: \"rose 1\" }, { value: 33, name: \"rose 2\" }, { value: 28, name: \"rose 3\" }, { value: 22, name: \"rose 4\" }, { value: 20, name: \"rose 5\" }, { value: 15, name: \"rose 6\" }, { value: 12, name: \"rose 7\" }, { value: 10, name: \"rose 8\" }, ], }, { name: \"面积模式\", type: \"pie\", radius: [20, 140], center: [\"75%\", \"50%\"], roseType: \"area\", itemStyle: { borderRadius: 5, }, data: [ { value: 30, name: \"rose 1\" }, { value: 28, name: \"rose 2\" }, { value: 26, name: \"rose 3\" }, { value: 24, name: \"rose 4\" }, { value: 22, name: \"rose 5\" }, { value: 20, name: \"rose 6\" }, { value: 18, name: \"rose 7\" }, { value: 16, name: \"rose 8\" }, ], }, ], }); }, }, }; \u003c/script\u003e \u003c!-- Add \"scoped\" attribute to limit CSS to this component only --\u003e \u003cstyle scoped\u003e h3 { margin: 40px 0 0; } ul { list-style-type: none; padding: 0; } li { display: inline-block; margin: 0 10px; } a { color: #42b983; } \u003c/style\u003e ","date":"2021-01-05","objectID":"/vue-cli3%E4%BD%BF%E7%94%A8echarts5/:0:0","tags":["vue"],"title":"vue-cli3使用ECharts5","uri":"/vue-cli3%E4%BD%BF%E7%94%A8echarts5/"},{"categories":["Java"],"content":"设计模式-单例模式 java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下特点： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。 作用：控制实例数目，节省系统资源 ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"图 ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 懒汉式，线程不安全 /** * 单例模式的几种实现方式: * 1、懒汉式，线程不安全 * 是否 Lazy 初始化：是 * * 是否多线程安全：否 * * 实现难度：易 * * 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 * 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 */ //创建Singleton类 class Singleton1 { //创建类 private static Singleton1 singleton; //私有化构造函数，避免该类被实例化 private Singleton1(){ } //获取唯一可用对象 public static Singleton1 getSingleton(){ if (singleton == null){ singleton = new Singleton1(); } return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } 线程不安全: 实现线程安全的懒汉模式 /** * 2、懒汉式，线程安全 * 是否 Lazy 初始化：是 * * 是否多线程安全：是 * * 实现难度：易 * * 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 * 优点：第一次调用才初始化，避免内存浪费。 * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 * getSingleton() 的性能对应用程序不是很关键（该方法使用不太频繁）。 */ //创建Singleton类 class Singleton2 { //创建类 private static Singleton2 singleton; //私有化构造函数，避免该类被实例化 private Singleton2(){ } //获取唯一可用对象 public synchronized static Singleton2 getSingleton(){ if (singleton == null){ singleton = new Singleton2(); } return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } 双重锁模式，实现线程安全的懒汉模式同时效率高 /** * 4、双检锁/双重校验锁（DCL，即 double-checked locking） * JDK 版本：JDK1.5 起 * * 是否 Lazy 初始化：是 * * 是否多线程安全：是 * * 实现难度：较复杂 * * 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 * getSingleton() 的性能对应用程序很关键。 */ //创建Singleton类 class Singleton4 { //创建类 private volatile static Singleton4 singleton; //私有化构造函数，避免该类被实例化 private Singleton4(){ } //获取唯一可用对象 public synchronized static Singleton4 getSingleton(){ if (singleton == null) { synchronized (Singleton4.class) { if (singleton == null) { singleton = new Singleton4(); } } } return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } 饿汉式 空间换时间 /** * 3、饿汉式 * 是否 Lazy 初始化：否 * * 是否多线程安全：是 * * 实现难度：易 * * 描述：这种方式比较常用，但容易产生垃圾对象。 * 优点：没有加锁，执行效率会提高。 * 缺点：类加载时就初始化，浪费内存。 * 它基于 classloader 机制避免了多线程的同步问题，不过，singleton 在类装载时就实例化，虽然导致类装载 * 的原因有很多种，在单例模式中大多数都是调用 getSingleton 方法， 但是也不能确定有其他的方式（或者其他 * 的静态方法）导致类装载，这时候初始化 singleton 显然没有达到 lazy loading 的效果。 */ //创建Singleton类 class Singleton3 { //创建类 private static Singleton3 singleton = new Singleton3(); //私有化构造函数，避免该类被实例化 private Singleton3(){ } //获取唯一可用对象 public static Singleton3 getSingleton(){ return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } 使用静态内部类实现单例模式 /** * 5、登记式/静态内部类 * 是否 Lazy 初始化：是 * * 是否多线程安全：是 * * 实现难度：一般 * * 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。 * 这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 * 这种方式同样利用了 classloader 机制来保证初始化 singleton 时只有一个线程，它跟第 3 种方式不同的是： * 第 3 种方式只要 Singleton 类被装载了，那么 singleton 就会被实例化（没有达到 lazy loading 效果）， * 而这种方式是 Singleton 类被装载了，singleton 不一定被初始化。因为 SingletonHolder 类没有被主动使 * 用，只有通过显式调用 getSingleton 方法时，才会显式装载 SingletonHolder 类，从而实例化 singleton。 * 想象一下，如果实例化 singleton 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加 * 载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 singleton * 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 */ //创建Singleton类 class Singleton5 { private static class SingletonHolder5 { private static final Singleton5 SINGLETON = new Singleton5(); } private Singleton5 (){} public static final Singleton5 getSingleton() { return SingletonHolder5.SINGLETON; } } 枚举 /** * 6、枚举 * JDK 版本：JDK1.5 起 * * 是否 Lazy 初始化：否 * * 是否多线程安全：是 * * 实现难度：易 * * 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 * 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制， * 防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 * 不能通过 reflection attack 来调用私有构造方法。 */ enum Singleton6 { SINGLETON; public void whateverMethod() { //功能处理 } } ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"破坏单例模式的三种方式 反射 序列化 克隆 package com.designPattern.singletonPattern; import java.io.*; import java.lang.reflect.Constructor; /** * 序列化对单例的破坏 * @author Administrator * */ public class SingletonTest { public static void main(String[] args) throws Exception{ Singleton originSingleton = Singleton.getInstance(); System.out.println(\"-----------序列化----------------------\"); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(Singleton.getInstance()); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); Singleton serializeSingleton = (Singleton) ois.readObject(); System.out.println(originSingleton == serializeSingleton);//false System.out.println(\"-----------反射----------------------\"); //通过反射获取 Constructor\u003cSingleton\u003e cons = Singleton.class.getDeclaredConstructor(); cons.setAccessible(true); Singleton reflextSingleton = cons.newInstance(); System.out.println(reflextSingleton == originSingleton);//false System.out.println(\"---------------------------克隆----------------------\"); Singleton cloneSingleton = (Singleton) originSingleton.clone(); System.out.println(cloneSingleton == originSingleton);//false } private static class Singleton implements Serializable,Cloneable{ /** * 1.构造方法私有化，外部不能new */ private Singleton() {} //2.本类内部创建对象实例 private static volatile Singleton instance; //3.提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { if(instance == null) { synchronized (Singleton.class) { if(instance == null) { instance = new Singleton(); } } } return instance; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } } 运行结果 解决方法 1、防止反射 定义一个全局变量，当第二次创建的时候抛出异常 2、防止克隆破坏 重写clone(),直接返回单例对象 3、防止序列化破坏 添加readResolve(),返回Object对象 package com.designPattern.singletonPattern; import java.io.*; import java.lang.reflect.Constructor; /** * 序列化对单例的破坏 * @author Administrator * */ public class SingletonTest { public static void main(String[] args) throws Exception{ Singleton originSingleton = Singleton.getInstance(); System.out.println(\"-----------序列化----------------------\"); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(Singleton.getInstance()); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); Singleton serializeSingleton = (Singleton) ois.readObject(); System.out.println(originSingleton == serializeSingleton);//false System.out.println(\"-----------反射----------------------\"); //通过反射获取 Constructor\u003cSingleton\u003e cons = Singleton.class.getDeclaredConstructor(); cons.setAccessible(true); Singleton reflextSingleton = cons.newInstance(); System.out.println(reflextSingleton == originSingleton);//false System.out.println(\"---------------------------克隆----------------------\"); Singleton cloneSingleton = (Singleton) originSingleton.clone(); System.out.println(cloneSingleton == originSingleton);//false } private static class Singleton implements Serializable,Cloneable{ private static volatile boolean isCreate = false;//默认是第一次创建 /** * 1.构造方法私有化，外部不能new */ private Singleton() { if(isCreate) { throw new RuntimeException(\"已然被实例化一次，不能在实例化\"); } isCreate = true; } //2.本类内部创建对象实例 private static volatile Singleton instance; //3.提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { if(instance == null) { synchronized (Singleton.class) { if(instance == null) { instance = new Singleton(); } } } return instance; } @Override protected Object clone() throws CloneNotSupportedException { return instance; } /** * 防止序列化破环 * @return */ private Object readResolve() { return instance; } } } ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式-单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"完整代码 package com.designPattern.singletonPattern; /** * 单例模式 */ public class SingletonPattern { public static void main(String[] args) { Singleton singleton = Singleton.getSingleton(); singleton.showMessage(); } } //创建Singleton类 class Singleton { //创建类 private static Singleton singleton = new Singleton(); //私有化构造函数，避免该类被实例化 private Singleton(){ } //获取唯一可用对象 public static Singleton getSingleton(){ return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } /** * 单例模式的几种实现方式: * 1、懒汉式，线程不安全 * 是否 Lazy 初始化：是 * * 是否多线程安全：否 * * 实现难度：易 * * 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 * 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 */ //创建Singleton类 class Singleton1 { //创建类 private static Singleton1 singleton; //私有化构造函数，避免该类被实例化 private Singleton1(){ } //获取唯一可用对象 public static Singleton1 getSingleton(){ if (singleton == null){ singleton = new Singleton1(); } return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } /** * 2、懒汉式，线程安全 * 是否 Lazy 初始化：是 * * 是否多线程安全：是 * * 实现难度：易 * * 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 * 优点：第一次调用才初始化，避免内存浪费。 * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 * getSingleton() 的性能对应用程序不是很关键（该方法使用不太频繁）。 */ //创建Singleton类 class Singleton2 { //创建类 private static Singleton2 singleton; //私有化构造函数，避免该类被实例化 private Singleton2(){ } //获取唯一可用对象 public synchronized static Singleton2 getSingleton(){ if (singleton == null){ singleton = new Singleton2(); } return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } /** * 3、饿汉式 * 是否 Lazy 初始化：否 * * 是否多线程安全：是 * * 实现难度：易 * * 描述：这种方式比较常用，但容易产生垃圾对象。 * 优点：没有加锁，执行效率会提高。 * 缺点：类加载时就初始化，浪费内存。 * 它基于 classloader 机制避免了多线程的同步问题，不过，singleton 在类装载时就实例化，虽然导致类装载 * 的原因有很多种，在单例模式中大多数都是调用 getSingleton 方法， 但是也不能确定有其他的方式（或者其他 * 的静态方法）导致类装载，这时候初始化 singleton 显然没有达到 lazy loading 的效果。 */ //创建Singleton类 class Singleton3 { //创建类 private static Singleton3 singleton = new Singleton3(); //私有化构造函数，避免该类被实例化 private Singleton3(){ } //获取唯一可用对象 public static Singleton3 getSingleton(){ return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } /** * 4、双检锁/双重校验锁（DCL，即 double-checked locking） * JDK 版本：JDK1.5 起 * * 是否 Lazy 初始化：是 * * 是否多线程安全：是 * * 实现难度：较复杂 * * 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 * getSingleton() 的性能对应用程序很关键。 */ //创建Singleton类 class Singleton4 { //创建类 private volatile static Singleton4 singleton; //私有化构造函数，避免该类被实例化 private Singleton4(){ } //获取唯一可用对象 public synchronized static Singleton4 getSingleton(){ if (singleton == null) { synchronized (Singleton4.class) { if (singleton == null) { singleton = new Singleton4(); } } } return singleton; } public void showMessage(){ System.out.println(\"Hello World!\"); } } /** * 5、登记式/静态内部类 * 是否 Lazy 初始化：是 * * 是否多线程安全：是 * * 实现难度：一般 * * 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。 * 这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 * 这种方式同样利用了 classloader 机制来保证初始化 singleton 时只有一个线程，它跟第 3 种方式不同的是： * 第 3 种方式只要 Singleton 类被装载了，那么 singleton 就会被实例化（没有达到 lazy loading 效果）， * 而这种方式是 Singleton 类被装载了，singleton 不一定被初始化。因为 SingletonHolder 类没有被主动使 * 用，只有通过显式调用 getSingleton 方法时，才会显式装载 SingletonHolder 类，从而实例化 singleton。 * 想象一下，如果实例化 singleton 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加 * 载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 singleton * 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 */ //创建Singleton类 class Singleton5 { private static class SingletonHolder5 { private static final Singleton5 SINGLETON = new Singleton5(); } private Singleton5 (){} public static final Singleton5 getSingleton() { return SingletonHolder5.SINGLETON; } } /** * 6、枚举 * JDK 版本：JDK1.5 起 * * 是否 Lazy 初始化：否 * * 是否多线程安全：是 * * 实现难度：易 * * 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 * 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制， * 防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 * 不能通过 reflection attack 来调用私有构造方法。 */ enum Singleton6 { SINGLETON; public void whateverMethod() { //功能处理 } } ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"设计模式-单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-原型模式 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。 ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"原型模式的结构与实现 由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。 1. 模式的结构 原型模式包含以下主要角色。 抽象原型类：规定了具体原型对象必须实现的接口。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 2. 模式的实现 原型模式的克隆分为浅克隆和深克隆。 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 package com.designPattern.prototypePattern; /** * 原型模式 */ public class PrototypePattern { public static void main(String[] args) throws CloneNotSupportedException { Realizetype obj1 = new Realizetype(); Realizetype obj2 = (Realizetype) obj1.clone(); System.out.println(\"obj1==obj2?\" + (obj1 == obj2)); } } //具体原型类 class Realizetype implements Cloneable { Realizetype() { System.out.println(\"具体原型创建成功！\"); } public Object clone() throws CloneNotSupportedException { System.out.println(\"具体原型复制成功！\"); return (Realizetype) super.clone(); } } ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-建造者模式 定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 个人理解:类似为一辆车挑选不同的部件 应用： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 优点如下： 封装性好，构建和表示分离。 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。 其缺点如下： 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-建造者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"1. 模式的结构 建造者（Builder）模式的主要角色如下。 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-建造者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"2. 图 ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-建造者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"3. 模式的实现 产品角色：包含多个组成部件的复杂对象。 class Product { private String partA; private String partB; private String partC; public void setPartA(String partA) { this.partA = partA; } public void setPartB(String partB) { this.partB = partB; } public void setPartC(String partC) { this.partC = partC; } @Override public String toString() { return \"Product{\" + \"partA='\" + partA + '\\'' + \", partB='\" + partB + '\\'' + \", partC='\" + partC + '\\'' + '}'; } } 抽象建造者：包含创建产品各个子部件的抽象方法。 //抽象建造者:包含创建产品各个子部件的抽象方法。 abstract class Builder{ Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); //返回产品对象 public Product getResult() { return product; } } 具体建造者：实现了抽象建造者接口。 //具体建造者：实现了抽象建造者接口。 class ConcreteBuilder extends Builder { public void buildPartA() { product.setPartA(\"建造 PartA\"); } public void buildPartB() { product.setPartB(\"建造 PartB\"); } public void buildPartC() { product.setPartC(\"建造 PartC\"); } } 指挥者：调用建造者中的方法完成复杂对象的创建。 //指挥者：调用建造者中的方法完成复杂对象的创建。 class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } //产品构建与组装方法 public Product construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); } } 客户类。 public class BuilderPattern { public static void main(String[] args) { Builder builder = new ConcreteBuilder(); Director director = new Director(builder); Product product = director.construct(); System.out.println(product); } } ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式-建造者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"4.模拟客厅装修 /** *用建造者（Builder）模式描述客厅装修。 * * 分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修， * 最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。 * * 这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。 */ public class ParlourDecorator { public static void main(String[] args) { Decorator decorator = new ConcreteDecorator2(); ProjectManager projectManager = new ProjectManager(decorator); Parlour decorate = projectManager.decorate(); System.out.println(decorate); } } //产品：客厅 class Parlour { private String wall; //墙 private String TV; //电视 private String sofa; //沙发 public void setWall(String wall) { this.wall = wall; } public void setTV(String TV) { this.TV = TV; } public void setSofa(String sofa) { this.sofa = sofa; } @Override public String toString() { return \"Parlour{\" + \"wall='\" + wall + '\\'' + \", TV='\" + TV + '\\'' + \", sofa='\" + sofa + '\\'' + '}'; } } //抽象建造者：装修工人 abstract class Decorator { //创建产品对象 protected Parlour product = new Parlour(); public void buildWall(){ product.setWall(\"w1\"); }; public abstract void buildTV(); public abstract void buildSofa(); //返回产品对象 public Parlour getResult() { return product; } } //具体建造者：具体装修工人1 class ConcreteDecorator1 extends Decorator { public void buildTV() { product.setTV(\"TV1\"); } public void buildSofa() { product.setSofa(\"sf1\"); } } //具体建造者：具体装修工人2 class ConcreteDecorator2 extends Decorator { public void buildTV() { product.setTV(\"TV2\"); } public void buildSofa() { product.setSofa(\"sf2\"); } } //指挥者：项目经理 class ProjectManager { private Decorator builder; public ProjectManager(Decorator builder) { this.builder = builder; } //产品构建与组装方法 public Parlour decorate() { builder.buildWall(); builder.buildTV(); builder.buildSofa(); return builder.getResult(); } } ","date":"2021-01-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"设计模式-建造者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-工厂模式 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"介绍 **意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 **主要解决：**主要解决接口选择的问题。 **何时使用：**我们明确地计划不同条件下创建不同实例时。 **如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。 **关键代码：**创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 **缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。 **注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"图 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 创建Shape接口 //创建接口类 interface Shape{ void draw(); } 创建实现类 //创建实现类 class Rectangle implements Shape{ @Override public void draw() { System.out.println(\"Rectangle\"); } } //创建实现类 class Square implements Shape{ @Override public void draw() { System.out.println(\"Square\"); } } 创建Shape工厂 //创建工厂 class ShapeFactory{ public Shape getShape(String shapeType){ if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } } 使用 public class FactoryPattern { //使用 public static void main(String[] args) { ShapeFactory shapeFactory = new ShapeFactory(); Shape shape1 = shapeFactory.getShape(\"RECTANGLE\"); shape1.draw(); Shape shape2 = shapeFactory.getShape(\"SQUARE\"); shape2.draw(); } } 运行结果 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式-工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"完整代码 package com.designPattern.factoryPattern; /** * 工厂模式 */ public class FactoryPattern { //使用 public static void main(String[] args) { ShapeFactory shapeFactory = new ShapeFactory(); Shape shape1 = shapeFactory.getShape(\"RECTANGLE\"); shape1.draw(); Shape shape2 = shapeFactory.getShape(\"SQUARE\"); shape2.draw(); } } //创建工厂 class ShapeFactory{ public Shape getShape(String shapeType){ if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } } //创建接口类 interface Shape{ void draw(); } //创建实现类 class Rectangle implements Shape{ @Override public void draw() { System.out.println(\"Rectangle\"); } } //创建实现类 class Square implements Shape{ @Override public void draw() { System.out.println(\"Square\"); } } 参考菜鸟教程 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"设计模式-工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"设计模式-抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式-抽象工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"图 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式-抽象工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"代码实现 创建图形接口类 interface Shape{ void draw(); } 创建图形实现类 //创建图形实现类 class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Rectangle\"); } } //创建图形实现类 class Square implements Shape { @Override public void draw() { System.out.println(\"Square\"); } } 创建颜色接口类 //创建颜色接口 interface Color{ void fill(); } 创建颜色实现类 //创建颜色实现类 class Red implements Color{ @Override public void fill() { System.out.println(\"red\"); } } //创建颜色实现类 class Blue implements Color{ @Override public void fill() { System.out.println(\"blue\"); } } 创建抽象类获取工厂 //创建抽象类获取工厂 abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape) ; } 实现抽象类 //实现抽象类 class ColorFactory extends AbstractFactory{ public Color getColor(String colorType){ if(colorType.equalsIgnoreCase(\"RED\")){ return new Red(); } else if(colorType.equalsIgnoreCase(\"BLUE\")){ return new Blue(); } return null; } @Override public Shape getShape(String shape) { return null; } } //实现抽象类 class ShapeFactory extends AbstractFactory{ @Override public Color getColor(String color) { return null; } public Shape getShape(String shapeType){ if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } } 创建工厂创造器/生成器类 //创建工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。 class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(\"SHAPE\")){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(\"COLOR\")){ return new ColorFactory(); } return null; } } 使用 public class AbstractFactoryPattern { public static void main(String[] args) { AbstractFactory shape = FactoryProducer.getFactory(\"SHAPE\"); System.out.println(shape.getColor(\"RED\")); Shape rectangle = shape.getShape(\"RECTANGLE\"); rectangle.draw(); } } 运行结果 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式-抽象工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["Java"],"content":"整体代码 package com.designPattern.abstractFactoryPattern; /** * 抽象工厂模式 */ public class AbstractFactoryPattern { public static void main(String[] args) { AbstractFactory shape = FactoryProducer.getFactory(\"SHAPE\"); System.out.println(shape.getColor(\"RED\")); Shape rectangle = shape.getShape(\"RECTANGLE\"); rectangle.draw(); } } //创建工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。 class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(\"SHAPE\")){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(\"COLOR\")){ return new ColorFactory(); } return null; } } //————————————————————————————————————————————————————————————————————————————————————————————————————————————————// //创建抽象类获取工厂 abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape) ; } //实现抽象类 class ColorFactory extends AbstractFactory{ public Color getColor(String colorType){ if(colorType.equalsIgnoreCase(\"RED\")){ return new Red(); } else if(colorType.equalsIgnoreCase(\"BLUE\")){ return new Blue(); } return null; } @Override public Shape getShape(String shape) { return null; } } //实现抽象类 class ShapeFactory extends AbstractFactory{ @Override public Color getColor(String color) { return null; } public Shape getShape(String shapeType){ if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } } //————————————————————————————————————————————————————————————————————————————————————————————————————————————————// //创建颜色接口 interface Color{ void fill(); } //创建颜色实现类 class Red implements Color{ @Override public void fill() { System.out.println(\"red\"); } } //创建颜色实现类 class Blue implements Color{ @Override public void fill() { System.out.println(\"blue\"); } } //————————————————————————————————————————————————————————————————————————————————————————————————————————————————// //创建图形接口类 interface Shape{ void draw(); } //创建图形实现类 class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Rectangle\"); } } //创建图形实现类 class Square implements Shape { @Override public void draw() { System.out.println(\"Square\"); } } 参考菜鸟教程 ","date":"2021-01-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式-抽象工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":[],"content":"guli-15-微信支付 ","date":"2020-10-04","objectID":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/:0:0","tags":[],"title":"guli-15-微信支付","uri":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"categories":[],"content":"一.后端 ","date":"2020-10-04","objectID":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/:1:0","tags":[],"title":"guli-15-微信支付","uri":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"categories":[],"content":"1.准备 创建service_order模块 配置 # 服务端口 server.port=8087 # 服务名 spring.application.name=service-order #数据库配置 spring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=123456 #返回json的全局时间格式 spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 #配置mapper xml文件的路径 mybatis-plus.mapper-locations=classpath:com/guigu/eduorder/mapper/xml/*.xml #mybatis日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # nacos服务地址 spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 ##开启熔断机制 #feign.hystrix.enabled=true ## 设置hystrix超时时间，默认1000ms #hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=3000 依赖 \u003cdependencies\u003e \u003c!-- 微信支付依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.github.wxpay\u003c/groupId\u003e \u003cartifactId\u003ewxpay-sdk\u003c/artifactId\u003e \u003cversion\u003e0.0.3\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 启动类 package com.guli.eduorder; @SpringBootApplication @ComponentScan(basePackages = \"com.guli\") @MapperScan(\"com.guli.eduorder.mapper\") @EnableDiscoveryClient @EnableFeignClients public class OrdersApplication { public static void main(String[] args) { SpringApplication.run(OrdersApplication.class,args); } } 数据库创建表 t_order t_pay_log 使用代码生成器创建基本包结构 ","date":"2020-10-04","objectID":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/:1:1","tags":[],"title":"guli-15-微信支付","uri":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"categories":[],"content":"2.接口开发 创建订单需要课程信息和用户信息 需要使用Nacos进行服务间调用 在公共模块中创建CourseWebVoOrder和UcenterMemberOrder进行数据封装 edu/CourseFrontController //根据课程id查询课程信息 @PostMapping(\"getCourseInfoOrder/{id}\") public CourseWebVoOrder getCourseInfoOrder(@PathVariable String id) { CourseWebVo baseCourseInfo = courseService.getBaseCourseInfo(id); CourseWebVoOrder courseWebVoOrder = new CourseWebVoOrder(); BeanUtils.copyProperties(baseCourseInfo,courseWebVoOrder); return courseWebVoOrder; } ucenter/UcenterMemberController //根据用户id获取用户信息 @PostMapping(\"getUserInfoOrder/{id}\") public UcenterMemberOrder getUserInfoOrder(@PathVariable String id) { UcenterMember member = memberService.getById(id); UcenterMemberOrder memberOrder = new UcenterMemberOrder(); BeanUtils.copyProperties(member,memberOrder); return memberOrder; } 在order模块中注册 package com.guli.eduorder.client; @Component @FeignClient(\"service-edu\") public interface EduClient { @PostMapping(\"/eduservice/coursefront/getCourseInfoOrder/{id}\") CourseWebVoOrder getCourseInfoOrder(@PathVariable(\"id\") String id); } @Component @FeignClient(\"service-ucenter\") public interface UcenterClient { //根据用户id获取用户信息 @PostMapping(\"/educenter/member/getUserInfoOrder/{id}\") UcenterMemberOrder getUserInfoOrder(@PathVariable(\"id\") String id); } controller OrderController package com.guli.eduorder.controller; @RestController @RequestMapping(\"/eduorder/order\") @CrossOrigin public class OrderController { @Autowired private OrderService orderService; //1.生成订单的方法 @PostMapping(\"createOrder/{courseId}\") public R createOrder(@PathVariable String courseId, HttpServletRequest request) { //通过前端的请求头信息获取用户id String memberIdByJwtToken = JwtUtils.getMemberIdByJwtToken(request); //根据用户id和课程id生成订单，返回订单号 String orderNo = orderService.createOrders(courseId,memberIdByJwtToken); return R.ok().data(\"orderId\",orderNo); } //2.根据订单编号查询订单信息 @GetMapping(\"getOrderInfo/{orderNo}\") public R getOrderInfo(@PathVariable String orderNo) { QueryWrapper\u003cOrder\u003e queryWrapper = new QueryWrapper\u003c\u003e(); queryWrapper.eq(\"order_no\",orderNo); Order order = orderService.getOne(queryWrapper); return R.ok().data(\"item\",order); } } PayLogController package com.guli.eduorder.controller; @RestController @RequestMapping(\"/eduorder/paylog\") @CrossOrigin public class PayLogController { @Autowired private PayLogService payLogService; //生成微信支付二维码接口 //参数是订单号 @GetMapping(\"createNative/{orderNo}\") public R createNative(@PathVariable String orderNo) { Map map = payLogService.createNatvie(orderNo); return R.ok().data(\"map\",map); } //查询订单支付状态 @GetMapping(\"queryPayStatus/{orderNo}\") public R queryPayStatus(@PathVariable String orderNo) { Map\u003cString,String\u003e map = payLogService.queryPayStatus(orderNo); if (map == null) { return R.error().message(\"支付出错\"); } //如果不为空，获取订单状态 if (map.get(\"trade_state\").equals(\"SUCCESS\")) {//支付成功 //向支付表中加记录，更新订单表订单状态 payLogService.updateOrdersStatus(map); return R.ok().message(\"支付成功\"); } return R.error().code(25000).message(\"支付中\"); } } service OrderServiceImpl package com.guli.eduorder.service.impl; @Service public class OrderServiceImpl extends ServiceImpl\u003cOrderMapper, Order\u003e implements OrderService { @Autowired private EduClient eduClient; @Autowired private UcenterClient ucenterClient; //1.生成订单的方法 @Override public String createOrders(String courseId, String memberIdByJwtToken) { //通过远程调用根据课程id获取课程信息 CourseWebVoOrder courseInfoOrder = eduClient.getCourseInfoOrder(courseId); //通过远程调用根据用户id获取用户信息 UcenterMemberOrder userInfoOrder = ucenterClient.getUserInfoOrder(memberIdByJwtToken); //创建order对象，设置数据 Order order = new Order(); order.setOrderNo(OrderNoUtil.getOrderNo());//订单号 order.setCourseId(courseId);//课程id order.setCourseTitle(courseInfoOrder.getTitle());//课程标题 order.setCourseCover(courseInfoOrder.getCover());//课程封面 order.setTeacherName(courseInfoOrder.getTeacherName());//讲师名称 order.setTotalFee(courseInfoOrder.getPrice());//课程价格 order.setMemberId(memberIdByJwtToken);//用户id order.setMobile(userInfoOrder.getMobile());//用户昵称 order.setNickname(userInfoOrder.getNickname());//手机号 ord","date":"2020-10-04","objectID":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/:1:2","tags":[],"title":"guli-15-微信支付","uri":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"categories":[],"content":"二.前端 安装插件qriously 在course/_id页面点击购买 调用生成订单方法 传递课程id 得到订单号 带着订单号跳转/orders/_oid orders/_oid 异步:根据订单编号查询订单信息，传递订单号，得到订单信息，在页面展示 点击支付，带着订单号跳转到/pay/_pid pay/_pid 异步:根据订单编号调用生成微信二维码 每隔三秒查询订单状态，判断情况 \u003ctemplate\u003e \u003cdiv class=\"cart py-container\"\u003e \u003c!--主内容--\u003e \u003cdiv class=\"checkout py-container pay\"\u003e \u003cdiv class=\"checkout-tit\"\u003e \u003ch4 class=\"fl tit-txt\"\u003e \u003cspan class=\"success-icon\"\u003e\u003c/span \u003e\u003cspan class=\"success-info\" \u003e订单提交成功，请您及时付款！订单号：{{ payObj.out_trade_no }}\u003c/span \u003e \u003c/h4\u003e \u003cspan class=\"fr\" \u003e\u003cem class=\"sui-lead\"\u003e应付金额：\u003c/em \u003e\u003cem class=\"orange money\"\u003e￥{{ payObj.total_fee }}\u003c/em\u003e\u003c/span \u003e \u003cdiv class=\"clearfix\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"checkout-steps\"\u003e \u003cdiv class=\"fl weixin\"\u003e微信支付\u003c/div\u003e \u003cdiv class=\"fl sao\"\u003e \u003cp class=\"red\"\u003e请使用微信扫一扫。\u003c/p\u003e \u003cdiv class=\"fl code\"\u003e \u003c!-- \u003cimg id=\"qrious\" src=\"~/assets/img/erweima.png\" alt=\"\"\u003e --\u003e \u003c!-- \u003cqriously value=\"weixin://wxpay/bizpayurl?pr=R7tnDpZ\" :size=\"338\"/\u003e --\u003e \u003cqriously :value=\"payObj.code_url\" :size=\"338\" /\u003e \u003cdiv class=\"saosao\"\u003e \u003cp\u003e请使用微信扫一扫\u003c/p\u003e \u003cp\u003e扫描二维码支付\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"clearfix\"\u003e\u003c/div\u003e \u003c!-- \u003cp\u003e\u003ca href=\"pay.html\" target=\"_blank\"\u003e\u003e 其他支付方式\u003c/a\u003e\u003c/p\u003e --\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import ordersApi from \"@/api/orders\"; export default { asyncData({ params, error }) { return ordersApi.createNative(params.pid).then((response) =\u003e { return { payObj: response.data.data.map, }; }); }, data() { return { timer1: \"\", }; }, //每隔三秒调用一次查询订单状态的方法 mounted() { //页面渲染之后执行 this.timer1 = setInterval(() =\u003e { this.queryOrderStatus(this.payObj.out_trade_no); }, 3000); }, methods: { queryOrderStatus(orderNo) { ordersApi.queryPayStatus(orderNo).then((response) =\u003e { if (response.data.success) { //支付成功，清除定时器 clearInterval(this.timer1); //提示 this.$message({ type: \"success\", message: \"支付成功!\", }); //跳转回到课程详情页面 this.$router.push({ path: \"/course/\" + this.payObj.course_id }); } }); }, }, }; \u003c/script\u003e 响应器拦截“支付中”消息request import axios from 'axios' import cookie from 'js-cookie'; import { MessageBox, Message } from 'element-ui'; // 创建axios实例 const service = axios.create({ baseURL: 'http://localhost:9001', // api的base_url timeout: 20000 // 请求超时时间 }) //3.编写拦截器 service.interceptors.request.use( config =\u003e { //debugger //判断1是否有名为'guli_token'的cookie if (cookie.get('guli_token')) { config.headers['token'] = cookie.get('guli_token'); } return config }, err =\u003e { return Promise.reject(err); } ) // http response 拦截器 service.interceptors.response.use( response =\u003e { //debugger if (response.data.code == 28004) { console.log(\"response.data.resultCode是28004\") // 返回 错误代码-1 清除ticket信息并跳转到登录页面 //debugger window.location.href = \"/login\" return } else { if (response.data.code !== 20000) { //25000：订单支付中，不做任何提示 if (response.data.code != 25000) { Message({ message: response.data.message || 'error', type: 'error', duration: 5 * 1000 }) } } else { return response; } } }, error =\u003e { return Promise.reject(error.response) // 返回接口返回的错误信息 }); export default service ","date":"2020-10-04","objectID":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/:2:0","tags":[],"title":"guli-15-微信支付","uri":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"categories":[],"content":"三.完善 order //3.根据课程id和用户id查询订单表中订单状态 @GetMapping(\"isBuyCourse/{courseId}/{memberId}\") public Boolean isBuyCourse (@PathVariable String courseId,@PathVariable String memberId) { QueryWrapper\u003cOrder\u003e queryWrapper = new QueryWrapper\u003c\u003e(); queryWrapper.eq(\"course_id\",courseId); queryWrapper.eq(\"member_id\",memberId); queryWrapper.eq(\"status\",1); int count = orderService.count(queryWrapper); if (count \u003e 0){ return true; } else { return false; } } 在edu中调用（补充课程详情方法） //2 课程详情的方法 @GetMapping(\"getFrontCourseInfo/{courseId}\") public R getFrontCourseInfo(@PathVariable String courseId, HttpServletRequest request) { //根据课程id，编写sql语句查询课程信息 CourseWebVo courseWebVo = courseService.getBaseCourseInfo(courseId); //根据课程id查询章节和小节 List\u003cChapterVo\u003e chapterVideoList = chapterService.getChapterById(courseId); //根据课程id和用户id查询课程是否可观看（已支付） String memberId = JwtUtils.getMemberIdByJwtToken(request); Boolean buyCourse = ordersClient.isBuyCourse(courseId, memberId); return R.ok().data(\"courseWebVo\",courseWebVo).data(\"chapterVideoList\",chapterVideoList).data(\"isBuy\",buyCourse); } 前端course/_id \u003ctemplate\u003e \u003cdiv id=\"aCoursesList\" class=\"bg-fa of\"\u003e \u003c!-- /课程详情 开始 --\u003e \u003csection class=\"container\"\u003e \u003csection class=\"path-wrap txtOf hLh30\"\u003e \u003ca href=\"#\" title class=\"c-999 fsize14\"\u003e首页\u003c/a\u003e \\ \u003ca href=\"#\" title class=\"c-999 fsize14\"\u003e{{courseWebVo.subjectLevelOne}}\u003c/a\u003e \\ \u003cspan class=\"c-333 fsize14\"\u003e{{courseWebVo.subjectLevelTwo}}\u003c/span\u003e \u003c/section\u003e \u003cdiv\u003e \u003carticle class=\"c-v-pic-wrap\" style=\"height: 357px;\"\u003e \u003csection class=\"p-h-video-box\" id=\"videoPlay\"\u003e \u003cimg height=\"357px\" :src=\"courseWebVo.cover\" :alt=\"courseWebVo.title\" class=\"dis c-v-pic\"\u003e \u003c/section\u003e \u003c/article\u003e \u003caside class=\"c-attr-wrap\"\u003e \u003csection class=\"ml20 mr15\"\u003e \u003ch2 class=\"hLh30 txtOf mt15\"\u003e \u003cspan class=\"c-fff fsize24\"\u003e{{courseWebVo.title}}\u003c/span\u003e \u003c/h2\u003e \u003csection class=\"c-attr-jg\"\u003e \u003cspan class=\"c-fff\"\u003e价格：\u003c/span\u003e \u003cb class=\"c-yellow\" style=\"font-size:24px;\"\u003e￥{{courseWebVo.price}}\u003c/b\u003e \u003c/section\u003e \u003csection class=\"c-attr-mt c-attr-undis\"\u003e \u003cspan class=\"c-fff fsize14\"\u003e主讲： {{courseWebVo.teacherName}}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003c/span\u003e \u003c/section\u003e \u003csection class=\"c-attr-mt of\"\u003e \u003cspan class=\"ml10 vam\"\u003e \u003cem class=\"icon18 scIcon\"\u003e\u003c/em\u003e \u003ca class=\"c-fff vam\" title=\"收藏\" href=\"#\" \u003e收藏\u003c/a\u003e \u003c/span\u003e \u003c/section\u003e \u003csection v-if=\"isbuy || Number(courseWebVo.price) === 0\" class=\"c-attr-mt\"\u003e \u003ca href=\"#\" title=\"立即观看\" class=\"comm-btn c-btn-3\"\u003e立即观看\u003c/a\u003e \u003c/section\u003e \u003csection v-else class=\"c-attr-mt\"\u003e \u003ca @click=\"createOrders()\" href=\"#\" title=\"立即购买\" class=\"comm-btn c-btn-3\"\u003e立即购买\u003c/a\u003e \u003c/section\u003e \u003c/section\u003e \u003c/aside\u003e \u003caside class=\"thr-attr-box\"\u003e \u003col class=\"thr-attr-ol\"\u003e \u003cli\u003e \u003cp\u003e\u0026nbsp;\u003c/p\u003e \u003caside\u003e \u003cspan class=\"c-fff f-fM\"\u003e购买数\u003c/span\u003e \u003cbr\u003e \u003ch6 class=\"c-fff f-fM mt10\"\u003e{{courseWebVo.buyCount}}\u003c/h6\u003e \u003c/aside\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003e\u0026nbsp;\u003c/p\u003e \u003caside\u003e \u003cspan class=\"c-fff f-fM\"\u003e课时数\u003c/span\u003e \u003cbr\u003e \u003ch6 class=\"c-fff f-fM mt10\"\u003e20\u003c/h6\u003e \u003c/aside\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003e\u0026nbsp;\u003c/p\u003e \u003caside\u003e \u003cspan class=\"c-fff f-fM\"\u003e浏览数\u003c/span\u003e \u003cbr\u003e \u003ch6 class=\"c-fff f-fM mt10\"\u003e501\u003c/h6\u003e \u003c/aside\u003e \u003c/li\u003e \u003c/ol\u003e \u003c/aside\u003e \u003cdiv class=\"clear\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c!-- /课程封面介绍 --\u003e \u003cdiv class=\"mt20 c-infor-box\"\u003e \u003carticle class=\"fl col-7\"\u003e \u003csection class=\"mr30\"\u003e \u003cdiv class=\"i-box\"\u003e \u003cdiv\u003e \u003csection id=\"c-i-tabTitle\" class=\"c-infor-tabTitle c-tab-title\"\u003e \u003ca name=\"c-i\" class=\"current\" title=\"课程详情\"\u003e课程详情\u003c/a\u003e \u003c/section\u003e \u003c/div\u003e \u003carticle class=\"ml10 mr10 pt20\"\u003e \u003cdiv\u003e \u003ch6 class=\"c-i-content c-infor-title\"\u003e \u003cspan\u003e课程介绍\u003c/span\u003e \u003c/h6\u003e \u003cdiv class=\"course-txt-body-wrap\"\u003e \u003csection class=\"course-txt-body\"\u003e \u003cp v-html=\"courseWebVo.description\"\u003e{{courseWebVo.description}}\u003c/p\u003e \u003c/section\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- /课程介绍 --\u003e \u003cdiv class=\"mt50\"\u003e \u003ch6 class=\"c-g-content c-infor-title\"\u003e \u003cspan\u003e课程大纲\u003c/span\u003e \u003c/h6\u003e \u003csection class=\"mt20\"\u003e \u003cdiv class=\"lh-menu-wrap\"\u003e \u003cmenu id=\"lh-menu\" class=\"lh-menu mt10 mr10\"\u003e \u003cul\u003e \u003c!-- 文件目录 --\u003e \u003cli class=\"lh-menu-stair\" v-for=\"chapter in chapterVideoList\" :key=\"chapter.id\"\u003e \u003ca href=\"javascript: void(0)\" :title=\"chapter.title\" class=\"current-1\"\u003e \u003cem class=\"lh-menu-i-1 icon18 mr10\"\u003e\u003c/em\u003e{{chapter.title}} \u003c/a\u003e \u003col class=\"lh-menu-ol\" style=\"display: block;\"\u003e \u003cli cl","date":"2020-10-04","objectID":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/:3:0","tags":[],"title":"guli-15-微信支付","uri":"/guli-15-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"categories":[],"content":"guli-14-阿里云视频点播 使用视频id+视频凭证加密播放 ","date":"2020-10-04","objectID":"/guli-14-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/:0:0","tags":[],"title":"guli-14-阿里云视频点播","uri":"/guli-14-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/"},{"categories":[],"content":"一.后端 service_vod controller //根据视频id获取视频凭证 @GetMapping(\"getPlayAuth/{id}\") public R getPlayAuth(@PathVariable String id) throws ClientException { //根据视频id获取视频凭证 //创建初始化对象 DefaultAcsClient defaultAcsClient = InitVodCilent.initVodClient(ConstantVodUtils.KEY_ID, ConstantVodUtils.KEY_SECRET); //创建获取视频地址request和response GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse(); //向request对象里面设置视频id request.setVideoId(id); //调用初始化对象里面的方法，传递request，获取视频凭证 response = defaultAcsClient.getAcsResponse(request); //获取凭证 String playAuth = response.getPlayAuth(); return R.ok().data(\"playAuth\",playAuth); } ","date":"2020-10-04","objectID":"/guli-14-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/:1:0","tags":[],"title":"guli-14-阿里云视频点播","uri":"/guli-14-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/"},{"categories":[],"content":"二.前端 api/vod.js import request from '@/utils/request' export default { getPlayAuth(vid) { return request({ url: `/eduvod/video/getPlayAuth/${vid}`, method: 'get' }) } } 页面 player/_vid.vue \u003ctemplate\u003e \u003cdiv\u003e \u003c!-- 阿里云视频播放器样式 --\u003e \u003clink rel=\"stylesheet\" href=\"https://g.alicdn.com/de/prismplayer/2.8.1/skins/default/aliplayer-min.css\" \u003e \u003c!-- 阿里云视频播放器脚本 --\u003e \u003cscript charset=\"utf-8\" type=\"text/javascript\" src=\"https://g.alicdn.com/de/prismplayer/2.8.1/aliplayer-min.js\" /\u003e \u003c!-- 定义播放器dom --\u003e \u003cdiv id=\"J_prismPlayer\" class=\"prism-player\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import vod from '@/api/vod' export default { layout: 'video',//应用video布局 asyncData({ params, error }) { return vod.getPlayAuth(params.vid) .then(response =\u003e { return { playAuth: response.data.data.playAuth, vid: params.vid } }) }, mounted() { //页面渲染之后 created new Aliplayer({ id: 'J_prismPlayer', vid: this.vid, // 视频id playauth: this.playAuth, // 播放凭证 encryptType: '1', // 如果播放加密视频，则需设置encryptType=1，非加密视频无需设置此项 width: '100%', height: '500px', // 以下可选设置 // cover: 'http://guli.shop/photo/banner/1525939573202.jpg', // 封面 // qualitySort: 'asc', // 清晰度排序 // mediaType: 'video', // 返回音频还是视频 // autoplay: false, // 自动播放 // isLive: false, // 直播 // rePlay: false, // 循环播放 // preload: true, // controlBarVisibility: 'hover', // 控制条的显示方式：鼠标悬停 // useH5Prism: true, // 播放器类型：html5 }, function(player) { console.log('播放器创建成功') }) } } \u003c/script\u003e ","date":"2020-10-04","objectID":"/guli-14-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/:2:0","tags":[],"title":"guli-14-阿里云视频点播","uri":"/guli-14-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/"},{"categories":[],"content":"三.其他 \u003ca :href=\"'/player/'+video.videoSourceId\" target=\"_blank\"\u003e a标签+target=\"_blank\"会产生新页面 播放器设置 https://player.alicdn.com/aliplayer/setting/setting.html https://player.alicdn.com/aliplayer/presentation/index.html?type=cover ","date":"2020-10-04","objectID":"/guli-14-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/:3:0","tags":[],"title":"guli-14-阿里云视频点播","uri":"/guli-14-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD/"},{"categories":[],"content":"guli-13-微信登录 ","date":"2020-10-01","objectID":"/guli-13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/:0:0","tags":[],"title":"guli-13-微信登录","uri":"/guli-13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"},{"categories":[],"content":"一.微信扫描登录 注册开发者资质 申请网站应用名称 需要域名地址 service_ucenter/utils创建类 配置微信id，密匙和域名地址 package com.guli.educenter.utils; @Component public class ConstantWxUtils implements InitializingBean { @Value(\"${wx.open.app_id}\") private String appId; @Value(\"${wx.open.app_secret}\") private String appSecret; @Value(\"${wx.open.redirect_url}\") private String redirectUrl; public static String WX_OPEN_APP_ID; public static String WX_OPEN_APP_SECRET; public static String WX_OPEN_REDIRECT_URL; @Override public void afterPropertiesSet() throws Exception { WX_OPEN_APP_ID = appId; WX_OPEN_APP_SECRET = appSecret; WX_OPEN_REDIRECT_URL = redirectUrl; } } 创建WxApiController 因为需要直接请求网址不是返回json所以注释变为@Controller return “redirect:\"+url; 重定向 package com.guli.educenter.controller; @CrossOrigin @RequestMapping(\"/api/ucenter/wx\") @Controller public class WxApiController { //1.生成微信扫描二维码 @GetMapping(\"login\") public String getWxCode() { //固定地址 拼接字符串 // String url = \"https://open.weixin.qq.com/connect/qrconnect?appid=\"; String baseUrl = \"https://open.weixin.qq.com/connect/qrconnect\" + \"?appid=%s\" + \"\u0026redirect_uri=%s\" + \"\u0026response_type=code\" + \"\u0026scope=snsapi_login\" + \"\u0026state=%s\" + \"#wechat_redirect\"; //对redirect_uri进行编码 String redirectUrl = ConstantWxUtils.WX_OPEN_REDIRECT_URL; try { redirectUrl = URLEncoder.encode(redirectUrl, \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } //设置%s中的值 String url = String.format( baseUrl, ConstantWxUtils.WX_OPEN_APP_ID, redirectUrl, \"guli\"); //请求微信地址 return \"redirect:\"+url; } } ","date":"2020-10-01","objectID":"/guli-13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/:1:0","tags":[],"title":"guli-13-微信登录","uri":"/guli-13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"},{"categories":[],"content":"二.扫描后获取扫描人信息 controller 需要使用HttpClientUtils工具类模拟浏览器去请求腾讯数据 package com.guli.educenter.utils; import org.apache.commons.io.IOUtils; import org.apache.commons.lang.StringUtils; import org.apache.http.Consts; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.NameValuePair; import org.apache.http.client.HttpClient; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.config.RequestConfig.Builder; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.conn.ConnectTimeoutException; import org.apache.http.conn.ssl.SSLConnectionSocketFactory; import org.apache.http.conn.ssl.SSLContextBuilder; import org.apache.http.conn.ssl.TrustStrategy; import org.apache.http.conn.ssl.X509HostnameVerifier; import org.apache.http.entity.ContentType; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.impl.conn.PoolingHttpClientConnectionManager; import org.apache.http.message.BasicNameValuePair; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLException; import javax.net.ssl.SSLSession; import javax.net.ssl.SSLSocket; import java.io.IOException; import java.net.SocketTimeoutException; import java.security.GeneralSecurityException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Set; /** * 依赖的jar包有：commons-lang-2.6.jar、httpclient-4.3.2.jar、httpcore-4.3.1.jar、commons-io-2.4.jar * @author zhaoyb * */ public class HttpClientUtils { public static final int connTimeout=10000; public static final int readTimeout=10000; public static final String charset=\"UTF-8\"; private static HttpClient client = null; static { PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager(); cm.setMaxTotal(128); cm.setDefaultMaxPerRoute(128); client = HttpClients.custom().setConnectionManager(cm).build(); } public static String postParameters(String url, String parameterStr) throws ConnectTimeoutException, SocketTimeoutException, Exception{ return post(url,parameterStr,\"application/x-www-form-urlencoded\",charset,connTimeout,readTimeout); } public static String postParameters(String url, String parameterStr,String charset, Integer connTimeout, Integer readTimeout) throws ConnectTimeoutException, SocketTimeoutException, Exception{ return post(url,parameterStr,\"application/x-www-form-urlencoded\",charset,connTimeout,readTimeout); } public static String postParameters(String url, Map\u003cString, String\u003e params) throws ConnectTimeoutException, SocketTimeoutException, Exception { return postForm(url, params, null, connTimeout, readTimeout); } public static String postParameters(String url, Map\u003cString, String\u003e params, Integer connTimeout,Integer readTimeout) throws ConnectTimeoutException, SocketTimeoutException, Exception { return postForm(url, params, null, connTimeout, readTimeout); } public static String get(String url) throws Exception { return get(url, charset, null, null); } public static String get(String url, String charset) throws Exception { return get(url, charset, connTimeout, readTimeout); } /** * 发送一个 Post 请求, 使用指定的字符集编码. * * @param url * @param body RequestBody * @param mimeType 例如 application/xml \"application/x-www-form-urlencoded\" a=1\u0026b=2\u0026c=3 * @param charset 编码 * @param connTimeout 建立链接超时时间,毫秒. * @param readTimeout 响应超时时间,毫秒. * @return ResponseBody, 使用指定的字符集编码. * @throws ConnectTimeoutException 建立链接超时异常 * @throws SocketTimeoutException 响应超时 * @throws Exception */ public static String post(String url, String body, String mimeType,String charset, Integer connTimeout, Integer readTimeout) throws ConnectTimeoutException, SocketTimeoutException, Exception { HttpClient client = nul","date":"2020-10-01","objectID":"/guli-13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/:2:0","tags":[],"title":"guli-13-微信登录","uri":"/guli-13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"},{"categories":[],"content":"三.前端数据显示 避免因分布式导致cookie丢失 使用jwt生成token传到前端 前端通过token进行数据查询 default.vue export default { data() { return { token: \"\", loginInfo: { id: \"\", age: \"\", avatar: \"\", mobile: \"\", nickname: \"\", sex: \"\", }, }; }, created() { //获取路径中的值 this.token = this.$route.query.token; if (this.token) { this.wxLogin(); } this.showInfo(); }, methods: { //微信登录显示的方法 wxLogin() { //把token值放到cookie里面 cookie.set('guli_token',this.token,{domain: 'localhost'}) //调用接口，根据token值获取用户信息 loginApi.getLoginUserInfo() .then(response =\u003e { cookie.set('guli_ucenter',this.loginInfo,{domain: 'localhost'}) }) }, //从cookie获取用户信息 showInfo() { //debugger var jsonStr = cookie.get(\"guli_ucenter\"); //alert(jsonStr) if (jsonStr) { this.loginInfo = JSON.parse(jsonStr); } }, logout() { //debugger cookie.set(\"guli_ucenter\", \"\", { domain: \"localhost\" }); cookie.set(\"guli_token\", \"\", { domain: \"localhost\" }); //跳转页面 window.location.href = \"/\"; }, }, }; ","date":"2020-10-01","objectID":"/guli-13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/:3:0","tags":[],"title":"guli-13-微信登录","uri":"/guli-13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"},{"categories":[],"content":"guli-12.5-登录注册功能 ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:0:0","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"一.单点登录三种方式介绍 ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:1:0","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"二.JWT token是按照一定规则生成字符串，包含用户信息 规则不一定 一般采用通用规则，JWT JWT就是给我们规定好了规则，使用jwt规则生成字符串，包含用户信息 jwt生成字符串包含三部分 jwt头信息 有效载荷 包含主体信息 签名哈希 防伪标志 ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:2:0","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"使用 在common引入依赖 common_utils \u003cdependencies\u003e \u003c!-- JWT --\u003e \u003cdependency\u003e \u003cgroupId\u003eio.jsonwebtoken\u003c/groupId\u003e \u003cartifactId\u003ejjwt\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 复制jwt工具类 package com.guli.commonutils; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jws; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.util.StringUtils; import javax.servlet.http.HttpServletRequest; import java.util.Date; /** * @author helen * @since 2019/10/16 */ public class JwtUtils { //token过期时间 public static final long EXPIRE = 1000 * 60 * 60 * 24; //密钥 public static final String APP_SECRET = \"ukc8BDbRigUDaY6pZFfWus2jSH\"; //生成token字符串的方法 public static String getJwtToken(String id, String nickname){ String JwtToken = Jwts.builder() //设置头信息 .setHeaderParam(\"typ\", \"JWT\") .setHeaderParam(\"alg\", \"HS256\") //设置过期时间 .setSubject(\"guli-user\") .setIssuedAt(new Date()) .setExpiration(new Date(System.currentTimeMillis() + EXPIRE)) //设置token主体部分 .claim(\"id\", id) .claim(\"nickname\", nickname) //设置编码 .signWith(SignatureAlgorithm.HS256, APP_SECRET) .compact(); return JwtToken; } /** * 判断token是否存在与有效 * @param jwtToken * @return */ public static boolean checkToken(String jwtToken) { if(StringUtils.isEmpty(jwtToken)) return false; try { Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); } catch (Exception e) { e.printStackTrace(); return false; } return true; } /** * 判断token是否存在与有效 * @param request * @return */ public static boolean checkToken(HttpServletRequest request) { try { String jwtToken = request.getHeader(\"token\"); if(StringUtils.isEmpty(jwtToken)) return false; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); } catch (Exception e) { e.printStackTrace(); return false; } return true; } /** * 根据token获取会员id * @param request * @return */ public static String getMemberIdByJwtToken(HttpServletRequest request) { String jwtToken = request.getHeader(\"token\"); if(StringUtils.isEmpty(jwtToken)) return \"\"; Jws\u003cClaims\u003e claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); Claims claims = claimsJws.getBody(); return (String)claims.get(\"id\"); } } ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:2:1","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"三.阿里云短信服务 ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:3:0","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"1.创建service_msm模块 ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:3:1","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"2.创建包结构，controller，service，启动类，配置文件 ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:3:2","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"3.阿里云控制台 开通短信服务 申请签名管理和模板管理 ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:3:3","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"四.阿里云短信发送 引入依赖 \u003cdependencies\u003e \u003c!-- 阿里云短信依赖 --\u003e \u003c!-- json转换工具 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 阿里云短信依赖核心库 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e controller 使用redis存储五分钟验证码 使用RandomUtil工具类生成验证码 package com.guli.msmservice.controller; @RestController @RequestMapping(\"/edumsm/msm\") @CrossOrigin public class MsmController { @Autowired private MsmService msmService; @Autowired private RedisTemplate\u003cString,String\u003e redisTemplate; //发送短信的方法 @GetMapping(\"send/{phone}\") public R sendMsm(@PathVariable(\"phone\") String phone) { //从redis中获取验证码，如果获取到直接返回 String code = redisTemplate.opsForValue().get(phone); if (!StringUtils.isEmpty(code)) { return R.ok(); } //如果redis获取不到，进行阿里云发送 //生成随机值，传递阿里云进行发送 code = RandomUtil.getSixBitRandom(); Map\u003cString,Object\u003e param = new HashMap\u003c\u003e(); param.put(\"code\",code); //调用service进行短信发送 boolean isSend = msmService.send(param,phone); if (isSend) { //发送成功，把发送成功方法放在redis中 //设置有效时间 redisTemplate.opsForValue().set(phone,code,5, TimeUnit.MINUTES); return R.ok(); } else { return R.error().message(\"发送短信错误\"); } } } service 有新方法 package com.guli.msmservice.service.impl; @Service public class MsmServiceImpl implements MsmService { //发送短信的方法 @Override public boolean send(Map\u003cString, Object\u003e param, String phone) { if(StringUtils.isEmpty(phone)) return false; DefaultProfile profile = DefaultProfile.getProfile(\"default\",\"key\",\"secret\"); IAcsClient client = new DefaultAcsClient(profile); //设置相关固定参数 CommonRequest request = new CommonRequest(); request.setMethod(MethodType.POST); request.setDomain(\"dysmsapi.aliyuncs.com\"); request.setVersion(\"2017-05-25\"); request.setAction(\"SendSms\"); //设置发送相关参数 //手机号 request.putQueryParameter(\"PhoneNumbers\",phone); //签名名称 request.putQueryParameter(\"SignName\",\"我的鼓励在线教育网站\"); //模板code request.putQueryParameter(\"TemplateCode\",\"SMS_203672814\"); //设置验证码 需要转换为JSON request.putQueryParameter(\"TemplateParam\", JSONObject.toJSONString(param)); //发送 try { CommonResponse commonResponse = client.getCommonResponse(request); boolean success = commonResponse.getHttpResponse().isSuccess(); return success; } catch (ClientException e) { e.printStackTrace(); return false; } } } ","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:4:0","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"五.登录注册接口 创建service_ucenter模块 数据库创建用户表，使用代码生成器生成三层架构 创建包结构,启动类，配置文件 controller package com.guli.educenter.entity.vo; import io.swagger.annotations.ApiModelProperty; import lombok.Data; @Data public class RegisterVo { @ApiModelProperty(value = \"昵称\") private String nickname; @ApiModelProperty(value = \"手机号\") private String mobile; @ApiModelProperty(value = \"密码\") private String password; @ApiModelProperty(value = \"验证码\") private String code; } package com.guli.educenter.controller; @RestController @RequestMapping(\"/educenter/member\") @CrossOrigin public class UcenterMemberController { @Autowired private UcenterMemberService memberService; //登录 @PostMapping(\"login\") public R loginUser(@RequestBody UcenterMember member) { //返回token String token = memberService.login(member); return R.ok().data(\"token\",token); } //注册 @PostMapping(\"register\") public R registerUser(@RequestBody RegisterVo registerVo) { memberService.register(registerVo); return R.ok(); } //根据token获取用户信息 @GetMapping(\"getMemberInfo\") public R getMemberInfo(HttpServletRequest request) { //调用jwt ， 获取用户id String memberId = JwtUtils.getMemberIdByJwtToken(request); UcenterMember ugetMemberInfo = memberService.getById(memberId); return R.ok().data(\"ugetMemberInfo\",ugetMemberInfo); } } service 密码进行MD5加密 package com.guli.commonutils; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public final class MD5 { public static String encrypt(String strSrc) { try { char hexChars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; byte[] bytes = strSrc.getBytes(); MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(bytes); bytes = md.digest(); int j = bytes.length; char[] chars = new char[j * 2]; int k = 0; for (int i = 0; i \u003c bytes.length; i++) { byte b = bytes[i]; chars[k++] = hexChars[b \u003e\u003e\u003e 4 \u0026 0xf]; chars[k++] = hexChars[b \u0026 0xf]; } return new String(chars); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); throw new RuntimeException(\"MD5加密出错！！+\" + e); } } public static void main(String[] args) { System.out.println(MD5.encrypt(\"111111\")); } } package com.guli.educenter.service.impl; @Service public class UcenterMemberServiceImpl extends ServiceImpl\u003cUcenterMemberMapper, UcenterMember\u003e implements UcenterMemberService { @Autowired private RedisTemplate\u003cString,String\u003e redisTemplate; //登录 @Override public String login(UcenterMember member) { //获取登录手机号和密码 String mobile = member.getMobile(); String password = member.getPassword(); //判空 if(StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password)) { throw new GuliException(20001,\"登陆失败\"); } //判断手机号是否正确 QueryWrapper\u003cUcenterMember\u003e queryWrapper = new QueryWrapper\u003c\u003e(); queryWrapper.eq(\"mobile\",mobile); UcenterMember mobileMember = baseMapper.selectOne(queryWrapper); if (mobileMember == null) { throw new GuliException(20001,\"手机号不存在\"); } //判断密码 //存储到数据库中的密码需要加密 //把输入的密码先进行加密 再 进行比较 //加密方式 MD5 if (!MD5.encrypt(password).equals(mobileMember.getPassword())) { throw new GuliException(20001,\"账号或密码错误\"); } //判断用户是否禁用 if (mobileMember.getIsDisabled()) { throw new GuliException(20001,\"用户已禁用\"); } //登录成功 //生成token字符串，使用jwt工具类 String jwtToken = JwtUtils.getJwtToken(mobileMember.getId(), mobileMember.getNickname()); return jwtToken; } //注册 @Override public void register(RegisterVo registerVo) { //获取注册的数据 String code = registerVo.getCode(); String mobile = registerVo.getMobile(); String nickname = registerVo.getNickname(); String password = registerVo.getPassword(); //非空判断 if (StringUtils.isEmpty(code) || StringUtils.isEmpty(mobile) || StringUtils.isEmpty(nickname) || StringUtils.isEmpty(password)) { throw new GuliException(20001,\"注册失败\"); } //判断手机验证码是否正确 //获取redis中的验证码 String redisCode = redisTemplate.opsForValue().get(mobile); //判断 if (redisCode == null) { throw new GuliException(20001,\"手机号或验证码错误\"); } if (!code.equals(redisCode)) { throw new GuliException(20001,\"手机号或验证码错误\"); } //判断手机号是否重复 QueryWrapper\u003cUcenterMember\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.eq(\"mobile\",mo","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:5:0","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"六.前端页面整合 安装插件 npm install element-ui npm install vue-qriously npm install js-cookie 在nuxt环境中安装插件 plugins/nuxt-swiper-plugin.js import Vue from 'vue' import VueAwesomeSwiper from 'vue-awesome-swiper/dist/ssr' import VueQriously from 'vue-qriously' import ElementUI from 'element-ui' //element-ui的全部组件 import 'element-ui/lib/theme-chalk/index.css'//element-ui的css Vue.use(ElementUI) //使用elementUI Vue.use(VueQriously) Vue.use(VueAwesomeSwiper) 在layouts文件夹创建登录注册页面布局 layouts/sign.vue \u003ctemplate\u003e \u003cdiv class=\"sign\"\u003e \u003c!--标题--\u003e \u003cdiv class=\"logo\"\u003e \u003cimg src=\"~/assets/img/logo.png\" alt=\"logo\"\u003e \u003c/div\u003e \u003c!--表单--\u003e \u003cnuxt/\u003e \u003c/div\u003e \u003c/template\u003e 在default.vue中修改登录注册超链接地址 创建登录注册页面 register.vue \u003ctemplate\u003e \u003cdiv class=\"main\"\u003e \u003cdiv class=\"title\"\u003e \u003ca href=\"/login\"\u003e登录\u003c/a\u003e \u003cspan\u003e·\u003c/span\u003e \u003ca class=\"active\" href=\"/register\"\u003e注册\u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"sign-up-container\"\u003e \u003cel-form ref=\"userForm\" :model=\"params\"\u003e \u003cel-form-item class=\"input-prepend restyle\" prop=\"nickname\" :rules=\"[ { required: true, message: '请输入你的昵称', trigger: 'blur', }, ]\" \u003e \u003cdiv\u003e \u003cel-input type=\"text\" placeholder=\"你的昵称\" v-model=\"params.nickname\" /\u003e \u003ci class=\"iconfont icon-user\" /\u003e \u003c/div\u003e \u003c/el-form-item\u003e \u003cel-form-item class=\"input-prepend restyle no-radius\" prop=\"mobile\" :rules=\"[ { required: true, message: '请输入手机号码', trigger: 'blur' }, { validator: checkPhone, trigger: 'blur' }, ]\" \u003e \u003cdiv\u003e \u003cel-input type=\"text\" placeholder=\"手机号\" v-model=\"params.mobile\" /\u003e \u003ci class=\"iconfont icon-phone\" /\u003e \u003c/div\u003e \u003c/el-form-item\u003e \u003cel-form-item class=\"input-prepend restyle no-radius\" prop=\"code\" :rules=\"[ { required: true, message: '请输入验证码', trigger: 'blur' }, ]\" \u003e \u003cdiv style=\"width: 100%; display: block; float: left; position: relative\" \u003e \u003cel-input type=\"text\" placeholder=\"验证码\" v-model=\"params.code\" /\u003e \u003ci class=\"iconfont icon-phone\" /\u003e \u003c/div\u003e \u003cdiv class=\"btn\" style=\"position: absolute; right: 0; top: 6px; width: 40%\" \u003e \u003ca href=\"javascript:\" type=\"button\" @click=\"getCodeFun()\" :value=\"codeTest\" style=\"border: none; background-color: none\" \u003e{{ codeTest }}\u003c/a \u003e \u003c/div\u003e \u003c/el-form-item\u003e \u003cel-form-item class=\"input-prepend\" prop=\"password\" :rules=\"[{ required: true, message: '请输入密码', trigger: 'blur' }]\" \u003e \u003cdiv\u003e \u003cel-input type=\"password\" placeholder=\"设置密码\" v-model=\"params.password\" /\u003e \u003ci class=\"iconfont icon-password\" /\u003e \u003c/div\u003e \u003c/el-form-item\u003e \u003cdiv class=\"btn\"\u003e \u003cinput type=\"button\" class=\"sign-up-button\" value=\"注册\" @click=\"submitRegister()\" /\u003e \u003c/div\u003e \u003cp class=\"sign-up-msg\"\u003e 点击 “注册” 即表示您同意并愿意遵守简书 \u003cbr /\u003e \u003ca target=\"_blank\" href=\"http://www.jianshu.com/p/c44d171298ce\" \u003e用户协议\u003c/a \u003e 和 \u003ca target=\"_blank\" href=\"http://www.jianshu.com/p/2ov8x3\"\u003e隐私政策\u003c/a\u003e \u003c/p\u003e \u003c/el-form\u003e \u003c!-- 更多注册方式 --\u003e \u003cdiv class=\"more-sign\"\u003e \u003ch6\u003e社交帐号直接注册\u003c/h6\u003e \u003cul\u003e \u003cli\u003e \u003ca id=\"weixin\" class=\"weixin\" target=\"_blank\" href=\"http://huaan.free.idcfengye.com/api/ucenter/wx/login\" \u003e\u003ci class=\"iconfont icon-weixin\" /\u003e\u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca id=\"qq\" class=\"qq\" target=\"_blank\" href=\"#\" \u003e\u003ci class=\"iconfont icon-qq\" /\u003e\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import \"~/assets/css/sign.css\"; import \"~/assets/css/iconfont.css\"; import registerApi from \"@/api/register\"; export default { layout: \"sign\", data() { return { params: { mobile: \"\", code: \"\", nickname: \"\", password: \"\", }, sending: true, //是否发送验证码 second: 60, //倒计时间 codeTest: \"获取验证码\", }; }, methods: { //发送验证码 getCodeFun() { //debugger // prop 换成你想监听的prop字段 this.$refs.userForm.validateField(\"mobile\", (errMsg) =\u003e { if (errMsg == \"\") { registerApi.sendCode(this.params.mobile).then((res) =\u003e { this.sending = false; this.timeDown(); }); } }); }, //倒计时 timeDown() { let result = setInterval(() =\u003e { --this.second; this.codeTest = this.second; if (this.second \u003c 1) { clearInterval(result); this.sending = true; //this.disabled = false; this.second = 60; this.codeTest = \"获取验证码\"; } }, 1000); }, //注册提交的方法 submitRegister() { registerApi.registerMember(this.params).then((response) =\u003e { //提示注册成功 this.$message({ type: \"success\", message: \"注册成功\", }); this.$router.push({ path: \"/login\" }); }); }, checkPhone(rule, value, callback) { /","date":"2020-09-30","objectID":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/:6:0","tags":[],"title":"guli-12.5-登录注册功能","uri":"/guli-12.5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"guli-11-NUXT ","date":"2020-09-26","objectID":"/guli-11-nuxt/:0:0","tags":[],"title":"guli-11-NUXT","uri":"/guli-11-nuxt/"},{"categories":[],"content":"一.NUXT环境搭建 目录结构 assets:一般放项目使用静态资源，比如css，js，img components:放项目使用相关组件 layouts:定义网页布局方式 pages:项目页面 nuxt.config.js nuxt页面加载过程 default.vue 头信息 nuxt标签 \u003c- \u003cifrcam\u003e引入 index.vue 尾信息 nuxt 路由 第一种：固定路由 \u003crouter-link to=\"/course\" tag=\"li\" active-class=\"current\"\u003e \u003ca\u003e课程\u003c/a\u003e \u003c/router-link\u003e 第二种：动态路由 每次生成路由地址不同 NUXT的动态路由是以下划线开头的vue文件，参数名为下划线后边的文件名 ","date":"2020-09-26","objectID":"/guli-11-nuxt/:1:0","tags":[],"title":"guli-11-NUXT","uri":"/guli-11-nuxt/"},{"categories":[],"content":"二.后端接口 创建 service_cms 模块 创建配置文件 #数据库配置 spring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=123456 ##mybatis日志 #mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # ##设置日志级别 #logging.level.root=info #环境设置:dev,test,prod spring.profiles.active=dev #服务端口 server.port=8081 #服务名 spring.application.name=service-edu #设置时间格式 spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 #配置mapper xml文件的路径 mybatis-plus.mapper-locations=classpath:com/guli/eduservice/mapper/xml/*.xml #nacos服务地址 spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 #开启熔断机制 feign.okhttp.enabled=true #设置hystrix超时时间 hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000 创建数据库表并生成相应代码 controller 巨幕： package com.guli.educms.controller; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.guli.commonutils.R; import com.guli.educms.entity.CrmBanner; import com.guli.educms.service.CrmBannerService; import io.swagger.annotations.ApiOperation; import org.mybatis.spring.annotation.MapperScan; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * \u003cp\u003e * 首页banner表 前端控制器 * \u003c/p\u003e * * @author testjava * @since 2020-09-19 */ @RestController @RequestMapping(\"/educms/banneradmin\") @CrossOrigin public class BannerAdminController { @Autowired private CrmBannerService bannerService; //1 分页查询banner @GetMapping(\"pageBanner/{page}/{limit}\") public R pageBanner(@PathVariable long page, @PathVariable long limit) { Page\u003cCrmBanner\u003e pageBanner = new Page\u003c\u003e(page,limit); bannerService.page(pageBanner,null); return R.ok().data(\"items\",pageBanner.getRecords()).data(\"total\",pageBanner.getTotal()); } //2 添加banner @PostMapping(\"addBanner\") public R addBanner(@RequestBody CrmBanner crmBanner) { bannerService.save(crmBanner); return R.ok(); } @ApiOperation(value = \"获取Banner\") @GetMapping(\"get/{id}\") public R get(@PathVariable String id) { CrmBanner banner = bannerService.getById(id); return R.ok().data(\"item\", banner); } @ApiOperation(value = \"修改Banner\") @PutMapping(\"update\") public R updateById(@RequestBody CrmBanner banner) { bannerService.updateById(banner); return R.ok(); } @ApiOperation(value = \"删除Banner\") @DeleteMapping(\"remove/{id}\") public R remove(@PathVariable String id) { bannerService.removeById(id); return R.ok(); } } package com.guli.educms.controller; import com.guli.commonutils.R; import com.guli.educms.entity.CrmBanner; import com.guli.educms.service.CrmBannerService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; /** * \u003cp\u003e * 首页banner表 前端控制器 * \u003c/p\u003e * * @author testjava * @since 2020-09-19 */ @RestController @RequestMapping(\"/educms/bannerfront\") @CrossOrigin public class BannerFrontController { @Autowired private CrmBannerService bannerService; //查询所有banner @GetMapping(\"getAllBanner\") public R getAllBanner() { List\u003cCrmBanner\u003e list = bannerService.selectAllBanner(); return R.ok().data(\"list\",list); } } 老师，课程： package com.guli.eduservice.controller.front; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.guli.commonutils.R; import com.guli.eduservice.entity.EduChapter; import com.guli.eduservice.entity.EduCourse; import com.guli.eduservice.entity.EduTeacher; import com.guli.eduservice.service.EduCourseService; import com.guli.eduservice.service.EduTeacherService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.anno","date":"2020-09-26","objectID":"/guli-11-nuxt/:2:0","tags":[],"title":"guli-11-NUXT","uri":"/guli-11-nuxt/"},{"categories":[],"content":"三.前端页面 封装axios 引入axios 创建utils/request.js import axios from 'axios' // 创建axios实例 const service = axios.create({ baseURL: 'http://localhost:9001', // api的base_url timeout: 20000 // 请求超时时间 }) export default service api banner import request from '@/utils/request' export default { //查询前两条banner数据 getListBanner() { return request({ url: '/educms/bannerfront/getAllBanner', method: 'get' }) } } index import request from '@/utils/request' export default { //查询热门课程和名师 getIndexData() { return request({ url: '/eduservice/indexfront/index', method: 'get' }) } } 页面 default \u003ctemplate\u003e \u003cdiv class=\"in-wrap\"\u003e \u003c!-- 公共头引入 --\u003e \u003cheader id=\"header\"\u003e \u003csection class=\"container\"\u003e \u003ch1 id=\"logo\"\u003e \u003ca href=\"#\" title=\"谷粒学院\"\u003e \u003cimg src=\"~/assets/img/logo.png\" width=\"100%\" alt=\"谷粒学院\"\u003e \u003c/a\u003e \u003c/h1\u003e \u003cdiv class=\"h-r-nsl\"\u003e \u003cul class=\"nav\"\u003e \u003crouter-link to=\"/\" tag=\"li\" active-class=\"current\" exact\u003e \u003ca\u003e首页\u003c/a\u003e \u003c/router-link\u003e \u003crouter-link to=\"/course\" tag=\"li\" active-class=\"current\"\u003e \u003ca\u003e课程\u003c/a\u003e \u003c/router-link\u003e \u003crouter-link to=\"/teacher\" tag=\"li\" active-class=\"current\"\u003e \u003ca\u003e名师\u003c/a\u003e \u003c/router-link\u003e \u003crouter-link to=\"/article\" tag=\"li\" active-class=\"current\"\u003e \u003ca\u003e文章\u003c/a\u003e \u003c/router-link\u003e \u003crouter-link to=\"/qa\" tag=\"li\" active-class=\"current\"\u003e \u003ca\u003e问答\u003c/a\u003e \u003c/router-link\u003e \u003c/ul\u003e \u003c!-- / nav --\u003e \u003cul class=\"h-r-login\"\u003e \u003cli id=\"no-login\"\u003e \u003ca href=\"/sing_in\" title=\"登录\"\u003e \u003cem class=\"icon18 login-icon\"\u003e\u0026nbsp;\u003c/em\u003e \u003cspan class=\"vam ml5\"\u003e登录\u003c/span\u003e \u003c/a\u003e | \u003ca href=\"/sign_up\" title=\"注册\"\u003e \u003cspan class=\"vam ml5\"\u003e注册\u003c/span\u003e \u003c/a\u003e \u003c/li\u003e \u003cli class=\"mr10 undis\" id=\"is-login-one\"\u003e \u003ca href=\"#\" title=\"消息\" id=\"headerMsgCountId\"\u003e \u003cem class=\"icon18 news-icon\"\u003e\u0026nbsp;\u003c/em\u003e \u003c/a\u003e \u003cq class=\"red-point\" style=\"display: none\"\u003e\u0026nbsp;\u003c/q\u003e \u003c/li\u003e \u003cli class=\"h-r-user undis\" id=\"is-login-two\"\u003e \u003ca href=\"#\" title\u003e \u003cimg src=\"~/assets/img/avatar-boy.gif\" width=\"30\" height=\"30\" class=\"vam picImg\" alt \u003e \u003cspan class=\"vam disIb\" id=\"userName\"\u003e\u003c/span\u003e \u003c/a\u003e \u003ca href=\"javascript:void(0)\" title=\"退出\" onclick=\"exit();\" class=\"ml5\"\u003e退出\u003c/a\u003e \u003c/li\u003e \u003c!-- /未登录显示第1 li；登录后显示第2，3 li --\u003e \u003c/ul\u003e \u003caside class=\"h-r-search\"\u003e \u003cform action=\"#\" method=\"post\"\u003e \u003clabel class=\"h-r-s-box\"\u003e \u003cinput type=\"text\" placeholder=\"输入你想学的课程\" name=\"queryCourse.courseName\" value\u003e \u003cbutton type=\"submit\" class=\"s-btn\"\u003e \u003cem class=\"icon18\"\u003e\u0026nbsp;\u003c/em\u003e \u003c/button\u003e \u003c/label\u003e \u003c/form\u003e \u003c/aside\u003e \u003c/div\u003e \u003caside class=\"mw-nav-btn\"\u003e \u003cdiv class=\"mw-nav-icon\"\u003e\u003c/div\u003e \u003c/aside\u003e \u003cdiv class=\"clear\"\u003e\u003c/div\u003e \u003c/section\u003e \u003c/header\u003e \u003c!-- /公共头引入 --\u003e \u003cnuxt/\u003e \u003c!-- 公共底引入 --\u003e \u003cfooter id=\"footer\"\u003e \u003csection class=\"container\"\u003e \u003cdiv class\u003e \u003ch4 class=\"hLh30\"\u003e \u003cspan class=\"fsize18 f-fM c-999\"\u003e友情链接\u003c/span\u003e \u003c/h4\u003e \u003cul class=\"of flink-list\"\u003e \u003cli\u003e \u003ca href=\"http://www.atguigu.com/\" title=\"尚硅谷\" target=\"_blank\"\u003e尚硅谷\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003cdiv class=\"clear\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"b-foot\"\u003e \u003csection class=\"fl col-7\"\u003e \u003csection class=\"mr20\"\u003e \u003csection class=\"b-f-link\"\u003e \u003ca href=\"#\" title=\"关于我们\" target=\"_blank\"\u003e关于我们\u003c/a\u003e| \u003ca href=\"#\" title=\"联系我们\" target=\"_blank\"\u003e联系我们\u003c/a\u003e| \u003ca href=\"#\" title=\"帮助中心\" target=\"_blank\"\u003e帮助中心\u003c/a\u003e| \u003ca href=\"#\" title=\"资源下载\" target=\"_blank\"\u003e资源下载\u003c/a\u003e| \u003cspan\u003e服务热线：010-56253825(北京) 0755-85293825(深圳)\u003c/span\u003e \u003cspan\u003eEmail：info@atguigu.com\u003c/span\u003e \u003c/section\u003e \u003csection class=\"b-f-link mt10\"\u003e \u003cspan\u003e©2018课程版权均归谷粒学院所有 京ICP备17055252号\u003c/span\u003e \u003c/section\u003e \u003c/section\u003e \u003c/section\u003e \u003caside class=\"fl col-3 tac mt15\"\u003e \u003csection class=\"gf-tx\"\u003e \u003cspan\u003e \u003cimg src=\"~/assets/img/wx-icon.png\" alt\u003e \u003c/span\u003e \u003c/section\u003e \u003csection class=\"gf-tx\"\u003e \u003cspan\u003e \u003cimg src=\"~/assets/img/wb-icon.png\" alt\u003e \u003c/span\u003e \u003c/section\u003e \u003c/aside\u003e \u003cdiv class=\"clear\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/section\u003e \u003c/footer\u003e \u003c!-- /公共底引入 --\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import \"~/assets/css/reset.css\"; import \"~/assets/css/theme.css\"; import \"~/assets/css/global.css\"; import \"~/assets/css/web.css\"; export default {}; \u003c/script\u003e pages/index \u003ctemplate\u003e \u003cdiv\u003e \u003c!-- 幻灯片 开始 --\u003e \u003cdiv v-swiper:mySwiper=\"swiperOption\"\u003e \u003cdiv class=\"swiper-wrapper\"\u003e \u003cdiv v-for=\"banner in bannerList\" :key=\"banner.id\" class=\"swiper-slide\" style=\"background: #040B1B;\"\u003e \u003ca target=\"_blank\" :href=\"banner.linkUrl\"\u003e \u003cimg :src=\"banner.imageUrl\" :alt=\"bann","date":"2020-09-26","objectID":"/guli-11-nuxt/:3:0","tags":[],"title":"guli-11-NUXT","uri":"/guli-11-nuxt/"},{"categories":[],"content":"guli-10-Nacos 服务发现和服务健康监测 动态配置服务 动态DNS服务 服务及其元数据管理 ","date":"2020-09-15","objectID":"/guli-10-nacos/:0:0","tags":[],"title":"guli-10-Nacos","uri":"/guli-10-nacos/"},{"categories":[],"content":"一.安装与配置 下载 启动 Linux/Unix/Mac 启动命令(standalone代表着单机模式运行，非集群模式) 启动命令：sh startup.sh -m standalone Windows 启动命令：cmd startup.cmd 或者双击startup.cmd运行文件。 访问：http://localhost:8848/nacos 用户名密码：nacos/nacos ","date":"2020-09-15","objectID":"/guli-10-nacos/:1:0","tags":[],"title":"guli-10-Nacos","uri":"/guli-10-nacos/"},{"categories":[],"content":"二.服务注册 配置pom依赖 \u003c!--服务注册--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e 添加服务配置信息 #nacos服务地址 spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 #还需要配置 #服务端口 server.port=8081 #服务名 不可以使用下划线 spring.application.name=service-edu 在启动类上添加注解 @EnableDiscoveryClient 启动客户端微服务，可以在Nacos服务列表中看到被注册的微服务 ","date":"2020-09-15","objectID":"/guli-10-nacos/:2:0","tags":[],"title":"guli-10-Nacos","uri":"/guli-10-nacos/"},{"categories":[],"content":"三.服务调用 配置pom依赖 \u003c!--服务调用--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e 调用端的启动类添加注解 @EnableFeignClients 创建包和接口 创建client包 @FeignClient注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。 @GetMapping注解用于对被调用的微服务进行地址映射,路径要写全。 @PathVariable注解一定要指定参数名称，否则出错 @Component注解防止，在其他位置注入CodClient时idea报错 package com.guli.eduservice.client; @Component @FeignClient(\"service-vod\") public interface VodClient { //定义调用方法的路径 //根据视频id删除视频 @DeleteMapping(\"/eduvod/video/removeAlyVideo/{id}\") public R removeAlyVideo(@PathVariable(\"id\") String id); //根据list删除多个视频 @DeleteMapping(\"/eduvod/video/deleteBatch\") public R deleteBatch(@RequestParam(\"videoIdList\") List\u003cString\u003e videoIdList); } ","date":"2020-09-15","objectID":"/guli-10-nacos/:3:0","tags":[],"title":"guli-10-Nacos","uri":"/guli-10-nacos/"},{"categories":[],"content":"四.业务 ","date":"2020-09-15","objectID":"/guli-10-nacos/:4:0","tags":[],"title":"guli-10-Nacos","uri":"/guli-10-nacos/"},{"categories":[],"content":"1.删除小结的同时删除视频 前置：在vod/controller中 //根据视频id删除视频 @DeleteMapping(\"removeAlyVideo/{id}\") public R removeAlyVideo(@PathVariable String id) { try { //初始化对象 DefaultAcsClient defaultAcsClient = InitVodCilent.initVodClient(ConstantVodUtils.KEY_ID, ConstantVodUtils.KEY_SECRET); //创建删除视频request对象 DeleteVideoRequest request = new DeleteVideoRequest(); //向request中设置id request.setVideoIds(id); defaultAcsClient.getAcsResponse(request); return R.ok(); } catch (ClientException e) { e.printStackTrace(); throw new GuliException(20001,\"删除失败\"); } } 在服务中心中注册vod，edu服务 pom application 启动类注解 在edu中进行服务调用配置 pom 启动类注解 在edu模块创建client包，创建接口，调用vod中的接口 @FeignClient注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。 @GetMapping注解用于对被调用的微服务进行地址映射,路径要写全。 @PathVariable注解一定要指定参数名称，否则出错 @Component注解防止，在其他位置注入CodClient时idea报错 package com.guli.eduservice.client; @Component @FeignClient(\"service-vod\") public interface VodClient { //定义调用方法的路径 //根据视频id删除视频 @DeleteMapping(\"/eduvod/video/removeAlyVideo/{id}\") public R removeAlyVideo(@PathVariable(\"id\") String id); } 在controller中调用 //删除小节 @DeleteMapping(\"deleteVideo/{id}\") public R deleteVideo(@PathVariable String id) { //删除阿里云视频 EduVideo eduVideo = videoService.getById(id); String videoSourceId = eduVideo.getVideoSourceId(); if (!StringUtils.isEmpty(videoSourceId)) { vodClient.removeAlyVideo(videoSourceId); } //删除数据库中内容 videoService.removeById(id); return R.ok(); } ","date":"2020-09-15","objectID":"/guli-10-nacos/:4:1","tags":[],"title":"guli-10-Nacos","uri":"/guli-10-nacos/"},{"categories":[],"content":"2.删除课程的同时删除多个视频 vod/controller //删除多个阿里云视频 @DeleteMapping(\"deleteBatch\") public R deleteBatch(@RequestParam(\"videoIdList\") List\u003cString\u003e videoIdList) { vodService.removeMoreAlyVideo(videoIdList); return R.ok(); } service @Override public void removeMoreAlyVideo(List\u003cString\u003e videoIdList) { try { //初始化对象 DefaultAcsClient defaultAcsClient = InitVodCilent.initVodClient(ConstantVodUtils.KEY_ID, ConstantVodUtils.KEY_SECRET); //创建删除视频request对象 DeleteVideoRequest request = new DeleteVideoRequest(); //拆开列表中的数组1，2，3 String join = StringUtils.join(videoIdList.toArray(), \",\"); //向request中设置id request.setVideoIds(join); defaultAcsClient.getAcsResponse(request); } catch (ClientException e) { e.printStackTrace(); throw new GuliException(20001,\"删除失败\"); } } client package com.guli.eduservice.client; @Component @FeignClient(\"service-vod\") public interface VodClient { //定义调用方法的路径 //根据视频id删除视频 @DeleteMapping(\"/eduvod/video/removeAlyVideo/{id}\") public R removeAlyVideo(@PathVariable(\"id\") String id); //根据list删除多个视频 @DeleteMapping(\"/eduvod/video/deleteBatch\") public R deleteBatch(@RequestParam(\"videoIdList\") List\u003cString\u003e videoIdList); } 调用 //删除小结 @Override @Transactional public void removeVideoByCourseId(String courseId) { //删除阿里云视频 QueryWrapper\u003cEduVideo\u003e queryWrapper = new QueryWrapper\u003c\u003e(); queryWrapper.eq(\"course_id\",courseId); queryWrapper.select(\"video_sourse_id\"); List\u003cEduVideo\u003e eduVideos = baseMapper.selectList(queryWrapper); List\u003cString\u003e videoIds = new ArrayList\u003c\u003e(); for(EduVideo eduVideo:eduVideos) { String videoSourceId = eduVideo.getVideoSourceId(); if (!StringUtils.isEmpty(videoSourceId)) { videoIds.add(videoSourceId); } } if (videoIds.size()\u003e0) { vodClient.deleteBatch(videoIds); } //删除数据库中小结本身 QueryWrapper\u003cEduVideo\u003e eduVideoQueryWrapper = new QueryWrapper\u003c\u003e(); eduVideoQueryWrapper.eq(\"course_id\",courseId); baseMapper.delete(eduVideoQueryWrapper); } ","date":"2020-09-15","objectID":"/guli-10-nacos/:4:2","tags":[],"title":"guli-10-Nacos","uri":"/guli-10-nacos/"},{"categories":[],"content":"guli-9.5-阿里云视频 一.测试 ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:0:0","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"1.阿里云控制台 https://help.aliyun.com/product/29932.html?spm=a2c4g.11186623.6.84.3b5873fboAolJQ ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:1:0","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"2.功能测试 创建service_vod模块 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun.oss\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-oss\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-vod\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-vod-upload\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.json\u003c/groupId\u003e \u003cartifactId\u003ejson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.google.code.gson\u003c/groupId\u003e \u003cartifactId\u003egson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejoda-time\u003c/groupId\u003e \u003cartifactId\u003ejoda-time\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 在test中创建InitObject类 初始化操作 package com.guli.vodtest; import com.aliyun.oss.ClientException; import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.profile.DefaultProfile; public class InitObject { public static DefaultAcsClient initVodClient(String accessKeyId, String accessKeySecret) throws ClientException { String regionId = \"cn-shanghai\"; // 点播服务接入区域 DefaultProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret); DefaultAcsClient client = new DefaultAcsClient(profile); return client; } } 根据视频id获取视频播放地址 //根据视频id获取视频播放地址 public static void getPalyUrl() throws ClientException { //1.根据视频id获取视频播放地址 //创建初始化对象 DefaultAcsClient defaultAcsClient = InitVodCilent.initVodClient(\"accessKeyId\",\"accessKeySecret\"); //创建获取视频地址request和response GetPlayInfoRequest request = new GetPlayInfoRequest(); GetPlayInfoResponse response = new GetPlayInfoResponse(); //向request对象里面设置视频id request.setVideoId(\"678bb315bf974ef0a23f2136ab155f13\"); //调用初始化对象里面的方法，传递request，获取数据 response = defaultAcsClient.getAcsResponse(request); List\u003cGetPlayInfoResponse.PlayInfo\u003e playInfoList = response.getPlayInfoList(); //播放地址 for (GetPlayInfoResponse.PlayInfo playInfo:playInfoList) { System.out.println(\"播放地址：\"+playInfo.getPlayURL()); } //Base信息 System.out.println(\"视频名称：\"+response.getVideoBase().getTitle()); } 根据视频id获取视频凭证 //根据视频id获取视频凭证 public static void getPlayAuth() throws ClientException { //根据视频id获取视频凭证 //创建初始化对象 DefaultAcsClient defaultAcsClient = InitVodCilent.initVodClient(\"accessKeyId\", \"accessKeySecret\"); //创建获取视频地址request和response GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse(); //向request对象里面设置视频id request.setVideoId(\"678bb315bf974ef0a23f2136ab155f13\"); //调用初始化对象里面的方法，传递request，获取视频凭证 response = defaultAcsClient.getAcsResponse(request); //获取凭证 System.out.println(\"视频凭证：\"+response.getPlayAuth()); } ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:2:0","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"3.视频上传 未开源jar包安装 在jar包目录中进入cmd运行 mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.11.jar public static void main(String[] args) throws ClientException { String accessKeyId = \"accessKeyId\"; String accessKeySecret = \"accessKeySecret\"; //上传后文件名称 String title = \"微博2333.mp4\"; //本地文件路径和名称 String fileName = \"E:\\\\视频存储\\\\pr储存\\\\19.12.10火炬女神\\\\微博.mp4\"; //本地上传视频 UploadVideoRequest request = new UploadVideoRequest(accessKeyId, accessKeySecret, title, fileName); /* 可指定分片上传时每个分片的大小，默认为2M字节 */ request.setPartSize(2 * 1024 * 1024L); /* 可指定分片上传时的并发线程数，默认为1，(注：该配置会占用服务器CPU资源，需根据服务器情况指定）*/ request.setTaskNum(1); UploadVideoImpl uploader = new UploadVideoImpl(); UploadVideoResponse response = uploader.uploadVideo(request); System.out.print(\"RequestId=\" + response.getRequestId() + \"\\n\"); //请求视频点播服务的请求ID if (response.isSuccess()) { System.out.print(\"VideoId=\" + response.getVideoId() + \"\\n\"); } else { /* 如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 */ System.out.print(\"VideoId=\" + response.getVideoId() + \"\\n\"); System.out.print(\"ErrorCode=\" + response.getCode() + \"\\n\"); System.out.print(\"ErrorMessage=\" + response.getMessage() + \"\\n\"); } } 二.小节视频功能 ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:3:0","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"1.后端 引入依赖 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun.oss\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-oss\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-vod\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-vod-upload\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.json\u003c/groupId\u003e \u003cartifactId\u003ejson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.google.code.gson\u003c/groupId\u003e \u003cartifactId\u003egson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejoda-time\u003c/groupId\u003e \u003cartifactId\u003ejoda-time\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 配置文件 #服务端口 server: port: 8083 #服务名 spring: application: name: service-vod #环境设置 profiles: active: dev servlet: multipart: max-file-size: 1024MB max-request-size: 1024MB #阿里云vod aliyun: oss: file: keyid: keyid keysecret: keysecret 创建启动类 package com.guli.vod; @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) @ComponentScan(basePackages = {\"com.guli\"}) public class VodApplication { public static void main(String[] args) { SpringApplication.run(VodApplication.class,args); } } controller package com.guli.vod.controller; import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.exceptions.ClientException; import com.aliyuncs.vod.model.v20170321.DeleteVideoRequest; import com.guli.commonutils.R; import com.guli.servicebase.exception.GuliException; import com.guli.vod.service.VodService; import com.guli.vod.utils.ConstantVodUtils; import com.guli.vod.utils.InitVodCilent; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; @RestController @RequestMapping(\"eduvod/video\") @CrossOrigin public class VodController { @Autowired private VodService vodService; //上传视频到阿里云的方法 @PostMapping(\"uploadAlyiVideo\") public R uploadAlyiVideo(MultipartFile file) { String videoId = vodService.uploadVideoAly(file); return R.ok().data(\"videoId\",videoId); } //根据视频id删除视频 @DeleteMapping(\"removeAlyVideo/{id}\") public R removeAlyVideo(@PathVariable String id) { try { //初始化对象 DefaultAcsClient defaultAcsClient = InitVodCilent.initVodClient(ConstantVodUtils.KEY_ID, ConstantVodUtils.KEY_SECRET); //创建删除视频request对象 DeleteVideoRequest request = new DeleteVideoRequest(); //向request中设置id request.setVideoIds(id); defaultAcsClient.getAcsResponse(request); return R.ok(); } catch (ClientException e) { e.printStackTrace(); throw new GuliException(20001,\"删除失败\"); } } } service package com.guli.vod.service.impl; import com.aliyun.vod.upload.impl.UploadVideoImpl; import com.aliyun.vod.upload.req.UploadStreamRequest; import com.aliyun.vod.upload.resp.UploadStreamResponse; import com.guli.vod.service.VodService; import com.guli.vod.utils.ConstantVodUtils; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; @Service public class VodServiceImpl implements VodService { @Override public String uploadVideoAly(MultipartFile file) { try { //fileName上传文件原始名称 String fileName = file.getOriginalFilename(); //title上传文件显示名称 String title = fileName.substring(0,fileName.lastIndexOf(\".\")); //inputStream上传文件输入流 InputStream inputStream = file.getInputStream(); UploadStreamRequest request = new UploadStreamRequest(ConstantVodUtils.KEY_ID, ConstantVodUtils.KEY_SECRET, title, fileName, inputStream); UploadVideoImpl uploader = new UploadVideoImpl(); UploadStreamResponse response = uploader.uploadStream(request); return response.getVideoId(); } catch (IOException e) { e.printStackTrace(); return null; } } } 文件大小设置 application spring: servlet: multipart: max-file-size: 1024MB max-request-size: 1024MB ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:4:0","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"2.Nginx 配置8083端口规则 设置文件上传大小设置 http { #文件大小配置 client_max_body_size 1204m; server { listen 9001; server_name localhost; location ~ /eduservice/ { proxy_pass http://localhost:8081; } location ~ /eduoss/ { proxy_pass http://localhost:8082; } location ~ /eduvod/ { proxy_pass http://localhost:8083; } } } ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:5:0","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"3.前端 ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:6:0","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"1.上传视频 表单 \u003cel-form-item label=\"上传视频\"\u003e \u003cel-upload :on-success=\"handleVodUploadSuccess\" :on-remove=\"handleVodRemove\" :before-remove=\"beforeVodRemove\" :on-exceed=\"handleUploadExceed\" :file-list=\"fileList\" :action=\"BASE_API+'/eduvod/video/uploadAlyiVideo'\" :limit=\"1\" class=\"upload-demo\" \u003e \u003cel-button size=\"small\" type=\"primary\"\u003e上传视频\u003c/el-button\u003e \u003cel-tooltip placement=\"right-end\"\u003e \u003cdiv slot=\"content\"\u003e 最大支持1G， \u003cbr /\u003e支持3GP、ASF、AVI、DAT、DV、FLV、F4V、 \u003cbr /\u003eGIF、M2T、M4V、MJ2、MJPEG、MKV、MOV、MP4、 \u003cbr /\u003eMPE、MPG、MPEG、MTS、OGG、QT、RM、RMVB、 \u003cbr /\u003eSWF、TS、VOB、WMV、WEBM 等视频格式上传 \u003c/div\u003e \u003ci class=\"el-icon-question\" /\u003e \u003c/el-tooltip\u003e \u003c/el-upload\u003e \u003c/el-form-item\u003e js //上传视频成功的方法 handleVodUploadSuccess(response,file,fileList) { this.video.videoSourceId = response.data.videoId; this.video.videoOriginalName = file.name; }, //再次上传 handleUploadExceed() { this.$message.warning(\"想要重新上传视频，请先删除已上传的视频\"); }, data data() { return { saveBtnDisabled: false, // 保存按钮是否禁用 courseId: \"\", // 所属课程章节嵌套课时列表 chapterNestedList: [], // //封装章节数据 chapter: { title: \"\", sort: 0, }, video: { title: \"\", sort: 0, free: 0, videoSourceId: \"\", videoOriginalName:\"\",//视频名称 }, dialogChapterFormVisible: false, //章节弹框 dialogVideoFormVisible: false, //小节弹框 fileList: [],//上传文件列表 BASE_API: process.env.BASE_API,//接口API地址 }; }, ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:6:1","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"2.删除 api/video //删除视频 removeAlyVideo(id) { return request({ url: '/eduvod/video/removeAlyVideo/'+id, method: 'delete', }) } 页面 //删除视频(点击确定) handleVodRemove() { //调用接口 video.removeAlyVideo(this.video.videoSourceId).then(response=\u003e{ this.$message({ type: \"success\", message: \"删除成功！\", }); //清空视频 this.fileList = []; //清空video中的视频id和视频名称 this.videoSourceId = ''; this.videoOriginalName = ''; }) }, //删除视频之前(点击X) beforeVodRemove(file,fileList) { return this.$confirm(`确定移除 ${file.name}？`) }, ","date":"2020-09-15","objectID":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/:6:2","tags":[],"title":"guli-9.5-阿里云视频","uri":"/guli-9.5-%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91/"},{"categories":[],"content":"guli-9-课程列表 一.后端 Course controller //课程列表查询 @PostMapping(\"{current}/{limit}\") public R getCourseList(@PathVariable long current, @PathVariable long limit, @RequestBody(required = false) CourseQuery courseQuery) { //1.创建page对象 Page\u003cEduCourse\u003e pageCourse = new Page\u003c\u003e(current,limit); //2.构建Wrapper QueryWrapper\u003cEduCourse\u003e queryWrapper = new QueryWrapper\u003c\u003e(); //3.构建条件 String title = courseQuery.getTitle(); String status = courseQuery.getStatus(); //4.添加条件 if(!StringUtils.isEmpty(title)) { queryWrapper.like(\"title\",title); } if(!StringUtils.isEmpty(status)) { queryWrapper.eq(\"status\",status); } //5.根据时间排序 queryWrapper.orderByDesc(\"gmt_create\"); //6.查询 courseService.page(pageCourse, queryWrapper); long total = pageCourse.getTotal();//总记录数 List\u003cEduCourse\u003e courses = pageCourse.getRecords();//每页教师数据集合 return R.ok().data(\"total\",total).data(\"rows\",courses); } //删除课程 @DeleteMapping(\"{courseId}\") public R deleteCourseById(@PathVariable String courseId) { courseService.removeCourse(courseId); return R.ok(); } service //课程描述注入 @Autowired private EduCourseDescriptionService eduCourseDescriptionService; //注入小结和章节 @Autowired private EduVideoService eduVideoService; @Autowired private EduChapterService eduChapterService; //删除课程的方法 @Override public void removeCourse(String courseId) { //1.删除小结 eduVideoService.removeVideoByCourseId(courseId); //2.删除章节 eduChapterService.removeChapterByCourseId(courseId); //3.删除描述 eduCourseDescriptionService.removeById(courseId); //4.删除本身 int result = baseMapper.deleteById(courseId); if (result == 0) { throw new GuliException(20001,\"删除失败\"); } } //删除小结 @Override public void removeVideoByCourseId(String courseId) { QueryWrapper\u003cEduVideo\u003e eduVideoQueryWrapper = new QueryWrapper\u003c\u003e(); eduVideoQueryWrapper.eq(\"course_id\",courseId); baseMapper.delete(eduVideoQueryWrapper); } @Override public void removeChapterByCourseId(String courseId) { QueryWrapper\u003cEduChapter\u003e eduChapterQueryWrapper = new QueryWrapper\u003c\u003e(); eduChapterQueryWrapper.eq(\"course_id\",courseId); baseMapper.delete(eduChapterQueryWrapper); } 二.前端 Course api //5.课程列表 getCourseList(current, limit, courseQuery) { return request({ url:`/eduservice/course/${current}/${limit}`, method:\"post\", data: courseQuery }) }, //6.删除课程 deleteCourseById(courseId) { return request({ url:\"/eduservice/course/\"+courseId, method:\"delete\" }) } view/list.vue \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e 课程列表 \u003c!--查询表单--\u003e \u003cel-form :inline=\"true\" class=\"demo-form-inline\"\u003e \u003cel-form-item\u003e \u003cel-input v-model=\"courseQuery.title\" placeholder=\"课程名称\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item\u003e \u003cel-select v-model=\"courseQuery.status\" clearable placeholder=\"课程状态\"\u003e \u003cel-option :value=\"'Draft'\" label=\"未发布\" /\u003e \u003cel-option :value=\"'Normal'\" label=\"已发布\" /\u003e \u003c/el-select\u003e \u003c/el-form-item\u003e \u003cel-button type=\"primary\" icon=\"el-icon-search\" @click=\"getCourseListPage()\"\u003e查询\u003c/el-button\u003e \u003cel-button type=\"default\" @click=\"resetData()\"\u003e清空\u003c/el-button\u003e \u003c/el-form\u003e \u003cel-table :data=\"list\" element-loading-text=\"数据加载中\" border fit highlight-current-row\u003e \u003cel-table-column label=\"序号\" width=\"70\" align=\"center\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e{{ (page - 1) * limit + scope.$index + 1 }}\u003c/template\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"title\" label=\"课程名称\" width=\"80\" /\u003e \u003cel-table-column label=\"课程状态\" width=\"80\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e{{ scope.row.status==='Normal'?'已发布':'未发布' }}\u003c/template\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"lessonNum\" label=\"课时数\" /\u003e \u003cel-table-column prop=\"gmtCreate\" label=\"添加时间\" width=\"160\" /\u003e \u003cel-table-column prop=\"viewCount\" label=\"浏览数量\" width=\"60\" /\u003e \u003cel-table-column label=\"操作\" width=\"200\" align=\"center\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e \u003crouter-link :to=\"'/course/updateTeacher/'+scope.row.id\"\u003e \u003cel-button type=\"primary\" size=\"mini\" icon=\"el-icon-edit\"\u003e编辑课程的基本信息\u003c/el-button\u003e \u003c/router-link\u003e \u003crouter-link :to=\"'/teacher/updateTeacher/'+scope.row.id\"\u003e \u003cel-button type=\"primary\" size=\"mini\" icon=\"el-icon-edit\"\u003e编辑课程的大纲\u003c/el-button\u003e \u003c/router-link\u003e \u003cel-button type=\"danger\" size=\"mini\" icon=\"el-icon-delete\" @click=\"removeCourseById(sco","date":"2020-09-13","objectID":"/guli-9-%E8%AF%BE%E7%A8%8B%E5%88%97%E8%A1%A8/:0:0","tags":[],"title":"guli-9-课程列表","uri":"/guli-9-%E8%AF%BE%E7%A8%8B%E5%88%97%E8%A1%A8/"},{"categories":[],"content":"guli-8.5-章节,小节,发布功能 一.章节，小节 后端 controller 章节 package com.guli.eduservice.controller; import com.guli.commonutils.R; import com.guli.eduservice.entity.EduChapter; import com.guli.eduservice.entity.chapter.ChapterVo; import com.guli.eduservice.service.EduChapterService; import com.guli.servicebase.exception.GuliException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\"/eduservice/chapter\") @CrossOrigin public class EduChapterController { // @Autowired private EduChapterService eduChapterService; //课程大纲列表，根据课程id进行查询 @GetMapping(\"getChapterById/{courseId}\") public R getChapterById(@PathVariable(\"courseId\") String courseId){ List\u003cChapterVo\u003e chapterVos = eduChapterService.getChapterById(courseId); return R.ok().data(\"allChapter\",chapterVos); } //添加章节 @PostMapping(\"addChapter\") public R addChapter(@RequestBody EduChapter eduChapter) { eduChapterService.save(eduChapter); return R.ok(); } //根据id查询 @GetMapping(\"getChapterInfo/{chapterId}\") public R getChapterInfo(@PathVariable String chapterId) { EduChapter eduChapter = eduChapterService.getById(chapterId); return R.ok().data(\"eduChapter\",eduChapter); } //修改章节 @PostMapping(\"updateChapterInfo\") public R updateChapterInfo(@RequestBody EduChapter eduChapter) { eduChapterService.updateById(eduChapter); return R.ok(); } //删除章节 @DeleteMapping(\"{chapterId}\") public R deleteChapter(@PathVariable String chapterId) { boolean flag = eduChapterService.deleteChapter(chapterId); if (flag) { return R.ok(); } else { return R.error(); } } } 小节 package com.guli.eduservice.controller; import com.guli.commonutils.R; import com.guli.eduservice.entity.EduVideo; import com.guli.eduservice.service.EduVideoService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * \u003cp\u003e * 课程视频 前端控制器 * \u003c/p\u003e * * @author testjava * @since 2020-08-07 */ @RestController @RequestMapping(\"/eduservice/video\") @CrossOrigin //解决跨域 public class EduVideoController { @Autowired private EduVideoService videoService; //添加小节 @PostMapping(\"addVideo\") public R addVideo(@RequestBody EduVideo eduVideo) { videoService.save(eduVideo); return R.ok(); } //删除小节 @DeleteMapping(\"deleteVideo/{id}\") public R deleteVideo(@PathVariable String id) { videoService.removeById(id); return R.ok(); } //根据id查询小节 @GetMapping(\"getVideo/{id}\") public R getVideo(@PathVariable String id) { EduVideo video = videoService.getById(id); return R.ok().data(\"video\",video); } //修改小节 @PostMapping(\"updateVideo\") public R updateVideo(@RequestBody EduVideo eduVideo) { videoService.updateById(eduVideo); return R.ok(); } } service 章节 package com.guli.eduservice.service.impl; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.guli.eduservice.entity.EduChapter; import com.guli.eduservice.entity.EduVideo; import com.guli.eduservice.entity.chapter.ChapterVo; import com.guli.eduservice.entity.chapter.VideoVo; import com.guli.eduservice.mapper.EduChapterMapper; import com.guli.eduservice.service.EduChapterService; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.guli.eduservice.service.EduVideoService; import com.guli.servicebase.exception.GuliException; import org.springframework.beans.BeanUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.ArrayList; import java.util.List; /** * \u003cp\u003e * 课程 服务实现类 * \u003c/p\u003e * * @author testjava * @since 2020-08-07 */ @Service public class EduChapterServiceImpl extends ServiceImpl\u003cEduChapterMapper, EduChapter\u003e implements EduChapterService { @Autowired private EduVideoService eduVideoService; //课程大纲列表，根据id查询 @Override public List\u003cChapterVo\u003e getChapterById(String courseId) { //1.根据课程id查询课程中所有章节 QueryWrapper\u003cEduChapter\u003e eduChapterQueryWrapper = new QueryWrapper\u003c\u003e(); eduChapterQueryWrapper.eq(\"course_id\",courseId); List\u003cEduChapter\u003e eduChapters ","date":"2020-09-07","objectID":"/guli-8.5-%E7%AB%A0%E8%8A%82%E5%B0%8F%E8%8A%82%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD/:0:0","tags":[],"title":"guli-8.5-章节,小节,发布功能","uri":"/guli-8.5-%E7%AB%A0%E8%8A%82%E5%B0%8F%E8%8A%82%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD/"},{"categories":[],"content":"guli-7.5-添加课程 ","date":"2020-08-07","objectID":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/:0:0","tags":[],"title":"guli-7.5-添加课程","uri":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/"},{"categories":[],"content":"一.使用代码生成器生成相关表代码 strategy.setInclude(\"edu_course\",\"edu_course_description\",\"edu_chapter\",\"edu_video\"); ","date":"2020-08-07","objectID":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/:1:0","tags":[],"title":"guli-7.5-添加课程","uri":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/"},{"categories":[],"content":"二.创建vo类封装表单提交的数据 edu_course 和 edu_course_description package com.guli.eduservice.entity.vo; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import java.math.BigDecimal; @Data public class CourseInfoVo { private static final long serialVersionUID = 1L; @ApiModelProperty(value = \"课程ID\") private String id; @ApiModelProperty(value = \"课程讲师ID\") private String teacherId; @ApiModelProperty(value = \"课程专业ID\") private String subjectId; @ApiModelProperty(value = \"课程标题\") private String title; @ApiModelProperty(value = \"课程销售价格，设置为0则可免费观看\") private BigDecimal price; @ApiModelProperty(value = \"总课时\") private Integer lessonNum; @ApiModelProperty(value = \"课程封面图片路径\") private String cover; @ApiModelProperty(value = \"课程简介\") private String description; } ","date":"2020-08-07","objectID":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/:2:0","tags":[],"title":"guli-7.5-添加课程","uri":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/"},{"categories":[],"content":"三.controller 和 service controller package com.guli.eduservice.controller; import com.guli.commonutils.R; import com.guli.eduservice.entity.vo.CourseInfoVo; import com.guli.eduservice.service.EduCourseService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * \u003cp\u003e * 课程 前端控制器 * \u003c/p\u003e * * @author testjava * @since 2020-08-07 */ @RestController @RequestMapping(\"/eduservice/course\") @CrossOrigin public class EduCourseController { @Autowired private EduCourseService courseService; //添加课程基本信息 @PostMapping(\"addCourseInfo\") public R addCourseInfo(@RequestBody CourseInfoVo courseInfoVo) { String id = courseService.addCourseInfo(courseInfoVo); return R.ok().data(\"courseId\",id); } } service package com.guli.eduservice.service.impl; import com.guli.eduservice.entity.EduCourse; import com.guli.eduservice.entity.EduCourseDescription; import com.guli.eduservice.entity.vo.CourseInfoVo; import com.guli.eduservice.mapper.EduCourseMapper; import com.guli.eduservice.service.EduCourseDescriptionService; import com.guli.eduservice.service.EduCourseService; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.guli.servicebase.exception.GuliException; import org.springframework.beans.BeanUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; /** * \u003cp\u003e * 课程 服务实现类 * \u003c/p\u003e * * @author testjava * @since 2020-08-07 */ @Service public class EduCourseServiceImpl extends ServiceImpl\u003cEduCourseMapper, EduCourse\u003e implements EduCourseService { @Autowired private EduCourseDescriptionService eduCourseDescriptionService; @Override public String addCourseInfo(CourseInfoVo courseInfoVo) { //向课程表添加课程基本信息 EduCourse eduCourse = new EduCourse(); BeanUtils.copyProperties(courseInfoVo,eduCourse); int insert = baseMapper.insert(eduCourse); if (insert == 0) { throw new GuliException(20001,\"添加课程信息失败\"); } //获取添加课程之后的id String cid = eduCourse.getId(); //向课程简介表中添加信息 EduCourseDescription eduCourseDescription = new EduCourseDescription(); BeanUtils.copyProperties(courseInfoVo,eduCourseDescription); //设置id eduCourseDescription.setId(cid); eduCourseDescriptionService.save(eduCourseDescription); return cid; } } 设置实体类id生成策略 public class EduCourseDescription implements Serializable { @ApiModelProperty(value = \"课程ID\") @TableId(value = \"id\", type = IdType.INPUT) private String id; ","date":"2020-08-07","objectID":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/:3:0","tags":[],"title":"guli-7.5-添加课程","uri":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/"},{"categories":[],"content":"四.前端 添加路由 //课程管理 { path: '/course', component: Layout, redirect: '/course/list', name: '课程管理', meta: { title: '课程管理', icon: 'example' }, children: [{ path: 'list', name: '课程列表', component: () =\u003e import('@/views/edu/course/list'), meta: { title: '课程列表', icon: 'table' } }, { path: 'save', name: '添加课程', component: () =\u003e import('@/views/edu/course/info'), meta: { title: '添加课程', icon: 'tree' } }, { path: 'info/:id', name: 'EduCourseInfoEdit', component: () =\u003e import('@/views/edu/course/info'), meta: { title: '编辑课程基本信息', noCache: true }, hidden: true }, { path: 'chapter/:id', name: 'EduCourseChapterEdit', component: () =\u003e import('@/views/edu/course/chapter'), meta: { title: '编辑课程大纲', noCache: true }, hidden: true }, { path: 'publish/:id', name: 'EduCoursePublishEdit', component: () =\u003e import('@/views/edu/course/publish'), meta: { title: '发布课程', noCache: true }, hidden: true } ] }, api/edu/course.js import request from '@/utils/request' export default { //1.添加课程信息 addCourseInfo(courseInfoVo) { return request({ url:\"/eduservice/course/addCourseInfo\", method:\"post\", data: courseInfoVo }) } } 编写页面 实现接口调用 \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e \u003ch2 style=\"text-align: center;\"\u003e发布新课程\u003c/h2\u003e \u003cel-steps :active=\"1\" process-status=\"wait\" align-center style=\"marginbottom: 40px;\"\u003e \u003cel-step title=\"填写课程基本信息\" /\u003e \u003cel-step title=\"创建课程大纲\" /\u003e \u003cel-step title=\"提交审核\" /\u003e \u003c/el-steps\u003e \u003cel-form label-width=\"120px\"\u003e \u003cel-form-item label=\"课程标题\"\u003e \u003cel-input v-model=\"courseInfo.title\" placeholder=\" 示例：机器学习项目课：从基础到搭建项目视频课程。专业名称注意大小写\" /\u003e \u003c/el-form-item\u003e \u003c!-- 所属分类 TODO --\u003e \u003c!-- 课程讲师 TODO --\u003e \u003c!-- 课程简介 TODO --\u003e \u003cel-form-item label=\"课程简介\"\u003e \u003cel-input v-model=\"courseInfo.description\" placeholder=\" \" /\u003e \u003c/el-form-item\u003e \u003c!-- 课程封面 TODO --\u003e \u003cel-form-item label=\"课程价格\"\u003e \u003cel-input-number :min=\"0\" v-model=\"courseInfo.price\" controls-position=\"right\" placeholder=\"免费课程请设置为0元\" /\u003e元 \u003c/el-form-item\u003e \u003cel-form-item\u003e \u003cel-button :disabled=\"saveBtnDisabled\" type=\"primary\" @click=\"saveOrUpdate\"\u003e保存并下一步\u003c/el-button\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import course from \"@/api/edu/course\"; import teacher from \"@/api/edu/teacher\"; import subject from \"@/api/edu/subject\"; export default { data() { return { saveBtnDisabled: false, // 保存按钮是否禁用 courseInfo: { title: \"\", subjectId: \"\", //二级分类id subjectParentId: \"\", //一级分类id teacherId: \"\", lessonNum: 0, description: \"\", cover: \"\", price: 0, }, }; }, created() { }, methods: { //提交信息 saveOrUpdate() { course.addCourseInfo(this.courseInfo).then((response) =\u003e { //提示信息 this.$message({ type: \"success\", message: \"添加课程信息成功\", }); console.log(response.data); this.$router.push({ path: \"/course/chapter/\" + response.data.courseId, }); }); }, }, }; \u003c/script\u003e 讲师下拉列表显示 编写方法调用api查询所有讲师 在created中初始化 显示到页面中 \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e \u003ch2 style=\"text-align: center;\"\u003e发布新课程\u003c/h2\u003e \u003cel-steps :active=\"1\" process-status=\"wait\" align-center style=\"marginbottom: 40px;\"\u003e \u003cel-step title=\"填写课程基本信息\" /\u003e \u003cel-step title=\"创建课程大纲\" /\u003e \u003cel-step title=\"提交审核\" /\u003e \u003c/el-steps\u003e \u003cel-form label-width=\"120px\"\u003e \u003cel-form-item label=\"课程标题\"\u003e \u003cel-input v-model=\"courseInfo.title\" placeholder=\" 示例：机器学习项目课：从基础到搭建项目视频课程。专业名称注意大小写\" /\u003e \u003c/el-form-item\u003e \u003c!-- 所属分类 TODO --\u003e \u003c!-- 课程讲师 TODO --\u003e \u003cel-form-item label=\"课程讲师\"\u003e \u003cel-select v-model=\"courseInfo.teacherId\" placeholder=\"请选择\"\u003e \u003cel-option v-for=\"teacher in teachers\" :key=\"teacher.id\" :label=\"teacher.name\" :value=\"teacher.id\" /\u003e \u003c/el-select\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"总课时\"\u003e \u003cel-input-number :min=\"0\" v-model=\"courseInfo.lessonNum\" controls-position=\"right\" placeholder=\"请填写课程的总课时数\" /\u003e \u003c/el-form-item\u003e \u003c!-- 课程简介 TODO --\u003e \u003cel-form-item label=\"课程简介\"\u003e \u003cel-input v-model=\"courseInfo.description\" placeholder=\" \" /\u003e \u003c/el-form-item\u003e \u003c!-- 课程封面 TODO --\u003e \u003cel-form-item label=\"课程价格\"\u003e \u003cel-input-number :min=\"0\" v-model=\"courseInfo.price\" controls-position=\"right\" placeholder=\"免费课程请设置为0元\" /\u003e元 \u003c/el-form-item\u003e \u003cel-form-item\u003e \u003cel-button :disabled=\"saveBtnDisabled\" type=\"primary\" @click=\"saveOrUpdate\"\u003e保存并下一步\u003c/el-button\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003c/di","date":"2020-08-07","objectID":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/:4:0","tags":[],"title":"guli-7.5-添加课程","uri":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/"},{"categories":[],"content":"五.课程大纲功能 后端 创建两个实体类 章节和小节 章节中包括多个小节 ChapterVo.java package com.guli.eduservice.entity.chapter; import lombok.Data; import java.util.ArrayList; import java.util.List; @Data public class ChapterVo { private String id; private String title; //小结 private List\u003cVideoVo\u003e videoVos = new ArrayList\u003c\u003e(); } VideoVo.java package com.guli.eduservice.entity.chapter; import lombok.Data; @Data public class VideoVo { private String id; private String title; } 编写封装代码 Controller package com.guli.eduservice.controller; import com.guli.commonutils.R; import com.guli.eduservice.entity.chapter.ChapterVo; import com.guli.eduservice.service.EduChapterService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\"/eduservice/chapter\") @CrossOrigin public class EduChapterController { // @Autowired private EduChapterService eduChapterService; //课程大纲列表，根据课程id进行查询 @GetMapping(\"getChapterById/{courseId}\") public R getChapterById(@PathVariable(\"courseId\") String courseId){ List\u003cChapterVo\u003e chapterVos = eduChapterService.getChapterById(courseId); return R.ok().data(\"allChapter\",chapterVos); } } service package com.guli.eduservice.service.impl; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.guli.eduservice.entity.EduChapter; import com.guli.eduservice.entity.EduVideo; import com.guli.eduservice.entity.chapter.ChapterVo; import com.guli.eduservice.entity.chapter.VideoVo; import com.guli.eduservice.mapper.EduChapterMapper; import com.guli.eduservice.service.EduChapterService; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.guli.eduservice.service.EduVideoService; import org.springframework.beans.BeanUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.ArrayList; import java.util.List; @Service public class EduChapterServiceImpl extends ServiceImpl\u003cEduChapterMapper, EduChapter\u003e implements EduChapterService { @Autowired private EduVideoService eduVideoService; //课程大纲列表，根据id查询 @Override public List\u003cChapterVo\u003e getChapterById(String courseId) { //1.根据课程id查询课程中所有章节 QueryWrapper\u003cEduChapter\u003e eduChapterQueryWrapper = new QueryWrapper\u003c\u003e(); eduChapterQueryWrapper.eq(\"course_id\",courseId); List\u003cEduChapter\u003e eduChapters = baseMapper.selectList(eduChapterQueryWrapper); //2.根据课程id查询课程中所有小节 QueryWrapper\u003cEduVideo\u003e eduVideoQueryWrapper = new QueryWrapper\u003c\u003e(); eduVideoQueryWrapper.eq(\"course_id\",courseId); List\u003cEduVideo\u003e eduVideos = eduVideoService.list(eduVideoQueryWrapper); //3.遍历章节list进行封装 List\u003cChapterVo\u003e chapterVos = new ArrayList\u003c\u003e(); for (EduChapter eduChapter:eduChapters) { ChapterVo chapterVo = new ChapterVo(); BeanUtils.copyProperties(eduChapter,chapterVo); //4.遍历小节list进行封装 List\u003cVideoVo\u003e videoVos = new ArrayList\u003c\u003e(); for (EduVideo eduVideo:eduVideos) { //判断小节中的chapterid和章节中的id是否相同 if(eduVideo.getChapterId().equals(eduChapter.getId())) { VideoVo videoVo = new VideoVo(); BeanUtils.copyProperties(eduVideo,videoVo); videoVos.add(videoVo); } } //把封装的小结放到章节中去 chapterVo.setVideoVos(videoVos); chapterVos.add(chapterVo); } return chapterVos; } } 前端 api chapter.js import request from '@/utils/request' export default { getChapterById(courseId) { return request({ url: `/eduservice/chapter/getChapterById/${courseId}`, method: 'get' }) } } 页面 \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e \u003ch2 style=\"text-align: center;\"\u003e发布新课程\u003c/h2\u003e \u003cel-steps :active=\"2\" process-status=\"wait\" align-center style=\"marginbottom: 40px;\"\u003e \u003cel-step title=\"填写课程基本信息\" /\u003e \u003cel-step title=\"创建课程大纲\" /\u003e \u003cel-step title=\"提交审核\" /\u003e \u003c/el-steps\u003e \u003cel-button type=\"text\"\u003e添加章节\u003c/el-button\u003e \u003c!-- 章节 --\u003e \u003cul class=\"chanpterList\"\u003e \u003cli v-for=\"chapter in chapterNestedList\" :key=\"chapter.id\"\u003e \u003cp\u003e {{ chapter.title }} \u003cspan class=\"acts\"\u003e \u003cel-button type=\"text\"\u003e添加课时\u003c/el-button\u003e \u003cel-button style type=\"text\"\u003e编辑\u003c/el-button\u003e \u003cel-button type=\"text\"\u003e删除\u003c/el-button\u003e \u003c/span\u003e \u003c/p\u003e \u003c!-- 视频 --\u003e \u003cul class=\"ch","date":"2020-08-07","objectID":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/:5:0","tags":[],"title":"guli-7.5-添加课程","uri":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/"},{"categories":[],"content":"六.课程修改功能 后端 两个功能 1.根据课程id查询课程的基本信息 2.根据课程id修改课程的基本信息 EduCourseController //根据课程id查询课程的基本信息 @GetMapping(\"getCourseInfo/{courseId}\") public R getCourseInfo(@PathVariable(\"courseId\") String courseId) { CourseInfoVo courseInfoVo = courseService.getCourseInfo(courseId); return R.ok().data(\"courseInfoVo\",courseInfoVo); } //根据课程id修改课程的基本信息 @PostMapping(\"updateCourseInfo\") public R updateCourseInfo(@RequestBody CourseInfoVo courseInfoVo) { courseService.updateCourseInfo(courseInfoVo); return R.ok(); } service //根据课程id查询课程信息 @Override public CourseInfoVo getCourseInfo(String courseId) { //1.查询课程表 EduCourse eduCourse = baseMapper.selectById(courseId); //2.查询描述表 EduCourseDescription eduCourseDescription = eduCourseDescriptionService.getById(courseId); //3.封装 CourseInfoVo courseInfoVo = new CourseInfoVo(); BeanUtils.copyProperties(eduCourse,courseInfoVo); BeanUtils.copyProperties(eduCourseDescription,courseInfoVo); return courseInfoVo; } @Override public void updateCourseInfo(CourseInfoVo courseInfoVo) { //1.修改课程表 EduCourse eduCourse = new EduCourse(); BeanUtils.copyProperties(courseInfoVo,eduCourse); int i = baseMapper.updateById(eduCourse); if (i != 0) { //2.修改简介表 EduCourseDescription eduCourseDescription = new EduCourseDescription(); BeanUtils.copyProperties(courseInfoVo,eduCourseDescription); eduCourseDescriptionService.updateById(eduCourseDescription); } else { throw new GuliException(20001,\"引入失败\"); } } 前端 api course.js //2.根据课程id查询课程的基本信息 getCourseInfo(courseId) { return request({ url:\"/eduservice/course/getCourseInfo/\"+courseId, method:\"get\" }) }, //3.根据课程id修改课程的基本信息 updateCourseInfo(courseInfoVo) { return request({ url:\"/eduservice/course/updateCourseInfo\", method:\"post\", data: courseInfoVo }) } 修改 chapter页面，路径跳转 previous() { this.$router.push({ path: \"/course/info/\"+this.courseId }); }, 在info页面进行数据回显 //获取路由id值 if (this.$route.params \u0026\u0026 this.$route.params.id) { this.courseId = this.$route.params.id; //调用根据id查询课程的方法 this.getInfo(); } else { //初始化所有讲师 this.findAll(); //初始化一级分类 this.getAllSubjectList(); } getInfo 解决了二级分类数据不显示的问题 getInfo() { course.getCourseInfo(this.courseId).then((response) =\u003e { this.courseInfo = response.data.courseInfoVo; //1.查询出所有分类 subject.getAllSubjectList().then((response) =\u003e { //2.获取所有一级分类 this.subjectNestedList = response.data.list; //3.把所有一级分类数组进行遍历，比较当前courseInfo里面的一级分类id和所有一级分类id for (var i = 0; this.subjectNestedList.length; i++) { //获取每个一级分类 var oneSubject = this.subjectNestedList[i]; //比较当前courseInfo里面的一级分类id和所有一级分类id if (this.courseInfo.subjectParentId == oneSubject.id) { //获取一级分类中的所有二级分类 this.subjectTwoList = oneSubject.twoSubjects; } } }); //初始化所有讲师 this.findAll(); }); }, ","date":"2020-08-07","objectID":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/:6:0","tags":[],"title":"guli-7.5-添加课程","uri":"/guli-7.5-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B/"},{"categories":[],"content":"guli-6.5-EasyExcel读操作分类 ","date":"2020-08-05","objectID":"/guli-6.5-easyexcel%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/:0:0","tags":[],"title":"guli-6.5-EasyExcel读操作分类","uri":"/guli-6.5-easyexcel%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/"},{"categories":[],"content":"一.读取Excel存储后端 添加依赖 easyexcel \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003eeasyexcel\u003c/artifactId\u003e \u003cversion\u003e2.1.1\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 使用代码生成器生成课程分类代码 创建实体类和excel的对应关系 package com.guli.eduservice.entity.excel; @Data public class SubjectData { @ExcelProperty(value = \"一级分类\",index = 0) private String oneSubjectName; @ExcelProperty(value = \"二级分类\",index = 1) private String twoSubjectName; } controller package com.guli.eduservice.controller; @RestController @RequestMapping(\"/eduservice/subject\") @CrossOrigin public class EduSubjectController { @Autowired private EduSubjectService subjectService; //添加课程分类 //获取上传过来的文件，读取文件内容 @PostMapping(\"addSubject\") public R addSubject(MultipartFile file) { subjectService.addSubject(file,subjectService); return R.ok(); } } service package com.guli.eduservice.service.impl; @Service public class EduSubjectServiceImpl extends ServiceImpl\u003cEduSubjectMapper, EduSubject\u003e implements EduSubjectService { //添加课程分类 @Override public void addSubject(MultipartFile file,EduSubjectService eduSubjectService) { try { EasyExcel.read(file.getInputStream(), SubjectData.class,new SubjecExcelListener(eduSubjectService)).sheet().doRead(); } catch (Exception e) { e.printStackTrace(); } } } 监听器 在监听器中进行数据存储 package com.guli.eduservice.listener; public class SubjecExcelListener extends AnalysisEventListener\u003cSubjectData\u003e { //因为SubjecExcelListener不能交给spring进行管理，需要自己new，不能注入其他对象 //不能实现数据库操作 public EduSubjectService subjectService; public SubjecExcelListener() { } public SubjecExcelListener(EduSubjectService subjectService) { this.subjectService = subjectService; } //读取excel内容,一行一行读取 @Override public void invoke(SubjectData data, AnalysisContext analysisContext) { if (data == null) { throw new GuliException(20001,\"文件数据为空\"); } //判断一级分类是否重复 EduSubject eduSubject = this.existOneSubject(data.getOneSubjectName(),subjectService); if (eduSubject == null) { //没有相同 进行添加 eduSubject = new EduSubject(); eduSubject.setParentId(\"0\"); eduSubject.setTitle(data.getOneSubjectName()); subjectService.save(eduSubject); } //获取一级分类的id值 String pid = eduSubject.getId(); //判断二级分类是否重复 EduSubject eduSubject2 = this.existTwoSubject(data.getTwoSubjectName(),subjectService,pid); if (eduSubject2 == null) { //没有相同 进行添加 eduSubject2 = new EduSubject(); eduSubject2.setParentId(pid); eduSubject2.setTitle(data.getTwoSubjectName()); subjectService.save(eduSubject2); } } //判断一级分类不能重复添加 private EduSubject existOneSubject(String name,EduSubjectService subjectService) { QueryWrapper\u003cEduSubject\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.eq(\"title\",name); wrapper.eq(\"parent_id\",\"0\"); EduSubject eduSubjectOne = subjectService.getOne(wrapper); return eduSubjectOne; } //判断二级分类不能重复添加 private EduSubject existTwoSubject(String name,EduSubjectService subjectService,String pid) { QueryWrapper\u003cEduSubject\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.eq(\"title\",name); wrapper.eq(\"parent_id\",pid); EduSubject eduSubjectTwo = subjectService.getOne(wrapper); return eduSubjectTwo; } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { } } ","date":"2020-08-05","objectID":"/guli-6.5-easyexcel%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/:1:0","tags":[],"title":"guli-6.5-EasyExcel读操作分类","uri":"/guli-6.5-easyexcel%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/"},{"categories":[],"content":"二.前端 添加路由 src/router/index.js //课程分类管理 { path: '/subject', component: Layout, redirect: '/subject/list', name: '课程分类管理', meta: { title: '课程分类管理', icon: 'example' }, children: [ { path: 'list', name: '课程分类列表', component: () =\u003e import('@/views/edu/subject/list'), meta: { title: '课程分类列表', icon: 'table' } }, { path: 'save', name: '添加课程分类', component: () =\u003e import('@/views/edu/subject/save'), meta: { title: '添加课程分类', icon: 'tree' } } ] }, 添加对应前端页面 \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e \u003cel-form label-width=\"120px\"\u003e \u003cel-form-item label=\"信息描述\"\u003e \u003cel-tag type=\"info\"\u003eexcel模版\u003c/el-tag\u003e \u003cel-tag\u003e \u003ci class=\"el-icon-download\" /\u003e \u003ca :href=\"'/static/模板.xlsx'\"\u003e点击下载模版\u003c/a\u003e \u003c/el-tag\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"选择Excel\"\u003e \u003cel-upload ref=\"upload\" :auto-upload=\"false\" :on-success=\"fileUploadSuccess\" :on-error=\"fileUploadError\" :disabled=\"importBtnDisabled\" :limit=\"1\" :action=\"BASE_API+'/eduservice/subject/addSubject'\" name=\"file\" accept=\"application/vnd.ms-excel\" \u003e \u003cel-button slot=\"trigger\" size=\"small\" type=\"primary\"\u003e选取文件\u003c/el-button\u003e \u003cel-button :loading=\"loading\" style=\"margin-left: 10px;\" size=\"small\" type=\"success\" @click=\"submitUpload\" \u003e上传到服务器\u003c/el-button\u003e \u003c/el-upload\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { BASE_API: process.env.BASE_API, // 接口API地址 importBtnDisabled: false, // 按钮是否禁用, loading: false, }; }, created() {}, methods: { //点击上传文件到接口 submitUpload() { this.importBtnDisabled = true; this.loading = true; //js:documet.getElementById(\"upload\").submit(); this.$refs.upload.submit(); }, //上传成功 fileUploadSuccess() { this.loading = false; this.$message({ type: \"success\", message: \"添加成功\", }); //跳转回列表页面 this.$router.push({path:\"/subject/list\"}); }, //上传失败 fileUploadError() { this.loading = false; this.$message({ type: \"error\", message: \"导入失败\", }); }, }, }; \u003c/script\u003e ","date":"2020-08-05","objectID":"/guli-6.5-easyexcel%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/:2:0","tags":[],"title":"guli-6.5-EasyExcel读操作分类","uri":"/guli-6.5-easyexcel%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/"},{"categories":[],"content":"三.列表分级显示 前端路由 页面 重点： data2: [ ], defaultProps: { children: “twoSubjects”, label: “title”, }, 参数设置 注意数据格式 \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e \u003cel-input v-model=\"filterText\" placeholder=\"Filter keyword\" style=\"margin-bottom:30px;\" /\u003e \u003cel-tree ref=\"tree2\" :data=\"data2\" :props=\"defaultProps\" :filter-node-method=\"filterNode\" class=\"filter-tree\" default-expand-all /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import subject from '@/api/edu/subject'; export default { data() { return { filterText: \"\", data2: [ ], defaultProps: { children: \"twoSubjects\", label: \"title\", }, }; }, watch: { filterText(val) { this.$refs.tree2.filter(val); }, }, created(){ this.getAllSubjectList(); }, methods: { filterNode(value, data) { if (!value) return true; return data.title.toLowerCase().indexOf(value) !== -1; }, getAllSubjectList(){ subject.getAllSubjectList().then(response =\u003e { this.data2 = response.data.list; }).catch((error) =\u003e { console.log(error); }); } }, }; \u003c/script\u003e 前端api src/api/edu/subject.js import request from '@/utils/request' export default { //查询课程分类 getAllSubjectList() { return request({ url:\"/eduservice/subject/getAllSubject\", method:\"get\" }) } } 后端创建controller //课程结构的列表功能 @GetMapping(\"getAllSubject\") public R getAllSubject(){ List\u003cOneSubject\u003e list = subjectService.getAllOneTwoSubject(); return R.ok().data(\"list\",list); } 实体类 OneSubject package com.guli.eduservice.entity.subject; import lombok.Data; import java.util.ArrayList; import java.util.List; @Data public class OneSubject { private String id; private String title; private List\u003cTwoSubject\u003e twoSubjects = new ArrayList\u003c\u003e(); } TwoSubject package com.guli.eduservice.entity.subject; import lombok.Data; @Data public class TwoSubject { private String id; private String title; } service 重点 主要在于数据的格式 @Override public List\u003cOneSubject\u003e getAllOneTwoSubject() { //1.查询出所有一级分类 QueryWrapper\u003cEduSubject\u003e queryWrapperOne = new QueryWrapper\u003c\u003e(); queryWrapperOne.eq(\"parent_id\",0); //查询 或者使用 this.list(queryWrapperOne); List\u003cEduSubject\u003e oneEduSubjects = baseMapper.selectList(queryWrapperOne); //2.查询出所有二级分类 QueryWrapper\u003cEduSubject\u003e queryWrapperTwo = new QueryWrapper\u003c\u003e(); queryWrapperTwo.ne(\"parent_id\",0); List\u003cEduSubject\u003e twoEduSubjects = baseMapper.selectList(queryWrapperTwo); //创建list集合 用于存储最终封装的数据 List\u003cOneSubject\u003e finalSubject = new ArrayList\u003c\u003e(); //3.封装一级分类 for (EduSubject eduSubject:oneEduSubjects) { OneSubject oneSubject = new OneSubject(); // oneSubject.setId(eduSubject.getId()); // oneSubject.setTitle(eduSubject.getTitle()); BeanUtils.copyProperties(eduSubject,oneSubject); //4.封装二级分类 List\u003cTwoSubject\u003e twoSubjects = new ArrayList\u003c\u003e(); for (EduSubject eduSubject2:twoEduSubjects) { TwoSubject twoSubject = new TwoSubject(); if (eduSubject2.getParentId().equals(eduSubject.getId())) { BeanUtils.copyProperties(eduSubject2,twoSubject); twoSubjects.add(twoSubject); } } oneSubject.setTwoSubjects(twoSubjects); finalSubject.add(oneSubject); } return finalSubject; } ","date":"2020-08-05","objectID":"/guli-6.5-easyexcel%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/:3:0","tags":[],"title":"guli-6.5-EasyExcel读操作分类","uri":"/guli-6.5-easyexcel%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB/"},{"categories":[],"content":"guli-6-讲师头像上传功能-阿里云oss云存储服务 ","date":"2020-08-04","objectID":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/:0:0","tags":[],"title":"guli-6-讲师头像上传功能-阿里云oss云存储服务","uri":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"},{"categories":[],"content":"一.控制台使用 打开阿里云控制台 进入oss 创建bucket 生成 endpoint keyid keysecret bucketname ","date":"2020-08-04","objectID":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/:1:0","tags":[],"title":"guli-6-讲师头像上传功能-阿里云oss云存储服务","uri":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"},{"categories":[],"content":"二.开发准备 在service创建子模块 service_oss 引入相关依赖 \u003cdependencies\u003e \u003c!-- 阿里云oss依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun.oss\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-oss\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 创建配置文件 #端口 server: port: 8082 #服务名 spring: application: name: service_oss #环境设置 dev,test,prod profiles: active: dev #阿里云oss #不同服务 地址不同 aliyun: oss: file: endpoint: \u003cyourEndpoint\u003e keyid: \u003cyourKeyid\u003e keysecret: \u003cyourKeysecret\u003e #bucke可以在控制台创建 也可以使用java代码创建 bucketname: \u003cyourBucketname\u003e 创建启动类 package com.guli.oss; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration; import org.springframework.context.annotation.ComponentScan; @SpringBootApplication @ComponentScan(basePackages = \"com.guli\") public class OssApplication { public static void main(String[] args) { SpringApplication.run(OssApplication.class,args); } } 启动 发现报错 错误 ：没有配置数据源 解决方法：第一种：添加数据源配置 ​ 第二种：排除数据源配置自动装配 @SpringBootApplication(exclude =DataSourceAutoConfiguration.class) package com.guli.oss; @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) @ComponentScan(basePackages = \"com.guli\") public class OssApplication { public static void main(String[] args) { SpringApplication.run(OssApplication.class,args); } } ","date":"2020-08-04","objectID":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/:2:0","tags":[],"title":"guli-6-讲师头像上传功能-阿里云oss云存储服务","uri":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"},{"categories":[],"content":"三.上传文件接口实现 创建常量，读取配置文件内容 package com.guli.oss.utils; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; //使用InitializingBean接口 当项目启动afterPropertiesSet方法自动执行 @Component public class ConstantPropertiesUtils implements InitializingBean { //读取配置文件内容 @Value(\"${aliyun.oss.file.endpoint}\") private String endpoint; @Value(\"${aliyun.oss.file.keyid}\") private String keyId; @Value(\"${aliyun.oss.file.keysecret}\") private String keySecret; @Value(\"${aliyun.oss.file.bucketname}\") private String bucketName; //定义公开静态常量 public static String END_POINT; public static String KEY_ID; public static String KEY_SECRET; public static String BUCKET_NAME; @Override public void afterPropertiesSet() throws Exception { END_POINT = endpoint; KEY_ID = keyId; KEY_SECRET = keySecret; BUCKET_NAME = bucketName; } } 创建controller,service controller package com.guli.oss.controller; import com.guli.commonutils.R; import com.guli.oss.service.OssService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; @RestController @RequestMapping(\"/eduoss/fileoss\") @CrossOrigin public class OssController { @Autowired private OssService ossService; //上传头像方法 @PostMapping(\"uploadOssFile\") public R uploadOssFile(MultipartFile file) { //获取上传文件 MultipartFile String url = ossService.uploadFileAvatar(file); return R.ok().data(\"url\",url); } } service package com.guli.oss.service.impl; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import com.guli.oss.service.OssService; import com.guli.oss.utils.ConstantPropertiesUtils; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import java.io.InputStream; import java.text.SimpleDateFormat; import java.util.Date; import java.util.UUID; @Service public class OssServiceImpl implements OssService { @Override public String uploadFileAvatar(MultipartFile file) { // Endpoint以杭州为例，其它Region请按实际情况填写。 String endpoint = ConstantPropertiesUtils.END_POINT; // 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。 String accessKeyId = ConstantPropertiesUtils.KEY_ID; String accessKeySecret = ConstantPropertiesUtils.KEY_SECRET; String bucketName = ConstantPropertiesUtils.BUCKET_NAME; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { // 上传文件流。 InputStream inputStream = file.getInputStream(); //获取文件名称 String fileName = file.getOriginalFilename(); //第一个参数 Bucket名称 //第二个参数 文件路径和文件名称 //第三个参数 文件输入流 ossClient.putObject(bucketName, fileName, inputStream); // 关闭OSSClient。 ossClient.shutdown(); //上传之后的文件路径返回 //需要手动拼接 return \"https://\"+bucketName+\".\"+endpoint+\"/\"+fileName; } catch (Exception e) { e.printStackTrace(); return null; } } } ","date":"2020-08-04","objectID":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/:3:0","tags":[],"title":"guli-6-讲师头像上传功能-阿里云oss云存储服务","uri":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"},{"categories":[],"content":"四.接口完善 多次上传文件名重复问题 文件进行分类管理问题 解决代码 //1.在文件名称中添加随机唯一值 String uuid = UUID.randomUUID().toString().replaceAll(\"-\",\"\"); fileName = uuid+fileName; //2.把文件按照年月日进行分类 //获取当前日期 Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat(\"yyyy/MM/dd\"); String time = format.format(date); //拼接 fileName = time+\"/\"+fileName; package com.guli.oss.service.impl; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import com.guli.oss.service.OssService; import com.guli.oss.utils.ConstantPropertiesUtils; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import java.io.InputStream; import java.text.SimpleDateFormat; import java.util.Date; import java.util.UUID; @Service public class OssServiceImpl implements OssService { @Override public String uploadFileAvatar(MultipartFile file) { // Endpoint以杭州为例，其它Region请按实际情况填写。 String endpoint = ConstantPropertiesUtils.END_POINT; // 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。 String accessKeyId = ConstantPropertiesUtils.KEY_ID; String accessKeySecret = ConstantPropertiesUtils.KEY_SECRET; String bucketName = ConstantPropertiesUtils.BUCKET_NAME; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { // 上传文件流。 InputStream inputStream = file.getInputStream(); //获取文件名称 String fileName = file.getOriginalFilename(); //1.在文件名称中添加随机唯一值 String uuid = UUID.randomUUID().toString().replaceAll(\"-\",\"\"); fileName = uuid+fileName; //2.把文件按照年月日进行分类 //获取当前日期 Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat(\"yyyy/MM/dd\"); String time = format.format(date); //拼接 fileName = time+\"/\"+fileName; //第一个参数 Bucket名称 //第二个参数 文件路径和文件名称 //第三个参数 文件输入流 ossClient.putObject(bucketName, fileName, inputStream); // 关闭OSSClient。 ossClient.shutdown(); //上传之后的文件路径返回 //需要手动拼接 return \"https://\"+bucketName+\".\"+endpoint+\"/\"+fileName; } catch (Exception e) { e.printStackTrace(); return null; } } } ","date":"2020-08-04","objectID":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/:4:0","tags":[],"title":"guli-6-讲师头像上传功能-阿里云oss云存储服务","uri":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"},{"categories":[],"content":"五.Nginx回顾 功能： 请求转发 负载均衡 动静分离 下载地址：http://nginx.org/en/download.html 使用：cmd命令窗口 #在解压的目录下 启动： nginx.exe 关闭： nginx.exe -s stop ","date":"2020-08-04","objectID":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/:5:0","tags":[],"title":"guli-6-讲师头像上传功能-阿里云oss云存储服务","uri":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"},{"categories":[],"content":"六.Nginx配置请求转发 找到配置文件：conf/nginx.conf http { ... server { #监听端口 listen 9001; #主机 server_name localhost; #匹配路径 使用正则表达式 location ~ /eduservice/ { proxy_pass http://localhost:8081; } location ~ /eduoss/ { proxy_pass http://localhost:8082; } } ... } 修改前端请求地址 config/dev.env.js 'use strict' const merge = require('webpack-merge') const prodEnv = require('./prod.env') module.exports = merge(prodEnv, { NODE_ENV: '\"development\"', // BASE_API: '\"https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin\"', BASE_API: '\"http://localhost:9001\"', }) ","date":"2020-08-04","objectID":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/:6:0","tags":[],"title":"guli-6-讲师头像上传功能-阿里云oss云存储服务","uri":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"},{"categories":[],"content":"七.上传头像前端整合 组件准备 把ImageCropper和PanThumb组件复制到src/components文件夹中 引入 \u003cscript\u003e import ImageCropper from '@/components/ImageCropper'; import PanThumb from '@/components/PanThumb'; export default { components: { ImageCropper, PanThumb }, ... \u003c/script\u003e 页面使用组件 注意修改接口地址 :url=“BASE_API+’/eduoss/fileoss/uploadOssFile'” \u003c!-- 讲师头像 --\u003e \u003cel-form-item label=\"讲师头像\"\u003e \u003c!-- 头衔缩略图 --\u003e \u003cpan-thumb :image=\"teacher.avatar\" /\u003e \u003c!-- 文件上传按钮 --\u003e \u003cel-button type=\"primary\" icon=\"el-icon-upload\" @click=\"imagecropperShow=true\"\u003e更换头像\u003c/el-button\u003e \u003c!--v-show：是否显示上传组件 :key：类似于id，如果一个页面多个图片上传控件，可以做区分 :url：后台上传的url地址 @close：关闭上传组件 @crop-upload-success：上传成功后的回调--\u003e \u003cimage-cropper v-show=\"imagecropperShow\" :width=\"300\" :height=\"300\" :key=\"imagecropperKey\" :url=\"BASE_API+'/eduoss/fileoss/uploadOssFile'\" field=\"file\" @close=\"close\" @crop-upload-success=\"cropSuccess\" /\u003e \u003c/el-form-item\u003e ....... data() { return { teacher: { }, saveBtnDisabled: false, // 保存按钮是否禁用, imagecropperShow: false,//上传弹窗组件是否显示 imagecropperKey: 0,//上传组件的key值 BASE_API: process.env.BASE_API,//获取dev.env.js中的BASE_API }; }, 其他方法实现 methods: { //关闭上传弹窗 close() { this.imagecropperShow = false; //上传组件初始化 this.imagecropperKey += 1; }, //上传成功的方法 cropSuccess(data) { this.imagecropperShow = false; this.teacher.avatar = data.url; this.imagecropperKey += 1; }, ...... ","date":"2020-08-04","objectID":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/:7:0","tags":[],"title":"guli-6-讲师头像上传功能-阿里云oss云存储服务","uri":"/guli-6-%E8%AE%B2%E5%B8%88%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"},{"categories":[],"content":"guli-5-业务开发 ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:0:0","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"一.后端登录功能改造 修改前端配置文件请求地址 config文件夹下dev.env.js 'use strict' const merge = require('webpack-merge') const prodEnv = require('./prod.env') module.exports = merge(prodEnv, { NODE_ENV: '\"development\"', // BASE_API: '\"https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin\"', BASE_API: '\"http://localhost:8081\"', }) 进行登录调用两个方法，login登录操作方法，info用于登录之后获取用户信息 login 返回 token值 info 返回 roles name avatar 后端开发接口 package com.guli.eduservice.controller; @RestController @RequestMapping(\"/eduservice/user\") @CrossOrigin //解决跨域 public class EduLoginController { //login @PostMapping(\"login\") public R login() { return R.ok().data(\"token\",\"admin\"); } //info @GetMapping(\"info\") public R info() { return R.ok().data(\"roles\",\"admin\") .data(\"name\",\"admin\") .data(\"avatar\",\"https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=137628589,3436980029\u0026fm=26\u0026gp=0.jpg\"); } } 前端修改api文件夹login.js修改本地接口路径 import request from '@/utils/request' export function login(username, password) { return request({ url: '/eduservice/user/login', method: 'post', data: { username, password } }) } export function getInfo(token) { return request({ url: '/eduservice/user/info', method: 'get', params: { token } }) } 最终测试 出现跨域问题 通过一个地址去访问另外一个地址 三个地方任何一个出现不一样 访问协议 http https ip地址 端口号 9825 8081 跨域解决方式 在后端接口controller添加注解@CrossOrigin package com.guli.eduservice.controller; @RestController @RequestMapping(\"/eduservice/user\") @CrossOrigin //解决跨域 public class EduLoginController { //login @PostMapping(\"login\") public R login() { return R.ok().data(\"token\",\"admin\"); } //info @GetMapping(\"info\") public R info() { return R.ok().data(\"roles\",\"admin\") .data(\"name\",\"admin\") .data(\"avatar\",\"https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=137628589,3436980029\u0026fm=26\u0026gp=0.jpg\"); } } ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:1:0","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"二.前端开发过程(思路) ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:2:0","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"1.路由 添加路由 src/router/index.js 添加路由 路由对应界面 component: () =\u003e import(’@/views/edu/teacher/listTeacher’), { path: 'listTeacher', name: '讲师列表', component: () =\u003e import('@/views/edu/teacher/listTeacher'), meta: { title: '讲师列表', icon: 'table' } }, 创建对应界面 ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:2:1","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"2.接口 在api文件夹创建js文件 定义接口地址，参数 import request from '@/utils/request' export default { //1.讲师列表（条件查询分页） getTeacherListPage(current, limit, teacherQuery) { return request({ url: `/eduservice/teacher/pageTeacherCondition/${current}/${limit}`, method: \"post\", //teacherQuery条件对象，后端使用RequestBody获取数据 //data表示把对象转换json进行传递到接口里面 data: teacherQuery }) }, //2.删除功能 removeTeacherById(id) { return request({ url: `/eduservice/teacher/${id}`, method: \"delete\" }) }, //3.添加讲师 addTeacher(teacher) { return request({ url: `/eduservice/teacher/addTeacher`, method: \"post\", data: teacher }) }, //4.根据id查询 getTeacherById(id) { return request({ url: `/eduservice/teacher/selectTeacherById/${id}`, method: \"get\", }) }, //修改讲师 updateTeacher(teacher) { return request({ url: `/eduservice/teacher/updateTeacher`, method: \"put\", data: teacher }) } } 在对应界面引入js文件 调用方法实现功能 ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:2:2","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"三.讲师列表前端开发 添加路由 src/router/index.js { path: '/teacher', component: Layout, redirect: '/teacher/listTeacher', name: '讲师管理', meta: { title: '讲师管理', icon: 'example' }, children: [ { path: 'listTeacher', name: '讲师列表', component: () =\u003e import('@/views/edu/teacher/listTeacher'), meta: { title: '讲师列表', icon: 'table' } }, { path: 'saveTeacher', name: '添加讲师', component: () =\u003e import('@/views/edu/teacher/saveTeacher'), meta: { title: '添加讲师', icon: 'tree' } } ] }, 创建路由对应界面 定义访问的接口地址 src/api/edu/teacher.js import request from '@/utils/request' export default { //1.讲师列表（条件查询分页） getTeacherListPage(current, limit, teacherQuery) { return request({ url: `/eduservice/teacher/pageTeacherCondition/${current}/${limit}`, method: \"post\", //teacherQuery条件对象，后端使用RequestBody获取数据 //data表示把对象转换json进行传递到接口里面 data: teacherQuery }) } } 在listTeacher页面调用方法 把数据进行显示 \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e \u003cel-table :data=\"list\" element-loading-text=\"数据加载中\" border fit highlight-current-row\u003e \u003cel-table-column label=\"序号\" width=\"70\" align=\"center\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e{{ (page - 1) * limit + scope.$index + 1 }}\u003c/template\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"name\" label=\"名称\" width=\"80\" /\u003e \u003cel-table-column label=\"头衔\" width=\"80\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e{{ scope.row.level===1?'高级讲师':'首席讲师' }}\u003c/template\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"intro\" label=\"资历\" /\u003e \u003cel-table-column prop=\"gmtCreate\" label=\"添加时间\" width=\"160\" /\u003e \u003cel-table-column prop=\"sort\" label=\"排序\" width=\"60\" /\u003e \u003cel-table-column label=\"操作\" width=\"200\" align=\"center\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e \u003crouter-link :to=\"'/teacher/updateTeacher/'+scope.row.id\"\u003e \u003cel-button type=\"primary\" size=\"mini\" icon=\"el-icon-edit\"\u003e修改\u003c/el-button\u003e \u003c/router-link\u003e \u003cel-button type=\"danger\" size=\"mini\" icon=\"el-icon-delete\" @click=\"removeTeacherById(scope.row.id)\" \u003e删除\u003c/el-button\u003e \u003c/template\u003e \u003c/el-table-column\u003e \u003c/el-table\u003e \u003c/template\u003e \u003cscript\u003e import teacher from \"@/api/edu/teacher\"; export default { data() { return { list: null, //查询之后接口返回集合 page: 1, //当前页 limit: 3, //每页记录数 total: 0, //总记录数 teacherQuery: {}, //条件封装对象 }; }, created() { //页面渲染之前执行，一般用于调用methods中定义的方法 this.getTeacherListPage(); }, methods: { //页面渲染之后执行，一般用于创建具体方法 //讲师列表方法 getTeacherListPage() { teacher .getTeacherListPage(this.page, this.limit, this.teacherQuery) .then((response) =\u003e { //请求成功 //response接口返回的数据 this.list = response.data.rows; this.total = response.data.total; }) .catch((error) =\u003e { console.log(error); }); } }, }; \u003c/script\u003e 分页实现 分页方法修改 需要修改当前页面数 getTeacherListPage(page = 1) { this.page = page; …… \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e \u003cel-table :data=\"list\" element-loading-text=\"数据加载中\" border fit highlight-current-row\u003e \u003cel-table-column label=\"序号\" width=\"70\" align=\"center\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e{{ (page - 1) * limit + scope.$index + 1 }}\u003c/template\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"name\" label=\"名称\" width=\"80\" /\u003e \u003cel-table-column label=\"头衔\" width=\"80\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e{{ scope.row.level===1?'高级讲师':'首席讲师' }}\u003c/template\u003e \u003c/el-table-column\u003e \u003cel-table-column prop=\"intro\" label=\"资历\" /\u003e \u003cel-table-column prop=\"gmtCreate\" label=\"添加时间\" width=\"160\" /\u003e \u003cel-table-column prop=\"sort\" label=\"排序\" width=\"60\" /\u003e \u003cel-table-column label=\"操作\" width=\"200\" align=\"center\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e \u003crouter-link :to=\"'/teacher/updateTeacher/'+scope.row.id\"\u003e \u003cel-button type=\"primary\" size=\"mini\" icon=\"el-icon-edit\"\u003e修改\u003c/el-button\u003e \u003c/router-link\u003e \u003cel-button type=\"danger\" size=\"mini\" icon=\"el-icon-delete\" @click=\"removeTeacherById(scope.row.id)\" \u003e删除\u003c/el-button\u003e \u003c/template\u003e \u003c/el-table-column\u003e \u003c/el-table\u003e \u003c!-- 分页 --\u003e \u003cel-pagination :current-page=\"page\" :page-size=\"limit\" :total=\"total\" style=\"padding: 30px 0; text-align: center;\" layout=\"total, prev, pager, next, jumper\" @current-change=\"getTeacherListPage\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import teacher from \"@/api/edu/teacher\"; export default { data() { return { list: null, //查询之后接口返回集合 page: 1, //当前页 limit: 3, //每页记录数 total: 0, //总记录数 teacherQuery: {}, //条件封装对象 }; }, created() { //","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:3:0","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"四.讲师删除功能 每条记录后添加删除按钮 按钮绑定删除事件 并传递参数：讲师的id \u003cel-button type=\"danger\" size=\"mini\" icon=\"el-icon-delete\" @click=\"removeTeacherById(scope.row.id)\" \u003e删除\u003c/el-button\u003e 在src/api/edu/teacher.js定义删除接口地址 //2.删除功能 removeTeacherById(id) { return request({ url: `/eduservice/teacher/${id}`, method: \"delete\" }) }, 页面调用 实现方法 removeTeacherById(id) { //删除功能 this.$confirm(\"此操作将永久删除该讲师记录, 是否继续?\", \"提示\", { confirmButtonText: \"确定\", cancelButtonText: \"取消\", type: \"warning\", }).then(() =\u003e { teacher .removeTeacherById(id) .then((response) =\u003e { //删除成功 //提示信息 this.$message({ type: \"success\", message: \"删除成功!\", }); //回到列表 this.getTeacherListPage(); }) .catch((error) =\u003e { //提示信息 this.$message({ type: \"warning\", message: \"删除失败!\", }); }); }); }, ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:4:0","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"五.讲师添加功能 创建路由 { path: '/teacher', component: Layout, redirect: '/teacher/listTeacher', name: '讲师管理', meta: { title: '讲师管理', icon: 'example' }, children: [ 。。。 { path: 'saveTeacher', name: '添加讲师', component: () =\u003e import('@/views/edu/teacher/saveTeacher'), meta: { title: '添加讲师', icon: 'tree' } } 。。。 ] }, 创建页面 添加合适的elment-ui组件 \u003ctemplate\u003e \u003cdiv class=\"app-container\"\u003e \u003cel-form label-width=\"120px\"\u003e \u003cel-form-item label=\"讲师名称\"\u003e \u003cel-input v-model=\"teacher.name\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"讲师排序\"\u003e \u003cel-input-number v-model=\"teacher.sort\" controls-position=\"right\" min=\"0\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"讲师头衔\"\u003e \u003cel-select v-model=\"teacher.level\" clearable placeholder=\"请选择\"\u003e \u003c!--数据类型一定要和取出的json中的一致，否则没法回填因此，这里value使用动态绑定的值，保证其数据类型是number--\u003e \u003cel-option :value=\"1\" label=\"高级讲师\" /\u003e \u003cel-option :value=\"2\" label=\"首席讲师\" /\u003e \u003c/el-select\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"讲师资历\"\u003e \u003cel-input v-model=\"teacher.career\" /\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"讲师简介\"\u003e \u003cel-input v-model=\"teacher.intro\" :rows=\"10\" type=\"textarea\" /\u003e \u003c/el-form-item\u003e \u003c!-- 讲师头像：TODO --\u003e \u003cel-form-item\u003e \u003cel-button :disabled=\"saveBtnDisabled\" type=\"primary\" @click=\"saveOrUpdate\"\u003e保存\u003c/el-button\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import teacher from \"@/api/edu/teacher\"; export default { data() { }, created() { }, methods: { }, }; \u003c/script\u003e api定义接口地址 //3.添加讲师 addTeacher(teacher) { return request({ url: `/eduservice/teacher/addTeacher`, method: \"post\", data: teacher }) }, 在页面实现调用 methods: { saveOrUpdate() { this.saveTeacher(); }, saveTeacher() { teacher .addTeacher(this.teacher) .then((response) =\u003e { //添加成功 //提示信息 this.$message({ type: \"success\", message: \"添加成功\", }); //回到讲师列表 路由跳转(重定向) this.$router.push({ path: \"/teacher/listTeacher\" }); }) .catch((error) =\u003e { //提示信息 this.$message({ type: \"warning\", message: \"添加失败\", }); }); }, }, ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:5:0","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"六.讲师修改 每条记录后添加修改按钮 通过路由跳转进入回显页面，添加路由 重点 id的传递 { path: '/teacher', component: Layout, redirect: '/teacher/listTeacher', name: '讲师管理', meta: { title: '讲师管理', icon: 'example' }, children: [ 。。。 { //接收id path: 'updateTeacher/:id', name: '编辑讲师', component: () =\u003e import('@/views/edu/teacher/saveTeacher'), meta: { title: '编辑讲师', icon: 'tree' }, hidden:true } ] }, 修改前端页面修改按钮的路径 传递 id \u003ctemplate slot-scope=\"scope\"\u003e \u003crouter-link :to=\"'/teacher/updateTeacher/'+scope.row.id\"\u003e \u003cel-button type=\"primary\" size=\"mini\" icon=\"el-icon-edit\"\u003e修改\u003c/el-button\u003e \u003c/router-link\u003e 。。。 定义api接口 //4.根据id查询 getTeacherById(id) { return request({ url: `/eduservice/teacher/selectTeacherById/${id}`, method: \"get\", }) }, //修改讲师 updateTeacher(teacher) { return request({ url: `/eduservice/teacher/updateTeacher`, method: \"put\", data: teacher }) } 在页面调用接口进行数据回显 //根据讲师id查询 getTeacherById(id) { teacher .getTeacherById(id) .then((response) =\u003e { this.teacher = response.data.teacher; }) .catch((error) =\u003e {}); }, 判断何时调用数据回显 created() { //判断路径中是否有id值 if (this.$route.params \u0026\u0026 this.$route.params.id) { const id = this.$route.params.id; this.getTeacherById(id); } }, 修改实现 在页面调用修改的方法 //修改讲师 updateTeacher() { teacher.updateTeacher(this.teacher).then((response) =\u003e { this.$message({ type: \"success\", message: \"修改成功!\", }); this.$router.push({ path: \"/teacher/listTeacher\" }); }); }, 判断是修改 还是 增加 saveOrUpdate() { //判断是修改还是添加 //判断路径中是否有id if (this.$route.params \u0026\u0026 this.$route.params.id) { //修改 this.updateTeacher(); } else { //添加 this.saveTeacher(); } }, ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:6:0","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"七.路由切换问题 问题：第一次点修改 进行数据回显 然后点击添加讲师 进入表单页面：添加讲师页面还是显示修改的回显数据 正确效果应该是表单数据清空 解决方法： 进行表单数据清空(可能解决不了) created(){ //判断路径中是否有id值 if (this.$route.params \u0026\u0026 this.$route.params.id) { const id = this.$route.params.id; this.getTeacherById(id); } else { //清空表单 this.teacher = {}; } } 未能解决的原因： ​ 多次路由跳转到同一页面，在页面中的created方法只会执行一次，后面再进行跳转时不会执行 最终解决 created() { this.init(); }, watch: { //监听 $route(to, from) { //路由发生变化 方法就会执行 this.init(); }, }, methods: { //初始化 init() { //判断路径中是否有id值 if (this.$route.params \u0026\u0026 this.$route.params.id) { const id = this.$route.params.id; this.getTeacherById(id); } else { //清空表单 this.teacher = {}; } }, } 使用 watch 方法进行监听 只要出现路由变化 就会执行init()方法 ","date":"2020-08-03","objectID":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/:7:0","tags":[],"title":"guli-5-业务开发","uri":"/guli-5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"},{"categories":[],"content":"guli-4-前端项目搭建 ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:0:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"一.axios var app = new Vue({ el: '#app', data: { memberList: []//数组 }, created() { //调用 this.getList() }, methods: { //定义 getList(id) { //vm = this axios.get('http://localhost:8081/admin/ucenter/member') .then(response =\u003e { console.log(response) this.memberList = response.data.data.items }) .catch(error =\u003e { console.log(error) }) } } }) ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:1:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"二.Node.js ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:2:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"三.npm 相当于前端的Maven //项目初始化 npm init #按照提示输入相关信息，如果是用默认值则直接回车即可。 #name: 项目名称 #version: 项目版本号 #description: 项目描述 #keywords: {Array}关键词，便于用户搜索到我们的项目 #最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml #如果想直接生成 package.json 文件，那么可以使用命令 npm init -y //修改npm镜像 #经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载 npm config set registry https://registry.npm.taobao.org #查看npm配置信息 npm config list //npm install命令的使用 npm install #根据package.json中的配置下载依赖，初始化项目 #使用 npm install 安装依赖包的最新版， #模块安装的位置：项目目录\\node_modules #安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本 #同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的\u003cdependencies\u003e npm install jquery //只有package.json和package-lock.json文件 没有下载依赖时 #devDependencies节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖 #使用 -D参数将依赖添加到devDependencies节点 npm install --save-dev eslint #或 npm install -D eslint #全局安装 #Node.js全局安装的npm包和工具的位置：用户目录\\AppData\\Roaming\\npm\\node_modules #一些命令行工具常使用全局安装的方式 npm install -g webpack ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:3:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"四.Babel Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行执行。 这意味着，你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持。 安装 npm install --global babel-cli #查看是否安装成功 babel --version 使用 初始化项目 npm init -y 创建文件 src/example.js //下面是一段ES6代码： // 转码前 // 定义数据 let input = [1, 2, 3] // 将数组的每个元素 +1 input = input.map(item =\u003e item + 1) console.log(input) 配置.babelrc Babel的配置文件是.babelrc，存放在项目的根目录下，该文件用来设置转码规则和插件，基本格式如 下。 { \"presets\": [], \"plugins\": [] } presets字段设定转码规则，将es2015规则加入 .babelrc： { \"presets\": [\"es2015\"], \"plugins\": [] } 安装转码器(在项目中安装) npm install --save-dev babel-preset-es2015 转码 # --out-file 或 -o 参数指定输出文件 babel src/example.js --out-file dist1/compiled.js # 或者 babel src/example.js -o dist1/compiled.js # --out-dir 或 -d 参数指定输出目录 babel src --out-dir dist2 # 或者 babel src -d dist2 ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:4:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"五.模块化 导出模块 export default { getList() { console.log('获取数据列表2') }, save() { console.log('保存数据2') } } 导入模块 import user from \"./userApi2.js\" user.getList() user.save() ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:5:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"六.Webpack Webpack 是一个前端资源加载/打包工具 安装 npm install -g webpack webpack-cli //查看版本号 webpack -v 初始化项目 创建webpack文件夹 进入webpack目录，执行命令 npm init -y 创建src文件夹 src下创建common.js exports.info = function (str) { document.write(str); } src下创建utils.js exports.add = function (a, b) { return a + b; } src下创建main.js const common = require('./common'); const utils = require('./utils'); common.info('Hello world!' + utils.add(100, 200)); JS打包 webpack目录下创建配置文件webpack.config.js const path = require(\"path\"); //Node.js内置模块 module.exports = { entry: './src/main.js', //配置入口文件 output: { path: path.resolve(__dirname, './dist'), //输出路径，__dirname：当前文件所在路径 filename: 'bundle.js' //输出文件 } } 命令行执行编译命令 webpack #有黄色警告 webpack --mode=development #没有警告 #执行后查看bundle.js 里面包含了上面两个js文件的内容并进行了代码压缩 CSS打包 安装style-loader和 css-loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器。 首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识css npm install --save-dev style-loader css-loader 修改webpack.config.js const path = require(\"path\"); //Node.js内置模块 module.exports = { //..., output:{}, module: { rules: [ { test: /\\.css$/, //打包规则应用到以css结尾的文件上 use: ['style-loader', 'css-loader'] } ] } } ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:6:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"七.vue-element-admin vue-element-admin是基于element-ui 的一套后台管理系统集成方案。 功能：https://panjiachen.github.io/vue-element-admin-site/zh/guide/# 功能 GitHub地址：https://github.com/PanJiaChen/vue-element-admin 项目在线预览：https://panjiachen.gitee.io/vue-element-admin 安装 # 解压压缩包 # 进入目录 cd vue-element-admin-master # 安装依赖 npm install # 启动。执行后，浏览器自动弹出并访问http://localhost:9527/ npm run dev ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:7:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"八.项目创建和基本配置 项目目录 . ├── build // 构建脚本 ├── config // 全局配置 ├── node_modules // 项目依赖模块 ├── src //项目源代码 ├── static // 静态资源 └── package.jspon // 项目信息和依赖配置 src ├── api // 各种接口 ├── assets // 图片等资源 ├── components // 各种公共组件，非公共组件在各自view下维护 ├── icons //svg icon ├── router // 路由表 ├── store // 存储 ├── styles // 各种样式 ├── utils // 公共工具，非公共工具，在各自view下维护 ├── views // 各种layout ├── App.vue //***项目顶层组件*** ├── main.js //***项目入口文件*** └── permission.js //认证入口 运行项目 npm run dev ","date":"2020-08-02","objectID":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:8:0","tags":[],"title":"guli-4-前端项目搭建","uri":"/guli-4-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"guli-3-es6,vue ","date":"2020-08-01","objectID":"/guli-3-es6vue/:0:0","tags":[],"title":"guli-3-es6,vue","uri":"/guli-3-es6vue/"},{"categories":[],"content":"一.ES6 let声明变量 // var 声明的变量没有局部作用域 // let 声明的变量 有局部作用域 { var a = 0 let b = 1 } console.log(a) // 0 console.log(b) // ReferenceError: b is not defined // var 可以声明多次 // let 只能声明一次 var m = 1 var m = 2 let n = 3 let n = 4 console.log(m) // 2 console.log(n) // Identifier 'n' has already been declared const声明常量（只读变量） // 1、声明之后不允许改变 const PI = \"3.1415926\" PI = 3 // TypeError: Assignment to constant variable. // 2、一但声明必须初始化，否则会报错 const MY_AGE // SyntaxError: Missing initializer in const declaration 解构赋值 //1、数组解构 // 传统 let a = 1, b = 2, c = 3 console.log(a, b, c) // ES6 let [x, y, z] = [1, 2, 3] console.log(x, y, z) //2、对象解构 let user = {name: 'Helen', age: 18} // 传统 let name1 = user.name let age1 = user.age console.log(name1, age1) // ES6 let { name, age } = user//注意：结构的变量必须是user中的属性 console.log(name, age) 模板字符串 // 1、多行字符串 let string1 = `Hey, can you stop angry now?` console.log(string1) // Hey, // can you stop angry now? // 2、字符串插入变量和表达式。变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。 let name = \"Mike\" let age = 27 let info = `My Name is ${name},I am ${age+1} years old next year.` console.log(info) // My Name is Mike,I am 28 years old next year. // 3、字符串中调用函数 function f(){ return \"have fun!\" } let string2 = `Game start,${f()}` console.log(string2); // Game start,have fun! 声明对象简写 const age = 12 const name = \"Amy\" // 传统 const person1 = {age: age, name: name} console.log(person1) // ES6 const person2 = {age, name} console.log(person2) //{age: 12, name: \"Amy\"} 定义方法简写 // 传统 const person1 = { sayHi:function(){ console.log(\"Hi\") } } person1.sayHi();//\"Hi\" // ES6 const person2 = { sayHi(){ console.log(\"Hi\") } } person2.sayHi() //\"Hi\" 对象拓展运算符 // 1、拷贝对象 let person1 = {name: \"Amy\", age: 15} let someone = { ...person1 } console.log(someone) //{name: \"Amy\", age: 15} // 2、合并对象 let age = {age: 15} let name = {name: \"Amy\"} let person2 = {...age, ...name} console.log(person2) //{age: 15, name: \"Amy\"} 箭头函数 箭头函数多用于匿名函数的定义 // 传统 var f1 = function(a){ return a } console.log(f1(1)) // ES6 var f2 = a =\u003e a console.log(f2(1)) // 当箭头函数没有参数或者有多个参数，要用 () 括起来。 // 当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块， // 当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。 var f3 = (a,b) =\u003e { let result = a+b return result } console.log(f3(6,2)) // 8 // 前面代码相当于： var f4 = (a,b) =\u003e a+b ","date":"2020-08-01","objectID":"/guli-3-es6vue/:1:0","tags":[],"title":"guli-3-es6,vue","uri":"/guli-3-es6vue/"},{"categories":[],"content":"二.vue 局部组件 定义 var app = new Vue({ el: '#app', // 定义局部组件，这里可以定义多个局部组件 components: { //组件的名字 'Navbar': { //组件的内容 template: '\u003cul\u003e\u003cli\u003e首页\u003c/li\u003e\u003cli\u003e学员管理\u003c/li\u003e\u003c/ul\u003e' } } }) 使用 \u003cdiv id=\"app\"\u003e \u003cNavbar\u003e\u003c/Navbar\u003e \u003c/div\u003e 全局组件 定义 components/Navbar.js // 定义全局组件 Vue.component('Navbar', { template: '\u003cul\u003e\u003cli\u003e首页\u003c/li\u003e\u003cli\u003e学员管理\u003c/li\u003e\u003cli\u003e讲师管理\u003c/li\u003e\u003c/ul\u003e' }) 使用 \u003cdiv id=\"app\"\u003e \u003cNavbar\u003e\u003c/Navbar\u003e \u003c/div\u003e \u003cscript src=\"vue.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"components/Navbar.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: '#app' }) \u003c/script\u003e 生命周期 //数据渲染之前 created() { // 第二个被执行的钩子方法 console.log(this.message) //床前明月光 this.show() //执行show方法 // created执行时，data 和 methods 都已经被初始化好了！ // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 }, //数据渲染之后 mounted() { // 第四个被执行的钩子方法 console.log(document.getElementById('h3').innerText) //床前明月光 // 内存中的模板已经渲染到页面，用户已经可以看见内容 }, 路由 引入js \u003cscript src=\"vue.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"vue-router.min.js\"\u003e\u003c/script\u003e 编写html \u003cdiv id=\"app\"\u003e \u003ch1\u003eHello App!\u003c/h1\u003e \u003cp\u003e \u003c!-- 使用 router-link 组件来导航. --\u003e \u003c!-- 通过传入 `to` 属性指定链接. --\u003e \u003c!-- \u003crouter-link\u003e 默认会被渲染成一个 `\u003ca\u003e` 标签 --\u003e \u003crouter-link to=\"/\"\u003e首页\u003c/router-link\u003e \u003crouter-link to=\"/student\"\u003e会员管理\u003c/router-link\u003e \u003crouter-link to=\"/teacher\"\u003e讲师管理\u003c/router-link\u003e \u003c/p\u003e \u003c!-- 路由出口 --\u003e \u003c!-- 路由匹配到的组件将渲染在这里 --\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e 编写js \u003cscript\u003e // 1. 定义（路由）组件。 // 可以从其他文件 import 进来 const Welcome = { template: '\u003cdiv\u003e欢迎\u003c/div\u003e' } const Student = { template: '\u003cdiv\u003estudent list\u003c/div\u003e' } const Teacher = { template: '\u003cdiv\u003eteacher list\u003c/div\u003e' } // 2. 定义路由 // 每个路由应该映射一个组件。 const routes = [ { path: '/', redirect: '/welcome' }, //设置默认指向的路径 { path: '/welcome', component: Welcome }, { path: '/student', component: Student }, { path: '/teacher', component: Teacher } ] // 3. 创建 router 实例，然后传 `routes` 配置 const router = new VueRouter({ routes // （缩写）相当于 routes: routes }) // 4. 创建和挂载根实例。 // 从而让整个应用都有路由功能 const app = new Vue({ el: '#app', router }) // 现在，应用已经启动了！ \u003c/script\u003e ","date":"2020-08-01","objectID":"/guli-3-es6vue/:2:0","tags":[],"title":"guli-3-es6,vue","uri":"/guli-3-es6vue/"},{"categories":[],"content":"guli-2-项目搭建 ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:0:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"一.工程目录 guli-parent：在线教学根目录（父工程），管理四个子模块： canal-client：canal数据库表同步模块（统计同步数据） common：公共模块父节点 common-util：工具类模块，所有模块都可以依赖于它 service-base：service服务的base包，包含service服务的公共配置类，所有service模块依赖于它 spring-security：认证与授权模块，需要认证授权的service服务依赖于它 infrastructure：基础服务模块父节点 api-gateway：api网关服务 service：api接口服务父节点 service-acl：用户权限管理api接口服务（用户管理、角色管理和权限管理等） service-cms：cms api接口服务 service-edu：教学相关api接口服务 service-msm：短信api接口服务 service-order：订单相关api接口服务 service-oss：阿里云oss api接口服务 service-statistics：统计报表api接口服务 service-ucenter：会员api接口服务 service-vod：视频点播api接口服务 ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:1:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"二.创建父工程 创建sprigboot工程guli-parent 在idea开发工具中，使用 Spring Initializr 快速初始化一个 Spring Boot 模块，版本使用：2.2.1.RELEASE 删除 src 目录 配置 pom.xml 修改版本为 ：2.2.1.RELEASE \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.2.1.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e 添加 pom类型 \u003cartifactId\u003eguli_parent\u003c/artifactId\u003e \u003cpackaging\u003epom\u003c/packaging\u003e 在pom.xml中添加依赖的版本 删除pom.xml中的内容 \u003c!-- 以下内容删除 --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 添加依赖的版本 \u003cproperties\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003cguli.version\u003e0.0.1-SNAPSHOT\u003c/guli.version\u003e \u003cmybatis-plus.version\u003e3.0.5\u003c/mybatis-plus.version\u003e \u003cvelocity.version\u003e2.0\u003c/velocity.version\u003e \u003cswagger.version\u003e2.7.0\u003c/swagger.version\u003e \u003caliyun.oss.version\u003e2.8.3\u003c/aliyun.oss.version\u003e \u003cjodatime.version\u003e2.10.1\u003c/jodatime.version\u003e \u003cpoi.version\u003e3.17\u003c/poi.version\u003e \u003ccommons-fileupload.version\u003e1.3.1\u003c/commons-fileupload.version\u003e \u003ccommons-io.version\u003e2.6\u003c/commons-io.version\u003e \u003chttpclient.version\u003e4.5.1\u003c/httpclient.version\u003e \u003cjwt.version\u003e0.7.0\u003c/jwt.version\u003e \u003caliyun-java-sdk-core.version\u003e4.3.3\u003c/aliyun-java-sdk-core.version\u003e \u003caliyun-sdk-oss.version\u003e3.1.0\u003c/aliyun-sdk-oss.version\u003e \u003caliyun-java-sdk-vod.version\u003e2.15.2\u003c/aliyun-java-sdk-vod.version\u003e \u003caliyun-java-vod-upload.version\u003e1.4.11\u003c/aliyun-java-vod-upload.version\u003e \u003caliyun-sdk-vod-upload.version\u003e1.4.11\u003c/aliyun-sdk-vod-upload.version\u003e \u003cfastjson.version\u003e1.2.28\u003c/fastjson.version\u003e \u003cgson.version\u003e2.8.2\u003c/gson.version\u003e \u003cjson.version\u003e20170516\u003c/json.version\u003e \u003ccommons-dbutils.version\u003e1.7\u003c/commons-dbutils.version\u003e \u003ccanal.client.version\u003e1.1.0\u003c/canal.client.version\u003e \u003cdocker.image.prefix\u003ezx\u003c/docker.image.prefix\u003e \u003ccloud-alibaba.version\u003e0.2.2.RELEASE\u003c/cloud-alibaba.version\u003e \u003c/properties\u003e dependencyManagement配置 \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003c!--Spring Cloud--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-dependencies\u003c/artifactId\u003e \u003cversion\u003eHoxton.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e${cloud-alibaba.version}\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--mybatis-plus 持久层--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${mybatis-plus.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.velocity\u003c/groupId\u003e \u003cartifactId\u003evelocity-engine-core\u003c/artifactId\u003e \u003cversion\u003e${velocity.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--swagger--\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e${swagger.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--swagger ui--\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e${swagger.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--aliyunOSS--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun.oss\u003c/groupId\u003e \u003cartifactId\u003ealiyun-sdk-oss\u003c/artifactId\u003e \u003cversion\u003e${aliyun.oss.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--日期时间工具--\u003e \u003cdependency\u003e \u003cgroupId\u003ejoda-time\u003c/groupId\u003e \u003cartifactId\u003ejoda-time\u003c/artifactId\u003e \u003cversion\u003e${jodatime.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--xls--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.poi\u003c/groupId\u003e \u003cartifactId\u003epoi\u003c/artifactId\u003e \u003cversion\u003e${poi.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--xlsx--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.poi\u003c/groupId\u003e \u003cartifactId\u003epoi-ooxml\u003c/artifactId\u003e \u003cversion\u003e${poi.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--文件上传--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-fileupload\u003c/groupId\u003e \u003cartifactId\u003ecommons-fileupload\u003c/artifactId\u003e \u003cversion\u003e${commons-fileupload.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--commons-io--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-io\u003c/groupId\u003e \u003cartifactId\u003ecommons-io\u003c/artifact","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:2:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"三.搭建Service模块 在父工程guli-parent下面创建模块service 删除src 添加模块类型是pom \u003cartifactId\u003eservice\u003c/artifactId\u003e \u003cpackaging\u003epom\u003c/packaging\u003e 添加项目需要的依赖 \u003cdependencies\u003e \u003c!-- \u003cdependency\u003e--\u003e \u003c!-- \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e--\u003e \u003c!-- \u003cartifactId\u003espring-cloud-starter-netflix-ribbon\u003c/artifactId\u003e--\u003e \u003c!-- \u003c/dependency\u003e--\u003e \u003c!-- hystrix依赖，主要是用 @HystrixCommand--\u003e \u003c!-- \u003cdependency\u003e--\u003e \u003c!-- \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e--\u003e \u003c!-- \u003cartifactId\u003espring-cloud-starter-netflix-hystrix\u003c/artifactId\u003e--\u003e \u003c!-- \u003c/dependency\u003e--\u003e \u003c!-- 服务注册--\u003e \u003c!-- \u003cdependency\u003e--\u003e \u003c!-- \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e--\u003e \u003c!-- \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e--\u003e \u003c!-- \u003c/dependency\u003e--\u003e \u003c!-- 服务调用--\u003e \u003c!-- \u003cdependency\u003e--\u003e \u003c!-- \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e--\u003e \u003c!-- \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e--\u003e \u003c!-- \u003c/dependency\u003e--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--mybatis-plus--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--mysql--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.velocity\u003c/groupId\u003e \u003cartifactId\u003evelocity-engine-core\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--swagger--\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--lombok用来简化实体类：需要安装lombok插件--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--xls--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.poi\u003c/groupId\u003e \u003cartifactId\u003epoi\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.poi\u003c/groupId\u003e \u003cartifactId\u003epoi-ooxml\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-fileupload\u003c/groupId\u003e \u003cartifactId\u003ecommons-fileupload\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--httpclient--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.httpcomponents\u003c/groupId\u003e \u003cartifactId\u003ehttpclient\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--commons-io--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-io\u003c/groupId\u003e \u003cartifactId\u003ecommons-io\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--gson--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.google.code.gson\u003c/groupId\u003e \u003cartifactId\u003egson\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:3:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"四.搭建service-edu模块 在父工程service模块下面创建子模块service-edu 配置 在service下面service-edu模块中创建配置文件 #数据库配置 spring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=123456 #mybatis日志 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl #环境设置:dev,test,prod spring.profiles.active=dev #服务端口 server.port=8001 #服务名 spring.application.name=service_edu #设置时间格式 spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:4:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"3.MP代码生成器 在test/java目录下创建包com.guli.demo，创建代码生成器：CodeGenerator.java package com.guli.demo; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.GlobalConfig; import com.baomidou.mybatisplus.generator.config.PackageConfig; import com.baomidou.mybatisplus.generator.config.StrategyConfig; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import org.junit.Test; /** * @author * @since 2018/12/13 */ public class CodeGenerator { @Test public void run() { // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(\"E:\\\\JAVA存储\\\\Web\\\\IDEA\\\\guli_parent\\\\service\\\\service_edu\" + \"/src/main/java\"); gc.setAuthor(\"testjava\"); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(false); //重新生成时文件是否覆盖 //UserServie gc.setServiceName(\"%sService\"); //去掉Service接口的首字母I gc.setIdType(IdType.ID_WORKER_STR); //主键策略 3.3.0以后需要更改 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); //包 com.guli.eduservice pc.setParent(\"com.guli\"); pc.setModuleName(\"eduservice\"); //模块名 //包 com.atguigu.eduservice.controller pc.setController(\"controller\"); pc.setEntity(\"entity\"); pc.setService(\"service\"); pc.setMapper(\"mapper\"); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"edu_teacher\");//表名，可以加入多张表 用\",\"隔开 strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setTablePrefix(pc.getModuleName() + \"_\"); //生成实体时去掉\"_\"变成大写 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); } } 创建SpringBoot配置类 在edu包下创建config包，创建EduConfig.java @Configuration @MapperScan(\"com.guli.eduservice.mapper\") public class EduConfig { } 创建SpringBoot启动类,注意启动类的创建位置 @SpringBootApplication public class EduApplication { public static void main(String[] args) { SpringApplication.run(EduApplication.class,args); } } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:4:1","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"6.讲师逻辑删除功能 EduTeacherController添加删除方法 @Autowired private EduTeacherService eduTeacherService; @DeleteMapping(\"{id}\") public R deleteTeacherById( @ApiParam(name = \"id\",value = \"讲师id\",required = true) @PathVariable String id){ return eduTeacherService.removeById(id); } 配置逻辑删除插件 EduConfig //逻辑删除插件 @Bean public ISqlInjector sqlInjector() { return new LogicSqlInjector(); } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:4:2","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"五.Swagger2 创建common模块 在guli-parent下创建模块common 配置： groupId：com.guli artifactId：common 在common中引入相关依赖 \u003cpackaging\u003epom\u003c/packaging\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003cscope\u003eprovided \u003c/scope\u003e \u003c/dependency\u003e \u003c!--mybatis-plus--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cscope\u003eprovided \u003c/scope\u003e \u003c/dependency\u003e \u003c!--lombok用来简化实体类：需要安装lombok插件--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cscope\u003eprovided \u003c/scope\u003e \u003c/dependency\u003e \u003c!--swagger--\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cscope\u003eprovided \u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cscope\u003eprovided \u003c/scope\u003e \u003c/dependency\u003e \u003c!-- redis --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- spring2.X集成redis所需common-pool2 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e \u003cartifactId\u003ecommons-pool2\u003c/artifactId\u003e \u003cversion\u003e2.6.0\u003c/version\u003e \u003c/dependency\u003e--\u003e \u003c/dependencies\u003e 在common下面创建子模块service-base 在模块service-base中，创建swagger的配置类 创建包com.guli.servicebase，创建类SwaggerConfig package com.guli.servicebase; @Configuration @EnableSwagger2//Swagger注解 public class SwaggerConfig { @Bean public Docket webApiConfig(){ return new Docket(DocumentationType.SWAGGER_2) .groupName(\"webApi\") .apiInfo(webApiInfo()) .select() .paths(Predicates.not(PathSelectors.regex(\"/admin/.*\"))) .paths(Predicates.not(PathSelectors.regex(\"/error.*\"))) .build(); } private ApiInfo webApiInfo(){ return new ApiInfoBuilder() .title(\"网站-课程中心API文档\") .description(\"本文档描述了课程中心微服务接口定义\") .version(\"1.0\") .contact(new Contact(\"Mr.J\", \"233333\", \"1157237955@qq.com\")) .build(); } } 在模块service模块中引入service-base \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu\u003c/groupId\u003e \u003cartifactId\u003eservice-base\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e 在service-edu启动类上添加注解，进行测试 目的是扫描到其他项目的com.guli包 @ComponentScan(basePackages = “com.guli”) @SpringBootApplication @ComponentScan(basePackages = \"com.guli\") public class EduApplication { public static void main(String[] args) { SpringApplication.run(EduApplication.class,args); } } API模型 可以添加一些自定义设置，例如： 定义样例数据 @ApiModelProperty(value = \"查询开始时间\", example = \"2019-01-01 10:10:10\") private String begin;//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换 @ApiModelProperty(value = \"查询结束时间\", example = \"2019-12-01 10:10:10\") private String end; 定义接口说明和参数说明 定义在类上：@Api @Api(tags = “讲师管理”) 定义在方法上：@ApiOperation @ApiOperation(value = “所有讲师列表”) 定义在参数上：@ApiParam @ApiParam(name = “id”,value = “讲师id”,required = true) ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:5:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"六.统一返回数据格式 项目中我们会将响应封装成json返回，一般我们会将所有接口的数据格式统一， 使前端(iOS Android, Web)对数据的操作更一致、轻松。 一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数 据就可以。但是一般会包含状态码、返回消息、数据这几部分内容 例如，我们的系统要求返回的基本数据格式如下： 列表： { \"success\": true, \"code\": 20000, \"message\": \"成功\", \"data\": { \"items\": [ { \"id\": \"1\", \"name\": \"刘德华\", \"intro\": \"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余\" } ] } } 分页 { \"success\": true, \"code\": 20000, \"message\": \"成功\", \"data\": { \"total\": 17, \"rows\": [ { \"id\": \"1\", \"name\": \"刘德华\", \"intro\": \"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余\" } ] } } 没有返回数据： { \"success\": true, \"code\": 20000, \"message\": \"成功\", \"data\": {} } 失败： { \"success\": false, \"code\": 20001, \"message\": \"失败\", \"data\": {} } 因此，我们定义统一结果 { \"success\": 布尔, //响应是否成功 \"code\": 数字, //响应码 \"message\": 字符串, //返回消息 \"data\": HashMap //返回数据，放在键值对中 } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:6:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"1.创建统一结果返回类 在common模块下创建子模块common-utils 创建接口定义返回码 创建包com.guli.commonutils，创建接口 ResultCode.java package com.guli.commonutils; public interface ResultCode { public static Integer SUCCESS = 20000;//成功 public static Integer ERROR = 20001;//失败 } 创建结果类 package com.guli.commonutils; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import java.util.HashMap; import java.util.Map; //统一返回结果的类 @Data public class R { @ApiModelProperty(value = \"是否成功\") private Boolean success; @ApiModelProperty(value = \"返回码\") private Integer code; @ApiModelProperty(value = \"返回消息\") private String message; @ApiModelProperty(value = \"返回数据\") private Map\u003cString, Object\u003e data = new HashMap\u003cString, Object\u003e(); //构造方法私有化 private R(){} //链式编程 //成功静态方法 public static R ok(){ R r = new R(); r.setSuccess(true); r.setCode(ResultCode.SUCCESS); r.setMessage(\"成功\"); return r; } //失败静态方法 public static R error(){ R r = new R(); r.setSuccess(false); r.setCode(ResultCode.ERROR); r.setMessage(\"失败\"); return r; } public R success(Boolean success){ this.setSuccess(success); return this; } public R message(String message){ this.setMessage(message); return this; } public R code(Integer code){ this.setCode(code); return this; } public R data(String key, Object value){ this.data.put(key, value); return this; } public R data(Map\u003cString, Object\u003e map) { this.setData(map); return this; } } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:6:1","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"2.统一返回结果使用 在service模块中添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.atguigu\u003c/groupId\u003e \u003cartifactId\u003ecommon_utils\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e 修改Controller中的返回结果 @Autowired private EduTeacherService eduTeacherService; //1.查询所有数据 @ApiOperation(value = \"所有讲师列表\") @GetMapping(\"findAll\") public R findAllTeacher() { List\u003cEduTeacher\u003e eduTeachers = eduTeacherService.list(null); return R.ok().data(\"items\",eduTeachers); } //2.逻辑删除讲师 @ApiOperation(value = \"根据id逻辑删除讲师\") @DeleteMapping(\"{id}\") public R deleteTeacherById( @ApiParam(name = \"id\",value = \"讲师id\",required = true) @PathVariable String id){ boolean flag = eduTeacherService.removeById(id); if (flag) { return R.ok(); }else { return R.error(); } } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:6:2","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"七.分页 EduConfig中配置分页插件 @Configuration @MapperScan(\"com.guli.eduservice.mapper\") public class EduConfig { //逻辑删除插件 @Bean public ISqlInjector sqlInjector() { return new LogicSqlInjector(); } //分页插件 @Bean public PaginationInterceptor paginationInterceptor(){ return new PaginationInterceptor(); } } 分页Controller方法 //3.分页查询 当前页（current）每页数据个数（limit） @ApiOperation(value = \"分页查询\") @GetMapping(\"pageTeacher/{current}/{limit}\") public R pageTeacher( @PathVariable long current, @PathVariable long limit) { //两个参数：当前页，每页数据个数 Page\u003cEduTeacher\u003e pageTeacher = new Page\u003c\u003e(current,limit); //返回数据存储在pageTeacher对象中 eduTeacherService.page(pageTeacher,null); long total = pageTeacher.getTotal();//总记录数 List\u003cEduTeacher\u003e teachers = pageTeacher.getRecords();//每页教师数据集合 return R.ok().data(\"total\",total).data(\"rows\",teachers); } Swagger中测试 ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:7:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"八.条件查询 根据讲师名称name，讲师头衔level、讲师入驻时间gmt_create（时间段）查询 创建查询对象 创建com.guli.eduservice.entity.vo包，创建TeacherQuery.java查询对象 package com.guli.eduservice.entity.vo; @Data public class TeacherQuery { private static final long serialVersionUID = 1L; @ApiModelProperty(value = \"教师名称,模糊查询\") private String name; @ApiModelProperty(value = \"头衔 1高级讲师 2首席讲师\") private Integer level; @ApiModelProperty(value = \"查询开始时间\", example = \"2019-01-01 10:10:10\") private String begin;//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换 @ApiModelProperty(value = \"查询结束时间\", example = \"2019-12-01 10:10:10\") private String end; } controller //4.分页带条件 @ApiOperation(value = \"条件分页查询\") @PostMapping(\"pageTeacherCondition/{current}/{limit}\") public R pageTeacherCondition( @PathVariable long current, @PathVariable long limit, //RequestBody 只能使用Post,required = false表示这个值可以没有 @RequestBody(required = false) TeacherQuery teacherQuery) { //1.创建page对象 Page\u003cEduTeacher\u003e pageTeacher = new Page\u003c\u003e(current,limit); //2.构建Wrapper QueryWrapper\u003cEduTeacher\u003e queryWrapper = new QueryWrapper\u003c\u003e(); //3.多条件组合查询 String name = teacherQuery.getName(); Integer level = teacherQuery.getLevel(); String begin = teacherQuery.getBegin(); String end = teacherQuery.getEnd(); //判断条件值是否为空，如果不为空拼接条件 if (!StringUtils.isEmpty(name)){ queryWrapper.like(\"name\",name); } if (!StringUtils.isEmpty(level)){ queryWrapper.eq(\"level\",level); } if (!StringUtils.isEmpty(begin)){ queryWrapper.ge(\"gmt_create\",begin); } if (!StringUtils.isEmpty(end)){ queryWrapper.eq(\"gmt_modified\",end); } //查询 eduTeacherService.page(pageTeacher,queryWrapper); long total = pageTeacher.getTotal();//总记录数 List\u003cEduTeacher\u003e teachers = pageTeacher.getRecords();//每页教师数据集合 return R.ok().data(\"total\",total).data(\"rows\",teachers); } Swagger中测试 ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:8:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"九.自动填充 在service-base模块中添加 创建包handler，创建自动填充类 MyMetaObjectHandler package com.guli.servicebase.handler; /** * 初始化控制器 */ @Component public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { //属性名称不是字段名称 this.setFieldValByName(\"gmtCreate\", new Date(), metaObject); this.setFieldValByName(\"gmtModified\", new Date(), metaObject); } @Override public void updateFill(MetaObject metaObject) { this.setFieldValByName(\"gmtModified\", new Date(), metaObject); } } 在实体类添加自动填充注解 @ApiModelProperty(value = \"创建时间\") @TableField(fill = FieldFill.INSERT) private Date gmtCreate; @ApiModelProperty(value = \"更新时间\") @TableField(fill = FieldFill.INSERT_UPDATE) private Date gmtModified; ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:9:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"十.Controller中其他方法 //添加讲师 @ApiOperation(value = \"添加讲师\") @PostMapping(\"addTeacher\") public R addTeacher(@RequestBody EduTeacher eduTeacher) { boolean flag = eduTeacherService.save(eduTeacher); if (flag) { return R.ok(); } else { return R.error(); } } //根据id查询讲师 @ApiOperation(value = \"根据id查询讲师\") @GetMapping(\"selectTeacherById/{id}\") public R selectTeacherById(@PathVariable String id) { EduTeacher teacher = eduTeacherService.getById(id); return R.ok().data(\"teacher\",teacher); } //修改讲师 @ApiOperation(value = \"修改讲师\") @PutMapping(\"updateTeacher\") public R updateTeacher(@RequestBody EduTeacher eduTeacher) { boolean flag = eduTeacherService.updateById(eduTeacher); if (flag) { return R.ok(); } else { return R.error(); } } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:10:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"十一.统一异常处理 我们想让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要统一异常处理 创建统一异常处理器 需要引入 common_utils中的R类 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.guli\u003c/groupId\u003e \u003cartifactId\u003ecommon_utils\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 在service-base中创建统一异常处理类GlobalExceptionHandler.java： package com.guli.servicebase.exceptionHandler; /** * 统一异常处理类 */ @ControllerAdvice public class GlobalExceptionHandler { //异常处理器：指定处理什么异常 @ExceptionHandler(Exception.class) //为了返回数据 @ResponseBody public R error(Exception e){ e.printStackTrace(); return R.error().message(\"执行了全局异常处理\"); } } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:11:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"十二.特定异常处理 GlobalExceptionHandler.java中添加 在@ExceptionHandler指定异常类型即可 //特定异常 @ExceptionHandler(ArithmeticException.class) @ResponseBody public R error(ArithmeticException e){ e.printStackTrace(); return R.error().message(\"执行了ArithmeticException异常处理\"); } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:12:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"十三.自定义异常 创建自定义异常类 package com.guli.servicebase.exception; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor //生成有参构造 @NoArgsConstructor //生成无参构造 public class GuliException extends RuntimeException{ private Integer code;//状态码 private String msg;//异常信息 } 业务中需要自己抛出指定异常 try { int a = 10/0; }catch(Exception e) { throw new GuliException(20001,\"出现自定义异常\"); } 添加异常处理方法 GlobalExceptionHandler.java中添加 //自定义异常 @ExceptionHandler(GuliException.class) @ResponseBody public R error(GuliException e){ log.error(ExceptionUtil.getMessage(e)); e.printStackTrace(); return R.error().code(e.getCode()).message(e.getMsg()); } ","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:13:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"十四.日志 配置日志级别 日志记录器（Logger）的行为是分等级的。如下表所示： 分为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL 默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别 # 设置日志级别 logging.level.root=WARN Logback日志 配置logback日志 删除application.properties中的日志配置 ##mybatis日志 #mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # ##设置日志级别 #logging.level.root=info resources 中创建 logback-spring.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设 置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值 为true --\u003e \u003c!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认 单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查 看logback运行状态。默认值为false。 --\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入 到logger上下文中。定义变量后，可以使“${}”来使用变量。 --\u003e \u003cproperty name=\"log.path\" value=\"E:/JAVA存储/Web/edu\" /\u003e \u003c!-- 彩色日志 --\u003e \u003c!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --\u003e \u003c!-- magenta:洋红 --\u003e \u003c!-- boldMagenta:粗红--\u003e \u003c!-- cyan:青色 --\u003e \u003c!-- white:白色 --\u003e \u003c!-- magenta:洋红 --\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)\"/\u003e \u003c!--输出到控制台--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或 等于此级别的日志信息--\u003e \u003c!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日 志，也不会被输出 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003eINFO\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--输出到文件--\u003e \u003c!-- 时间滚动输出 level为 INFO 日志 --\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文件的路径及文件名 --\u003e \u003cfile\u003e${log.path}/log_info.log\u003c/file\u003e \u003c!--日志文件输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/info/log-info-%d{yyyy-MMdd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e100MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文件保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文件只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003eINFO\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 时间滚动输出 level为 WARN 日志 --\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文件的路径及文件名 --\u003e \u003cfile\u003e${log.path}/log_warn.log\u003c/file\u003e \u003c!--日志文件输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c!-- 此处设置字符集 --\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003cfileNamePattern\u003e${log.path}/warn/log-warn-%d{yyyy-MMdd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e100MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文件保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文件只记录warn级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003ewarn\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 时间滚动输出 level为 ERROR 日志 --\u003e \u003cappender name=\"ERROR_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文件的路径及文件名 --\u003e \u003cfile\u003e${log.path}/log_error.log\u003c/file\u003e \u003c!--日志文件输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c!-- 此处设置字符集 --\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"c","date":"2020-07-31","objectID":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:14:0","tags":[],"title":"guli-2-项目搭建","uri":"/guli-2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"guli-1-Mybatis-Plus ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:0:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"一.配置 pom.xml \u003c!-- mybatisPlus--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.0.5\u003c/version\u003e \u003c/dependency\u003e \u003c!-- lombok用来简化实例 需要安装lombok插件--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e application.properties #数据库配置 spring.datasource.url=jdbc:mysql://localhost:3306/testdata spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=123456 ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:1:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"二.编写代码 ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:2:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"1.实体类 使用Lombok简化代码 @Data public class User { private Long id; private String name; private Integer age; private String email; } ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:2:1","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"2.数据库 CREATE TABLE USER ( id BIGINT(20) NOT NULL COMMENT '主键ID', NAME VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); INSERT INTO USER (id, NAME, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:2:2","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"3.mapper 需要继承：BaseMapper\u003c实体\u003e package com.jsh.mybatisplus.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.jsh.mybatisplus.entity.User; import org.springframework.stereotype.Repository; @Repository public interface UserMapper extends BaseMapper\u003cUser\u003e { } ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:2:3","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"三.整体测试代码 package com.jsh.mybatisplus; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.jsh.mybatisplus.entity.User; import com.jsh.mybatisplus.mapper.UserMapper; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.Arrays; import java.util.HashMap; import java.util.List; @SpringBootTest public class MybatisplusApplicationTests { // 测试mybatisPlus @Autowired private UserMapper userMapper; // 查询user表所有数据 @Test public void testSelectList() { List\u003cUser\u003e userList = userMapper.selectList(null); System.out.println(userList); } // 添加操作 @Test public void testInsert(){ User user = new User(); user.setName(\"GG1\"); user.setAge(20); user.setEmail(\"1157237955@qq.cmm\"); int insert = userMapper.insert(user); System.out.println(insert); } // 修改操作 @Test public void testUpdate() { User user = new User(); user.setId(1288368399486828545L); user.setName(\"P\"); userMapper.updateById(user); } // 测试乐观锁 @Test public void OptimisticLocker() { //根据id查询数据 User user = userMapper.selectById(1288368399486828545L); user.setName(\"P\"); userMapper.updateById(user); } // 多个id批量查询 @Test public void testSelectDemo1() { List\u003cUser\u003e userList = userMapper.selectBatchIds(Arrays.asList(1L,2L,3L)); System.out.println(userList); } // 根据条件查询(map) @Test public void testDeleteByMap() { HashMap\u003cString, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"name\", \"Helen\"); map.put(\"age\", 18); List\u003cUser\u003e userList = userMapper.selectByMap(map); System.out.println(userList); } // 分页查询 @Test public void testSelectPage() { //1.创建page对象 //两个参数：当前页，每页显示数据 Page\u003cUser\u003e page = new Page\u003c\u003e(1,3); //调用mp分页查询方法:底层封装（把分页的所有数据封装到page中） userMapper.selectPage(page,null); //通过page对象获取分页数据 System.out.println(page.getCurrent());//当前页 System.out.println(page.getRecords());//每页数据的list集合 System.out.println(page.getSize());//每页显示记录数 System.out.println(page.getTotal());//总记录数 System.out.println(page.getPages());//总页数 System.out.println(page.hasNext());//是否有下一页 System.out.println(page.hasPrevious());//是否有上一页 } //删除操作 物理删除 @Test public void testDelete() { int result = userMapper.deleteById(1288412637062803457L); System.out.println(result); } //批量删除 @Test public void testDeleteBatchIds() { int result = userMapper.deleteBatchIds(Arrays.asList(2,1,3)); System.out.println(result); } //复杂条件查询 构建条件 @Test public void testQueryWapper(){ //创建QueryWrapper对象 QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper\u003c\u003e(); //通过QueryWrapper设置条件 //ge(大于等于),gt(大于),le(小于等于),lt(小于) // queryWrapper.gt(\"age\",20); //eq(等于),ne(不等于) // queryWrapper.eq(\"name\",\"GG\"); //between(查询区间 包括临界值) // queryWrapper.between(\"age\",20,30); //like(模糊查询) // queryWrapper.like(\"name\",\"G\"); //orderByDesc(排序) // queryWrapper.orderByDesc(\"id\"); //last(在sql语句后拼接) // queryWrapper.last(\"limit 1\"); //select(指定要查询的列) queryWrapper.select(\"id\",\"name\"); userMapper.selectList(queryWrapper); } } ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:3:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"四.配置日志 application.properties #mybatis日志 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:4:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"五.主键策略 // 主键生成策略 /** * AUTO：自动生长 * INPUT：手动输入设置 * NONE：没有策略 * UUID：随即唯一的值 * * mybatisPlus自带策略：（不写会默认识别） * ID_WORKER：生成19位值，数字类型使用这种策略，例如long * ID_WORKER_STR：生成19位值，字符串类型使用这种策略 */ @TableId(type = IdType.ID_WORKER) private Long id; ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:5:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"六.自动填充 数据库表中添加自动填充字段 在User表中添加datetime类型的新的字段 create_time、update_time 实体上添加注解 //creat_time 添加时 INSERT @TableField(fill = FieldFill.INSERT) private Date createTime; //update_time 添加和修改时 INSERT_UPDATE @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime; 实现元对象处理器接口(不要忘记添加 @Component 注解) package com.jsh.mybatisplus.handler; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Component public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { //三个参数：修改的参数名，修改的值，metaObject this.setFieldValByName(\"createTime\",new Date(),metaObject); this.setFieldValByName(\"updateTime\",new Date(),metaObject); } @Override public void updateFill(MetaObject metaObject) { this.setFieldValByName(\"updateTime\",new Date(),metaObject); } } ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:6:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"七.乐观锁 主要适用场景：当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新 乐观锁实现方式： 取出记录时，获取当前version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 数据库中添加version字段 实体类添加version字段 并添加 @Version 注解 //版本号 @Version @TableField(fill = FieldFill.INSERT) private Integer version; 元对象处理器接口添加version的insert默认值 @Override public void insertFill(MetaObject metaObject) { ...... this.setFieldValByName(\"version\", 1, metaObject); } 在MpConfig(用于配置)中注册 Bean @Configuration @MapperScan(\"com.jsh.mybatisplus.mapper\") public class MpConfig { //乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor(){ return new OptimisticLockerInterceptor(); } } 测试 测试后分析打印的sql语句，将version的数值进行了加1操作 // 测试乐观锁 @Test public void OptimisticLocker() { //根据id查询数据 User user = userMapper.selectById(1288368399486828545L); user.setName(\"P\"); userMapper.updateById(user); } ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:7:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"八.分页查询 MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能 配置分页插件 @Configuration @MapperScan(\"com.jsh.mybatisplus.mapper\") public class MpConfig { //分页插件 @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } } 测试 最终通过page对象获取相关数据 // 分页查询 @Test public void testSelectPage() { //1.创建page对象 //两个参数：当前页，每页显示数据 Page\u003cUser\u003e page = new Page\u003c\u003e(1,3); //调用mp分页查询方法:底层封装（把分页的所有数据封装到page中） userMapper.selectPage(page,null); //通过page对象获取分页数据 System.out.println(page.getCurrent());//当前页 System.out.println(page.getRecords());//每页数据的list集合 System.out.println(page.getSize());//每页显示记录数 System.out.println(page.getTotal());//总记录数 System.out.println(page.getPages());//总页数 System.out.println(page.hasNext());//是否有下一页 System.out.println(page.hasPrevious());//是否有上一页 } ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:8:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"九.逻辑删除 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除数据 逻辑删除：假删除，将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍 旧能看到此条数据记录 数据库中添加 deleted字段 实体类添加deleted 字段 //逻辑删除标识符 @TableLogic @TableField(fill = FieldFill.INSERT) private Integer deleted; 元对象处理器接口添加deleted的insert默认值 public void insertFill(MetaObject metaObject) { ...... this.setFieldValByName(\"deleted\", 0, metaObject); } application.properties #mybatis逻辑删除标志定义 默认是0和1 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 在 MyConfig 中注册 Bean @Configuration @MapperScan(\"com.jsh.mybatisplus.mapper\") public class MpConfig { //逻辑删除插件 mybatis-Plus版本3.3.0以后不需要 @Bean public ISqlInjector iSqlInjector() { return new LogicSqlInjector(); } } 测试 测试后发现，数据并没有被删除，deleted字段的值由0变成了1 测试后分析打印的sql语句，是一条update 注意：被删除数据的deleted 字段的值必须是 0，才能被选取出来执行逻辑删除的操作 @Test public void testDelete() { int result = userMapper.deleteById(1288412637062803457L); System.out.println(result); } 测试逻辑删除后的查询 MyBatis Plus中查询操作也会自动添加逻辑删除字段的判断 测试后分析打印的sql语句，包含 WHERE deleted=0 SELECT id,name,age,email,create_time,update_time,deleted FROM user WHERE deleted=0 /** * 测试 逻辑删除后的查询： * 不包括被逻辑删除的记录 */ @Test public void testLogicDeleteSelect() { User user = new User(); List\u003cUser\u003e users = userMapper.selectList(null); users.forEach(System.out::println); } ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:9:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"十.性能分析 在 MyConfig 中注册 Bean @Configuration @MapperScan(\"com.jsh.mybatisplus.mapper\") public class MpConfig { /** * sql执行性能分析插件 * 开发环境使用，线上不推荐，maxTime:最大执行时常 * * 三种环境 * dev:开发环境 * test:测试环境 * prod:生产环境 */ @Bean @Profile({\"dev\",\"test\"})//设置 dev test 环境开启 public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(500);//ms,超过500ms sql语句不执行 performanceInterceptor.setFormat(true);//格式化日志 return performanceInterceptor; } } Spring Boot 中设置dev环境 #环境设置 spring.profiles.active=dev ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:10:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":[],"content":"十一.条件查询(QueryWrapper) @SpringBootTest public class MybatisplusApplicationTests { // 测试mybatisPlus @Autowired private UserMapper userMapper; //复杂条件查询 构建条件 @Test public void testQueryWapper(){ //创建QueryWrapper对象 QueryWrapper\u003cUser\u003e queryWrapper = new QueryWrapper\u003c\u003e(); //通过QueryWrapper设置条件 //ge(大于等于),gt(大于),le(小于等于),lt(小于) // queryWrapper.gt(\"age\",20); //eq(等于),ne(不等于) // queryWrapper.eq(\"name\",\"GG\"); //between(查询区间 包括临界值) // queryWrapper.between(\"age\",20,30); //like(模糊查询) // queryWrapper.like(\"name\",\"G\"); //orderByDesc(排序) // queryWrapper.orderByDesc(\"id\"); //last(在sql语句后拼接) // queryWrapper.last(\"limit 1\"); //select(指定要查询的列) queryWrapper.select(\"id\",\"name\"); userMapper.selectList(queryWrapper); } } ","date":"2020-07-30","objectID":"/guli-1-mybatis-plus/:11:0","tags":[],"title":"guli-1-Mybatis-Plus","uri":"/guli-1-mybatis-plus/"},{"categories":["Spring"],"content":"Springboot-任务 ","date":"2020-06-04","objectID":"/springboot-%E4%BB%BB%E5%8A%A1/:0:0","tags":["任务","框架"],"title":"Springboot-任务","uri":"/springboot-%E4%BB%BB%E5%8A%A1/"},{"categories":["Spring"],"content":"一.异步任务 主程序注解 @EnableAsync package com.jsh.task; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.scheduling.annotation.EnableAsync; @SpringBootApplication @EnableAsync public class SpringbootTaskApplication { public static void main(String[] args) { SpringApplication.run(SpringbootTaskApplication.class, args); } } 需要异步的方法 @Async package com.jsh.task.service; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Service; @Service public class AsyncService { @Async public void hello(){ try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"处理数据中。。。\"); } } ","date":"2020-06-04","objectID":"/springboot-%E4%BB%BB%E5%8A%A1/:1:0","tags":["任务","框架"],"title":"Springboot-任务","uri":"/springboot-%E4%BB%BB%E5%8A%A1/"},{"categories":["Spring"],"content":"二.定时任务 主程序加上注解 @EnableScheduling 需要定时调动的方法 @Scheduled(cron = “0 * * * * MON-SAT”) cron 表达式： 六个参数（空格隔开）：秒 分 时 每月的第几天 月 每周第几天 0-7表示周 0和7是周天 可以使用通配符 通配符说明: “*”表示所有值. 例如:在分的字段上设置，表示每一分钟都会触发。 “?”表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为\"?\" 具体设置为 0 0 0 10 * ? “-”表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。 “,” 表示指定多个值，例如在周字段上设置 “1，3，5” 表示周一，周三和周五触发 “/”用于递增触发。如在秒上面设置\"5/15\" 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置'1/3’所示每月1号开始，每隔三天触发一次。一般不写的话，默认递增为基本单位，如1分钟，1秒钟 “L”表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于\"6\"或\"SAT\"。如果在\"L\"前加上数字，则表示该数据的最后一个。例如在周字段上设置\"5L\"这样的格式,则表示“本月最后一个星期五\" “W”表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置\"15W\"，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，“W\"前只能设置具体的数字,不允许区间”-\"). 小提示 ‘L’和 ‘W’可以一组合使用。如果在日字段上设置\"LW\",则表示在本月的最后一个工作日触发(一般指发工资 ) “#”序号(表示每月的第几个周几)，例如在周字段上设置\"6#3\"表示在每月的第三个周六. package com.jsh.task.service; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Service; @Service public class ScheduledService { /* * \u003cul\u003e * \u003cli\u003esecond\u003c/li\u003e * \u003cli\u003eminute\u003c/li\u003e * \u003cli\u003ehour\u003c/li\u003e * \u003cli\u003eday of month\u003c/li\u003e * \u003cli\u003emonth\u003c/li\u003e * \u003cli\u003eday of week\u003c/li\u003e * \u003c/ul\u003e */ @Scheduled(cron = \"0 * * * * MON-SAT\") public void hello(){ System.out.println(\"hello\"); } } ","date":"2020-06-04","objectID":"/springboot-%E4%BB%BB%E5%8A%A1/:2:0","tags":["任务","框架"],"title":"Springboot-任务","uri":"/springboot-%E4%BB%BB%E5%8A%A1/"},{"categories":["Spring"],"content":"三.邮件任务 application.properties spring.mail.username=1157237955@qq.com # 开启服务 申请密码 不是qq密码 spring.mail.password=xxxxxxxxxxxxxxxxx spring.mail.host=smtp.qq.com 简单邮箱 @Autowired JavaMailSenderImpl mailSender; @Test void contextLoads() { SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); //邮件设置 //标题 simpleMailMessage.setSubject(\"通知：今晚开会\"); //内容 simpleMailMessage.setText(\"今晚7：30开会\"); simpleMailMessage.setTo(\"1157237955@qq.com\"); simpleMailMessage.setFrom(\"1157237955@qq.com\"); mailSender.send(simpleMailMessage); } 复杂邮箱 @Autowired JavaMailSenderImpl mailSender; @Test void contextLoads2() throws MessagingException { //创建一个复杂的消息邮件 MimeMessage mimeMailMessage =mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMailMessage,true); //邮件设置 helper.setSubject(\"通知：今晚开会\"); //可以使用html语法 helper.setText(\"\u003cb\u003e今晚7：30开会\u003c/b\u003e\",true); helper.setTo(\"1157237955@qq.com\"); helper.setFrom(\"1157237955@qq.com\"); //上传文件 helper.addAttachment(\"1.png\",new File(\"E:\\\\照片\\\\20.04.13景\\\\IMG_0490-31.png\")); mailSender.send(mimeMailMessage); } ","date":"2020-06-04","objectID":"/springboot-%E4%BB%BB%E5%8A%A1/:3:0","tags":["任务","框架"],"title":"Springboot-任务","uri":"/springboot-%E4%BB%BB%E5%8A%A1/"},{"categories":["Spring"],"content":"Springboot-权限控制 mvn \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e 编写security配置类 package com.jsh.security.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @EnableWebSecurity public class MySecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { // super.configure(http); //定制请求授权的规则 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasAnyRole(\"VIP1\") .antMatchers(\"/level2/**\").hasAnyRole(\"VIP2\") .antMatchers(\"/level3/**\").hasAnyRole(\"VIP3\"); //开启自动配置的登录功能 /** \u003ch2 align=\"center\"\u003e游客您好，如果想查看武林秘籍 \u003ca th:href=\"@{/userlogin}\"\u003e请登录\u003c/a\u003e\u003c/h2\u003e */ http.formLogin() .usernameParameter(\"user\").passwordParameter(\"pwd\")//定制参数name .loginPage(\"/userlogin\");//定制登陆页面 /** 验证请求 \u003cform th:action=\"@{/userlogin}\" method=\"post\"\u003e 用户名:\u003cinput name=\"user\"/\u003e\u003cbr\u003e 密码:\u003cinput name=\"pwd\"\u003e\u003cbr/\u003e \u003cinput type=\"checkbox\" name=\"remeber\"\u003e记住我\u003cbr/\u003e \u003cinput type=\"submit\" value=\"登陆\"\u003e \u003c/form\u003e */ //1.成功：\"/login\" //2.失败：\"/login?error\" //开启自动配置的注销功能 http.logout().logoutSuccessUrl(\"/\");//注销成功后来到首页 //1.访问/logout表示用户注销 ，清空session //2.注销成功 返回/login?logout 页面 /** \u003cform th:action=\"@{/logout}\" method=\"post\"\u003e \u003cinput type=\"submit\" value=\"注销\"\u003e \u003c/form\u003e */ //开启记住我功能 http.rememberMe().rememberMeParameter(\"remeber\"); //登陆成功后，将cookie发送给浏览器保存， 注销后会删除 } //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // super.configure(auth); auth.inMemoryAuthentication() .passwordEncoder(new BCryptPasswordEncoder()).withUser(\"张三\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"VIP1\",\"VIP2\") .and() .passwordEncoder(new BCryptPasswordEncoder()).withUser(\"李四\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"VIP3\",\"VIP2\"); } } ","date":"2020-06-04","objectID":"/springboot-%E8%AE%A4%E8%AF%81/:0:0","tags":["框架"],"title":"Springboot-认证","uri":"/springboot-%E8%AE%A4%E8%AF%81/"},{"categories":["Spring"],"content":"Springboot-消息 ","date":"2020-06-03","objectID":"/springboot-%E6%B6%88%E6%81%AF/:0:0","tags":["框架","消息"],"title":"Springboot-消息","uri":"/springboot-%E6%B6%88%E6%81%AF/"},{"categories":["Spring"],"content":"一.安装rabbitmq //拉取镜像 docker pull rabbitmq:[版本] //运行 docker run -d -p 5672:5672 -p 15672:15672 –name myrabbitmq [镜像id] 本机访问 如果进不去 docker exec -it myrabbitmq /bin/bash rabbitmq-plugins enable rabbitmq_management ","date":"2020-06-03","objectID":"/springboot-%E6%B6%88%E6%81%AF/:1:0","tags":["框架","消息"],"title":"Springboot-消息","uri":"/springboot-%E6%B6%88%E6%81%AF/"},{"categories":["Spring"],"content":"二.客户端测试 本机进入192.168.0.103:15672 账号密码guest 创建三个类型的交换器 类型： direct 完全匹配 fanout 广播模式 会把消息放在每一个消息队列上 topic 匹配模式 ‘#’匹配一个或者多个单词 ‘*’ 匹配一个单词 创建四个消息队列 将消息队列绑定在交换器上 Routing Key :是路由件 根据这个接收消息 topic的路由件名字 需要使用‘*’‘#’进行匹配 ​ 例如：#.emps 发送消息进行测试 通过哪个消息交换器进行发送 就遵守哪个的规则发送的消息队列中 ","date":"2020-06-03","objectID":"/springboot-%E6%B6%88%E6%81%AF/:2:0","tags":["框架","消息"],"title":"Springboot-消息","uri":"/springboot-%E6%B6%88%E6%81%AF/"},{"categories":["Spring"],"content":"三.springboot整合 ","date":"2020-06-03","objectID":"/springboot-%E6%B6%88%E6%81%AF/:3:0","tags":["框架","消息"],"title":"Springboot-消息","uri":"/springboot-%E6%B6%88%E6%81%AF/"},{"categories":["Spring"],"content":"1.简单测试 自动配置 1、RabbitAutoConfiguration 2、有自动配置了连接工厂ConnectionFactory； 3、RabbitProperties 封装了 RabbitMQ的配置 4、 RabbitTemplate ：给RabbitMQ发送和接受消息； 5、 AmqpAdmin ： RabbitMQ系统管理功能组件; AmqpAdmin：创建和删除 Queue，Exchange，Binding 6、@EnableRabbit + @RabbitListener 监听消息队列的内容 mvn \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-amqp\u003c/artifactId\u003e \u003c/dependency\u003e 使用 package com.jsh.amqp; import com.jsh.amqp.bean.Book; import org.junit.jupiter.api.Test; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.Arrays; import java.util.HashMap; import java.util.Map; @SpringBootTest class SpringbootAmqpApplicationTests { @Autowired RabbitTemplate rabbitTemplate; /** * 1.单播 ：点对点 */ @Test void contextLoads() { //只需要传入要发送的对象，自动序列化发送给rabbitmq //rabbitTemplate.convertAndSend(exchage,routeKey,object); Map\u003cString,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"msg\",\"第一个消息\"); map.put(\"data\", Arrays.asList(\"helloworld\",123,true)); //对象被默认序列化后发送出去 //rabbitTemplate.convertAndSend(\"exchange.direct\",\"jsh.news\",map); rabbitTemplate.convertAndSend(\"exchange.direct\",\"jsh.news\",new Book(\"西游记\",\"吴承恩\")); } //接收数据，如何将数据转为JOSN发送出去 @Test public void receive(){ Object o = rabbitTemplate.receiveAndConvert(\"jsh.news\"); System.out.println(o.getClass()); System.out.println(o); } /** * 广播 */ @Test public void sendMsg(){ rabbitTemplate.convertAndSend(\"exchange.fanout\",\"\",new Book(\"西游记\",\"吴承恩\")); } } 配置序列化变为JOSN格式 package com.jsh.amqp.config; import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter; import org.springframework.amqp.support.converter.MessageConverter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MyAMQPConfig { @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } } ","date":"2020-06-03","objectID":"/springboot-%E6%B6%88%E6%81%AF/:3:1","tags":["框架","消息"],"title":"Springboot-消息","uri":"/springboot-%E6%B6%88%E6%81%AF/"},{"categories":["Spring"],"content":"2.监听使用 主程序开启@EnableRabbit注解 package com.jsh.amqp; import org.springframework.amqp.rabbit.annotation.EnableRabbit; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @EnableRabbit //开启基于注解的RabbitMQ模式 @SpringBootApplication public class SpringbootAmqpApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAmqpApplication.class, args); } } 方法上加入@RabbitListener注解 自动监听消息 两种方法接收参数 一种只接受消息 Object o 第二种可以接收消息的其他信息 Message message package com.jsh.amqp.service; import com.jsh.amqp.bean.Book; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class BookService { @RabbitListener(queues = \"jsh.news\") public void receive(Book book){ System.out.println(\"收到:\"+book); } @RabbitListener(queues = \"jsh\") public void receive2(Message message){ System.out.println(message.getBody()); System.out.println(message.getMessageProperties()); } } ","date":"2020-06-03","objectID":"/springboot-%E6%B6%88%E6%81%AF/:3:2","tags":["框架","消息"],"title":"Springboot-消息","uri":"/springboot-%E6%B6%88%E6%81%AF/"},{"categories":["Spring"],"content":"3.AmqpAdmin在程序中管理RabbitMQ @SpringBootTest class SpringbootAmqpApplicationTests { @Autowired AmqpAdmin amqpAdmin; @Test public void createExchange(){ //创建交换器 //amqpAdmin.declareExchange(new DirectExchange(\"amqpadmin.exchange\")); //System.out.println(\"创建完成\"); //创建消息队列 //amqpAdmin.declareQueue(new Queue(\"amqpadmin.queue\",true)); //创建绑定规则 amqpAdmin.declareBinding(new Binding(\"amqpadmin.queue\", Binding.DestinationType.QUEUE,\"amqpadmin.exchange\",\"amqp.haha\",null)); } } ","date":"2020-06-03","objectID":"/springboot-%E6%B6%88%E6%81%AF/:3:3","tags":["框架","消息"],"title":"Springboot-消息","uri":"/springboot-%E6%B6%88%E6%81%AF/"},{"categories":["数据库"],"content":"Redis ","date":"2020-06-01","objectID":"/redis/:0:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"一.基本指令 key * //查询当前数据库所有的键 exists \u003ckey\u003e //判断某个键是否存在 1：true 2：false type \u003ckey\u003e //查看键的类型 del \u003ckey\u003e //删除键 expire \u003ckey\u003e \u003cseconds\u003e //为键设置过启德的时间 单位为秒 ttl \u003ckey\u003e //查看还有多长时间过期 “-1”代表永不过期 “-2”代表已过期 dbsize //查看当前库的key的数量 Flushdb //清空当前库 Flushall //通杀全部库 ","date":"2020-06-01","objectID":"/redis/:1:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"二.Redis的五大数据类型 ","date":"2020-06-01","objectID":"/redis/:2:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"1.String(使用最多) get \u003ckey\u003e //查询对应的键值 set \u003ckey\u003e \u003cvalue\u003e //添加键值对 append \u003ckey\u003e \u003cvalue\u003e //给给定的key追加值 strlen \u003ckey\u003e //获取值的长度 setnx \u003ckey\u003e \u003cvalue\u003e //只有在key不存在时设置key的值 incr \u003ckey\u003e //将key存储的数字值+1 只能对数字操作 decr \u003ckey\u003e //将key存储的数字值-1 只能对数字操作 incrby \u003ckey\u003e \u003c步长\u003e //将key存储的数字值+步长 只能对数字操作 decrby \u003ckey\u003e \u003c步长\u003e //将key存储的数字值-步长 只能对数字操作 mset \u003ckey1\u003e \u003cvalue1\u003e \u003ckey2\u003e \u003cvalue2\u003e ... //同时设置多个键值对 mget \u003ckey1\u003e \u003ckey2\u003e \u003ckey3\u003e ... //同时获取多尔衮value msetnx \u003ckey1\u003e \u003cvalue1\u003e \u003ckey2\u003e \u003cvalue2\u003e ... //同时设置多个键值对;当且仅当所有给定的key都不存在时 getrange \u003ckey\u003e \u003c起始位置\u003e \u003c结束位置\u003e //截取一段值；起始位置从0开始；包前也包后 setrange \u003ckey\u003e \u003c起始位置\u003e \u003cvalue\u003e //从起始位置开始赋值覆盖 setex \u003ckey\u003e \u003c过期时间\u003e \u003cvalue\u003e //设置键值的同时，设置过期时间 getset \u003ckey\u003e \u003cvalue\u003e //以旧换新 设置了新值的同时获得旧值 ","date":"2020-06-01","objectID":"/redis/:2:1","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"2.List 单键多值 底层是双向链表 对两端的操作性高，通过索引操作中间节点性能较差 lpush/rpush \u003ckey\u003e \u003cvalue1\u003e \u003cvalue2\u003e... //从左边/右边加入一个或多个值 lpop/rpop \u003ckey\u003e //从左边/右边取出一个值 rpoplpush \u003ckey1\u003e \u003ckey2\u003e //从key1的右边取出一个放在key2的左边 lrange \u003ckey\u003e \u003cstart\u003e \u003cstop\u003e //按照索引下标获得元素（从左到右）负值从右到左 lindex \u003ckey\u003e \u003cindex\u003e //按照索引下标获得元素（从左到右） llen \u003ckey\u003e //获得列表长r度 linsert \u003ckey\u003e after/before \u003cvalue\u003e \u003cnewvalue\u003e //在value 后/前插入 newvalue 的值 如果有相同的值 只对第一个起作用 lrem \u003ckey\u003e \u003cn\u003e \u003cvalue\u003e //删除n个value 正数从左往右删 负数从右往左 0代表删除所有 ","date":"2020-06-01","objectID":"/redis/:2:2","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"3.Set 与list功能类似 但是value不能重复 String类型的无序集合 底层是value为空的hash表 删除查找的复杂度都是O(1) sadd \u003ckey\u003e \u003cvalue1\u003e \u003cvalue2\u003e... //加入一个或多个值 smembers \u003ckey\u003e //取出该集合的所有值 sismember \u003ckey\u003e \u003cvalue\u003e //判断集合\u003ckey\u003e是否为含有该\u003cvalue\u003e值，有返回1，没有返回0 scard \u003ckey\u003e //返回该集合的元素个数 srem \u003ckey\u003e \u003cvalue1\u003e \u003cvalue2\u003e //删除集合中的某个元素 spop \u003ckey\u003e //随机从元素中吐出一个值 srandmember \u003ckey\u003e \u003cn\u003e //随机从元素中吐出N个值,不会删除 sinter \u003ckey1\u003e \u003ckey2\u003e //返回两个集合的交集 sunion \u003ckey1\u003e \u003ckey2\u003e //返回两个集合的并集 sdiff \u003ckey1\u003e \u003ckey2\u003e //返回两个集合的差集 ","date":"2020-06-01","objectID":"/redis/:2:3","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"4.Hash 是键值对集合 适合存储对象 类似java中的 Map\u003cString,String\u003e hset \u003ckey\u003e \u003cfield\u003e \u003cvalue\u003e //为指定的key设定field和value hget \u003ckey\u003e \u003cfield\u003e //取出指定的value hmset \u003ckey\u003e \u003cfield\u003e \u003cvalue\u003e \u003cfield\u003e \u003cvalue\u003e... //为指定的key设定一个或多个field和value hexists \u003ckey\u003e \u003cfield\u003e //在key里面是否存在指定的field hkeys \u003ckey\u003e //获取hash表所有key hvals \u003ckey\u003e //获取hash表所有值 hgetall \u003ckey\u003e //获取hash表所有的键值对 hincrby \u003ckey\u003e \u003cfield\u003e \u003cincrement\u003e //增加某个field的值,只能是数字 hsetnx \u003ckey\u003e \u003cfield\u003e \u003cvalue\u003e //当不存在才创建该field hlen \u003ckey\u003e //获取hash表中的字段数量 hdel \u003ckey\u003e \u003cfield1\u003e \u003cfield2\u003e //删除一个或多个hash表的字段 ","date":"2020-06-01","objectID":"/redis/:2:4","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"5.ZSet 在Set的基础上加上评分 zadd \u003ckey\u003e \u003cscore1\u003e \u003cvalue1\u003e //将一个或多个元素及其评分加入;相同元素，不同分数，会将分数更新 zrange \u003ckey\u003e \u003cstart\u003e \u003cstop\u003e [WITHSCORES] // 指定输出索引范围内的成员;[WITHSCORES]可以携带分数 zrevrange \u003ckey\u003e \u003cstart\u003e \u003cstop\u003e //返回有序集中指定区间内的成员，通过索引，分数从高到底 zrangebyscore \u003ckey\u003e \u003cmin\u003e \u003cmax\u003e //指定输出score区间内的成员 zincrby \u003ckey\u003e \u003cincrement\u003e \u003cvalue\u003e //为value元素的分数加上增量 zrem \u003ckey\u003e \u003cvalue\u003e //移除有序集合中的一个或多个成员 zcard \u003ckey\u003e //获取集合中的元素数量 zcount \u003ckey\u003e \u003cmin\u003e \u003cmax\u003e //计算在有序集合中指定区间分数的成员数 zrank \u003ckey\u003e \u003cvalue\u003e 返回有序集合指定成员的排名 使用zset实现文章访问量的排行 redis2:0\u003ezadd test 100000 java 80000 python 50000 php 120000 c++ 20000 js \"5\" redis2:0\u003ezrevrange test 0 -1 1) \"c++\" 2) \"java\" 3) \"python\" 4) \"php\" 5) \"js\" redis2:0\u003ezrevrangebyscore test 120000 10redis2:0\u003e0000 1) \"c++\" 2) \"java\" ","date":"2020-06-01","objectID":"/redis/:2:5","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"三.Redis的相关配置 ip地址绑定 默认 “bind 127.0.0.1”只接受本机访问 使其他机器访问解决方法 注释“bind 127.0.0.1” 取消绑定id “protected-mode yes” yes改为no 关闭保护模式 tcp-backlog 默认“tcp-backlog 511” 可以理解为请求到达后至进程处理前的队列 timeout 一个空闲的客户端维持多长时间(秒)会关闭，0代表永不关闭，默认0 tcp-keepalive 对客户端的心跳检测 官方推荐60s daemonize 是否为后台进程 pidfile 存放pid文件的位置 loglevel 默认 loglevel notice 日志级别 四个等级 database 设定库的数量 默认16 maxclient 最大客户端链接数 maxmemory 设置内存量 超过后 会根据maxmemory-policy指定移除 maxmemory-policy volatile-lru 使用LRU（最近最少使用）算法移除key，只对设置了过期时间的键 allkeys-lru 使用LRU算法移除key volatile-random 在过期集合中移除key，只对设置了过期时间的键 allkeys-random 随机移除 volatile-ttl(即将过期) 移除ttl最小的key noeviction 不移除(头铁 等着报错) maxmemory-samples 设置样本大小 3-7 一般3或5 ","date":"2020-06-01","objectID":"/redis/:3:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"四.连接java(SSM) jar： jedis-xxx.jar package com.jsh; import redis.clients.jedis.Jedis; public class Test { public static void main(String[] args) { Jedis jedis = new Jedis(\"127.0.0.1\",6379); String result = jedis.ping(); System.out.println(result); // jedis.set(\"a\",\"a\"); jedis.get(\"a\"); System.out.println(\"a\"); jedis.close(); } } ","date":"2020-06-01","objectID":"/redis/:4:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"手机短信验证例子 前端 \u003cform class=\"navbar-form navbar-left\" role=\"search\" id=\"codeform\"\u003e \u003cdiv class=\"form-group\"\u003e \u003cinput type=\"text\" class=\"form-control\" placeholder=\"填写手机号\" name=\"phone_no\"\u003e \u003cbutton type=\"button\" class=\"btn btn-default\" id=\"sendCode\"\u003e发送验证码\u003c/button\u003e\u003cbr\u003e \u003cfont id=\"countdown\" color=\"red\" \u003e\u003c/font\u003e \u003cbr\u003e \u003cinput type=\"text\" class=\"form-control\" placeholder=\"填写验证码\" name=\"verify_code\"\u003e \u003cbutton type=\"button\" class=\"btn btn-default\" id=\"verifyCode\"\u003e确定\u003c/button\u003e \u003cfont id=\"result\" color=\"green\" \u003e\u003c/font\u003e\u003cfont id=\"error\" color=\"red\" \u003e\u003c/font\u003e \u003c/div\u003e \u003c/form\u003e \u003cscript type=\"text/javascript\"\u003e var t=120;//设定倒计时的时间 var interval; function refer(){ $(\"#countdown\").text(\"请于\"+t+\"秒内填写验证码 \"); // 显示倒计时 t--; // 计数器递减 if(t\u003c=0){ clearInterval(interval); $(\"#countdown\").text(\"验证码已失效，请重新发送！ \"); } } $(function(){ $(\"#sendCode\").click( function () { $.post(\"/Verify_code/CodeSenderServlet\",$(\"#codeform\").serialize(),function(data){ if(data==\"true\"){ t=120; clearInterval(interval); interval= setInterval(\"refer()\",1000);//启动1秒定时 }else if (data==\"limit\"){ clearInterval(interval); $(\"#countdown\").text(\"单日发送超过次数！ \") } }); }); $(\"#verifyCode\").click( function () { $.post(\"/Verify_code/CodeVerifyServlet\",$(\"#codeform\").serialize(),function(data){ if(data==\"true\"){ $(\"#result\").attr(\"color\",\"green\"); $(\"#result\").text(\"验证成功\"); clearInterval(interval); $(\"#countdown\").text(\"\"); }else{ $(\"#result\").attr(\"color\",\"red\"); $(\"#result\").text(\"验证失败\"); } }); }); }); \u003c/script\u003e controller 模拟接收短信验证码并缓存 @WebServlet(\"/CodeSenderServlet\") public class CodeSenderServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CodeSenderServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取手机号 String phone_no = request.getParameter(\"phone_no\"); //模拟获取验证码 String code = getCode(6); //拼接key String codeKey = \"Verify_code:\" + phone_no + \":code\";//Verify_code:12345:code String countKey = \"Verify_code:\" + phone_no + \":count\"; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); //判断发送验证码的次数 String count = jedis.get(countKey); if(count == null) { //代表第一次 jedis.setex(countKey, 24*60*60, \"1\"); }else if(Integer.parseInt(count) \u003c= 2) { jedis.incr(countKey); }else if(Integer.parseInt(count) \u003e 2) { response.getWriter().print(\"limit\"); jedis.close(); return ; } //向redis中进行存储，以手机号为键，以验证码为值 jedis.setex(codeKey, 120, code); jedis.close(); response.getWriter().print(true); } //模拟短信 private String getCode(int length) { String code = \"\"; Random random = new Random(); for(int i = 0; i \u003c length; i++) { int rand = random.nextInt(10); code += rand; } return code; } } 从缓存中取出返回到前端 package com.atguigu.servlet; @WebServlet(\"/CodeVerifyServlet\") public class CodeVerifyServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CodeVerifyServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取验证码和手机号 String phone_no = request.getParameter(\"phone_no\"); String verify_code = request.getParameter(\"verify_code\"); //拼接key String codeKey = \"Verify_code:\" + phone_no + \":code\"; //从redis中获取手机号所对应的验证码 Jedis jedis = new Jedis(\"127.0.0.1\", 6379); String code = jedis.get(codeKey); if(code.equals(verify_code)) { response.getWriter().print(true); } jedis.close(); } } ","date":"2020-06-01","objectID":"/redis/:4:1","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"五.Redis事务 编译出错会直接取消 例如：单词拼写错误 某一步如果在运行时出错 只会取消那一步的操作 multi //开启事务 exec //提交事务 discard //取消事务 演示 redis2:0\u003emulti \"OK\" redis2:0\u003eset a a \"QUEUED\" redis2:0\u003eset b c \"QUEUED\" redis2:0\u003eexec 1) \"OK\" 2) \"OK\" 监视 watch \u003ckey\u003e //监视key 如果发现被改变 事务取消 unwatch // 取消对所有key的监视 如果exec或discard执行了 就不需要再执行unwatch 三特性 单独的隔离操作：事务中的所有命令都会序列化，按顺序的执行。事务在等待执行的时候，不会被其他客户端发送来的米命令请求打断 没有隔离级别的概念：队列中的所有命令没有提交exec之前都是不会被执行的 不保证原子性：redis中如果一条命令执行失败，其后的命令仍然会被执行，没有回滚 ","date":"2020-06-01","objectID":"/redis/:5:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"六.持久化 ","date":"2020-06-01","objectID":"/redis/:6:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"RDB 在指定的时间间隔内生成内存中整个数据集的持久化快照。快照文件默认被存储在当前文件夹中，名称为dump.rdb，可以通过dir和dbfilename参数来修改默认值。 恢复数据特别快，节省空间，存储的是数据 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何的IO操作的，这就确保了极高的性能。 缺点：最后一次持久化后数据可能丢失 配置文件 # redis是基于内存的数据库，可以通过设置该值定期写入磁盘。 # 注释掉“save”这一行配置项就可以让保存数据库功能失效 # 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） # 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） # 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化） save 900 1 save 300 10 save 60 10000 #当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误 stop-writes-on-bgsave-error yes #使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间 推荐压缩 rdbcompression yes #是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。 rdbchecksum yes #rdb文件的名称 dbfilename dump.rdb #数据目录，数据库的写入会在这个目录。 dir ./ 默认在当前文件夹下 触发条件 通过配制文件中的save条件（可自己配置） save 900 1 save 300 10 save 60 10000 手动通过save和bgsave命令 save：save时只管保存，其他不管，全部阻塞 bgsave：redis会在后台异步的进行快照操作，同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的事件 如何恢复 关闭Redis 把备份的文件拷贝到工作目录下 启动Redis,会自动加载 ","date":"2020-06-01","objectID":"/redis/:6:1","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"AOF 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作补不可记录），只许追加文件但不可以改写文件，redis启动之初会读取改文件重新构建数据。保存的是appendonly.aof文件 aof机制默认关闭，可以通过appendonly = yes参数开启aof机制，通过appendfilename = myaoffile.aof指定aof文件名称。 #aof持久化策略的配置 #no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 #always表示每次写入都执行fsync，以保证数据同步到磁盘。 #everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。 appendfsync everysec 对于触发aof重写机制也可以通过配置文件来进行设置： # aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。 auto-aof-rewrite-percentage 100 # 设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写 auto-aof-rewrite-min-size 64mb # 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题。如果对延迟要求很高的应用，这个字段可以设置为yes，，设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,不会造成阻塞的问题（因为没有磁盘竞争），等rewrite完成后再写入，这个时候redis会丢失数据。Linux的默认fsync策略是30秒。可能丢失30秒数据。因此，如果应用系统无法忍受延迟，而可以容忍少量的数据丢失，则设置为yes。如果应用系统无法忍受数据丢失，则设置为no。 no-appendfsync-on-rewrite no 如何恢复 正常恢复 ​ 将文件放到dir指定的文件夹下，当redis启动的时候会自动加载数据，注意：aof文件的优先级比dump大。 异常恢复 有些操作可以直接到appendonly.aof文件里去修改。 eg：使用了flushall这个命令，此刻持久化文件中就会有这么一条命令记录，把它删掉就可以了 写坏的文件可以通过 redis-check-aof --fix进行修复 优势 根据不同的策略，可以实现每秒，每一次修改操作的同步持久化，就算在最恶劣的情况下只会丢失不会超过两秒数据。 当文件太大时，会触发重写机制，确保文件不会太大。 文件可以简单的读懂 劣势 aof文件的大小太大，就算有重写机制，但重写所造成的阻塞问题是不可避免的 aof文件恢复速度慢。 ","date":"2020-06-01","objectID":"/redis/:6:2","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"总结 如果你只希望你的数据在服务器运行的时候存在，可以不使用任何的持久化方式 一般建议同时开启两种持久化方式。AOF进行数据的持久化，确保数据不会丢失太多，而RDB更适合用于备份数据库，留着一个做万一的手段。 性能建议： 因为RDB文件只用做后备用途，建议只在slave上持久化RDB文件，而且只要在15分钟备份一次就够了，只保留900 1这条规则。 如果Enalbe AOF,好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价：1、带来了持续的IO；2、AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。 如果不Enable AOF,仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时宕掉，会丢失10几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。 ","date":"2020-06-01","objectID":"/redis/:6:3","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"七.复制(master/slaver) 就是我们常说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主 读写分离 容灾恢复 主服务器用来写 从服务器用来读 不管何时 从机都和主机数据相同 主机shutdown后，从机等待 ","date":"2020-06-01","objectID":"/redis/:7:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"配置(配置从服务器，不配置主服务器) 拷贝多个redis文件include 开启daemonize yes Pid文件名字pidfile 指定端口port Log文件名字 Dump.rdb名字dbfilename Appendonly关掉或者换名字 如果要永久 在配置文件中 配置 slaveof 命令 info replication //打印主从相关信息 slaveof \u003cip\u003e \u003cport\u003e //成为某个实例的从服务器 slaveof no one //将从机变为主机 ","date":"2020-06-01","objectID":"/redis/:7:1","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"薪火相传 含义:就是上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。 ","date":"2020-06-01","objectID":"/redis/:7:2","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"哨兵模式 反客为主的自动版，能够后台监控Master库是否故障，如果故障了根据投票数自动将slave库转换为主库。一组sentinel能同时监控多个Master。 使用步骤： 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错； 配置哨兵，在sentinel.conf文件中填入内容(可以配置多个)： #说明：最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机。 sentinel monitor 被监控数据库名字（自己起名字） ip port 1 启动哨兵模式(路径按照自己的需求进行配置)： redis-sentinel /myredis/sentinel.conf 注意： 当master挂掉后，会通过选票进行选出下一个master。而且只有使用了sentinel.conf启动的才能开启选票 当原来的master后来后，很不幸变成了slave。 ","date":"2020-06-01","objectID":"/redis/:7:3","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"八.Redis集群（以后再学） 实现了水平扩容，启动N个节点，将整个数据库储存分布在N个节点中，每个节点存储数据的1/N ","date":"2020-06-01","objectID":"/redis/:8:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["Spring"],"content":"Springboot-缓存 ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:0:0","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"一.搭建基本环境 ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:1:0","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"1.导入数据库文件 创建出 Department Employee 表 SET FOREIGN_KEY_CHECKS=0; -- ---------------------------- -- Table structure for department -- ---------------------------- DROP TABLE IF EXISTS `department`; CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Table structure for employee -- ---------------------------- DROP TABLE IF EXISTS `employee`; CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `lastName` varchar(255) DEFAULT NULL, `email` varchar(255) DEFAULT NULL, `gender` int(2) DEFAULT NULL, `d_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:1:1","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"2.封装数据 创建实体类 Department package com.jsh.cache.bean; public class Department { private Integer id; private String departmentName; public Department() { super(); // TODO Auto-generated constructor stub } public Department(Integer id, String departmentName) { super(); this.id = id; this.departmentName = departmentName; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getDepartmentName() { return departmentName; } public void setDepartmentName(String departmentName) { this.departmentName = departmentName; } @Override public String toString() { return \"Department [id=\" + id + \", departmentName=\" + departmentName + \"]\"; } } Employee package com.jsh.cache.bean; public class Employee { private Integer id; private String lastName; private String email; private Integer gender; //性别 1男 0女 private Integer dId; public Employee() { super(); } public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) { super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.dId = dId; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public Integer getdId() { return dId; } public void setdId(Integer dId) { this.dId = dId; } @Override public String toString() { return \"Employee [id=\" + id + \", lastName=\" + lastName + \", email=\" + email + \", gender=\" + gender + \", dId=\" + dId + \"]\"; } } ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:1:2","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"3.整合Mybatis (1)配置数据源 spring.datasource.url=jdbc:mysql://localhost/spring_cache spring.datasource.password=123456 spring.datasource.username=root spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver (2)使用注解版mybatis public interface EmployeeMapper { @Select(\"SELECT * FROM employee WHERE id = #{id}\") public Employee getEmpById(Integer id); @Update(\"UPDATE employee SET lastName=#{lastName},email=#{email},gender=#{gender},d_id=#{dId} WHERE id=#{id}\") public void updateEmp(Employee employee); @Delete(\"DELETE FROM employee WHERE id=#{id}\") public void deleteEmpById(Integer id); @Insert(\"INSERT INTO employee(lastName,email,gender,d_id) VALUES(#{lastName},#{email},#{gender},#{dId})\") public void insertEmployee(Employee employee); @Select(\"SELECT * FROM employee WHERE lastName = #{lastName}\") Employee getEmpByLastName(String lastName); } (3)开启驼峰命名法 #开启驼峰命名 mybatis.configuration.map-underscore-to-camel-case=true ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:1:3","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"二.快速体验缓存 ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:2:0","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"1.开启基于缓存的注解 主程序标注@EnableCaching @MapperScan(\"com.jsh.cache.mapper\") @SpringBootApplication @EnableCaching public class SpringBootCacheApplication { public static void main(String[] args) { SpringApplication.run(SpringBootCacheApplication.class, args); } } ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:2:1","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"2.Service层方法标注缓存注解 (1)@Cacheable @Cacheable 对方法结果进行缓存 方法调用之前运行 @Cacheable 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法 CacheManager管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一的名字 几个属性 1.cacheNames/value:指定缓存组件的名字 2.key:缓存数据使用的key；可以用它来指定。默认使用方法参数的值 --- 方法的返回值 编写SqEL: #id:参数id的值 #a0 #p0 #root.args[0] 3.keyGenerator:key的生成器；可以自己指定key的生成器的组件id key/keyGenerator二选一使用 4.cacheManager:缓存管理器 或者使用cacheResolver指定缓存管理器 5.condition：指定符合条件的情况下才缓存 condition = \"#id\u003e0\" 6.unless:否定缓存；当unless指定条件为true，方法的返回值就不会被缓存；可以获取结果进行缓存 unless = \"#result == null\" 7.sync:是否使用异步模式 package com.jsh.cache.service; @Service public class EmployeeService { @Autowired EmployeeMapper employeeMapper; @Cacheable(cacheNames = {\"emp\"}) public Employee getEmpById(Integer id){ System.out.println(\"查询\"+id+\"号员工\"); return employeeMapper.getEmpById(id); } } keyGenerator的使用 创建生成器 package com.jsh.cache.config; @Configuration public class MyCacheConfig { @Bean(\"myKeyGenerator\") public KeyGenerator keyGenerator(){ return new KeyGenerator(){ @Override public Object generate(Object target, Method method, Object... params) { return method.getNjavaame()+\"[\"+ Arrays.asList(params).toString()+\"]\"; } }; } } 使用 @Cacheable(cacheNames = {\"emp\"},keyGenerator = \"myKeyGenerator\") public Employee getEmpById(Integer id){ System.out.println(\"查询\"+id+\"号员工\"); return employeeMapper.getEmpById(id); } (2)@CachePut @CachePut:即调用方法，又更新缓存数据 使用场景：修改数据库的某个数据，同时更新缓存 方法调用之后运行 1.先调用目标方法 2.将目标方法的结果缓存起来 测试步骤： 1、查询1号员工；查到的结果会放在缓存中； key：1 value：lastName：张三 2、以后查询还是之前的结果 3、更新1号员工；【lastName:zhangsan；gender:0】 将方法的返回值也放进缓存了； key：传入的employee对象 值：返回的employee对象； 4、查询1号员工？ 为什么是没更新前的？【1号员工没有在缓存中更新】 应该是更新后的员工； 解决 key = \"#employee.id\":使用传入的参数的员工id； key = \"#result.id\"：使用返回后的id @Cacheable的key是不能用#result @CachePut(cacheNames = \"emp\",key = \"#a0.id\") public Employee upadteEmp(Employee employee){ System.out.println(\"员工更新了\"); employeeMapper.updateEmp(employee); return employee; } (3)@CacheEvict @CacheEvict:清除缓存 allEntries = true 删除所有emp中的缓存 默认false beforeInvocation = true 缓存的清除是否在方法之前执行 默认false false时 如果方法出现异常则不会清除异常 @CacheEvict(cacheNames = \"emp\",key = \"#id\"/*,allEntries = true*/,beforeInvocation = true) public void deleteEmp(Integer id){ System.out.println(\"员工删除了\"); } (4)@Caching 组合@CacheEvict @CachePut @Cacheable @Caching( cacheable = { @Cacheable(cacheNames = \"emp\",key = \"#a0\") }, put = { @CachePut(cacheNames = \"emp\",key = \"#result.id\"), @CachePut(cacheNames = \"emp\",key = \"#result.email\") } ) public Employee getEmpByLastName(String lastName){ System.out.println(2); return employeeMapper.getEmpByLastName(lastName); } (5)@CacheConfig 在类上使用 用于整体设置 @Service @CacheConfig(cacheNames = \"emp\") public class EmployeeService {...... ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:2:2","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"三.Springboot-Redis ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:3:0","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"1.配置 pom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e application.properties spring.redis.host=127.0.0.1 ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:3:1","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"2.测试 实体类 需要序列化 将数据以JSON存储 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.opsForXXX来操纵五种数据 @Autowired StringRedisTemplate stringRedisTemplate; //操作字符串 @Autowired RedisTemplate redisTemplate; //K-V @Test public void testRedis(){ // stringRedisTemplate.opsForValue().set(\"a\",\"a\"); // 测试存储对象 Employee employee = employeeMapper.getEmpById(1); // 将数据以JSON存储 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.opsForValue().set(\"emp-01\",employee); Employee e = (Employee) redisTemplate.opsForValue().get(\"emp-01\"); System.out.println(e); } ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:3:2","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Spring"],"content":"3.使用 当配置好redis时 默认使用Redis ","date":"2020-06-01","objectID":"/springboot-%E7%BC%93%E5%AD%98/:3:3","tags":["框架"],"title":"Springboot-缓存","uri":"/springboot-%E7%BC%93%E5%AD%98/"},{"categories":["Java"],"content":"数据结构与算法—稀疏数组 ","date":"2020-05-29","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/:0:0","tags":["数据结构与算法"],"title":"数据结构与算法---稀疏数组","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"categories":["Java"],"content":"概念 作用：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 第一行 存储 原始二维数组有几行几列几个有效数值 第二行及以后存储有效数值以及位置 ","date":"2020-05-29","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/:1:0","tags":["数据结构与算法"],"title":"数据结构与算法---稀疏数组","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"categories":["Java"],"content":"代码实现 package com.jsh.DataStructures; import java.io.*; /* Mr.J 稀疏数组 2020/05/28 */ public class SparseArray { public static void main(String[] args) throws IOException { // 创建一个原始的二维数组 11*11 // 0:表示没有棋子，1表示黑子，2表示蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; // 输出原始二维数组 System.out.println(\"原始二维数组\"); for (int[] row:chessArr1){ for (int data:row){ System.out.print(data+\"\\t\"); } System.out.println(); } // 二维数组 =\u003e 稀疏数组 // 1.遍历二维数组 得到非零数据的个数 /* chessArr1.length 获取行数---11行 chessArr1[0].length 获取列数---11列 */ int sum = 0; for (int i = 0;i \u003c chessArr1.length;i++){ for (int j = 0;j \u003c chessArr1[0].length;j++) { if (chessArr1[i][j] != 0){ sum++; } } } System.out.println(\"sum=\"+sum); // 2.创建对应的稀疏数组 int sparseArr[][] = new int[sum+1][3]; // 给稀疏数组赋值 // 第一行 sparseArr[0][0] = chessArr1.length; sparseArr[0][1] = chessArr1[0].length; sparseArr[0][2] = sum; // 其他 // 遍历二维数组，将非零的值放在sparseArr中 int count = 0;//count 用于记录是第几个非零数据 for (int i = 0;i \u003c chessArr1.length;i++){ for (int j = 0;j \u003c chessArr1[0].length;j++) { if (chessArr1[i][j] != 0){ count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } } } // 将稀疏数组写入文件中 // File chess = new File(\"D://chess.data\"); // FileWriter out = new FileWriter(chess); // 输出稀疏数组 System.out.println(\"得到的稀疏数组为---\"); for (int[] row:sparseArr){ for (int data:row){ System.out.print(data+\"\\t\"); // out.write(data+\"\\t\"); } System.out.println(); // out.write(\"\\n\"); } // out.close(); // BufferedReader in = new BufferedReader(new FileReader(chess)); // String line;//一行数据 // int row=0; // //逐行读取，并将每个数组放入到数组中 // while ((line = in.readLine()) != null){ // String[] temp = line.split(\"\\t\"); // for(int j=0;j\u003ctemp.length;j++){ // sparseArr[row][j] = Integer.parseInt(temp[j]); // } // row++; // } // in.close(); // // System.out.println(\"得到的稀疏数组为---\"); // for (int[] raw:sparseArr){ // for (int data:raw){ // System.out.print(data+\"\\t\"); // } // System.out.println(); // } // 稀疏数组 =\u003e 二维数组 // 1.先读取稀疏数组的第一行，根据的一行的数据，创建原始的二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; // 2.读取第二行及以后的数据，赋给原始二维数组 for (int i = 1;i \u003c sparseArr.length;i++){ chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; } //输出恢复后的二维数组 System.out.println(\"恢复后的二维数组\"); for (int[] raw:chessArr2){ for (int data:raw){ System.out.print(data+\"\\t\"); } System.out.println(); } } } ","date":"2020-05-29","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/:2:0","tags":["数据结构与算法"],"title":"数据结构与算法---稀疏数组","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"categories":["Java"],"content":"数组模拟队列 ","date":"2020-05-29","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/:0:0","tags":["数据结构与算法"],"title":"数组模拟队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"categories":["Java"],"content":"原理 队列是一个有序列表，可以用数组或链表来实现 遵循先入先出的原则。即：先存入队列的数据要先去除。后存入的后取出。 ","date":"2020-05-29","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/:1:0","tags":["数据结构与算法"],"title":"数组模拟队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"categories":["Java"],"content":"实现简单队列 package com.jsh.DataStructures; import java.util.Scanner; /* Mr.J 数组队列 2020/05/29 问题：数组使用一次就不能使用，没有达到复用的效果 需要改为环形队列 */ public class ArrayQueueDemo { public static void main(String[] args) { ArrayQueue arrayQueue = new ArrayQueue(3); char key = ' ';//接收用户输入 Scanner scanner = new Scanner(System.in); boolean loop = true; while (loop) { System.out.println(\"s(show):显示队列\"); System.out.println(\"e(exit):退出队列\"); System.out.println(\"a(add):添加数据\"); System.out.println(\"g(get):从队列读取数据\"); System.out.println(\"h(head):查看队列头的数据\"); key = scanner.next().charAt(0); switch (key) { case 's': arrayQueue.showQueue(); break; case 'e': scanner.close(); loop=false; break; case 'a': System.out.println(\"请输入一个数\"); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case 'g': try { int res = arrayQueue.getQueue(); System.out.println(\"取出的数据为：\" + res); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'h': try { int res = arrayQueue.headQueue(); System.out.println(\"取出的数据为：\" + res); } catch (Exception e) { System.out.println(e.getMessage()); } break; } } System.out.println(\"程序退出\"); } } //使用数组模拟队列-编写一个ArrayQueue类 class ArrayQueue { private int maxSize;//表示数组的最大容器 private int front;//队列头 private int rear;//队列尾 private int[] arr;//该数组用于存放数据，模拟队列 // 创建队列的构造器 public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1;//队列头的前一个位置 rear = -1;//队列尾 } // 判断队列是不是满 public boolean ifFull() { return rear == maxSize - 1; } // 判断队列是否为空 public boolean isEmpty() { return front == rear; } // 添加数据到队列 public void addQueue(int n) { if (ifFull()) { System.out.println(\"队列满，不能加入数据\"); return; } rear++; //让rear后裔 arr[rear] = n; } // 数据出队列 public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"队列空，不能取数据\"); } front++; return arr[front]; } // 显示队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列空\"); return; } for (int a : arr) { System.out.println(a); } } // 显示队列的头数据 public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"队列空\"); } return arr[front + 1]; } } ","date":"2020-05-29","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/:2:0","tags":["数据结构与算法"],"title":"数组模拟队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"categories":["Java"],"content":"循环队列 package com.jsh.DataStructures; import java.util.Scanner; /* Mr.J 数组队列 2020/05/29 问题：数组使用一次就不能使用，没有达到复用的效果 需要改为环形队列 */ public class CircleArrayQueueDemo { public static void main(String[] args) { CircleArrayQueue arrayQueue = new CircleArrayQueue(3); char key = ' ';//接收用户输入 Scanner scanner = new Scanner(System.in); boolean loop = true; while (loop) { System.out.println(\"s(show):显示队列\"); System.out.println(\"e(exit):退出队列\"); System.out.println(\"a(add):添加数据\"); System.out.println(\"g(get):从队列读取数据\"); System.out.println(\"h(head):查看队列头的数据\"); key = scanner.next().charAt(0); switch (key) { case 's': arrayQueue.showQueue(); break; case 'e': scanner.close(); loop=false; break; case 'a': System.out.println(\"请输入一个数\"); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case 'g': try { int res = arrayQueue.getQueue(); System.out.println(\"取出的数据为：\" + res); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'h': try { int res = arrayQueue.headQueue(); System.out.println(\"取出的数据为：\" + res); } catch (Exception e) { System.out.println(e.getMessage()); } break; } } System.out.println(\"程序退出\"); } } //使用数组模拟队列-编写一个ArrayQueue类 class CircleArrayQueue { private int maxSize;//表示数组的最大容器 private int front;//队列头 front 的初始值 = 0 front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 private int rear;//队列尾 rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.rear 的初始值 = 0 private int[] arr;//该数组用于存放数据，模拟队列 // 创建队列的构造器 public CircleArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; // 初始化时为零 可以不写 // front = 0;//队列头 // rear = 0;//队列尾 } // 判断队列是不是满 public boolean ifFull() { return (rear + 1) % maxSize == front; } // 判断队列是否为空 public boolean isEmpty() { return front == rear; } // 添加数据到队列 public void addQueue(int n) { if (ifFull()) { System.out.println(\"队列满，不能加入数据\"); return; } // 直接将数据加入 arr[rear] = n; // rear后移 rear = (rear+1) % maxSize; } // 数据出队列 public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"队列空，不能取数据\"); } int value = arr[front]; front = (front+1) % maxSize; return value; } // 显示队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列空\"); return; } for (int i = front;i\u003cfront+size();i++) { System.out.println(arr[i%maxSize]); } } // 求出当前队列有效数据的个数 public int size(){ return (rear + maxSize -front) % maxSize; } // 显示队列的头数据 public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"队列空\"); } return arr[front]; } } ","date":"2020-05-29","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/:3:0","tags":["数据结构与算法"],"title":"数组模拟队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"},{"categories":["Spring"],"content":"Springboot自定义starter ","date":"2020-05-28","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/:0:0","tags":["框架","原理"],"title":"Springboot自定义starter","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"},{"categories":["Spring"],"content":"启动器模块 普通maven项目 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.jsh.starter\u003c/groupId\u003e \u003cartifactId\u003ejsh-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c!-- 启动器--\u003e \u003cdependencies\u003e \u003c!-- 引入自动配置模块--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.jsh.statrter\u003c/groupId\u003e \u003cartifactId\u003ejsh-spring-boot-starter-autoconfigurre\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e ","date":"2020-05-28","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/:1:0","tags":["框架","原理"],"title":"Springboot自定义starter","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"},{"categories":["Spring"],"content":"自动配置模块 pom.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.3.0.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e \u003cgroupId\u003ecom.jsh.statrter\u003c/groupId\u003e \u003cartifactId\u003ejsh-spring-boot-starter-autoconfigurre\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cname\u003ejsh-spring-boot-starter-autoconfigurre\u003c/name\u003e \u003cdescription\u003eDemo project for Spring Boot\u003c/description\u003e \u003cproperties\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e properties 用于配置 package com.jsh.statrter; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = \"jsh.hello\") public class HelloProperties { private String prefix; private String suffix; public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } } service package com.jsh.statrter; public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHelloJsh(String name){ return helloProperties.getPrefix()+\"-\"+name+\"-\"+helloProperties.getSuffix(); } } AutoConfiguration package com.jsh.statrter; @Configuration//声明是一个配置类 @ConditionalOnWebApplication//web应用才生效 @EnableConfigurationProperties(HelloProperties.class)//绑定配置类 public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; } } resources/META-INF/spring.factories org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.jsh.statrter.HelloServiceAutoConfiguration ","date":"2020-05-28","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/:2:0","tags":["框架","原理"],"title":"Springboot自定义starter","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"},{"categories":["Spring"],"content":"SpringBoot-Mybatis ","date":"2020-05-27","objectID":"/springboot-mybatis/:0:0","tags":["框架"],"title":"SpringBoot-Mybatis","uri":"/springboot-mybatis/"},{"categories":["Spring"],"content":"maven依赖 jdbc mybatis mysql \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.1.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2020-05-27","objectID":"/springboot-mybatis/:1:0","tags":["框架"],"title":"SpringBoot-Mybatis","uri":"/springboot-mybatis/"},{"categories":["Spring"],"content":"注解方式 package com.jsh.springbootmybatis.mapper; import com.jsh.springbootmybatis.entity.Student; import org.apache.ibatis.annotations.*; @Mapper public interface StudentMapper { @Select(\"select * from student where stunum = #{stunum}\") public Student getStudentByStunum(Integer stunum); @Delete(\"delete from student where stunum = #{stunum}\") public int delStudentByStunum(Integer stunum); @Insert(\"insert into student(stunum,name,age,sex,classid) values(#{stunum},#{name},#{age},#{sex},#{classID})\") public int insertStudent(Student student); @Update(\"update Student set name = #{name} where stunum = #{stunum}\") public int updateStudent(Student student); } ","date":"2020-05-27","objectID":"/springboot-mybatis/:2:0","tags":["框架"],"title":"SpringBoot-Mybatis","uri":"/springboot-mybatis/"},{"categories":["Spring"],"content":"配置方式 yml 配置 mybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml package com.jsh.springbootmybatis.mapper; import com.jsh.springbootmybatis.entity.Student; import org.apache.ibatis.annotations.Mapper; @Mapper public interface StudentMapperByConfig { public Student getStudentByStunum(Integer stunum); } mapper \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.jsh.springbootmybatis.mapper.StudentMapperByConfig\"\u003e \u003cselect id=\"getStudentByStunum\" resultType=\"com.jsh.springbootmybatis.entity.Student\"\u003e select * from student where stunum = #{stunum} \u003c/select\u003e \u003c/mapper\u003e ","date":"2020-05-27","objectID":"/springboot-mybatis/:3:0","tags":["框架"],"title":"SpringBoot-Mybatis","uri":"/springboot-mybatis/"},{"categories":["Spring"],"content":"其他 mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 配置驼峰命名--\u003e \u003csettings\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003c/settings\u003e \u003c/configuration\u003e 扫描所有接口 使用MapperScan批量扫描所有的Mapper接口； @MapperScan(value = \"com.atguigu.springboot.mapper\") @SpringBootApplication public class DomeApplication { public static void main(String[] args) { SpringApplication.run(DomeApplication.class, args); } } ","date":"2020-05-27","objectID":"/springboot-mybatis/:4:0","tags":["框架"],"title":"SpringBoot-Mybatis","uri":"/springboot-mybatis/"},{"categories":["中间件"],"content":"git命令 ","date":"2020-05-26","objectID":"/git/:0:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"在本地新建git项目 在项目根目录 右键 - git bash - git init ","date":"2020-05-26","objectID":"/git/:1:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"在远程建立git项目 new-建立项目- 生成 URL或者SSH ","date":"2020-05-26","objectID":"/git/:2:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"本地项目-远程项目关联 git remote add origin URL或者SSH ","date":"2020-05-26","objectID":"/git/:3:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"第一次发布项目 （本地-远程） git add . //文件-暂存区 git commit -m “注释内容” //暂存区-本地分支（默认master） git push -u origin master ","date":"2020-05-26","objectID":"/git/:4:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"第一次下载项目（远程-本地） git clone git@github.com:yanqun/mygitremote.git ","date":"2020-05-26","objectID":"/git/:5:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"提交(本地-远程) (在当前工作目录 右键-git bash) git add. git commit -m “提交到分支” git push origin master ","date":"2020-05-26","objectID":"/git/:6:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"更新(远程-本地) git pull ","date":"2020-05-26","objectID":"/git/:7:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"用于提供自己的名字和email地址 git config –global user.name [name] git config –global user.email [] ","date":"2020-05-26","objectID":"/git/:8:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"保存登陆的用户密码，避免每次都要重新输入 git config –gloable credential.helper store ","date":"2020-05-26","objectID":"/git/:9:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"查看配置信息列表 git config –list ","date":"2020-05-26","objectID":"/git/:10:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"克隆项目 git clone URL ","date":"2020-05-26","objectID":"/git/:11:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"拉取项目变动 git pull res_name ","date":"2020-05-26","objectID":"/git/:12:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"上传更改 git commit -m “上传说明” git push ","date":"2020-05-26","objectID":"/git/:13:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"撤销上传（版本回退） git reset –hard HEAD~N (到退N次提交前) git commit git push -f （强制传送到远程respostiries） 注意：-f 是一个强制推送的操作，是危险操作！设置倒退N个版本之前，那么在N个版本之前到最新版本的内容会全部消失，若是同时有人想该respostories上传了文件，也会一并消失 ","date":"2020-05-26","objectID":"/git/:14:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"直接由本地，上传文件到指定respostories git init git remote add res_name URL git add . git commit -m “上传说明” git pull res_name master git push res_name master ","date":"2020-05-26","objectID":"/git/:15:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"添加文件的追踪 git add file_name git status (可以看见文件追踪的变动情况) git commit -m “提交说明” (这一步特别注意，不知道为什么，使用 git commit 是无法生效的，必须按照左边的格式提交) git push res_name branch_name ","date":"2020-05-26","objectID":"/git/:16:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["中间件"],"content":"本地项目-远程项目关联 git remote add origin git@github.com:yanqun/mygitremote.git ","date":"2020-05-26","objectID":"/git/:17:0","tags":["git"],"title":"Git","uri":"/git/"},{"categories":["云原生"],"content":"Docker ","date":"2020-05-20","objectID":"/docker/:0:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"1、简介 Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 ","date":"2020-05-20","objectID":"/docker/:1:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"2、核心概念 docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； ","date":"2020-05-20","objectID":"/docker/:2:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"3、安装Docker 1）、安装linux虚拟机 ​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 service network restart ​ 7）、查看linux的ip地址 ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker 步骤： 1、检查内核版本，必须是3.10及以上 uname -r 2、安装docker yum install docker 3、输入y确认安装 4、启动docker [root@localhost ~]# systemctl start docker [root@localhost ~]# docker -v Docker version 1.12.6, build 3e8e77d/1.12.6 5、开机启动docker [root@localhost ~]# systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 6、停止docker systemctl stop docker ","date":"2020-05-20","objectID":"/docker/:3:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"4、Docker常用命令\u0026操作 ","date":"2020-05-20","objectID":"/docker/:4:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ ","date":"2020-05-20","objectID":"/docker/:4:1","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"2）、容器操作 软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1、搜索镜像 [root@localhost ~]# docker search tomcat 2、拉取镜像 [root@localhost ~]# docker pull tomcat 3、根据镜像启动容器 docker run --name mytomcat -d tomcat:latest 4、docker ps 查看运行中的容器 5、 停止运行中的容器 docker stop 容器的id 6、查看所有的容器 docker ps -a 7、启动容器 docker start 容器id 8、删除一个容器 docker rm 容器id 9、启动一个做了端口映射的tomcat [root@localhost ~]# docker run -d -p 8888:8080 tomcat -d：后台运行 -p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 10、为了演示简单关闭了linux的防火墙 service firewalld status ；查看防火墙状态 service firewalld stop：关闭防火墙 11、查看容器的日志 docker logs container-name/container-id 12.进入容器内部 docker exec -it \u003c容器名称\u003e bash 软件安装在etc下 更多命令参看 https://docs.docker.com/engine/reference/commandline/docker/ 可以参考每一个镜像的文档 ","date":"2020-05-20","objectID":"/docker/:4:2","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"3）、安装MySQL示例 docker pull mysql 做了端口映射 [root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434 [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-\u003e3306/tcp mysql02 几个其他的高级操作 docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面 改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql） docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 指定mysql的一些配置参数 ","date":"2020-05-20","objectID":"/docker/:4:3","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"外部配置运行niginx docker run --name nginx_docker -p 80:80 -v /home/docker-nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/docker-nginx/log:/var/log/nginx -v /home/docker-nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -d nginx ","date":"2020-05-20","objectID":"/docker/:4:4","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["Spring"],"content":"SpringBoot-Web ","date":"2020-05-18","objectID":"/springboot-web/:0:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"一. 自动配置 SpsringBoot已经帮我们配置好了基础的配置 例如 视图解析器 扫描器等 如果要使用自己定义的配置 只需要创建一个相应的对象 加入到 IOC容器中即可 例如 // 添加自己的视图解析器 @Bean public ViewResolver myViewReolver(){ return new MyViewReolver(); } private class MyViewReolver implements ViewResolver{ @Override public View resolveViewName(String s, Locale locale) throws Exception { return null; } } ","date":"2020-05-18","objectID":"/springboot-web/:1:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"二.静态资源 ","date":"2020-05-18","objectID":"/springboot-web/:2:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"1.引入jQuery等 webjars上找对应的maven依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.webjars\u003c/groupId\u003e \u003cartifactId\u003ejquery\u003c/artifactId\u003e \u003cversion\u003e3.3.1\u003c/version\u003e \u003c/dependency\u003e ","date":"2020-05-18","objectID":"/springboot-web/:2:1","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"2. 默认静态文件夹位置 \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" \"/\"：当前项目的根路径 #改变静态文件夹，默认的会失效 #spring.resources.static-locations=classpath:/hello/,classpath:/jsh/ ","date":"2020-05-18","objectID":"/springboot-web/:2:2","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"3.欢迎页 localhost:8080/ 找index页面 index.html 会自动去静态文件夹下找 ","date":"2020-05-18","objectID":"/springboot-web/:2:3","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"4.页面图标 favicon.ico 放在静态文件夹下 会自动寻找 ","date":"2020-05-18","objectID":"/springboot-web/:2:4","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"三.模板引擎Thymeleaf ","date":"2020-05-18","objectID":"/springboot-web/:3:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"1.引入thymeleaf \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-thymeleaf\u003c/artifactId\u003e \u003c/dependency\u003e 更改版本 \u003cproperties\u003e \u003cthymeleaf.version\u003e3.0.11.RELEASE\u003c/thymeleaf.version\u003e \u003c!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --\u003e \u003c!-- thymeleaf2 layout1--\u003e \u003cthymeleaf-layout-dialect.version\u003e2.2.2\u003c/thymeleaf-layout-dialect.version\u003e \u003c/properties\u003e ","date":"2020-05-18","objectID":"/springboot-web/:3:1","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"2.使用 1.导入thymeleaf的名称空间 \u003chtml lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\u003e 2.语法 ​ th：任意html属性；来替换原生属性的值 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e成功\u003c/h1\u003e \u003c!-- th:text设置div里边的文本内容 如果没有数据 会显示原本的数据 --\u003e \u003c!-- th：任意html属性；来替换原生属性的值--\u003e \u003cdiv id=\"div01\" class=\"myDiv\" th:id=\"${hello}\" th:text=\"${hello}\"\u003e 这里应该显示数据 \u003c/div\u003e \u003c!-- utext 不转义特殊字符 --\u003e \u003cdiv th:text=\"${hello}\"\u003e\u003c/div\u003e \u003c!-- 行内写法--\u003e \u003cdiv\u003e[[${hello}]]\u003c/div\u003e \u003cdiv th:utext=\"${hello}\"\u003e\u003c/div\u003e \u003cdiv\u003e[(${hello})]\u003c/div\u003e \u003c!-- th:each 遍历--\u003e \u003ch4 th:text=\"${user}\" th:each=\"user:${users}\"\u003e\u003c/h4\u003e \u003ch4\u003e \u003cspan th:each=\"user:${users}\"\u003e[[${user}]]\u003c/span\u003e \u003c/h4\u003e \u003c/body\u003e \u003c/html\u003e 3.语法规则 Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； Variable Expressions: ${...}：获取变量值；OGNL； Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. ${session.foo} 3）、内置的一些工具对象： #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； 补充：配合 th:object=\"${session.user}： \u003cdiv th:object=\"${session.user}\"\u003e \u003cp\u003eName: \u003cspan th:text=\"*{firstName}\"\u003eSebastian\u003c/span\u003e.\u003c/p\u003e \u003cp\u003eSurname: \u003cspan th:text=\"*{lastName}\"\u003ePepper\u003c/span\u003e.\u003c/p\u003e \u003cp\u003eNationality: \u003cspan th:text=\"*{nationality}\"\u003eSaturn\u003c/span\u003e.\u003c/p\u003e \u003c/div\u003e Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； @{/order/process(execId=${execId},execType='FAST')} Fragment Expressions: ~{...}：片段引用表达式 \u003cdiv th:insert=\"~{commons :: main}\"\u003e...\u003c/div\u003e Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: \u003e , \u003c , \u003e= , \u003c= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _ ","date":"2020-05-18","objectID":"/springboot-web/:3:2","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"3. 抽取模板 抽取 在需要抽取的部分 使用 th:fragment=“模板名称” th:fragment=“topbar” \u003cbody\u003e \u003cnav class=\"navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0\" th:fragment=\"topbar\"\u003e \u003ca class=\"navbar-brand col-sm-3 col-md-2 mr-0\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\"\u003e[[${session.loginUser}]]\u003c/a\u003e \u003cinput class=\"form-control form-control-dark w-100\" type=\"text\" placeholder=\"Search\" aria-label=\"Search\"\u003e \u003cul class=\"navbar-nav px-3\"\u003e \u003cli class=\"nav-item text-nowrap\"\u003e \u003ca class=\"nav-link\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\"\u003eSign out\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003cnav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"\u003e \u003cdiv class=\"sidebar-sticky\"\u003e \u003cul class=\"nav flex-column\"\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link active\" th:class=\"${activeUri=='main.html'?'nav-link active':'nav-link'}\" th:href=\"@{/main.html}\" href=\"#\"\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"\u003e \u003cpath d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"\u003e\u003c/path\u003e \u003cpolyline points=\"9 22 9 12 15 12 15 22\"\u003e\u003c/polyline\u003e \u003c/svg\u003e Dashboard \u003cspan class=\"sr-only\"\u003e(current)\u003c/span\u003e \u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\"\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-file\"\u003e \u003cpath d=\"M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z\"\u003e\u003c/path\u003e \u003cpolyline points=\"13 2 13 9 20 9\"\u003e\u003c/polyline\u003e \u003c/svg\u003e Orders \u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\"\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-shopping-cart\"\u003e \u003ccircle cx=\"9\" cy=\"21\" r=\"1\"\u003e\u003c/circle\u003e \u003ccircle cx=\"20\" cy=\"21\" r=\"1\"\u003e\u003c/circle\u003e \u003cpath d=\"M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6\"\u003e\u003c/path\u003e \u003c/svg\u003e Products \u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"#\" th:href=\"@{/emps}\" th:class=\"${activeUri=='emps.html'?'nav-link active':'nav-link'}\"\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-users\"\u003e \u003cpath d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"\u003e\u003c/path\u003e \u003ccircle cx=\"9\" cy=\"7\" r=\"4\"\u003e\u003c/circle\u003e \u003cpath d=\"M23 21v-2a4 4 0 0 0-3-3.87\"\u003e\u003c/path\u003e \u003cpath d=\"M16 3.13a4 4 0 0 1 0 7.75\"\u003e\u003c/path\u003e \u003c/svg\u003e 员工管理 \u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\"\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-bar-chart-2\"\u003e \u003cline x1=\"18\" y1=\"20\" x2=\"18\" y2=\"10\"\u003e\u003c/line\u003e \u003cline x1=\"12\" y1=\"20\" x2=\"12\" y2=\"4\"\u003e\u003c/line\u003e \u003cline x1=\"6\" y1=\"20\" x2=\"6\" y2=\"14\"\u003e\u003c/line\u003e \u003c/svg\u003e Reports \u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\"\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-layers\"\u003e \u003cpolygon points=\"12 2 2 7 12 12 22 7 12 2\"\u003e\u003c/polygon\u003e \u003cpolyline points=\"2 17 12 22 22 17\"\u003e\u003c/polyline\u003e \u003cpolyline points=\"2 12 12 17 22 12\"\u003e\u003c/polyline\u003e \u003c/svg\u003e Integrations \u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003ch6 class=\"sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted\"\u003e \u003cspan\u003eSaved reports\u003c/span\u003e \u003ca class=\"d-flex align-items-center text-muted\" href=\"http://getbootstrap.com/docs/4.0/examp","date":"2020-05-18","objectID":"/springboot-web/:3:3","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"四.扩展SpringMVC 原本配置方法 \u003cmvc:view-controller path=\"/hello\" view-name=\"success\"/\u003e \u003cmvc:interceptors\u003e \u003cmvc:interceptor\u003e \u003cmvc:mapping path=\"/hello\"/\u003e \u003cbean\u003e\u003c/bean\u003e \u003c/mvc:interceptor\u003e \u003c/mvc:interceptors\u003e springBoot配置方法 实现WebMvcConfigurer接口 添加注释@Configuration 会保留原来的自动配置 @EnableWebMvc 不会保留 完全由自己编写SpringMvc配置 //所有的WebMvcConfigurer组件都会一起起作用 //使用implements WebMvcConfigurer扩展springmvc功能 //@EnableWebMvc全面接管springmvc 自动配置会失效 @Configuration //@EnableWebMvc public class MyMvcConfig implements WebMvcConfigurer{ @Override public void addViewControllers(ViewControllerRegistry registry) { //super.addViewControllers(registry); // 浏览器发送 /lujieling 请求来到 success registry.addViewController(\"/lujieling\").setViewName(\"success\"); registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } ","date":"2020-05-18","objectID":"/springboot-web/:4:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"1.默认访问首页 @Configuration public class MyMvcConfig implements WebMvcConfigurer{ @Override public void addViewControllers(ViewControllerRegistry registry) { //super.addViewControllers(registry); // 浏览器发送 /lujieling 请求来到 success registry.addViewController(\"/lujieling\").setViewName(\"success\"); registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index\").setViewName(\"login\"); ","date":"2020-05-18","objectID":"/springboot-web/:4:1","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"2.国际化 1.编写国际化配置文件 classpath目录下 i18n 2.直接在页面中使用 语法 #{} \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\u003e \u003cmeta name=\"description\" content=\"\"\u003e \u003cmeta name=\"author\" content=\"\"\u003e \u003ctitle\u003eSignin Template for Bootstrap\u003c/title\u003e \u003c!-- Bootstrap core CSS --\u003e \u003clink href=\"asserts/css/bootstrap.min.css\" th:href=\"@{/webjars/bootstrap/4.0.0/css/bootstrap.css}\" rel=\"stylesheet\"\u003e \u003c!-- Custom styles for this template --\u003e \u003clink href=\"asserts/css/signin.css\" th:href=\"@{/asserts/css/signin.css}\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody class=\"text-center\"\u003e \u003cform class=\"form-signin\" action=\"dashboard.html\"\u003e \u003cimg class=\"mb-4\" th:src=\"@{/asserts/img/bootstrap-solid.svg}\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"\u003e \u003ch1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\"\u003ePlease sign in\u003c/h1\u003e \u003clabel class=\"sr-only\" th:text=\"#{login.username}\"\u003eUsername\u003c/label\u003e \u003cinput type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#{login.username}\" required=\"\" autofocus=\"\"\u003e \u003clabel class=\"sr-only\" th:text=\"#{login.password}\"\u003ePassword\u003c/label\u003e \u003cinput type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#{login.password}\" required=\"\"\u003e \u003cdiv class=\"checkbox mb-3\"\u003e \u003clabel\u003e \u003cinput type=\"checkbox\" value=\"remember-me\"/\u003e [[#{login.remember}]] \u003c/label\u003e \u003c/div\u003e \u003cbutton class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\"\u003eSign in\u003c/button\u003e \u003cp class=\"mt-5 mb-3 text-muted\"\u003e© 2017-2018\u003c/p\u003e \u003ca class=\"btn btn-sm\"\u003e中文\u003c/a\u003e \u003ca class=\"btn btn-sm\"\u003eEnglish\u003c/a\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 3.点击链接切换国际化 1.编写自己的LocaleResolver package com.jsh.springweb.componet; import org.springframework.web.servlet.LocaleResolver; import org.thymeleaf.util.StringUtils; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; /** * 可以在链接上携带区域信息 */ public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) { String l = httpServletRequest.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l)){ String[] strings = l.split(\"_\"); locale = new Locale(strings[0],strings[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) { } } 2.放在IOC容器中 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } } ","date":"2020-05-18","objectID":"/springboot-web/:4:2","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"3.开发时前端修改不用重启设置 开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 # 禁用缓存 spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； ","date":"2020-05-18","objectID":"/springboot-web/:4:3","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"4.防止表单进行重复提交 @Controller public class LoginController { // @DeleteMapping // @PutMapping // @GetMapping @PostMapping(\"/user/login\") public String login(@RequestParam(\"username\") String username, @RequestParam(\"password\") String password, Map\u003cString,Object\u003e maps, HttpSession session){ if (!StringUtils.isEmpty(username) \u0026\u0026 \"123456\".equals(password)){ session.setAttribute(\"loginUser\",username); // 登陆成功,防止表单重复提交，使用重定向 return \"redirect:/main.html\"; } // 登陆失败 maps.put(\"msg\",\"账户名或密码错误\"); return \"login\"; } } @Configuration public class MyMvcConfig implements WebMvcConfigurer{ @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } ","date":"2020-05-18","objectID":"/springboot-web/:4:4","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"5.拦截器进行登陆检查 编写拦截器 package com.jsh.springweb.componet; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import org.thymeleaf.util.StringUtils; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; //登陆检查 public class LoginHandlerInterceptor implements HandlerInterceptor { // 目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object user = request.getSession().getAttribute(\"loginUser\"); if (user == null){ // 未登录 request.setAttribute(\"mag\",\"没有权限\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; }else { // 已登陆 return true; } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 注册拦截器 注: SpringBoot已经做好了静态资源映射 方法作用 ​ addPathPatterns拦截目标 ​ excludePathPatterns排除目标 @Configuration public class MyMvcConfig implements WebMvcConfigurer{ @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); } } ","date":"2020-05-18","objectID":"/springboot-web/:4:5","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"五.CRUD ","date":"2020-05-18","objectID":"/springboot-web/:5:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"1.RestfulCRUD 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx\u0026xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 实验请求架构 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE ","date":"2020-05-18","objectID":"/springboot-web/:5:1","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"2.CRUD-员工添加 前端首页 \u003ch2\u003e\u003ca class=\"btn btn-sm btn-success\" href=\"/emps\" th:href=\"@{/emp}\"\u003eSection title\u003c/a\u003e\u003c/h2\u003e Controller // 来到添加员工页面 @GetMapping(\"/emp\") public String toAddPage(Map\u003cString,Object\u003e maps){ // 页面要显示的所有部门列表 Collection\u003cDepartment\u003e departments = departmentDao.getDepartments(); maps.put(\"departments\",departments); return \"emp/add\"; } 添加员工页面 提交时日期格式设置 #日期格式化器 默认yyyy/MM/dd spring.mvc.date-format=yyyy-MM-dd 关键代码： \u003cform th:action=\"@{/emp}\" method=\"post\"\u003e 完整代码：（包含后边的修改功能） \u003c!DOCTYPE html\u003e \u003c!-- saved from url=(0052)http://getbootstrap.com/docs/4.0/examples/dashboard/ --\u003e \u003chtml lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\u003e \u003cmeta name=\"description\" content=\"\"\u003e \u003cmeta name=\"author\" content=\"\"\u003e \u003ctitle\u003eDashboard Template for Bootstrap\u003c/title\u003e \u003c!-- Bootstrap core CSS --\u003e \u003clink th:href=\"@{/webjars/bootstrap/4.0.0/css/bootstrap.css}\" href=\"../../static/asserts/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003c!-- Custom styles for this template --\u003e \u003clink th:href=\"@{/asserts/css/dashboard.css}\" href=\"../../static/asserts/css/dashboard.css\" rel=\"stylesheet\"\u003e \u003cstyle type=\"text/css\"\u003e /* Chart.js */ @-webkit-keyframes chartjs-render-animation { from { opacity: 0.99 } to { opacity: 1 } } @keyframes chartjs-render-animation { from { opacity: 0.99 } to { opacity: 1 } } .chartjs-render-monitor { -webkit-animation: chartjs-render-animation 0.001s; animation: chartjs-render-animation 0.001s; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 引入抽取的topbar--\u003e \u003c!-- 模板名：使用thymeleaf的前后缀配置规则进行解析--\u003e \u003cdiv th:replace=\"~{commons/bar::topbar}\"\u003e\u003c/div\u003e \u003cdiv class=\"container-fluid\"\u003e \u003cdiv class=\"row\"\u003e \u003c!-- 引入侧边栏--\u003e \u003cdiv th:replace=\"commons/bar::#sidebar(activeUri='emps.html')\"\u003e\u003c/div\u003e \u003cmain role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\"\u003e \u003c!-- 区分是员工修改 还是添加 post 添加 --\u003e \u003cform th:action=\"@{/emp}\" method=\"post\"\u003e \u003c!-- put 修改--\u003e \u003c!-- 1.SpringMVC中配置HiddenHttpMethodFilter 2.页面创建post表单 3.创建input name = \"_method\" value = 指定的请求方式 --\u003e \u003cinput th:if=\"${emp!=null}\" type=\"hidden\" name=\"_method\" value=\"put\"\u003e \u003cinput th:if=\"${emp!=null}\" type=\"hidden\" name=\"id\" th:value=\"${emp.id}\"\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003eLastName\u003c/label\u003e \u003cinput th:value=\"${emp!=null}?${emp.lastName}\" name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"\u003e \u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003eEmail\u003c/label\u003e \u003cinput th:value=\"${emp!=null}?${emp.email}\" name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"\u003e \u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003eGender\u003c/label\u003e\u003cbr/\u003e \u003cdiv class=\"form-check form-check-inline\"\u003e \u003cinput th:checked=\"${emp!=null}?${emp.gender==1}\" class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"\u003e \u003clabel class=\"form-check-label\"\u003e男\u003c/label\u003e \u003c/div\u003e \u003cdiv class=\"form-check form-check-inline\"\u003e \u003cinput th:checked=\"${emp!=null}?${emp.gender==0}\" class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"\u003e \u003clabel class=\"form-check-label\"\u003e女\u003c/label\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003edepartment\u003c/label\u003e \u003cselect name=\"department.id\" class=\"form-control\"\u003e \u003coption th:selected=\"${emp!=null}?${department.id == emp.department.id}\" th:value=\"${department.id}\" th:each=\"department:${departments}\" th:text=\"${department.departmentName}\"\u003e1\u003c/option\u003e \u003c/select\u003e \u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003eBirth\u003c/label\u003e \u003cinput th:value=\"${emp!=null}?${#dates.format(emp.birth,'yyyy-MM-dd HH:mm')}\" name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"1999-02-14\"\u003e \u003c/div\u003e \u003cbutton th:text=\"${emp!=null}?'修改':'添加'\" type=\"submit\" class=\"btn btn-primary\"\u003e添加\u003c/button\u003e \u003c/form\u003e \u003c/main\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- Bootstrap core JavaScript ================================================== --\u003e \u003c!-- Placed at the end of the document so the pages load faster --\u003e \u003cscript type=\"text/javascript\" src=\"../../static/asserts/js/jquery-3.2.1.slim.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../../static/asserts/js/popper.min.js\"\u003e\u003c/script","date":"2020-05-18","objectID":"/springboot-web/:5:2","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"3.CRUD-员工修改 put 和 delete 需要设置 #配置put delete请求 spring.mvc.hiddenmethod.filter.enabled=true 前端首页 因为需要获取修改员工的ID 所以需要传递参数 \u003ca class=\"btn btn-sm btn-primary\" th:href=\"@{/emp/}+${emp.id}\"\u003e编辑\u003c/a\u003e Controller // 查询出当前员工 来到表单页面 @GetMapping(\"/emp/{id}\") public String toEditPage(@PathVariable(\"id\") Integer id, Model model){ // 查询出当前员工 Employee employee = employeeDao.get(id); model.addAttribute(\"emp\",employee); // 页面要显示的所有部门列表 Collection\u003cDepartment\u003e departments = departmentDao.getDepartments(); model.addAttribute(\"departments\",departments); // 回到修改页面 return \"emp/add\"; } 前端修改页面 关键代码： \u003c!-- 区分是员工修改 还是添加 post 添加 --\u003e \u003cform th:action=\"@{/emp}\" method=\"post\"\u003e \u003c!-- put 修改--\u003e \u003c!-- 1.SpringMVC中配置HiddenHttpMethodFilter 2.页面创建post表单 3.创建input name = \"_method\" value = 指定的请求方式 --\u003e \u003cinput th:if=\"${emp!=null}\" type=\"hidden\" name=\"_method\" value=\"put\"\u003e \u003cinput th:if=\"${emp!=null}\" type=\"hidden\" name=\"id\" th:value=\"${emp.id}\"\u003e 全部代码： 增加和修改功能同时实现 通过 ${emp!=null} 判断 \u003c!DOCTYPE html\u003e \u003c!-- saved from url=(0052)http://getbootstrap.com/docs/4.0/examples/dashboard/ --\u003e \u003chtml lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\u003e \u003cmeta name=\"description\" content=\"\"\u003e \u003cmeta name=\"author\" content=\"\"\u003e \u003ctitle\u003eDashboard Template for Bootstrap\u003c/title\u003e \u003c!-- Bootstrap core CSS --\u003e \u003clink th:href=\"@{/webjars/bootstrap/4.0.0/css/bootstrap.css}\" href=\"../../static/asserts/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003c!-- Custom styles for this template --\u003e \u003clink th:href=\"@{/asserts/css/dashboard.css}\" href=\"../../static/asserts/css/dashboard.css\" rel=\"stylesheet\"\u003e \u003cstyle type=\"text/css\"\u003e /* Chart.js */ @-webkit-keyframes chartjs-render-animation { from { opacity: 0.99 } to { opacity: 1 } } @keyframes chartjs-render-animation { from { opacity: 0.99 } to { opacity: 1 } } .chartjs-render-monitor { -webkit-animation: chartjs-render-animation 0.001s; animation: chartjs-render-animation 0.001s; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 引入抽取的topbar--\u003e \u003c!-- 模板名：使用thymeleaf的前后缀配置规则进行解析--\u003e \u003cdiv th:replace=\"~{commons/bar::topbar}\"\u003e\u003c/div\u003e \u003cdiv class=\"container-fluid\"\u003e \u003cdiv class=\"row\"\u003e \u003c!-- 引入侧边栏--\u003e \u003cdiv th:replace=\"commons/bar::#sidebar(activeUri='emps.html')\"\u003e\u003c/div\u003e \u003cmain role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\"\u003e \u003c!-- 区分是员工修改 还是添加 post 添加 --\u003e \u003cform th:action=\"@{/emp}\" method=\"post\"\u003e \u003c!-- put 修改--\u003e \u003c!-- 1.SpringMVC中配置HiddenHttpMethodFilter 2.页面创建post表单 3.创建input name = \"_method\" value = 指定的请求方式 --\u003e \u003cinput th:if=\"${emp!=null}\" type=\"hidden\" name=\"_method\" value=\"put\"\u003e \u003cinput th:if=\"${emp!=null}\" type=\"hidden\" name=\"id\" th:value=\"${emp.id}\"\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003eLastName\u003c/label\u003e \u003cinput th:value=\"${emp!=null}?${emp.lastName}\" name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"\u003e \u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003eEmail\u003c/label\u003e \u003cinput th:value=\"${emp!=null}?${emp.email}\" name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"\u003e \u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003eGender\u003c/label\u003e\u003cbr/\u003e \u003cdiv class=\"form-check form-check-inline\"\u003e \u003cinput th:checked=\"${emp!=null}?${emp.gender==1}\" class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"\u003e \u003clabel class=\"form-check-label\"\u003e男\u003c/label\u003e \u003c/div\u003e \u003cdiv class=\"form-check form-check-inline\"\u003e \u003cinput th:checked=\"${emp!=null}?${emp.gender==0}\" class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"\u003e \u003clabel class=\"form-check-label\"\u003e女\u003c/label\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003edepartment\u003c/label\u003e \u003cselect name=\"department.id\" class=\"form-control\"\u003e \u003coption th:selected=\"${emp!=null}?${department.id == emp.department.id}\" th:value=\"${department.id}\" th:each=\"department:${departments}\" th:text=\"${department.departmentName}\"\u003e1\u003c/option\u003e \u003c/select\u003e \u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003clabel\u003eBirth\u003c/label\u003e \u003cinput th:value=\"${emp!=null}?${#dates.format(emp.birth,'yyyy-MM-dd HH:mm')}\" name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"1999-02-1","date":"2020-05-18","objectID":"/springboot-web/:5:3","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"4.CRUD-员工删除 前端首页 \u003cform style=\"display: inline;\" th:action=\"@{/emp/}+${emp.id}\" method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"_method\" value=\"delete\"\u003e \u003cbutton type=\"submit\" class=\"btn btn-sm btn-danger\"\u003e删除\u003c/button\u003e \u003c/form\u003e Controller // 员工删除 @DeleteMapping(\"/emp/{id}\") public String deleteEmployeeById(@PathVariable(\"id\") Integer id){ employeeDao.delete(id); return \"redirect:/emps\"; } ","date":"2020-05-18","objectID":"/springboot-web/:5:4","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"六.错误机制处理 ","date":"2020-05-18","objectID":"/springboot-web/:6:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"1.SpringBoot默认的错误处理机制 @ResponseBody @RequestMapping(\"/hello\") public String hello(@RequestParam(\"user\") String user){ if(user.equals(\"aaa\")){ throw new UserNotExistException(); } return \"Hello World\"; } 浏览器，返回一个默认的错误页面 如果是其他客户端，默认响应一个json数据 通过请求头判断 ","date":"2020-05-18","objectID":"/springboot-web/:6:1","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"2.原理 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 帮我们在页面共享信息； @Override public Map\u003cString, Object\u003e getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map\u003cString, Object\u003e errorAttributes = new LinkedHashMap\u003cString, Object\u003e(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; } ​ 2、BasicErrorController：处理默认/error请求 @Controller @RequestMapping(\"${server.error.path:${error.path:/error}}\") public class BasicErrorController extends AbstractErrorController { @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map\u003cString, Object\u003e model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); } @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity\u003cMap\u003cString, Object\u003e\u003e error(HttpServletRequest request) { Map\u003cString, Object\u003e body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity\u003cMap\u003cString, Object\u003e\u003e(body, status); } ​ 3、ErrorPageCustomizer： @Value(\"${error.path:/error}\") private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map\u003cString, Object\u003e model) { ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null \u0026\u0026 SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView; } private ModelAndView resolve(String viewName, Map\u003cString, Object\u003e model) { //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); } ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map\u003cString, Object\u003e model) { //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) { ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) { return modelAndView; } } return null; } ","date":"2020-05-18","objectID":"/springboot-web/:6:2","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"3.定制错误响应 定制错误页面 有模板引擎的情况下 error/状态码;** 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； 以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 定制错误的json数据 浏览器和客户端返回都是json @ControllerAdvice public class MyExceptionHandler { // 1.浏览器和客户端返回都是json @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map\u003cString,Object\u003e handlerException(Exception e){ Map\u003cString,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; } } 转发到/error进行自适应响应效果处理 将数据放在request域中 @ExceptionHandler(UserNotExistException.class) public String handlerException(Exception e, HttpServletRequest request){ Map\u003cString,Object\u003e map = new HashMap\u003c\u003e(); request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); request.setAttribute(\"ext\",map); return \"forward:/error\"; } 将我们的定制数据携带出去 自定义一个类 继承 DefaultErrorAttributes 获取 Map\u003cString, Object\u003e ext = (Map\u003cString, Object\u003e) webRequest.getAttribute(“ext”,0); 存放在map中 @Component public class MyErrorAttributes extends DefaultErrorAttributes { // 返回的map就是页面和json能获取的字段 @Override public Map\u003cString, Object\u003e getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map\u003cString, Object\u003e map = super.getErrorAttributes(webRequest, includeStackTrace); map.put(\"jsh\",\"jsh\"); // 异常处理器携带的数据 Map\u003cString, Object\u003e ext = (Map\u003cString, Object\u003e) webRequest.getAttribute(\"ext\",0); map.put(\"ext\",ext); return map; } } ","date":"2020-05-18","objectID":"/springboot-web/:6:3","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"七.Servlet容器 ","date":"2020-05-18","objectID":"/springboot-web/:7:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"1）、如何定制和修改Servlet容器的相关配置； 1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； server.port=8081 server.context-path=/crud server.tomcat.uri-encoding=UTF-8 //通用的Servlet容器设置 server.xxx //Tomcat的设置 server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 //定制嵌入式的servlet容器 @Bean public WebServerFactoryCustomizer\u003cConfigurableWebServerFactory\u003e webServerFactoryCustomizer(){ return new WebServerFactoryCustomizer\u003cConfigurableWebServerFactory\u003e() { // 定制嵌入式的servlet容器相关的规则 @Override public void customize(ConfigurableWebServerFactory factory) { factory.setPort(8083); } }; } ","date":"2020-05-18","objectID":"/springboot-web/:7:1","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"2）、注册Servlet三大组件【Servlet、Filter、Listener】 由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean //注册三大组件 @Bean public ServletRegistrationBean myServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean; } FilterRegistrationBean @Bean public FilterRegistrationBean myFilter(){ FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean; } ServletListenerRegistrationBean @Bean public ServletListenerRegistrationBean myListener(){ ServletListenerRegistrationBean\u003cMyListener\u003e registrationBean = new ServletListenerRegistrationBean\u003c\u003e(new MyListener()); return registrationBean; } SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME) @ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) { registration.setMultipartConfig(this.multipartConfig); } return registration; } 2）、SpringBoot能不能支持其他的Servlet容器； ","date":"2020-05-18","objectID":"/springboot-web/:7:2","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器； \u003c/dependency\u003e Jetty \u003c!-- 引入web模块 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cartifactId\u003espring-boot-starter-tomcat\u003c/artifactId\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003c!--引入其他的Servlet容器--\u003e \u003cdependency\u003e \u003cartifactId\u003espring-boot-starter-jetty\u003c/artifactId\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003c/dependency\u003e Undertow \u003c!-- 引入web模块 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cartifactId\u003espring-boot-starter-tomcat\u003c/artifactId\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003c!--引入其他的Servlet容器--\u003e \u003cdependency\u003e \u003cartifactId\u003espring-boot-starter-undertow\u003c/artifactId\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003c/dependency\u003e ","date":"2020-05-18","objectID":"/springboot-web/:7:3","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"4）、嵌入式Servlet容器自动配置原理； EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Configuration @ConditionalOnWebApplication @Import(BeanPostProcessorsRegistrar.class) //导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件 //导入了EmbeddedServletContainerCustomizerBeanPostProcessor： //后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作 public class EmbeddedServletContainerAutoConfiguration { @Configuration @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat { @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() { return new TomcatEmbeddedServletContainerFactory(); } } /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty { @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() { return new JettyEmbeddedServletContainerFactory(); } } /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow { @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() { return new UndertowEmbeddedServletContainerFactory(); } } 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） public interface EmbeddedServletContainerFactory { //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers); } 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 @Override public EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) { //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); } prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat); } 4）、我们对嵌入式容器的配置修改是怎么生效？ ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor //初始化之前 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) { // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); } return bean; } private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) { //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) { customizer.customize(bean); } } private Collection\u003cEmbeddedServletContainerCustomizer\u003e getCustomizers() { if (this.customizers == null) { // Look up does not include the parent context this.customizers = new ArrayList\u003cEmbeddedServletContainerCustomizer\u003e( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustom","date":"2020-05-18","objectID":"/springboot-web/:7:4","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"9、使用外置的Servlet容器 嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； ","date":"2020-05-18","objectID":"/springboot-web/:8:0","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"步骤 1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-tomcat\u003c/artifactId\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); } } 4）、启动服务器就可以使用； ","date":"2020-05-18","objectID":"/springboot-web/:8:1","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"原理 jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set\u003cClass\u003c?\u003e\u003e；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) { //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) { this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); } builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() \u0026\u0026 AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) { application.getSources().add(getClass()); } Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the \" + \"configure method or add an @Configuration annotation\"); // Ensure error pages are registered if (this.registerErrorPageFilter) { application.getSources().add(ErrorPageFilterConfiguration.class); } //启动Spring应用 return run(application); } 7）、Spring的应用就启动并且创建IOC容器 public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } } ==启动Servlet容器，再启动SpringBoot应用== ","date":"2020-05-18","objectID":"/springboot-web/:8:2","tags":["框架"],"title":"SpringBoot-Web","uri":"/springboot-web/"},{"categories":["Spring"],"content":"SpringBoot入门 ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:0:0","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"1、创建一个maven工程；（jar） ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:0:1","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"2、导入spring boot相关的依赖 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e1.5.9.RELEASE\u003c/version\u003e \u003c/parent\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:0:2","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"3、编写一个主程序；启动Spring Boot应用 /** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } } ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:0:3","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"4、编写相关的Controller、Service @Controller public class HelloController { @ResponseBody @RequestMapping(\"/hello\") public String hello(){ return \"Hello World!\"; } } ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:0:4","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"5、运行主程序测试 ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:0:5","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"6、简化部署 \u003c!-- 这个插件，可以将应用打包成一个可执行的jar包；--\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 将这个应用打成jar包，直接使用java -jar的命令进行执行； ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:0:6","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"5、Hello World探究 ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:1:0","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"1、POM文件 1、父项目 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e1.5.9.RELEASE\u003c/version\u003e \u003c/parent\u003e 他的父项目是 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e1.5.9.RELEASE\u003c/version\u003e \u003crelativePath\u003e../../spring-boot-dependencies\u003c/relativePath\u003e \u003c/parent\u003e 他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:1:1","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"2、主程序类，主入口类 /** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } } @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； @AutoConfigurationPackage @Import(EnableAutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:1:2","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"6、使用Spring Initializer快速创建Spring Boot项目 ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:2:0","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["Spring"],"content":"1、IDEA：使用 Spring Initializer快速创建项目 IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； ","date":"2020-05-08","objectID":"/springboot%E5%85%A5%E9%97%A8/:2:1","tags":["框架"],"title":"SpringBoot入门","uri":"/springboot%E5%85%A5%E9%97%A8/"},{"categories":["前端"],"content":"前端-jQuery-DOM ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:0:0","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["前端"],"content":"HTML text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 获取 ​ 直接使用 设置 ​ 1.括号里传递参数 ​ 2.使用回调函数function(i,origText) i:元素下标 origText:旧的值 $(document).ready(function(){ // alert($(\"p\").text()) // alert($(\"div\").html()) $(\"button\").click(function(){ // $(\"input\").val(\"dddddd\") $(\"input\").val(function(i,origText){ return \"a\"+origText+i; }) // $(\"p\").text(\"dsdsdsds\") $(\"p\").text(function(i,origText){ return \"a\"+origText+i; }) // $(\"div\").html(\"\u003ch1\u003esdsd\u003c/h1\u003e\") $(\"div\").attr(\"style\",\"background-color: aquamarine\") }) }) append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 function appendText() { var txt1=\"\u003cp\u003eText.\u003c/p\u003e\"; // 以 HTML 创建新元素 var txt2=$(\"\u003cp\u003e\u003c/p\u003e\").text(\"Text.\"); // 以 jQuery 创建新元素 var txt3=document.createElement(\"p\"); // 以 DOM 创建新元素 txt3.innerHTML=\"Text.\"; $(\"p\").append(txt1,txt2,txt3); // 追加新元素 } remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:1:0","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["前端"],"content":"设置CSS addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 $(\"p\").css({\"background-color\":\"yellow\",\"font-size\":\"200%\"}); ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:1:1","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["前端"],"content":"尺寸 width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。 height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 outerWidth(true) 方法返回元素的宽度（包括内边距、边框和外边距）。 outerHeight(true) 方法返回元素的高度（包括内边距、边框和外边距）。 ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:1:2","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["前端"],"content":"节点 ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:2:0","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["前端"],"content":"祖先 parent() 返回被选元素的直接父元素 parents() 返回被选元素的所有祖先元素 parentsUntil() 返回介于两个给定元素之间的所有祖先元素 ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:2:1","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["前端"],"content":"后代 children() 返回被选元素的所有子元素 find() 返回被选元素的后代元素 参数“*”代表所有 可以写标签名 ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:2:2","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["前端"],"content":"同胞 siblings() 返回被选元素的所有同胞元素 next() 返回被选元素的下一个同胞元素 nextAll() 返回被选元素后的所有同胞元素 nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素 例$(“h2”).nextUntil(“h6”); prev() 向前 prevAll() prevUntil() ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:2:3","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["前端"],"content":"过滤 first() 方法返回被选元素的首个元素 last() 最后一个 //选取首个 \u003cdiv\u003e 元素内部的第一个 \u003cp\u003e 元素 $(document).ready(function(){ $(\"div p\").first(); }); eq() 方法返回被选元素中带有指定索引号的元素 $(document).ready(function(){ $(\"p\").eq(1); }); filter() 规定一个标准 not() 相反 //返回带有类名 \"intro\" 的所有 \u003cp\u003e 元素 $(document).ready(function(){ $(\"p\").filter(\".intro\"); }); ","date":"2020-05-08","objectID":"/%E5%89%8D%E7%AB%AF-jquery-dom/:2:4","tags":[],"title":"前端-jQuery-DOM","uri":"/%E5%89%8D%E7%AB%AF-jquery-dom/"},{"categories":["中间件"],"content":"Maven 笔记整理 ","date":"2020-05-06","objectID":"/maven/:0:0","tags":[],"title":"Maven 笔记整理","uri":"/maven/"},{"categories":["中间件"],"content":"1.作用 jar依赖 将项目拆分成若干个模块 ","date":"2020-05-06","objectID":"/maven/:1:0","tags":[],"title":"Maven 笔记整理","uri":"/maven/"},{"categories":["中间件"],"content":"2.概念 基于Java平台的 自动化构建工具 清理：删除编译的结果，为重新编译做准备。 编译：java-\u003eclass 测试： 针对于 项目中的关键点进行测试，亦可用 项目中的测试代码 去测试开发代码； 报告：将测试的结果 进行显示 打包： 将项目中包含的多个文件 压缩成一个文件， 用于安装或部署。 （java项目-jar、web项目-war） 安装：将打成的包 放到 本地仓库，供其他项目使用。 部署：将打成的包 放到 服务器上准备运行。 ","date":"2020-05-06","objectID":"/maven/:2:0","tags":[],"title":"Maven 笔记整理","uri":"/maven/"},{"categories":["中间件"],"content":"3.使用 下载配置maven a.配置JAVA_HOME b.配置MAVEN_HOME : D:\\apache-maven-3.5.3\\bin c.配置path %MAVEN_HOME%\\bin d.验证 mvn -v e.配置本地仓库 maven目录/conf/settings.xml 默认本地仓库 ：C:/Users/YANQUN/.m2/repository 修改本地仓库： D:/mvnrep 使用maven maven约定的目录结构： 项目 -src –main ：程序功能代码 –java java代码 (Hello xxx) –resources 资源代码、配置代码 –test ：测试代码 –java –resources pom.xml 域名翻转.大项目名 org.lanqiao.maven 子模块名 HelloWorld 版本号 0.0.1-SNAPSHOT 依赖： commons-fileupload.jar –\u003e commons-io.jar A中的某些类 需要使用B中的某些类，则称为A依赖于B 在maven项目中，如果要使用 一个当时存在的Jar或模块，则可以通过 依赖实现（去本地仓库、远程仓库去寻找） 执行mvn： 必须在pom.xml所在目录中执行 ","date":"2020-05-06","objectID":"/maven/:3:0","tags":[],"title":"Maven 笔记整理","uri":"/maven/"},{"categories":["中间件"],"content":"4.常见命令 mvn compile –只编译main目录中的java文件 mvn test 测试 mvn package 打成jar/war mvn install 将开发的模块 放入本地仓库，供其他模块使用 （放入的位置 是通过gav决定） mvn clean 删除target目录（删除编译文件的目录） deploy 在eclipes中运行 运行mvn命令，必须在pom.xml文件所在目录 ","date":"2020-05-06","objectID":"/maven/:4:0","tags":[],"title":"Maven 笔记整理","uri":"/maven/"},{"categories":["中间件"],"content":"5.依赖 \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 1.依赖的范围、依赖的有效性 compile(默认) test provided 2.依赖排除 A.jar -\u003eB.jar 当我们通过maven引入A.jar时，会自动引入B.jar A.jar(x.java ,y.java,z.java) B.jar(p.java c.java i.java) A.jar和B.jar之间的 依赖的本质：z.java -\u003ec.java \u003c!-- 排除依赖 beans --\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-beans\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e 3.依赖的传递性 4依赖原则：为了防止冲突 a.路径最短优先原则 b.路径长度相同： i.在同一个pom.xml文件中有2个相同的依赖（覆盖）：后面声明的依赖 会覆盖前面声明的依赖 （严禁使用本情况，严禁在同一个pom中声明2个版本不同的依赖） ii.如果是不同的 pom.xml中有2个相同的依赖（优先）：则先声明的依赖 ，会覆盖后声明的依赖 5.多个maven项目（模块）之间如何 依赖： p项目 依赖于-\u003eq项目 p项目 install 到本地仓库 q项目 依赖： \u003c!-- 本项目 依赖于HelloWorld2项目 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.lanqiao.maven\u003c/groupId\u003e \u003cartifactId\u003eHelloWorld2\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e ``` ## 6.在Eclipse中创建maven工程 1.配置maven: 配置maven版本 配置本地仓库 ： 设置settings.xml 在eclipse中编写完pom.xml依赖后，需要maven-update project package: resources compile test package maven生命周期: 生命周期和构建的关系： 生命周期中的顺序：a b c d e 当我们执行c命令，则实际执行的是 a b c 生命周期包含的阶段：3个阶段 clean lifecycle ：清理 pre-clean clean post-clearn default lifecycle ：默认(常用) site lifecycle：站点 pre-site site post-site site-deploy 再次强调：在pom.xml中增加完依赖后 需要maven - update project 统一项目的jdk： build path:删除旧版本，增加新版本 右键项目-属性-Project Factors -java version 改版本 （之前存在要改的版本） 通过maven统一jdk版本： jdk-18 true 1.8 1.8 1.8 1.8 ``` ","date":"2020-05-06","objectID":"/maven/:5:0","tags":[],"title":"Maven 笔记整理","uri":"/maven/"},{"categories":["中间件"],"content":"其他 打包方式： java工程——jar web项目-war 父工程，聚合工程·-pom 继承实现步骤： 1.建立父工程： 父工程的打包方式为pom 2.在父工程的pom.xml中编写依赖： \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e 3.子类: \u003c!-- 给当前工程 继承一个父工程：1加入父工程坐标gav 2当前工程的Pom.xml到父工程的Pom.xml之间的 相对路径 --\u003e \u003cparent\u003e \u003c!-- 1加入父工程坐标gav --\u003e \u003cgroupId\u003eorg.lanqiao.maven\u003c/groupId\u003e \u003cartifactId\u003eB\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c!-- 2当前工程的Pom.xml到父工程的Pom.xml之间的 相对路径 --\u003e \u003crelativePath\u003e../B/pom.xml\u003c/relativePath\u003e \u003c/parent\u003e 4.在子类中 需要声明 ：使用那些父类的依赖 \u003cdependency\u003e \u003c!-- 声明：需要使用到父类的junit （只需要ga） --\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003c/dependency\u003e 聚合： Maven项目能够识别的： 自身包含、本地仓库中的 Maven2依赖于Maven1，则在执行时：必须先将Maven1加入到本地仓库(install)，之后才能执行Maven2 以上 前置工程的install操作，可以交由“聚合” 一次性搞定。。。 聚合的使用： 在一个总工程中配置聚合： （聚合的配置 只能配置在（打包方式为pom）的Maven工程中） modules \u003cmodules\u003e \u003c!--项目的根路径 --\u003e \u003cmodule\u003e../Maven1\u003c/module\u003e \u003cmodule\u003e../Maven2\u003c/module\u003e \u003c/modules\u003e 配置完聚合之后，以后只要操作总工程，则会自动操作 改聚合中配置过的工程 配置完聚合之后，以后只要操作总工程，则会自动操作 改聚合中配置过的工程 注意：clean命令 是删除 target目录，并不是清理install存放入的本地仓库 聚合： Maven将一个大工程拆分成 若干个子工程（子模块） 聚合可以将拆分的多个子工程 合起来 继承： 父-\u003e子工程,可以通过父工程 统一管理依赖的版本 部署Web工程：war 通过maven直接部署运行web项目： a.配置cargo b. maven命令：deploy 实际开发中，开发人员 将自己的项目开发完毕后 打成war包(package) 交给实施人员去部署； ","date":"2020-05-06","objectID":"/maven/:6:0","tags":[],"title":"Maven 笔记整理","uri":"/maven/"},{"categories":["中间件"],"content":"deploy \u003cbuild\u003e \u003cfinalName\u003eWebProjectName\u003c/finalName\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.codehaus.cargo\u003c/groupId\u003e \u003cartifactId\u003ecargo-maven2-plugin\u003c/artifactId\u003e \u003cversion\u003e1.6.6\u003c/version\u003e \u003cconfiguration\u003e \u003ccontainer\u003e \u003ccontainerId\u003etomcat9x\u003c/containerId\u003e \u003chome\u003eD:\\apache-tomcat\\apache-tomcat-9.0.29\u003c/home\u003e \u003c/container\u003e \u003cconfiguration\u003e \u003ctype\u003eexisting\u003c/type\u003e \u003chome\u003eD:\\apache-tomcat\\apache-tomcat-9.0.29\u003c/home\u003e \u003c!-- 默认值8080 --\u003e \u003cproperties\u003e \u003ccargo.servlet.port\u003e8888\u003c/cargo.servlet.port\u003e \u003c/properties\u003e \u003c/configuration\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003ecargo-run\u003c/id\u003e \u003c!-- 阶段 --\u003e \u003cphase\u003einstall\u003c/phase\u003e \u003cgoals\u003e \u003c!-- 执行 --\u003e \u003cgoal\u003erun\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e ","date":"2020-05-06","objectID":"/maven/:6:1","tags":[],"title":"Maven 笔记整理","uri":"/maven/"},{"categories":["前端"],"content":"前端-jQuery-事件，效果 ","date":"2020-05-06","objectID":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/:0:0","tags":[],"title":"前端-jQuery-事件，效果","uri":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/"},{"categories":["前端"],"content":"事件 方法 描述 bind() 向匹配元素附加一个或更多事件处理器 blur() 触发、或将函数绑定到指定元素的 blur 事件 change() 触发、或将函数绑定到指定元素的 change 事件 click() 触发、或将函数绑定到指定元素的 click 事件 dblclick() 触发、或将函数绑定到指定元素的 double click 事件 delegate() 向匹配元素的当前或未来的子元素附加一个或多个事件处理器 die() 移除所有通过 live() 函数添加的事件处理程序。 error() 触发、或将函数绑定到指定元素的 error 事件 event.isDefaultPrevented() 返回 event 对象上是否调用了 event.preventDefault()。 event.pageX 相对于文档左边缘的鼠标位置。 event.pageY 相对于文档上边缘的鼠标位置。 event.preventDefault() 阻止事件的默认动作。 event.result 包含由被指定事件触发的事件处理器返回的最后一个值。 event.target 触发该事件的 DOM 元素。 event.timeStamp 该属性返回从 1970 年 1 月 1 日到事件发生时的毫秒数。 event.type 描述事件的类型。 event.which 指示按了哪个键或按钮。 focus() 触发、或将函数绑定到指定元素的 focus 事件 keydown() 触发、或将函数绑定到指定元素的 key down 事件 keypress() 触发、或将函数绑定到指定元素的 key press 事件 keyup() 触发、或将函数绑定到指定元素的 key up 事件 live() 为当前或未来的匹配元素添加一个或多个事件处理器 load() 触发、或将函数绑定到指定元素的 load 事件 mousedown() 触发、或将函数绑定到指定元素的 mouse down 事件 mouseenter() 触发、或将函数绑定到指定元素的 mouse enter 事件 mouseleave() 触发、或将函数绑定到指定元素的 mouse leave 事件 mousemove() 触发、或将函数绑定到指定元素的 mouse move 事件 mouseout() 触发、或将函数绑定到指定元素的 mouse out 事件 mouseover() 触发、或将函数绑定到指定元素的 mouse over 事件 mouseup() 触发、或将函数绑定到指定元素的 mouse up 事件 one() 向匹配元素添加事件处理器。每个元素只能触发一次该处理器。 ready() 文档就绪事件（当 HTML 文档就绪可用时） resize() 触发、或将函数绑定到指定元素的 resize 事件 scroll() 触发、或将函数绑定到指定元素的 scroll 事件 select() 触发、或将函数绑定到指定元素的 select 事件 submit() 触发、或将函数绑定到指定元素的 submit 事件 toggle() 绑定两个或多个事件处理器函数，当发生轮流的 click 事件时执行。 trigger() 所有匹配元素的指定事件 triggerHandler() 第一个被匹配元素的指定事件 unbind() 从匹配元素移除一个被添加的事件处理器 undelegate() 从匹配元素移除一个被添加的事件处理器，现在或将来 unload() 触发、或将函数绑定到指定元素的 unload 事件 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"js/jquery-3.5.0.js\"\u003e\u003c/script\u003e \u003cscript\u003e $(document).ready(function(){ // 双击 dblclick $(\"button\").dblclick(function(){ $(\"p\").css(\"color\",\"#eee\"); }) // 点击 click $(\"button\").click(function(){ // $(\"p\").hide(); $(\"p\").css(\"color\",\"red\"); }); // 鼠标悬停 mouseover $(\"button\").mouseover(function(){ $(\"p\").css(\"color\",\"aqua\"); }) // 选中元素获得焦点 focus $(\"#inp1\").focus(function(){ $(\"#inp1\").val(\"ssss\"); }) // 选中元素失去焦点 blur $(\"#inp1\").blur(function(){ $(\"#inp1\").val(\"sss\"); }) // 输入域发生变化时 change $(\"#inp1\").change(function(){ let a = Math.floor(Math.random()*10); let c = Math.floor(Math.random()*10); let b = Math.floor(Math.random()*10); alert(\"#\"+a+b+c); $(\"button\").css(\"color\",\"#\"+a+b+c); }) // 当元素遇到错误（没有正确载入）时，发生 error 事件 $(\"img\").error(function(){ $(\"img\").replaceWith(\"\u003cp\u003e\u003cb\u003e图片未加载！\u003c/b\u003e\u003c/p\u003e\"); }); // delegate() 方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序 // delegate(childSelector,event,data,function) $(\"div\").delegate(\"button\",\"click\",function(){ $(\"p\").slideToggle(); }) // 附加一个或更多事件处理器 bind(event,data,function) // event 必需 添加事件 用空格隔开 // data 可选 规定传递到函数的额外数据 // function 必需 规定当事件发生时运行的函数 $(\"#inp1\").bind(\"click mouseover\",function(){ $(\"#inp1\").val(\"ss\"); }) }); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e \u003cp\u003eThis is my jquery\u003c/p\u003e \u003cbutton style=\"color: aqua;\"\u003e点击\u003c/button\u003e \u003cinput id=\"inp1\" type=\"text\" \u003e \u003cimg src=\"1.png\" /\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-05-06","objectID":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/:1:0","tags":[],"title":"前端-jQuery-事件，效果","uri":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/"},{"categories":["前端"],"content":"效果 隐藏 hide() 显示 show() 切换显示与消失 toggle() 淡入 fadeIn(speed,callback) 淡出 fadeOut(speed,callback) fadeToggle(speed,callback) 淡入淡出切换 渐变为给定的透明度 fadeTo(speed,opacity,callback) 上下滑动 ​ slideDown(speed,callback); ​ slideUp(speed,callback); ​ slideToggle(speed,callback); \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"js/jquery-3.5.0.js\"\u003e\u003c/script\u003e \u003cscript\u003e $(document).ready(function(){ $(\"button\").click(function(){ // 隐藏 // $(\"p\").hide(); // show() 显示 // toggle 切换显示与消失 // $(\"p\").toggle(); // 淡入淡出 // 淡入 fadeIn(speed,callback) // speed:\"slow\"、\"fast\" 或毫秒。 // callback 回调函数 // $(\"#div1\").fadeIn(3000); // 淡出 fadeOut(speed,callback) // $(\"#div1\").fadeOut(); // fadeToggle(speed,callback) 淡入淡出切换 //$(\"#div1\").fadeToggle(); // 渐变为给定的透明度 fadeTo(speed,opacity,callback) //$(\"#div1\").fadeTo(\"slow\",0.15); // 上下滑动 // slideDown(speed,callback); // slideUp(speed,callback); // slideToggle(speed,callback); // 动画animate({params},speed,callback); params 参数定义形成动画的 CSS 属性 $(\"#div1\").animate({ left:\"250px\", width:\"+=200px\" }); $(\"#div1\").animate({ opacity:'0.4' }); }) }) \u003c/script\u003e \u003cstyle\u003e div{ position: relative; width: 100px; height: 100px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton\u003e111\u003c/button\u003e \u003cp\u003eaaaaaaaaaaaaaaaaaaaa\u003c/p\u003e \u003cdiv id=\"div1\" style=\"background-color: aqua;\"\u003e\u003c/div\u003e \u003cdiv id=\"div2\" style=\"background-color: black;\"\u003e\u003c/div\u003e \u003cdiv id=\"div3\" style=\"background-color: blanchedalmond;\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-05-06","objectID":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/:2:0","tags":[],"title":"前端-jQuery-事件，效果","uri":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/"},{"categories":["前端"],"content":"animate动画 animate({params},speed,callback); params 参数定义形成动画的 CSS 属性 -变为字母大写 同一个动画 可以定义多个属性变量 可以定义多个动画 依次执行 颜色变化需要额外的插件 $(\"#div1\").animate({ left:\"250px\", width:\"+=200px\" }); $(\"#div1\").animate({ opacity:'0.4' }); ","date":"2020-05-06","objectID":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/:2:1","tags":[],"title":"前端-jQuery-事件，效果","uri":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/"},{"categories":["前端"],"content":"其他 stop() stop(stopAll,goToEnd) 动画 stopAll 默认是false 只停止当前正在进行的动画 true会停止此节点所有后续动画 goToEnd是否立即完成当前动画。默认是 false。 stop() 效果 直接停止 ","date":"2020-05-06","objectID":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/:2:2","tags":[],"title":"前端-jQuery-事件，效果","uri":"/%E5%89%8D%E7%AB%AF-jquery-%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C/"},{"categories":["Spring"],"content":"SSM整合 jar commons-dbcp-1.4.jar commons-logging-1.1.1.jar commons-pool-1.6.jar log4j-1.2.17.jar mybatis-3.4.6.jar mybatis-spring-1.3.1.jar mysql-connector-java-8.0.15.jar spring-aop-4.3.9.RELEASE.jar spring-beans-4.3.9.RELEASE.jar spring-context-4.3.9.RELEASE.jar spring-core-4.3.9.RELEASE.jar spring-expression-4.3.9.RELEASE.jar spring-jdbc-4.3.9.RELEASE.jar spring-tx-4.3.9.RELEASE.jar spring-web-4.3.9.RELEASE.jar spring-webmvc-4.3.9.RELEASE.jar spring 和 mabits整合 数据源，mapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- 依赖注入 --\u003e \u003cbean id=\"studentService\" class=\"org.jsh.service.impl.StudentServiceImpl\"\u003e \u003cproperty name=\"studentMapper\" ref=\"studentMapper\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- \u003cbean id=\"studentController\" class=\"org.jsh.controller.StudentController\"\u003e \u003cproperty name=\"studentService\" ref=\"studentService\"\u003e\u003c/property\u003e \u003c/bean\u003e --\u003e \u003c!-- 加载db.properties文件 --\u003e \u003cbean id=\"config\" class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"\u003e \u003cproperty name=\"locations\"\u003e \u003carray\u003e \u003cvalue\u003eclasspath:db.properties\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 数据源，mapper.xml --\u003e \u003c!-- 配置配置数据库信息（替代mybatis的配置文件conf.xml） --\u003e \u003cbean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"${driver}\"\u003e\u003c/property\u003e \u003cproperty name=\"url\" value=\"${url}\"\u003e\u003c/property\u003e \u003cproperty name=\"username\" value=\"${username}\"\u003e\u003c/property\u003e \u003cproperty name=\"password\" value=\"${password}\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- 在SpringIoc容器中 创建MyBatis的核心类 SqlSesionFactory --\u003e \u003cbean id=\"sqlSessionFacotry\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"\u003e\u003c/property\u003e \u003c!-- 加载mapper.xml路径 --\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:org/jsh/mapper/*.xml\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- Spring整合Mybatis --\u003e \u003c!-- 第三种方式生成mapper对象(批量产生多个mapper) 批量产生Mapper对在SpringIOC中的 id值 默认就是 首字母小写接口名 (首字母小写的接口名=id值) --\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFacotry\"\u003e\u003c/property\u003e \u003c!--指定批量产生 哪个包中的mapper对象--\u003e \u003cproperty name=\"basePackage\" value=\"org.jsh.mapper\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e 配置springmvc \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"\u003e \u003c!--配置视图解析器--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003cproperty name=\"prefix\" value=\"/views/\"\u003e\u003c/property\u003e \u003cproperty name=\"suffix\" value=\".jsp\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- 此配置是SpringMVC的基础配置，很多功能都需要通过该注解来协调 --\u003e \u003cmvc:annotation-driven\u003e\u003c/mvc:annotation-driven\u003e \u003c!-- 扫描--\u003e \u003ccontext:component-scan base-package=\"org.jsh.controller\"\u003e\u003c/context:component-scan\u003e \u003c/beans\u003e ","date":"2020-04-30","objectID":"/ssm%E6%95%B4%E5%90%88/:0:0","tags":["框架","整理"],"title":"SSM整合","uri":"/ssm%E6%95%B4%E5%90%88/"},{"categories":["Spring"],"content":"代码 ","date":"2020-04-30","objectID":"/ssm%E6%95%B4%E5%90%88/:1:0","tags":["框架","整理"],"title":"SSM整合","uri":"/ssm%E6%95%B4%E5%90%88/"},{"categories":["Spring"],"content":"后端 entity package org.jsh.entity; public class Student { private int stunum; private String name; private int age ; public int getStunum() { return stunum; } public void setStunum(int stunum) { this.stunum = stunum; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } dao \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- namespace:该mapper.xml映射文件的 唯一标识 --\u003e \u003cmapper namespace=\"org.jsh.mapper.StudentMapper\"\u003e \u003cselect id=\"queryStudentByStuno\" parameterType=\"int\" resultType=\"org.jsh.entity.Student\" \u003e select * from student where stunum = #{stuNo} \u003c/select\u003e \u003cinsert id=\"addStudent\" parameterType=\"org.jsh.entity.Student\" \u003e insert into student(stunum,name,age) values(#{stunum},#{name},#{age}) \u003c/insert\u003e \u003c/mapper\u003e package org.jsh.mapper; import org.jsh.entity.Student; public interface StudentMapper { public void addStudent(Student student ); public Student queryStudentByStuno(int stunum); } service package org.jsh.service.impl; import org.jsh.entity.Student; import org.jsh.mapper.StudentMapper; import org.jsh.service.StudentService; public class StudentServiceImpl implements StudentService { private StudentMapper studentMapper; public void setStudentMapper(StudentMapper studentMapper) { this.studentMapper = studentMapper; } public Student queryStudentByNum(int stunum) { Student student = studentMapper.queryStudentByStuno(stunum); System.out.println(student); return student; } } controller package org.jsh.controller; import java.util.Map; import org.jsh.entity.Student; import org.jsh.service.impl.StudentServiceImpl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"studentController\") public class StudentController { @Autowired StudentServiceImpl studentService; public void setStudentService(StudentServiceImpl studentService) { this.studentService = studentService; } @RequestMapping(\"queryStudentByNum/{stunum}\") public String queryStudentByNum(@PathVariable(\"stunum\") int stunum,Map\u003cString,Object\u003e map) { Student student = studentService.queryStudentByNum(stunum); map.put(\"student\",student); return \"result\"; } } ","date":"2020-04-30","objectID":"/ssm%E6%95%B4%E5%90%88/:1:1","tags":["框架","整理"],"title":"SSM整合","uri":"/ssm%E6%95%B4%E5%90%88/"},{"categories":["Spring"],"content":"前端 web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"\u003e \u003cdisplay-name\u003eSSMProject\u003c/display-name\u003e \u003cwelcome-file-list\u003e \u003cwelcome-file\u003eindex.html\u003c/welcome-file\u003e \u003cwelcome-file\u003eindex.htm\u003c/welcome-file\u003e \u003cwelcome-file\u003eindex.jsp\u003c/welcome-file\u003e \u003cwelcome-file\u003edefault.html\u003c/welcome-file\u003e \u003cwelcome-file\u003edefault.htm\u003c/welcome-file\u003e \u003cwelcome-file\u003edefault.jsp\u003c/welcome-file\u003e \u003c/welcome-file-list\u003e \u003c!-- web项目中引入Spring --\u003e \u003c!-- needed for ContextLoaderListener --\u003e \u003ccontext-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:applicationContext.xml\u003c/param-value\u003e \u003c/context-param\u003e \u003c!-- Bootstraps the root web application context before servlet initialization --\u003e \u003clistener\u003e \u003clistener-class\u003eorg.springframework.web.context.ContextLoaderListener\u003c/listener-class\u003e \u003c/listener\u003e \u003c!-- 配置SpringMVC --\u003e \u003c!-- The front controller of this Spring Web application, responsible for handling all application requests --\u003e \u003cservlet\u003e \u003cservlet-name\u003espringDispatcherServlet\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:applicationContext-controller.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!-- Map all requests to the DispatcherServlet for handling --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringDispatcherServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e index.jsp \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" %\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003ctitle\u003eInsert title here\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ca href=\"studentController/queryStudentByNum/1\"\u003e查询一号学生\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e result.jsp \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"ISO-8859-1\"%\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003ctitle\u003eInsert title here\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e ${requestScope.student.stunum}+${requestScope.student.name}+${requestScope.student.age} \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-30","objectID":"/ssm%E6%95%B4%E5%90%88/:1:2","tags":["框架","整理"],"title":"SSM整合","uri":"/ssm%E6%95%B4%E5%90%88/"},{"categories":["前端"],"content":"前端-js-定时器延时器 ","date":"2020-04-30","objectID":"/%E5%89%8D%E7%AB%AF-js-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%99%A8/:0:0","tags":[],"title":"前端-js-定时器延时器","uri":"/%E5%89%8D%E7%AB%AF-js-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%99%A8/"},{"categories":["前端"],"content":"定时调用 setInterval() 定时调用 可以将一个函数，每隔一段时间执行一次 参数： 1.回调函数，该函数会每隔一段时间被调用一次 2.每次调用间隔的时间，单位是毫秒 返回值： 返回一个Number类型的数据 这个数字用来作为定时器的唯一标识 clearInterval(timer) 关闭定时器 var num = 1; var timer = setInterval(function(){ count.innerHTML = num++; if(num == 11){ //关闭定时器 clearInterval(timer); } },1000); ","date":"2020-04-30","objectID":"/%E5%89%8D%E7%AB%AF-js-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%99%A8/:1:0","tags":[],"title":"前端-js-定时器延时器","uri":"/%E5%89%8D%E7%AB%AF-js-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%99%A8/"},{"categories":["前端"],"content":"延时调用 延时调用， 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次 var timer = setTimeout(function(){ console.log(num++); },3000); //使用clearTimeout()来关闭一个延时调用 clearTimeout(timer); ","date":"2020-04-30","objectID":"/%E5%89%8D%E7%AB%AF-js-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%99%A8/:2:0","tags":[],"title":"前端-js-定时器延时器","uri":"/%E5%89%8D%E7%AB%AF-js-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6%E5%99%A8/"},{"categories":["Spring"],"content":"后端-SpringMVC(day11)-异常 ","date":"2020-04-28","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday11-%E5%BC%82%E5%B8%B8/:0:0","tags":[],"title":"后端-SpringMVC(day11)-异常","uri":"/%E5%90%8E%E7%AB%AF-springmvcday11-%E5%BC%82%E5%B8%B8/"},{"categories":["Spring"],"content":"@ExceptionHandler ExceptionHandlerExceptionResolver： 主要提供了@ExceptionHandler注解，并通过该注解处理异常 @ExceptionHandler 对方法使用 可以捕获 本类中 抛出的异常 传递异常信息时不可以使用Map 如果出现两个方法都可以处理异常 最短优先 @ExceptionHandler({ArithmeticException.class,ArrayIndexOutOfBoundsException.class}) public ModelAndView handlerArithmeticException(Exception e){ System.out.println(e); ModelAndView modelAndView = new ModelAndView(\"error\"); modelAndView.addObject(\"e\",e); return modelAndView; } 如果要使用该方法处理别的类中的异常 在类上使用注释@ControllerAdvice package org.jsh.exception; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.servlet.ModelAndView; //该类中的任何处理异常的方法 可以处理任何类中的异常 @ControllerAdvice public class MyExceptionHandler {// 不是控制器，处理异常的类 @ExceptionHandler({ArithmeticException.class,ArrayIndexOutOfBoundsException.class}) public ModelAndView handlerArithmeticException(Exception e){ System.out.println(e); ModelAndView modelAndView = new ModelAndView(\"error\"); modelAndView.addObject(\"e\",e); return modelAndView; } } ","date":"2020-04-28","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday11-%E5%BC%82%E5%B8%B8/:1:0","tags":[],"title":"后端-SpringMVC(day11)-异常","uri":"/%E5%90%8E%E7%AB%AF-springmvcday11-%E5%BC%82%E5%B8%B8/"},{"categories":["Spring"],"content":"@ResponseStatus ResponseStatusExceptionResolver：自定义异常显示页面 @ResponseStatus 类的方法 package org.jsh.exception; import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ResponseStatus; @ResponseStatus(value = HttpStatus.FORBIDDEN,reason = \"数组越界\") public class MyArrayIndexOutofBoundsException extends Exception { } 使用 @RequestMapping(\"testMyException\") public String testMyException(@RequestParam(\"i\") int i) throws MyArrayIndexOutofBoundsException { if (i==3){ throw new MyArrayIndexOutofBoundsException(); } return \"succes\"; } 方法 @ResponseStatus(value = HttpStatus.FORBIDDEN,reason = \"测试\") @RequestMapping(\"testResponseStatus\") public String testResponseStatus(){ return \"succes\"; } 使用 @RequestMapping(\"testMyException2\") public String testMyException2(@RequestParam(\"i\") int i){ if (i==3){ return \"redirect:testResponseStatus\"; } return \"succes\"; } ","date":"2020-04-28","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday11-%E5%BC%82%E5%B8%B8/:2:0","tags":[],"title":"后端-SpringMVC(day11)-异常","uri":"/%E5%90%8E%E7%AB%AF-springmvcday11-%E5%BC%82%E5%B8%B8/"},{"categories":["Spring"],"content":"SimpleMappingExceptionResolver 通过配置来实现异常的处理 \u003c!-- SimpleMappingExceptionResolver:以配置方式处理异常--\u003e \u003cbean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"\u003e \u003c!-- 将错误信息存放在request域中 如果不写 默认存放在exception中--\u003e \u003c!-- \u003cproperty name=\"exceptionAttribute\" value=\"e\"\u003e--\u003e \u003c!-- \u003c/property\u003e--\u003e \u003cproperty name=\"exceptionMappings\"\u003e \u003cprops\u003e \u003cprop key=\"java.lang.ArithmeticException\"\u003e error \u003c/prop\u003e \u003cprop key=\"java.lang.NullPointerException\"\u003e error \u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e ","date":"2020-04-28","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday11-%E5%BC%82%E5%B8%B8/:3:0","tags":[],"title":"后端-SpringMVC(day11)-异常","uri":"/%E5%90%8E%E7%AB%AF-springmvcday11-%E5%BC%82%E5%B8%B8/"},{"categories":["Spring"],"content":"后端-SpringMVC(day10) ","date":"2020-04-26","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday10/:0:0","tags":[],"title":"后端-SpringMVC(day10)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday10/"},{"categories":["Spring"],"content":"文件上传 和Servlet方式的本质一样，都是通过commons-fileupload.jar和commons-io.jar SpringMVC可以简化文件上传的代码，但是必须满足条件：实现MultipartResolver接口 ；而该接口的实现类SpringMVC也已经提供了CommonsMultipartResolver jar commons-fileupload.jar commons-io.jar 配置 CommonsMultipartResolver类中有许多属性可以配置 \u003c!-- 配置CommonsMultipartResolver，用于实现文件上传，将其加入到SpringIOC容器中,固定id：multipartResolver--\u003e \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e \u003cproperty name=\"defaultEncoding\" value=\"UTF-8\"\u003e\u003c/property\u003e \u003c!-- 上传单个文件最大值，单位Byte -1表示无限制--\u003e \u003cproperty name=\"maxUploadSize\" value=\"1024000000\"\u003e\u003c/property\u003e \u003c/bean\u003e 处理方法 文件使用@RequestParam(“file”) MultipartFile file来接收 然后用流的方法保存 @RequestMapping(value=\"testUpload\") public String testUpload(@RequestParam(\"desc\") String desc,@RequestParam(\"file\") MultipartFile file) throws IOException { System.out.println(desc); // file InputStream inputStream = file.getInputStream(); String fileName = file.getOriginalFilename(); OutputStream outputStream = new FileOutputStream(\"d:\\\\\"+fileName); byte[] bs = new byte[1024]; int len = -1; while ((len = inputStream.read(bs))!=-1){ outputStream.write(bs,0,len); } outputStream.close(); inputStream.close(); return \"succes\"; } 前端页面 \u003cform action=\"SpringMVCHandler/testUpload\" method=\"post\" enctype=\"multipart/form-data\"\u003e 描述：\u003cinput name=\"desc\" type=\"text\"\u003e \u003cinput type=\"file\" name=\"file\"\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e ","date":"2020-04-26","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday10/:1:0","tags":[],"title":"后端-SpringMVC(day10)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday10/"},{"categories":["Spring"],"content":"拦截器 拦截器的原理和过滤器相同。 SpringMVC：要想实现拦截器，必须实现一个接口HandlerInterceptor 编写拦截器 package org.jsh.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { //拦截请求 @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\"拦截请求\"); return true;//true：拦截之后放行 false：拦截之后不放行 } //拦截响应 @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\"拦截响应\"); } //视图(jsp)被渲染完毕 @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\"视图(jsp)被渲染完毕\"); } } 配置 \u003c!-- 配置拦截器--\u003e \u003cmvc:interceptors\u003e \u003c!--\u0026lt;!\u0026ndash; 默认拦截全部\u0026ndash;\u0026gt;--\u003e \u003c!-- \u003cbean class=\"org.jsh.interceptor.MyInterceptor\"\u003e\u003c/bean\u003e--\u003e \u003c!-- 配置具体的拦截路径--\u003e \u003cmvc:interceptor\u003e \u003c!-- 指定拦截的路径，基于ant风格 --\u003e \u003cmvc:mapping path=\"/**\"/\u003e \u003c!-- 指定不拦截的路径--\u003e \u003cmvc:exclude-mapping path=\"/SpringMVCHandler/testUpload\"/\u003e \u003cbean class=\"org.jsh.interceptor.MyInterceptor\"\u003e\u003c/bean\u003e \u003c/mvc:interceptor\u003e \u003c/mvc:interceptors\u003e 如果有多个拦截器 拦截顺序 ： 拦截请求 拦截请求2 zs 拦截响应2 拦截响应 视图(jsp)被渲染完毕2 视图(jsp)被渲染完毕 ","date":"2020-04-26","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday10/:2:0","tags":[],"title":"后端-SpringMVC(day10)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday10/"},{"categories":["Spring"],"content":"后端-SpringMVC(day9) ","date":"2020-04-25","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday9/:0:0","tags":[],"title":"后端-SpringMVC(day9)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday9/"},{"categories":["Spring"],"content":"数据校验 jar hibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jar validation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar 配置 \u003cmvc:annotation-driven \u003e\u003c/mvc:annotation-driven\u003e 此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory LocalValidatorFactoryBean是ValidatorFactory的一个实现类。 \u003cmvc:annotation-driven \u003e\u003c/mvc:annotation-driven\u003e会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。 使用 public class Student { @Past//当前时间以前 private Date birthday ; } 在校验的Controller中 ，给校验的对象前增加 @Valid public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map\u003cString,Object\u003e map) { {...} ","date":"2020-04-25","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday9/:1:0","tags":[],"title":"后端-SpringMVC(day9)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday9/"},{"categories":["Spring"],"content":"注解 注解 简介 @Null 被注释的元素必须为 null。 @NotNull 被注释的元素必须不为 null。 @AssertTrue 被注释的元素必须为 true。 @AssertFalse 被注释的元素必须为 false。 @Min(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @Max(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @Size(max, min) 被注释的元素的取值范围必须是介于min和max之间。 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内。 @Past 被注释的元素必须是一个过去的日期。 @Future 被注释的元素必须是一个将来的日期。 @Pattern(value) 被注释的元素必须符合指定的正则表达式。 注解 简介 @Email 被注释的元素值必须是合法的电子邮箱地址。 @Length 被注释的字符串的长度必须在指定的范围内。 @NotEmpty 被注释的字符串的必须非空。 @Range 被注释的元素必须在合适的范围内。 ","date":"2020-04-25","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday9/:1:1","tags":[],"title":"后端-SpringMVC(day9)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday9/"},{"categories":["Spring"],"content":"Ajax请求SpringMVC，并且JSON格式的数据 jar jackson-annotations-2.8.9.jar jackson-core-2.8.9.jar jackson-databind-2.8.9.jar handler @ResponseBody//告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） @ResponseBody @RequestMapping(value=\"testJson\") public List\u003cStudent\u003e SpringMVCHandler(){ List\u003cStudent\u003e students = new ArrayList\u003c\u003e(); Student student1 = new Student(4,\"zs\"); Student student2 = new Student(2,\"zs\"); Student student3 = new Student(1,\"zs\"); students.add(student1); students.add(student2); students.add(student3); return students; } 前端页面 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e$Title$\u003c/title\u003e \u003cscript type=\"text/javascript\" src=\"js/jquery-1.8.3.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { $(\"#testJson\").click(function () { $.post( \"SpringMVCHandler/testJson\",//服务器地址 function (result) {//回调函数 List\u003cStudent\u003e json数组格式 for(var i=0;i\u003cresult.length;i++){ console.log(result[i].id+\"-\"+result[i].name); } } ); }) }) \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"json\" id=\"testJson\"\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-25","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday9/:2:0","tags":[],"title":"后端-SpringMVC(day9)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday9/"},{"categories":["Spring"],"content":"后端-SpringMVC(day8) ","date":"2020-04-24","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday8/:0:0","tags":[],"title":"后端-SpringMVC(day8)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday8/"},{"categories":["Spring"],"content":"数据格式化 用到的类 org.springframework.format.support.FormattingConversionServiceFactoryBean springmvc中的配置 \u003c!--配置数据格式化 注解 所依赖的bean--\u003e \u003cbean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"\u003e \u003c/bean\u003e @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday; @NumberFormat(pattern = \"###,#\") private int id; 应用 \u003cform action=\"SpringMVCHandler/testDateTimeFarmat\" method=\"get\"\u003e 编号：\u003cinput name=\"id\" type=\"text\"\u003e 姓名：\u003cinput name=\"name\" type=\"text\"\u003e 出生日期：\u003cinput name=\"birthday\" type=\"text\"\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e @RequestMapping(value=\"testDateTimeFarmat\") public String testDateTimeFarmat(Student student, BindingResult result){ if(result.getErrorCount()\u003e0){ for(FieldError error:result.getFieldErrors()){ System.out.println(error.getDefaultMessage()); } } System.out.println(student); return \"succes\"; } ","date":"2020-04-24","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday8/:1:0","tags":[],"title":"后端-SpringMVC(day8)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday8/"},{"categories":["Spring"],"content":"补充 前边 类型转换器用的类是ConversionServiceFactoryBean 可以改为FormattingConversionServiceFactoryBean 就可以满足两个功能 ","date":"2020-04-24","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday8/:1:1","tags":[],"title":"后端-SpringMVC(day8)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday8/"},{"categories":["Spring"],"content":"错误消息传前端 错误消息： public String testDateTimeFormat(Student student, BindingResult result ,Map\u003cString,Object\u003e map) { 需要验证的数据是 Student中的birthday, SPringMVC要求 如果校验失败 则将错误信息 自动放入 该对象之后紧挨着的 BindingResult中。 即Student student, BindingResult result之间 不能有其他参数。 如果要将控制台的错误消息 传到jsp中显示，则可以将 错误消息对象放入request域中，然后 在jsp中 从request中获取。 ","date":"2020-04-24","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday8/:2:0","tags":[],"title":"后端-SpringMVC(day8)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday8/"},{"categories":["Spring"],"content":"后端-SpringMVC(day7) ","date":"2020-04-22","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday7/:0:0","tags":[],"title":"后端-SpringMVC(day7)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday7/"},{"categories":["Spring"],"content":"1.SpringMVC实现：index.jsp -\u003e succes.jsp index.jsp \u003ca href=\"handler/testMvcViewController\"\u003ehandler/testMvcViewController\u003c/a\u003e springmvc.xml 单独使用mvc:view-controller时会屏蔽原本的@RequestMapping形式跳转 需要使用mvc:annotation-driven协调 \u003c!-- view-name 会被视图解析器加上 前缀 后缀 --\u003e \u003cmvc:view-controller path=\"handler/testMvcViewController\" view-name=\"succes\"\u003e\u003c/mvc:view-controller\u003e \u003c!-- 此配置是SpringMVC的基础配置，很多功能都需要通过该注解来协调 --\u003e \u003cmvc:annotation-driven\u003e\u003c/mvc:annotation-driven\u003e ","date":"2020-04-22","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday7/:1:0","tags":[],"title":"后端-SpringMVC(day7)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday7/"},{"categories":["Spring"],"content":"2.指定请求方式 默认为request 指定跳转方式：return “forward:/views/success.jsp”; forward: redirect: ，需要注意 此种方式，不会被视图解析器加上前缀(/views)、后缀(.jsp) @RequestMapping(value=\"testModelMap\") public String testModelMap(ModelMap modelMap){//ModelAndView既有数据又有视图 Student student = new Student(); student.setName(\"aaa\"); modelMap.put(\"student\",student); //String s = \"forward:/views/succes.jsp\";//请求转发 默认 String s = \"redirect:/views/succes.jsp\";//重定向 return s; } ","date":"2020-04-22","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday7/:2:0","tags":[],"title":"后端-SpringMVC(day7)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday7/"},{"categories":["Spring"],"content":"3.处理静态资源 原本使用静态资源会被拦截寻找对应的@RequestMapping \u003cservlet-mapping\u003e \u003cservlet-name\u003espringDispatcherServelet\u003c/servlet-name\u003e \u003c!--拦截所有--\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 解决 如果是 需要mvc处理的，则交给@RequsetMapping(“img.png”)处理；如果不需要springmvc处理，则使用 tomcat默认的Servlet去处理。 tomcat默认的Servlet去处理：如果有 对应的请求拦截,则交给相应的Servlet去处理；如果没有对应的servlet，则直接访问。 在springmvc.xml中添加两个注解 \u003c!-- 此配置是SpringMVC的基础配置，很多功能都需要通过该注解来协调 --\u003e \u003cmvc:annotation-driven\u003e\u003c/mvc:annotation-driven\u003e \u003c!-- 该注解会让 springmvc：接收一个请求，并且该请求没有对应的@requestmapping时，将该请求交给默认的servlet--\u003e \u003cmvc:default-servlet-handler\u003e\u003c/mvc:default-servlet-handler\u003e ","date":"2020-04-22","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday7/:3:0","tags":[],"title":"后端-SpringMVC(day7)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday7/"},{"categories":["Spring"],"content":"4.类型转换 Spring自带类型转换 自定义类型转换器 编写 自定义类型转器的类 （实现Converter接口） package org.jsh.converter; import org.jsh.entity.Student; import org.springframework.core.convert.converter.Converter; public class MyConverter implements Converter\u003cString, Student\u003e { @Override public Student convert(String source) { Student student = new Student(); String[] studentStrArr = source.split(\"-\"); student.setId(Integer.parseInt(studentStrArr[0])); student.setName(studentStrArr[1]); return student; } } 配置：将MyConverter加入到springmvc中 \u003c!-- 类型转换器配置--\u003e \u003c!-- 1.将自定义转换器纳入SpringIOC容器中--\u003e \u003cbean id=\"myConverter\" class=\"org.jsh.converter.MyConverter\"\u003e\u003c/bean\u003e \u003c!-- 2.将myConverter纳入SpringMVC提供的转换器bean--\u003e \u003cbean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"\u003e \u003cproperty name=\"converters\"\u003e \u003cset\u003e \u003cref bean=\"myConverter\"/\u003e \u003c/set\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 3.将conversionService注册到annotation-driven中--\u003e \u003c!-- 此配置是SpringMVC的基础配置，很多功能都需要通过该注解来协调 --\u003e \u003cmvc:annotation-driven conversion-service=\"conversionService\"\u003e\u003c/mvc:annotation-driven\u003e 测试 index.jsp \u003cform action=\"SpringMVCHandler/testConverter\" method=\"get\"\u003e 学生信息：\u003cinput name=\"studentInfo\" type=\"text\"\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e SpringMVCHandler.java @RequestMapping(value=\"testConverter\") public String testConverter(@RequestParam(\"studentInfo\")Student student){//ModelAndView既有数据又有视图 System.out.println(student); return \"succes\"; } ","date":"2020-04-22","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday7/:4:0","tags":[],"title":"后端-SpringMVC(day7)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday7/"},{"categories":["前端"],"content":"前端-CSS-Grid网格布局 ","date":"2020-04-21","objectID":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/:0:0","tags":[],"title":"前端-CSS-Grid网格布局","uri":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"容器属性 grid-template-columns 列宽 grid-template-columns: 70% 30%; 百分比设置 grid-template-columns: 1fr 2fr 1fr; 比例设置（推荐使用） grid-template-columns: repeat(3,1fr); 使用函数进行比例设置 grid-column-gap 列间距 grid-row-gap 行间距 grid-gap 统一设置列间距和行间距 grid-auto-rows 行高 grid-auto-rows: 100px; 固定数值 grid-auto-rows: minmax(100px,auto); 通过函数设置最大最小值 防止内容超出 justify-items 列对齐方式 默认值为stretch 拉伸 align-items 行对齐方式 默认值为stretch 拉伸 grid-template-areas 设置模板 与子组件属性grid-area搭配使用 ","date":"2020-04-21","objectID":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/:1:0","tags":[],"title":"前端-CSS-Grid网格布局","uri":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"子组件属性 align-self 行对齐方式 默认值为stretch 拉伸 justify-self 列对齐方式 默认值为stretch 拉伸 grid-column 跨列 grid-row 跨行 grid-area 与grid-template-areas配合使用 ","date":"2020-04-21","objectID":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/:2:0","tags":[],"title":"前端-CSS-Grid网格布局","uri":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"基础布局 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eCSS Grid2\u003c/title\u003e \u003cstyle\u003e .wrapper { display: grid; /* 推荐 比例 */ /* grid-template-columns: 1fr 2fr 1fr; */ grid-template-columns: repeat(3,1fr); /* 间距 */ grid-gap: 1rem; /* 行高 */ grid-auto-rows: 100px; /* minmax函数 用来限制框的最大最小值 */ grid-auto-rows: minmax(100px,auto); } .wrapper\u003ediv { background: #eee; padding: 1rem; } .wrapper\u003ediv:nth-child(odd) { background: #ddd; } .nested{ display: grid; grid-template-columns: repeat(3,1fr); grid-gap: 1rem; grid-auto-rows: minmax(20px,auto); } .nested\u003ediv{ border: 1px #333 solid; padding: 1rem; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv\u003eLorem ipsum dolor, sit amet consectetur adipisicing elit. Aliquid eum, quos unde soluta, sapiente accusamus nesciunt earum corrupti cumque explicabo ducimus labore similique? Aperiam totam incidunt reiciendis facilis blanditiis soluta!\u003c/div\u003e \u003cdiv\u003eLorem ipsum dolor, sit amet consectetur adipisicing elit. Aliquid eum, quos unde soluta, sapiente accusamus nesciunt earum corrupti cumque explicabo ducimus labore similique? Aperiam totam incidunt reiciendis facilis blanditiis soluta!\u003c/div\u003e \u003cdiv class=\"nested\"\u003e \u003cdiv\u003e111\u003c/div\u003e \u003cdiv\u003e222\u003c/div\u003e \u003cdiv\u003e333\u003c/div\u003e \u003cdiv\u003e111\u003c/div\u003e \u003cdiv\u003e222\u003c/div\u003e \u003cdiv\u003e333\u003c/div\u003e \u003cdiv\u003e111\u003c/div\u003e \u003cdiv\u003e222\u003c/div\u003e \u003cdiv\u003e333\u003c/div\u003e \u003cdiv\u003e111\u003c/div\u003e \u003cdiv\u003e222\u003c/div\u003e \u003cdiv\u003e333\u003c/div\u003e \u003c/div\u003e \u003cdiv\u003eLorem ipsum dolor, sit amet consectetur adipisicing elit. Aliquid eum, quos unde soluta, sapiente accusamus nesciunt earum corrupti cumque explicabo ducimus labore similique? Aperiam totam incidunt reiciendis facilis blanditiis soluta!\u003c/div\u003e \u003cdiv\u003eLorem ipsum dolor, sit amet consectetur adipisicing elit. Aliquid eum, quos unde soluta, sapiente accusamus nesciunt earum corrupti cumque explicabo ducimus labore similique? Aperiam totam incidunt reiciendis facilis blanditiis soluta!\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-21","objectID":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/:3:0","tags":[],"title":"前端-CSS-Grid网格布局","uri":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"跨行 跨列 具体使用 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eCSS Grid2\u003c/title\u003e \u003cstyle\u003e .wrapper { display: grid; grid-template-columns: 1fr 2fr 1fr; grid-auto-rows: minmax(100px,auto); grid-gap: 1rem; justify-items: stretch; align-items: stretch; } .wrapper\u003ediv { background: #eee; padding: 1rem; } .wrapper\u003ediv:nth-child(odd) { background: #ddd; } .box1{ /* align-self: start; */ /* 跨列 */ grid-column: 1/3; grid-row: 1/3; } .box2{ /* align-self: end; */ grid-column: 3; grid-row: 1/3; } .box3{ /* justify-self: end; */ grid-column: 2/4; grid-row: 3; } .box4{ /* justify-self: start; */ grid-column: 1; grid-row: 2/4; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"box1\"\u003e 111 \u003c/div\u003e \u003cdiv class=\"box2\"\u003e 111 \u003c/div\u003e \u003cdiv class=\"box3\"\u003e 111 \u003c/div\u003e \u003cdiv class=\"box4\"\u003e 111 \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-21","objectID":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/:4:0","tags":[],"title":"前端-CSS-Grid网格布局","uri":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"模板具体使用 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eCSS Grid4\u003c/title\u003e \u003cstyle\u003e .wrapper{ display: grid; grid-template-areas: 'a a a' 'b b c' 'd e f'; grid-gap: 1rem; } .box1{ grid-area: a; } .box2{ grid-area:b; } .box3{ grid-area:c; } .box4{ grid-area: d; } .box5{ grid-area:e; } .box6{ grid-area:f; } .wrapper\u003ediv { background: #eee; padding: 1rem; } .wrapper\u003ediv:nth-child(odd) { background: #ddd; } @media(max-width: 700px) { .wrapper{ grid-template-areas: 'a''b''c''d''e''f'; } } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"box1\"\u003eLorem ipsum dolor, sit amet consectetur adipisicing elit. Ad laudantium explicabo impedit. Aliquid, aut doloremque illo eum ex deleniti unde ea non optio laboriosam voluptas ipsum voluptatibus illum, quaerat obcaecati inventore, temporibus vel earum quibusdam necessitatibus? Aperiam tempore ullam assumenda nulla facere! Architecto reiciendis nisi ex totam labore. Ad ipsam quae eligendi cupiditate maxime commodi reprehenderit similique exercitationem nam porro ducimus quos facere incidunt natus magni cum fugit culpa soluta, sed maiores doloribus voluptatum deserunt. Ex consequatur eius atque ipsa! \u003c/div\u003e \u003cdiv class=\"box2\"\u003eLorem ipsum dolor sit amet consectetur adipisicing elit. Saepe accusamus doloribus fuga dolores natus, sapiente vero veritatis aut facere itaque eos quam fugiat maxime aperiam possimus reiciendis? Voluptatibus, nostrum expedita! \u003c/div\u003e \u003cdiv class=\"box3\"\u003eLorem ipsum dolor, sit amet consectetur adipisicing elit. Ad laudantium explicabo impedit. Aliquid, aut doloremque illo eum ex deleniti unde ea non optio laboriosam voluptas ipsum voluptatibus illum, quaerat obcaecati inventore, temporibus vel earum quibusdam necessitatibus? Aperiam tempore ullam assumenda nulla facere! Architecto reiciendis nisi ex totam labore. Ad ipsam quae eligendi cupiditate maxime commodi reprehenderit similique exercitationem nam porro ducimus quos facere incidunt natus magni cum fugit culpa soluta, sed maiores doloribus voluptatum deserunt. Ex consequatur eius atque ipsa! \u003c/div\u003e \u003cdiv class=\"box4\"\u003eLorem ipsum dolor sit amet consectetur adipisicing elit. Saepe accusamus doloribus fuga dolores natus, sapiente vero veritatis aut facere itaque eos quam fugiat maxime aperiam possimus reiciendis? Voluptatibus, nostrum expedita! \u003c/div\u003e \u003cdiv class=\"box5\"\u003eLorem ipsum dolor, sit amet consectetur adipisicing elit. Ad laudantium explicabo impedit. Aliquid, aut doloremque illo eum ex deleniti unde ea non optio laboriosam voluptas ipsum voluptatibus illum, quaerat obcaecati inventore, temporibus vel earum quibusdam necessitatibus? Aperiam tempore ullam assumenda nulla facere! Architecto reiciendis nisi ex totam labore. Ad ipsam quae eligendi cupiditate maxime commodi reprehenderit similique exercitationem nam porro ducimus quos facere incidunt natus magni cum fugit culpa soluta, sed maiores doloribus voluptatum deserunt. Ex consequatur eius atque ipsa! \u003c/div\u003e \u003cdiv class=\"box6\"\u003eLorem ipsum dolor sit amet consectetur adipisicing elit. Saepe accusamus doloribus fuga dolores natus, sapiente vero veritatis aut facere itaque eos quam fugiat maxime aperiam possimus reiciendis? Voluptatibus, nostrum expedita! \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-21","objectID":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/:5:0","tags":[],"title":"前端-CSS-Grid网格布局","uri":"/%E5%89%8D%E7%AB%AF-css-grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"categories":["Spring"],"content":"后端-SpringMVC(day6) ","date":"2020-04-21","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday6/:0:0","tags":[],"title":"后端-SpringMVC(day6)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday6/"},{"categories":["Spring"],"content":"国际化(视图解析器) 创建资源文件 基名 _ 语言 _ 地区.properties 基名_语言.properties 数据以k v对形式存在 //i18n_zh_CN.properties resource.welcome=\\u4F60\\u597D resource.exist=\\u9000\\u51FA //i18n_en_US.properties resource.welcome=WELCOME resource.exist=EXIST 配置springmvc.xml，加载资源文件 \u003c!--加载国际化配置文件 1.加入SpringMVC id=\"\" 2.配置ResourceBundleMessageSource --\u003e \u003cbean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"\u003e \u003cproperty name=\"basename\" value=\"i18n\"\u003e\u003c/property\u003e \u003c/bean\u003e 通过jstl使用国际化 jstl.jar standar.jar \u003c%-- Created by IntelliJ IDEA. User: Mr.J Date: 2020/4/7 Time: 18:27 To change this template use File | Settings | File Templates. --%\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isErrorPage=\"true\" %\u003e \u003c%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cfmt:message key=\"resource.welcome\"\u003e\u003c/fmt:message\u003e \u003ch1\u003ewelcome come111\u003c/h1\u003e ${requestScope.student.name} ${requestScope.student.id} \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-21","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday6/:1:0","tags":[],"title":"后端-SpringMVC(day6)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday6/"},{"categories":["Spring"],"content":"后端-SpringMVC(day5) ","date":"2020-04-20","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday5/:0:0","tags":[],"title":"后端-SpringMVC(day5)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday5/"},{"categories":["Spring"],"content":"ModelAndView 如果跳转时需要带数据：V、M,则可以使用以下方式： ModelAndView、ModelMap 、Map、Model -数据放在了request作用域 ","date":"2020-04-20","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday5/:1:0","tags":[],"title":"后端-SpringMVC(day5)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday5/"},{"categories":["Spring"],"content":"ModelAndView 方法的返回值变为 ModelAndView ModelAndView modelAndView = new ModelAndView(“succes”); 使用addObject方法将数据加入到request域中 @RequestMapping(value=\"testModelAndView\") public ModelAndView testModelAndView(){//ModelAndView既有数据又有视图 ModelAndView modelAndView = new ModelAndView(\"succes\"); // view/succes.jsp Student student = new Student(); student.setName(\"aaa\"); modelAndView.addObject(\"student\",student);//相当于request.setAttribute(\"student\",student) return modelAndView; } ","date":"2020-04-20","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday5/:1:1","tags":[],"title":"后端-SpringMVC(day5)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday5/"},{"categories":["Spring"],"content":"ModelMap 、Map、Model 三者基本一样 返回值为String类型 传递参数 使用方法加入到request域中 @RequestMapping(value=\"testModelMap\") public String testModelMap(ModelMap modelMap){//ModelAndView既有数据又有视图 Student student = new Student(); student.setName(\"aaa\"); modelMap.put(\"student\",student); return \"succes\"; } @RequestMapping(value=\"testModel\") public String testModel(Model model){//ModelAndView既有数据又有视图 Student student = new Student(); student.setName(\"aaa\"); model.addAttribute(\"student\",student); return \"succes\"; } @RequestMapping(value=\"testMap\") public String testMap(Map\u003cString,Object\u003e map){//ModelAndView既有数据又有视图 Student student = new Student(); student.setName(\"aaa\"); map.put(\"student\",student); return \"succes\"; } ","date":"2020-04-20","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday5/:1:2","tags":[],"title":"后端-SpringMVC(day5)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday5/"},{"categories":["Spring"],"content":"注解@SessionAttributes 将数据存放在session域中 request中也会保存（从request中复制到session） 位置: 类前 多个值用大括号 //@SessionAttributes(\"student\") //存放student对象 request域中也有 复制了一份到session中 //@SessionAttributes(types = Student.class) //将Student类型的存放在session中 ","date":"2020-04-20","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday5/:2:0","tags":[],"title":"后端-SpringMVC(day5)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday5/"},{"categories":["Spring"],"content":"注解@ModelAttribute i.经常在 更新时使用 ii.在不改变原有代码的基础之上，插入一个新方法。 必须满足的约定： map.put(k,v) 其中的k 必须是即将查询的方法参数 的首字母小写 testModelAttribute(Student xxx) ，即student； 如果不一致，需要通过@ModelAttribute声明 @ModelAttribute//在执行任何一次请求前都会执行 // 在请求该类的方法前都被执行： 思想：一个控制器只做一个功能 public void queryStudentById(Map\u003cString,Object\u003e map){ //模拟查询 Student student = new Student(); student.setId(31); student.setName(\"zs\"); Address address = new Address(); address.setHomeAddress(\"sss\"); address.setSchoolAddress(\"bbb\"); student.setAddress(address); //map.put(\"student\",student);//约定：map的key 就是方法参数类型的首字母的小写 map.put(\"stu\",student); } @RequestMapping(value=\"testModelAttribute\") public String testModelAttribute(@ModelAttribute(\"stu\")Student student){//ModelAndView既有数据又有视图 student.setName(\"ls\"); System.out.println(student); return \"succes\"; } ","date":"2020-04-20","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday5/:3:0","tags":[],"title":"后端-SpringMVC(day5)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday5/"},{"categories":["Spring"],"content":"后端-SpringMVC(day4) 使用注解接收参数 SpringMVC处理各种参数的流程/逻辑： 请求： 前端发请求a-\u003e @RequestMappting(“a”) 处理请求中的参数xyz： @RequestMappting(“a”) public String aa(@Xxx注解(“xyz”) xyz) { ​ } \u003cform action=\"SpringMVCHandler/testParam\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"uname\"\u003e \u003cinput type=\"text\" name=\"uage\"\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e @RequestMapping(value=\"testParam\") public String testParam(@RequestParam(\"uname\") String name,@RequestParam(value = \"uage\",required = false,defaultValue = \"23\") int age){ System.out.println(name+age); return \"succes\"; // view/succes.jsp } //获取请求头 @RequestMapping(value=\"testRequestHeader\") public String testRequestHeader(@RequestHeader(\"Accept-Encoding\") String al){ System.out.println(al); return \"succes\"; // view/succes.jsp } //获取Cookie @RequestMapping(value=\"testCookieValue\") public String testCookieValue(@CookieValue(\"JSESSIONID\") String al){ System.out.println(al); return \"succes\"; // view/succes.jsp } ","date":"2020-04-10","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday4/:0:0","tags":[],"title":"后端-SpringMVC(day4)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday4/"},{"categories":["Spring"],"content":"Object 直接将前端数据封装到实体类中 必须与实体类属性一一对应 支持级联 \u003cform action=\"SpringMVCHandler/testObjectProperties\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"id\"\u003e \u003cinput type=\"text\" name=\"name\"\u003e \u003cinput type=\"text\" name=\"address.homeAddress\"\u003e \u003cinput type=\"text\" name=\"address.schoolAddress\"\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e @RequestMapping(value=\"testObjectProperties\") public String testObjectProperties(Student student){//student属性必须和from表单中的属性Name一致 支持级联属性 System.out.println(student); return \"succes\"; // view/succes.jsp } ","date":"2020-04-10","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday4/:1:0","tags":[],"title":"后端-SpringMVC(day4)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday4/"},{"categories":["Spring"],"content":"使用ServletAPI 直接写在参数中 //使用servlet中的对象 直接传递参数 @RequestMapping(value=\"testServletAPI\") public String testServletAPI(HttpServletRequest request, HttpServletResponse response){ request.getParameter(\"uname\"); return \"succes\"; // view/succes.jsp } ","date":"2020-04-10","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday4/:2:0","tags":[],"title":"后端-SpringMVC(day4)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday4/"},{"categories":["Spring"],"content":"后端-SpringMVC(day3) ","date":"2020-04-09","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday3/:0:0","tags":[],"title":"后端-SpringMVC(day3)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday3/"},{"categories":["Spring"],"content":"REST风格 Springmvc: GET :查 POST ：增 DELETE ：删 PUT ：改 普通浏览器 只支持get post方式 ；其他请求方式 如 delelte|put请求是通过 过滤器新加入的支持。 ","date":"2020-04-09","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday3/:1:0","tags":[],"title":"后端-SpringMVC(day3)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday3/"},{"categories":["Spring"],"content":"实现 增加过滤器 web.xml \u003cfilter\u003e \u003cfilter-name\u003eHiddenHttpMethodFilter\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.HiddenHttpMethodFilter\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eHiddenHttpMethodFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e 表单 DELETE ：删 PUT ：改 必须是post方式 通过隐藏域 的value值 设置实际的请求方式 DELETE|PUT \u003cform action=\"SpringMVCHandler/testPost/1234\" method=\"post\"\u003e \u003cinput type=\"submit\" value=\"增\"\u003e \u003c/form\u003e \u003cform action=\"SpringMVCHandler/testDelete/1234\" method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"_method\" value=\"DELETE\"\u003e \u003cinput type=\"submit\" value=\"删\"\u003e \u003c/form\u003e \u003cform action=\"SpringMVCHandler/testPut/1234\" method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"_method\" value=\"PUT\"\u003e \u003cinput type=\"submit\" value=\"改\"\u003e \u003c/form\u003e \u003cform action=\"SpringMVCHandler/testGet/1234\" method=\"get\"\u003e \u003cinput type=\"submit\" value=\"差\"\u003e \u003c/form\u003e 控制器 @RequestMapping(value=\"testPost/{id}\",method = RequestMethod.POST) public String testPost(@PathVariable(\"id\") int id){ System.out.println(\"增\"+id); return \"succes\"; // view/succes.jsp } @RequestMapping(value=\"testGet/{id}\",method = RequestMethod.GET) public String testGet(@PathVariable(\"id\") int id){ System.out.println(\"查\"+id); return \"succes\"; // view/succes.jsp } @RequestMapping(value=\"testDelete/{id}\",method = RequestMethod.DELETE) public String testDelete(@PathVariable(\"id\") int id){ System.out.println(\"删\"+id); return \"succes\"; // view/succes.jsp } @RequestMapping(value=\"testPut/{id}\",method = RequestMethod.PUT) public String testPut(@PathVariable(\"id\") int id){ System.out.println(\"改\"+id); return \"succes\"; // view/succes.jsp } 映射名相同时@RequestMapping(value=“testRest)，可以通过method处理不同的请求。 重名时会调用 不同的请求方法 ","date":"2020-04-09","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday3/:2:0","tags":[],"title":"后端-SpringMVC(day3)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday3/"},{"categories":["Spring"],"content":"后端-SpringMVC(day2) ","date":"2020-04-08","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday2/:0:0","tags":[],"title":"后端-SpringMVC(day2)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday2/"},{"categories":["Spring"],"content":"@RequestMapping 参数 映射是 去匹配@RequestMapping注解，可以和方法名、类名不一致 value=\"welcome\" 映射 method = RequestMethod.POST 规定提交方式 params = {\"name=zs\",\"age!=23\"} 对参数的限制 headers 网络 package org.jsh.handler; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; @Controller @RequestMapping(value=\"SpringMVCHandler\") //映射 public class SpringMVCHandler { @RequestMapping(value=\"welcome\", method = RequestMethod.POST, params = {\"name=zs\",\"age!=23\"}) public String welcome(){ return \"succes\"; // view/succes.jsp } @RequestMapping(value=\"welcome2\", headers = {\"Accept=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\"Accept-Encoding= gzip, deflate, br\"}) public String welcome2(){ return \"succes\"; // view/succes.jsp } @RequestMapping(value=\"welcome3/*/test\") public String welcome3(){ return \"succes\"; // view/succes.jsp } } \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e$Title$\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e $END$ \u003ca href=\"SpringMVCHandler/welcome3/ssssssssss/test\"\u003efirst springmvc\u003c/a\u003e \u003cform action=\"SpringMVCHandler/welcome\" method=\"post\"\u003e \u003cinput type=\"submit\" value=\"post\"\u003e \u003cinput name=\"name\" value=\"zs\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-08","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday2/:1:0","tags":[],"title":"后端-SpringMVC(day2)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday2/"},{"categories":["Spring"],"content":"ant风格的请求路径 ? 单字符 *任意个字符（0或多个） ** 任意目录 ","date":"2020-04-08","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday2/:2:0","tags":[],"title":"后端-SpringMVC(day2)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday2/"},{"categories":["Spring"],"content":"动态参数 通过@PathVariable获取 \u003ca href=\"SpringMVCHandler/welcome4/zs\"\u003efirst springmvc\u003c/a\u003e @RequestMapping(value=\"welcome4/{name}\") public String welcome4(@PathVariable(\"name\") String name){ System.out.println(name); return \"succes\"; // view/succes.jsp } ","date":"2020-04-08","objectID":"/%E5%90%8E%E7%AB%AF-springmvcday2/:3:0","tags":[],"title":"后端-SpringMVC(day2)","uri":"/%E5%90%8E%E7%AB%AF-springmvcday2/"},{"categories":["Spring"],"content":"后端-SpringMVC-1 jar commons-logging-1.1.1.jar spring-aop-4.3.9.RELEASE.jar spring-beans-4.3.9.RELEASE.jar spring-context-4.3.9.RELEASE.jar spring-core-4.3.9.RELEASE.jar spring-expression-4.3.9.RELEASE.jar spring-web-4.3.9.RELEASE.jar spring-webmvc-4.3.9.RELEASE.jar 配置 springmvc 配置 在src下 给使用注解的包配置扫描器 配置视图解析器 前缀 和 后缀 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!--suppress ALL --\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\"\u003e \u003c!-- 扫描 使用注解需要--\u003e \u003ccontext:component-scan base-package=\"org.jsh.handler\"\u003e\u003c/context:component-scan\u003e \u003c!--配置视图解析器--\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003cproperty name=\"prefix\" value=\"/views/\"\u003e\u003c/property\u003e \u003cproperty name=\"suffix\" value=\".jsp\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e web.xml 配置 \u003cservlet\u003e \u003cservlet-name\u003espringDispatcherServelet\u003c/servlet-name\u003e \u003c!--springmvc 类--\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--加载springmvc配置文件--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003espringDispatcherServelet\u003c/servlet-name\u003e \u003c!--拦截所有--\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 编写 第一个页面 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e$Title$\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e $END$ \u003ca href=\"welcome\"\u003efirst springmvc\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e 拦截 @Controller 使用注解 将普通类 变成控制器 @RequestMapping(“welcome”) 在方法上加注解 拦截对应的请求 return “succes” 配合springmvc 配置 拼接成 具体跳转目录 package org.jsh.handler; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class SpringMVCHandler { @RequestMapping(\"welcome\") public String welcome(){ return \"succes\"; // view/succes.jsp } } 第二个页面 在 web/views/ \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003ewelcome come111\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-07","objectID":"/%E5%90%8E%E7%AB%AF-springmvc-1/:0:0","tags":[],"title":"后端-SpringMVC(day1)","uri":"/%E5%90%8E%E7%AB%AF-springmvc-1/"},{"categories":["Spring"],"content":"Spring-Mybatis整合 思路： SqlSessionFactory -\u003e SqlSession -\u003eStudentMapper -\u003eCRUD 可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库， Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring jar mybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jar spring-context-support.jar spring-core.jar spring-context.jar spring-beans.jar spring-aop.jar spring-web.jar commons-logging.jar commons-dbcp.jar mysql-connector.jar mybatis.jar log4j.jar commons-pool.jar 建立 三层架构 表与实体类 通过mapper.xml将 类、表建立映射关系 配置文件 spring applicationContext.xml mybatis conf.xml(包含数据库信息 和加载mapper)合并到spring配置文件中 applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- 加载db.properties文件 --\u003e \u003cbean id=\"config\" class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"\u003e \u003cproperty name=\"locations\"\u003e \u003carray\u003e \u003cvalue\u003eclasspath:db.properties\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 第一种方式生成mapper对象 \u003cbean id=\"studentMapper\" class=\"org.lanqiao.dao.impl.StudentDaoImpl\"\u003e 将SPring配置的sqlSessionFactory 对象交给mapper(dao) \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFacotry\"\u003e\u003c/property\u003e \u003c/bean\u003e --\u003e \u003c!-- 第二种方式生成mapper对象 \u003cbean id=\"studentMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"\u003e \u003cproperty name=\"mapperInterface\" value=\"org.lanqiao.mapper.StudentMapper\"\u003e\u003c/property\u003e \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFacotry\"\u003e\u003c/property\u003e \u003c/bean\u003e --\u003e \u003c!-- 第三种方式生成mapper对象(批量产生多个mapper) 批量产生Mapper对在SpringIOC中的 id值 默认就是 首字母小写接口名 (首字母小写的接口名=id值) --\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFacotry\"\u003e\u003c/property\u003e \u003c!--指定批量产生 哪个包中的mapper对象 --\u003e \u003cproperty name=\"basePackage\" value=\"org.lanqiao.mapper\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"studentService\" class=\"org.lanqiao.service.impl.StudentServiceImpl\"\u003e \u003cproperty name=\"studentMapper\" ref=\"studentMapper\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- 配置配置数据库信息（替代mybatis的配置文件conf.xml） --\u003e \u003cbean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"${driver}\"\u003e\u003c/property\u003e \u003cproperty name=\"url\" value=\"${url}\"\u003e\u003c/property\u003e \u003cproperty name=\"username\" value=\"${username}\"\u003e\u003c/property\u003e \u003cproperty name=\"password\" value=\"${password}\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- 在SpringIoc容器中 创建MyBatis的核心类 SqlSesionFactory --\u003e \u003cbean id=\"sqlSessionFacotry\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"\u003e\u003c/property\u003e \u003c!-- 加载mybatis配置文件 \u003cproperty name=\"configLocation\" value=\"classpath:conf.xml\"\u003e\u003c/property\u003e --\u003e \u003c!-- 加载mapper.xml路径 --\u003e \u003cproperty name=\"mapperLocations\" value=\"org/lanqiao/mapper/*.xml\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e dao层实体类 在spring中实现的方式 a.第一种方式 DAO层实现类 继承 SqlSessionDaoSupport类 SqlSessionDaoSupport类提供了一个属性 SqlSession b.第二种方式 就是省略掉 第一种方式的 实现类 直接MyBatis提供的 Mapper实现类： org.mybatis.spring.mapper.MapperFactoryBean 缺点：每个mapper都需要一个配置一次 c.第三种方式 批量配置 实现类 \u003c!-- 第一种方式生成mapper对象 \u003cbean id=\"studentMapper\" class=\"org.lanqiao.dao.impl.StudentDaoImpl\"\u003e 将SPring配置的sqlSessionFactory 对象交给mapper(dao) \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFacotry\"\u003e\u003c/property\u003e \u003c/bean\u003e --\u003e \u003c!-- 第二种方式生成mapper对象 \u003cbean id=\"studentMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"\u003e \u003cproperty name=\"mapperInterface\" value=\"org.lanqiao.mapper.StudentMapper\"\u003e\u003c/property\u003e \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFacotry\"\u003e\u003c/property\u003e \u003c/bean\u003e --\u003e \u003c!-- 第三种方式生成mapper对象(批量产生多个mapper) 批量产生Mapper对在SpringIOC中的 id值 默认就是 首字母小写接口名 (首字母小写的接口名=id值) --\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFacotry\"\u003e\u003c/property\u003e \u003c!--指定批量产生 哪个包中的mapper对象 --\u003e \u003cproperty name=\"basePackage\" value=\"org.lanqiao.mapper\"\u003e\u003c/property\u003e \u003c/bean\u003e ","date":"2020-04-01","objectID":"/spring-mybatis%E6%95%B4%E5%90%88/:0:0","tags":["框架"],"title":"Spring-Mybatis整合","uri":"/spring-mybatis%E6%95%B4%E5%90%88/"},{"categories":["Spring"],"content":"后端-springweb ","date":"2020-03-30","objectID":"/%E5%90%8E%E7%AB%AF-springweb/:0:0","tags":[],"title":"后端-springweb","uri":"/%E5%90%8E%E7%AB%AF-springweb/"},{"categories":["Spring"],"content":"Web项目如何初始化SpringIOC容器 ： 思路：当服务启动时（tomcat），通过监听器将SpringIOC容器初始化一次（该监听器 spring-web.jar已经提供） 因此用spring开发web项目 至少需要7个jar： spring-java的6个jar + spring-web.jar， 注意：web项目的jar包 是存入到WEB-INF/lib中 方法一： web.xml \u003clistener\u003e \u003c!-- 配置spring-web.jar提供的监听器，此监听器可以在服务器启动时 初始化IOC容器 初始化IOC容器（applicationContext.xml）,需要指定位置context-param --\u003e \u003clistener-class\u003eorg.springframework.web.context.ContextLoaderListener\u003c/listener-class\u003e \u003c/listener\u003e \u003c!-- 指定IOC容器的位置 --\u003e \u003ccontext-param\u003e \u003c!-- 监听器父类中 有一个属性contextConfigLocation 需要给赋值告诉配置文件位置 --\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:applicationContext.xml\u003c/param-value\u003e \u003c/context-param\u003e 方法二：约定 放入web-inf中 不用指定位置 且名字只能为applicationContext.xml ","date":"2020-03-30","objectID":"/%E5%90%8E%E7%AB%AF-springweb/:1:0","tags":[],"title":"后端-springweb","uri":"/%E5%90%8E%E7%AB%AF-springweb/"},{"categories":["Spring"],"content":"配置文件拆分 方法一 value 中写多个值 web.xml \u003ccontext-param\u003e \u003c!-- 监听器父类中 有一个属性contextConfigLocation 需要给赋值告诉配置文件位置 --\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:applicationContext.xml, classpath:applicationContext-*.xml \u003c/param-value\u003e \u003c/context-param\u003e 方法二 在总的applicationContext.xml中引入 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cimport resource=\"classpath:applicationContext-*.xml\"/\u003e \u003c/beans\u003e ","date":"2020-03-30","objectID":"/%E5%90%8E%E7%AB%AF-springweb/:2:0","tags":[],"title":"后端-springweb","uri":"/%E5%90%8E%E7%AB%AF-springweb/"},{"categories":["Spring"],"content":"三层使用 将ioc容器与web容器打通 在init初始化时 ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); package org.jsh.servlet; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.jsh.service.IStudentService; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.web.context.support.WebApplicationContextUtils; /** * Servlet implementation class QueryStudentByIdServlet */ public class QueryStudentByIdServlet extends HttpServlet { private static final long serialVersionUID = 1L; IStudentService studentService; public void setStudentService(IStudentService studentService) { this.studentService = studentService; } @Override public void init() throws ServletException { /* ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-Service.xml\");*/ ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); studentService = (IStudentService)context.getBean(\"studentService\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String name = studentService.queryStudentById(); request.setAttribute(\"name\", name); request.getRequestDispatcher(\"result.jsp\").forward(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub doGet(request, response); } } ","date":"2020-03-30","objectID":"/%E5%90%8E%E7%AB%AF-springweb/:3:0","tags":[],"title":"后端-springweb","uri":"/%E5%90%8E%E7%AB%AF-springweb/"},{"categories":["前端"],"content":"前端-js-DOM总结 ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:0:0","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"1.获取元素节点对象 方法：通过document对象调用 getElementById() 通过id获取一个元素节点对象 getElementsByTagName() 通过标签名获取一组元素节点对象 getElementsByName()通过name属性获取一组元素节点对象 属性： innerHTML 属性获得元素内部的HTML代码 innerTest 忽略html标签 元素对象.属性名 可以读取到元素的属性值 读取class属性时 需要使用className children 表示当前节点的所有子元素 childNodes 表示当前节点的所有子节点(包括文本节点) firstElementChild 表示当前节点的第一个子元素 firstChild 表示当前节点的第一个子节点 lastChild 表示当前节点的最后子节点 parentNode 表示当前节点的父节点 previousElementSibling 表示当前节点的前一个兄弟元素 previousSibling 表示当前节点的前一个兄弟节点 nextElementSibling 表示当前节点的前一个兄弟元素 nextSibling 表示当前节点的后一个兄弟节点 其他 获取body标签 var body = document.body; 获取HTML根标签 var html = document.documentElement; all 页面中所有元素 var all = document.all; 根据元素的class属性查询一组元素的节点对象 var box1 = document.getElementsByClassName(\"box1\"); 根据一个CSS选择器的字符串作为参数，查询一个元素节点对象 只会返回第一个 var box1 = document.querySelector(\".box1 div\"); 根据一个CSS选择器的字符串作为参数，查询所有元素节点对象 数组 var box1 = document.querySelectorAll(\".box1 div\"); ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:1:0","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"2.修改元素节点对象 创建一个标签 var li = document.createElement(\"li\"); 创建文本 var text = document.createTextNode(\"文本\"); 将文本加入到标签中 把一个节点加入到另一个节点当中 li.appendChild(text); 在指定节点前加入新的子节点 insertBefore() 语法:父节点.insertBefore(新节点，旧节点)； city.insertBefore(li,bj); 替换节点 replaceChild() 使用指定子节点替换原有节点 语法:父节点.replaceChild(新节点，旧节点)； city.replaceChild(li,bj); 删除节点 removeChild() 删除字节点 语法:父节点.removeChild(节点)； 子节点.parentNode.removeChild(子节点); city.removeChild(bj); ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:2:0","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"3.DOM操作CSS 通过修改 元素.style.CSS属性名 = “属性值” 来修改元素的内联样式 读取当前样式 ​ var obj = getComputedStyle(元素对象名,null); ​ obj.属性名 读取当前样式 ​ IE8：alert(box1.currentStyle.width);读取当前样式 解决兼容性问题： ​ // obj元素对象 name属性名 function getStyle(obj,name){ if(window.getComputedStyle){ return getComputedStyle(obj,null)[name]; }else{ return obj.currentStyle[name]; } } ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:3:0","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"其他属性 /* 获取可见高度和宽度 无法进行修改 clientWidth clientHeight 不带px 返回数字 可以直接进行计算 包括内容区和内边距 不包括外边距 */ alert(box1.clientWidth); /* 获取可见高度和宽度 无法进行修改 offsetWidth offsetHeight 不带px 返回数字 可以直接进行计算 包括内容区和内边距和外边距 */ alert(box1.offsetWidth); /* offsetParent 定位父元素 会获取到离当前元素最近的开启了定位的祖先元素（postion 不是默认值） */ alert(box1.offsetParent); /* offsetLeft - 当前元素相对于其定位父元素的水平偏移量 offsetTop - 当前元素相对于其定位父元素的垂直偏移量 */ alert(box1.offsetLeft); /* scrollHeight scrollWidth - 获取元素在整个滚动区域的高度和宽度 scrollLeft - 获取水平滚动条 滚动的距离 scrollTop - 获取垂直滚动条 滚动的距离 */ disabled 可以设置一个元素是否禁用 true 禁用 false 不禁用 ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:3:1","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"4.事件 ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:4:0","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"事件的冒泡 事件默认会冒泡（一层一层往上传 默认开启） 关闭冒泡： event = event || window.event;//兼容性问题 event.cancelBubble = true; \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function(){ var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); var x = document.getElementById(\"x\"); x.onclick = function(event){ event = event || window.event; event.cancelBubble = true; alert(\"x\"); } box1.onclick = function(event){ alert(\"box1\"); } box2.onclick = function(event){ alert(\"box2\"); } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"box2\" style=\"width: 500px;height: 500px; border: #7FFFD4 1px solid;\"\u003e \u003cdiv id=\"box1\" style=\"width: 50px;height: 50px; border: #7FFFD4 1px solid;\"\u003e \u003ch2 id=\"x\"\u003errr\u003c/h2\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:4:1","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"事件的委派 对冒泡原理的应用 解决了大量事件的问题 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript\u003e window.onload= function(){ var ul = document.getElementById(\"ul\"); ul.onclick = function(event){ if(event.target.className==\"link\"){ alert(\"a\"); } } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cul id=\"ul\"\u003e \u003cli\u003e\u003ca href=\"javascript:;\" class=\"link\"\u003eaaaa\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"javascript:;\" class=\"link\"\u003eaaaa\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"javascript:;\" class=\"link\"\u003eaaaa\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:4:2","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"事件绑定 方式一 只能绑定一个 this是绑定事件对象 but0.onclick = function(){ alert(“1”); 方式二：可以绑定多个 除IE8 this是绑定事件对象 addEventListener 参数： 1.事件字符串 不要on 2.回调函数 3.是否在捕获阶段触发事件，需要布尔值，一般传false（子-\u003e父） attachEvent 兼容ie8 不兼容火狐 this是window 参数 1.事件字符串 要on 2.回调函数 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function(){ var but0 = document.getElementById(\"but0\"); // 方式一 只能绑定一个 // but0.onclick = function(){ // alert(\"1\"); // } /* 方式二：可以绑定多个 除IE8 addEventListener 参数： 1.事件字符串 不要on 2.回调函数 3.是否在捕获阶段触发事件，需要布尔值，一般传false */ but0.addEventListener(\"click\",function(){ alert(\"2\"); },false) but0.addEventListener(\"click\",function(){ alert(\"2\"); },false) but0.addEventListener(\"click\",function(){ alert(\"2\"); },false) /* attachEvent 兼容ie8 不兼容火狐 参数 1.事件字符串 要on 2.回调函数 */ bnt0.attachEvent(\"onclick\",function(){ alert(\"ie8\") }) } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"but0\"\u003e按钮\u003c/button\u003e \u003c/body\u003e \u003c/html\u003e bind() 解决兼容问题 function bind(obj,eventStr,callback){ if(obj.addEventListener){ obj.addEventListener(eventStr,callback,false); }else{ obj.attachEvent(\"on\"+eventStr,function(){ // 在匿名函数中调回调函数 callback(); }) } } ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:4:3","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"鼠标事件 event 传入参数 event = event || window.event 解决兼容性问题 获取鼠标位置 clientX clientY 相对于绑定元素 pageX pageY 相对于整个页面 onclick 点击 onmousemove 鼠标移动 onmousedown 鼠标点住 onmouseup 鼠标松开 onmousemove 鼠标移动 ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:4:4","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"滚轮事件 onmousewhell (火狐不支持，火狐中使用DOMMouseScroll并且需要使用addEventListener) 向上 event.wheelDelta\u003e0 可以获取滚轮方向(火狐不支持 使用event.detail\u003c0) if(event.wheelDelta\u003e0 || event.detail\u003c0){ alert(\"上\"); }else{ alert(\"下\"); } addEventListener 取消默认行为 event.preventDefault(); 默认 return false; ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:4:5","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"键盘事件 一般绑定给可以聚焦的对象或者document onkeydown onkeyup 属性 event. keyCode 获取按键的编码 altKey 判断alt是否被按下 ctrlKey 判断ctrl是否被按下 shiftKey 判断shift是否被按下 在文本框中输入 如果 加入 return false; 则无法输入 //输入框中无法输入数字 input.onkeydown = function(event){ event = event || window.event; if(event.keyCode\u003e=48 \u0026\u0026 event.keyCode\u003c=57){ return false; } } ","date":"2020-03-29","objectID":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/:4:6","tags":[],"title":"前端-js-DOM总结","uri":"/%E5%89%8D%E7%AB%AF-js-dom%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"前端-js-事件2 ","date":"2020-03-28","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B62/:0:0","tags":[],"title":"前端-js-事件2","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B62/"},{"categories":["前端"],"content":"滚轮事件 onmousewhell (火狐不支持，火狐中使用DOMMouseScroll并且需要使用addEventListener) 向上 event.wheelDelta\u003e0 可以获取滚轮方向(火狐不支持 使用event.detail\u003c0) if(event.wheelDelta\u003e0 || event.detail\u003c0){ alert(\"上\"); }else{ alert(\"下\"); } addEventListener 取消默认行为 event.preventDefault(); 默认 return false; ","date":"2020-03-28","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B62/:1:0","tags":[],"title":"前端-js-事件2","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B62/"},{"categories":["前端"],"content":"键盘事件 一般绑定给可以聚焦的对象或者document onkeydown onkeyup 属性 event. keyCode 获取按键的编码 altKey 判断alt是否被按下 ctrlKey 判断ctrl是否被按下 shiftKey 判断shift是否被按下 在文本框中输入 如果 加入 return false; 则无法输入 //输入框中无法输入数字 input.onkeydown = function(event){ event = event || window.event; if(event.keyCode\u003e=48 \u0026\u0026 event.keyCode\u003c=57){ return false; } } ","date":"2020-03-28","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B62/:2:0","tags":[],"title":"前端-js-事件2","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B62/"},{"categories":["Spring"],"content":"后端-Spring-注解实现AOP(day7) jar 与实现接口的方式相同 配置 将 业务类，通知 纳入springIOC容器中 开启注解对AOP的支持 \u003caop:aspectj-autoproxy\u003e\u003c/aop:aspectj-autoproxy\u003e execution 连接通知类和业务类 编写 通知类 @Component(“logAnnotation”) 加入IOC容器中(不要忘记开启扫描) @Aspect 声明是一个通知 @Before() 前置通知 package org.jsh.aop; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.AfterReturning; import org.aspectj.lang.annotation.AfterThrowing; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Component(\"logAnnotation\") @Aspect public class LogAnnotation { // 前置 @Before(\"execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\")//定义切点 public void myBefore(JoinPoint jp) { System.out.println(\"。。。。。注解形式前置:目标对象\"+jp.getTarget()+\",方法名：\"+jp.getSignature().getName()+\",参数列表\"+jp.getArgs().length); } // 后置 @AfterReturning(pointcut =\"execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\",returning=\"returningValue\") public void myAfter(JoinPoint jp,Object returningValue) { System.out.println(\"。。。。。注解形式后置\"+returningValue); } // 环绕 @Around(\"execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\") public void myAround(ProceedingJoinPoint jp) { // 前置 System.out.println(\"\u003c前置\"); try { // 方法执行 Object result = jp.proceed(); // 方法执行之后 System.out.println(\"\u003c后置\"); }catch (Throwable e) { // TODO: handle exception System.out.println(\"\u003c异常\"); }finally { System.out.println(\"\u003c最终\"); } } // 异常通知 如果只捕获特定类型的异常 可以通过第二个参数实现 @AfterThrowing(pointcut=\"execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\",throwing=\"e\") public void myException(JoinPoint jp,NullPointerException e) { System.out.println(\"。。。。。注解形式异常\"); } // 最终 @After(\"execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\") public void myAfter() { System.out.println(\"最终\"); } } 参数问题 参数：（JoinPoint jp） 目标对象：jp.getTarget() 方法名：jp.getSignature().getName() 参数列表：jp.getArgs().length 返回值： 在注解中配置 returning=“returningValue” 参数 Object returningValue 异常通知 如果只捕获特定类型的异常 可以通过第二个参数实现 ​ 在注解中配置 throwing=“e” 参数 NullPointerException(异常类型) e Schema配置 application.xml \u003c!-- 将准备转为 通知的类 纳入ioc容器 --\u003e \u003cbean id=\"logSchema\" class=\"org.lanqiao.aop.LogSchema\"\u003e\u003c/bean\u003e \u003caop:config\u003e \u003c!-- 切入点（连接线的一端：业务类的具体方法） --\u003e \u003caop:pointcut expression=\"execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\" id=\"pcShema\"/\u003e \u003c!-- （连接线的另一端：通知 类） \u003caop:advisor advice-ref=\"logSchea\" pointcut-ref=\"pcShema\" /\u003e --\u003e \u003c!-- schema方式 --\u003e \u003caop:aspect ref=\"logSchema\"\u003e \u003c!-- 连接线：连接 业务 addStudent 和 通知before --\u003e \u003caop:before method=\"before\" pointcut-ref=\"pcShema\"/\u003e \u003c!-- 连接线：连接 业务 addStudent 和 通知afterReturning --\u003e \u003caop:after-returning method=\"afterReturning\" returning=\"returnValue\" pointcut-ref=\"pcShema\"/\u003e \u003caop:after-throwing method=\"whenException\" pointcut-ref=\"pcShema\" throwing=\"e\"/\u003e \u003c!-- 环绕 --\u003e \u003caop:around method=\"around\" pointcut-ref=\"pcShema\" /\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e 通知类 package org.lanqiao.aop; import java.lang.reflect.Method; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; public class LogSchema { //后置通知方法 :JoinPoint适用于注解 public void afterReturning(JoinPoint jp,Object returnValue) throws Throwable { System.out.println(\"》》》》》》》》》》》后置通知：目标对象：\"+jp.getThis()+\",调用的方法名：\"+jp.getSignature().getName()+\",方法的参数个数：\"+jp.getArgs().length+\"，方法的返回值：\"+returnValue); } public void before() { System.out.println(\"》》》》》》》》》》》前置通知...\"); } public void whenException(JoinPoint jp,NullPointerException e) { System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e异常：\" +e.getMessage()); } //注意：环绕通知 会返回目标方法的返回值，因此返回值为Object public Object around(ProceedingJoinPoint jp) { System.out.println(\"''''''''''''''''''环绕通知：前置通知\"); Object result = null ; try { result = jp.proceed() ;//执行方法 System.out.println(\"'''","date":"2020-03-28","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0aopday7/:0:0","tags":[],"title":"后端-Spring-注解实现AOP(day7)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0aopday7/"},{"categories":["数据库"],"content":"SQL ","date":"2020-03-26","objectID":"/sql/:0:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"创建数据库 : CREATE DATABASE 数据库名; CREATE DATABASE teach; ","date":"2020-03-26","objectID":"/sql/:1:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"进入数据库：USE 数据库名; USE teach; ","date":"2020-03-26","objectID":"/sql/:2:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"创建表：CREATE TABLE 表名; ​ 属性名 属性类型 完整性约束, ​ 属性名 属性类型 完整性约束, ​ 属性名 属性类型 完整性约束 ​ ); 完整性约束： 主码约束: PRIMARY KEY 参照完整性约束：FOREIGN KEY…REFERENCES… 唯一性约束: UNIQUE 非空值约束：NOT NULL 取值约束：CHECK 属性类型： 整数 bigint: 以8个字节来存储正负数, 范围：-2 63 到 2 63 -1 int: 以4个字节来存储正负数，范围：-2 31 到 2 31 -1 smallint: 以2个字节来存储正负数.，范围：-2 15 到 2 15 -1 tinyint: 是最小的整数类型,存储正整数，仅用1字节,范围:0至2 8 -1 bit: 值只能是0或1，当输入0以外的其他值时，系统均认为是1 常用来表示真假、男女等二值选择。 精确数值 decimal:用来存储从-1038+1到1038 -1的固定精度和范围的数值型数据 • 必须指定范围和精度：decimal (p,q) 例：decimal (10,2) numeric:和decimal相同 浮点 float: 用8个字节来存储数据.最多可为53位. 范围为:-1.79E+308至1.79E+308. real: 位数为24,用4个字节 数字范围:-3.04E+38至3.04E+38 字符串 char: char(n)固定的长度为 n个字符的字符串, 不足的长度会用空格 补上. varchar: varchar(n)可变的最长长度为n个字符的字符串，尾部的空 格会去掉. 时间日期 date: 日期类型 • DATE ‘yyyy-mm-dd’ • Example: DATE ‘2004-09-30’ time:时间类型 • TIME ‘hh:mm:ss’ • Example: TIME ‘15:30:02.5‘ datetime:日期时间类型 CREATE TABLE student( sid CHAR(8) PRIMARY KEY, sname VARCHAR(20) NOT NULL, sgender CHAR(1), sdept INT, sbirth DATE ); 当多个属性为主键时 CREATE TABLE SC( Sno CHAR(5) , Cno INT , Grade INT, PRIMARY KEY (Sno, Cno)); ","date":"2020-03-26","objectID":"/sql/:3:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"修改基本表 ALTER TABLE \u003c表名\u003e [ ADD \u003c新列名\u003e \u003c数据类型\u003e | 完整性约束 ] [ DROP \u003c列名\u003e|\u003c完整性约束名\u003e ] [ MODIFY \u003c列名\u003e \u003c数据类型\u003e ]； ADD子句：增加新列和新的完整性约束条件 DROP子句：删除指定列或完整性约束条件 MODIFY子句：用于修改列名和数据类型 ","date":"2020-03-26","objectID":"/sql/:4:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"ADD ALTER TABLE 表名 ADD 属性名 属性类型; ALTER TABLE student ADD stime DATETIME; ","date":"2020-03-26","objectID":"/sql/:4:1","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"DROP ALTER TABLE 表名 DROP 属性名; ALTER TABLE Student DROP 主键约束的名字; ALTER TABLE student DROP STIME; ","date":"2020-03-26","objectID":"/sql/:4:2","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"MODIFY 更改数据类型 ALTER TABLE student MODIFY sname VARCHAR(20); ","date":"2020-03-26","objectID":"/sql/:4:3","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"删除基本表 DROP TABLE \u003c表名\u003e; DROP TABLE student; ","date":"2020-03-26","objectID":"/sql/:4:4","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"增删改查 ","date":"2020-03-26","objectID":"/sql/:5:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"SELECT SELECT ALL|DISTINCT(默认ALL(不去重) DISTINCT(去重)) 属性名(查询目标列或者表达式) FROM 表名（从哪个表中查询） WHERE 分组前条件 GROUP BY 属性名（根据属性值相同进行分组） HAVING 表达式（分组后条件） ORDER BY 属性名 ASC|DESC（根据属性名进行排序 默认升序(ASC) 降序(DESC)） 查询全体学生的学号和姓名 SELECT sno,sname FROM student; 查询全体学生的详细信息 SELECT * FROM student; 查询全体学生的出生日期 NOW()取得当前时间 SELECT 2020-sage FROM student; 查询出的值可以进行运算 SELECT YEAR(NOW())-sage FROM student; NOW()取得当前时间 对查询出的结果的列取别名 AS(可以省略) SELECT YEAR(NOW())-sage AS birthyear FROM student; SELECT sno AS s,sname AS b FROM student; 去重 DISTINCT SELECT DISTINCT sno FROM sc; 查询结果 变小写 变大写 SELECT LOWER(sdept) FROM student; SELECT UPPER(sdept) FROM student; where语句 查询所有年龄在20岁以下的学生姓名及其年龄 SELECT sname,sage FROM student WHERE sage\u003c20; 属性 BETWEEN 条件1 AND 条件2; --[例9] 查询年龄在20~23岁(包括20岁和23岁)之间的学生的姓名、系别和年龄 SELECT sname,sdept,sage FROM student WHERE sage BETWEEN 20 AND 23; --[例10] 查询年龄不在20~23岁之间的学生姓名、系别和年龄 SELECT sname,sdept,sage FROM student WHERE sage NOT BETWEEN 20 AND 23; 属性名 IN(‘属性一’,‘属性二’,‘属性三’) --[例11] 查询信息系(IS)、数学系(MA)和计算机科学系(CS)学生的姓名和性别 SELECT sname,ssex FROM student WHERE sdept IN('CS','IS','MA'); --[例12]查询既不是信息系、数学系，也不是计算机科学系的学生的姓名和性别 SELECT sname,ssex FROM student WHERE sdept NOT IN('CS','IS','MA'); like 模糊查询 %表示若干字符 _表示一个字符 避免原字符串中存在%或_的方法: 例十八 ，例十九 --[例14] 查询所有姓刘学生的姓名、学号和性别 SELECT sname,sno,ssex FROM student WHERE sname LIKE '刘%'; --[例15] 查询所有不姓刘的学生姓名、学号和性别 SELECT sname,sno,ssex FROM student WHERE sname NOT LIKE '刘%'; --[例16] 查询姓\"欧阳\"且全名为三个汉字的学生的姓名 SELECT sname FROM student WHERE sname LIKE '欧阳_'; --[例17] 查询名字中第2个字为\"阳\"字的学生的姓名和学号 SELECT sname FROM student WHERE sname LIKE '_阳%'; --[例18] 查询DB_Design课程的课程号和学分。 SELECT cno,ccredit FROM course WHERE cname LIKE 'DB\\_Design' ESCAPE'\\\\'; --[例19] 查询以\"DB_\"开头，且倒数第3个字符为 i的课程的详细情况 SELECT * FROM course WHERE cname LIKE 'DB\\_%i__' ESCAPE'\\\\'; IS NULL 判断为空 不可以使用 = NULL --[例20] 某些学生选修课程后没有参加考试，所以有选课记录，但没有考试成绩。查询缺少成绩的学生的学号和相应的课程号。 SELECT sno,cno FROM sc WHERE grade IS NULL; -- [例21] 查所有有成绩的学生学号和课程号 SELECT sno,cno FROM sc WHERE grade IS NOT NULL; 排序 ORDER BY 默认为升序 加上DESC变为降序 --[例25] 查询选修了3号课程的学生的学号及其成绩， --查询结果按分数降序排列 SELECT sno,grade FROM sc ORDER BY grade DESC; --[例26] 查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。 SELECT * FROM student ORDER BY sdept,sage DESC; COUNT(属性名) 返回数量 COUNT(*)表示全部 可以使用DISTINCT --[例27] 查询学生总人数。 SELECT COUNT(*) FROM student; --[例28] 查询选修了课程的学生人数。 SELECT COUNT(DISTINCT SNO) FROM sc; 平均值AVG 最大值MAX 最小值MIN --[例29] 计算1号课程的学生平均成绩 SELECT AVG(Grade) FROM sc WHERE cno=1; --[例30] 查询选修1号课程的学生最高分数 SELECT MAX(Grade) FROM sc WHERE cno=1; 分组 GROUP BY 属性名 --[例31] 求各个课程号及相应的选课人数。 SELECT cno,COUNT(sno) FROM sc GROUP BY cno; --[例32] 求各个课程号及相应的课程成绩在90分以上的学生人数 SELECT cno,COUNT(*) FROM sc WHERE grade\u003e=90 GROUP BY cno; HAVING 对分组后的数据进行判断 --[例33] 查询选修了3门以上课程的学生学号 SELECT sno FROM sc GROUP BY sno HAVING COUNT(*)\u003e=3; --[例34] 查询有3门以上课程在90分以上的学生的学号 --及90分以上的课程数 SELECT sno,COUNT(*) FROM sc WHERE grade\u003e=90 GROUP BY sno HAVING COUNT(*)\u003e=3; --[例35] 统计每门课程的最高分 SELECT cno,grade FROM sc GROUP BY cno HAVING MAX(Grade); 关联查询 --[例32] 查询每个学生及其选修课程的情况。 SELECT student.*,sc.* FROM student,sc; --[例33] 对[例32]用自然连接完成 SELECT student.*,sc.* FROM student,sc WHERE student.sno=sc.sno; --例：查询计算机系（CS）学生的学号，姓名，所在系， --选修的课程号，课程名和成绩 SELECT sc.sno,sname,sdept,sc.cno,cname,grade FROM student,sc,course WHERE student.sno=sc.sno AND course.cno=sc.cno AND sdept='CS'; -- [例34] 查询每一门课的直接先修课的课程名 SELECT a1.`Cname`,a2.`Cname` FROM course a1,course a2 WHERE a1.Cpno=a2.Cno; --[例35] 查询每一门课的间接先修课的课程号（即先修课的先修课）。 SELECT a1.cno,a2.cpno FROM course a1,course a2 WHERE a1.Cpno=a2.Cno; --[例36] 查询同时选修2号课程和3号课程学生的学号。 SELECT c1.sno FROM sc c1,sc c2 WHERE c1.sno = c2.sno AND c1.cno!=c2.cno AND c1.cno=2 AND c2.cno =3; 左连接查询 left join 右连接 right join 左连接，左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。 -- 例，查询全体学生信息及其选课信息 SELECT student.*,sc.* FROM student LEFT JOIN sc ON student.sno=sc.sno; 嵌套查询 -- [例37] 查询与“刘晨”在同一个系学习的学生。 -- ① 确定“刘晨”所在系名 SELECT Sdept FROM student WHERE sname = '刘晨'; -- ② 查找所有在IS系学习的学生。 SELECT * FROM student WHERE sdept IN (SELECT Sdept FROM student WHERE sname = '刘晨'); -- [例39]查","date":"2020-03-26","objectID":"/sql/:5:1","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"INSERT INSERT INTO 表名(属性名1，属性名2……) VALUES(属性值1，属性值二……); /*[例1]将一个新学生记录(学号:95020;姓名:陈冬; 性别:男;所在系:IS;年龄:18岁)插入到Student表中 */ INSERT INTO student VALUES('95020','陈冬','M',18,'IS'); -- [例2] 插入一条选课记录( '95020'，'1 ') INSERT INTO sc(sno,cno) VALUES ('95020','1'); 可以插入子查询的值 -- [例3] 对每一个系，求学生的平均年龄, -- 并把结果存入数据表 -- 第一步：建表 /*学生平均年龄*/ CREATE TABLE studentAvgAge( sdept VARCHAR(20), avgage SMALLINT ); -- 第二步：插入数据 INSERT INTO studentAvgAge SELECT sdept,AVG(sage) FROM student GROUP BY sdept; ","date":"2020-03-26","objectID":"/sql/:5:2","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"UPDATE UPDATE 表名 SET 属性名=属性值 WHERE 条件； --[例4] 将学生95001的年龄改为22岁。 UPDATE student SET sage = 22 WHERE sno='95001'; -- 将学生95001的年龄改为21岁,性别改为女性。 UPDATE student SET sage = 21,ssex='F' WHERE sno='95001'; --[例5] 将所有学生的年龄增加1岁 UPDATE student SET sage=sage+1; --[例6] 将信息系所有学生的年龄增加1岁 UPDATE student SET sage=sage+1 WHERE sdept='CS'; --[例7] 将计算机科学系全体学生的成绩置零 UPDATE sc SET grade = 0 WHERE sno IN(SELECT sno FROM student WHERE sdept='IS'); ","date":"2020-03-26","objectID":"/sql/:5:3","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"DELETE DELETE FROM 表名 WHERE 条件 TRUNCATE删除所有数据保留表 --[例8] 删除学号为95019的学生记录 DELETE FROM student WHERE sno='95020'; --[例9] 删除2号课程的所有选课记录 DELETE FROM sc WHERE cno='2'; --[例10] 删除所有的学生选课记录 -- 删除所有数据 TRUNCATE TABLE sc; --[例11] 删除计算机科学系所有学生的选课记录。 DELETE FROM sc WHERE sno IN (SELECT sno FROM student WHERE sdept='IS'); ","date":"2020-03-26","objectID":"/sql/:5:4","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["前端"],"content":"前端-js-事件 监听鼠标移动 onmousemove event 传入参数 event = event || window.event 解决兼容性问题 clientX clientY 相对于绑定元素 pageX pageY 相对于整个页面 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript\u003e window.onload = function(){ var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); box1.onmousemove = function(event){ event = event || window.event; var x = event.clientX; var y = event.clientY; box2.innerHTML = \"x=\"+x+\",y=\"+y; } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"width: 500px; height: 200px; border: black 1px solid;\" id=\"box1\"\u003e \u003c/div\u003e \u003cdiv style=\"width: 500px; height: 200px; border: black 1px solid;\" id=\"box2\"\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-26","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/:0:0","tags":[],"title":"前端-js-事件","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/"},{"categories":["前端"],"content":"事件的冒泡 事件默认会冒泡（一层一层往上传 默认开启） 关闭冒泡： event = event || window.event;//兼容性问题 event.cancelBubble = true; \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function(){ var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); var x = document.getElementById(\"x\"); x.onclick = function(event){ event = event || window.event; event.cancelBubble = true; alert(\"x\"); } box1.onclick = function(event){ alert(\"box1\"); } box2.onclick = function(event){ alert(\"box2\"); } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"box2\" style=\"width: 500px;height: 500px; border: #7FFFD4 1px solid;\"\u003e \u003cdiv id=\"box1\" style=\"width: 50px;height: 50px; border: #7FFFD4 1px solid;\"\u003e \u003ch2 id=\"x\"\u003errr\u003c/h2\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-26","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/:1:0","tags":[],"title":"前端-js-事件","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/"},{"categories":["前端"],"content":"事件的委派 对冒泡原理的应用 解决了大量事件的问题 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript\u003e window.onload= function(){ var ul = document.getElementById(\"ul\"); ul.onclick = function(event){ if(event.target.className==\"link\"){ alert(\"a\"); } } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cul id=\"ul\"\u003e \u003cli\u003e\u003ca href=\"javascript:;\" class=\"link\"\u003eaaaa\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"javascript:;\" class=\"link\"\u003eaaaa\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"javascript:;\" class=\"link\"\u003eaaaa\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-26","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/:2:0","tags":[],"title":"前端-js-事件","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/"},{"categories":["前端"],"content":"事件绑定 方式一 只能绑定一个 this是绑定事件对象 but0.onclick = function(){ alert(“1”); 方式二：可以绑定多个 除IE8 this是绑定事件对象 addEventListener 参数： 1.事件字符串 不要on 2.回调函数 3.是否在捕获阶段触发事件，需要布尔值，一般传false（子-\u003e父） attachEvent 兼容ie8 不兼容火狐 this是window 参数 1.事件字符串 要on 2.回调函数 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function(){ var but0 = document.getElementById(\"but0\"); // 方式一 只能绑定一个 // but0.onclick = function(){ // alert(\"1\"); // } /* 方式二：可以绑定多个 除IE8 addEventListener 参数： 1.事件字符串 不要on 2.回调函数 3.是否在捕获阶段触发事件，需要布尔值，一般传false */ but0.addEventListener(\"click\",function(){ alert(\"2\"); },false) but0.addEventListener(\"click\",function(){ alert(\"2\"); },false) but0.addEventListener(\"click\",function(){ alert(\"2\"); },false) /* attachEvent 兼容ie8 不兼容火狐 参数 1.事件字符串 要on 2.回调函数 */ bnt0.attachEvent(\"onclick\",function(){ alert(\"ie8\") }) } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"but0\"\u003e按钮\u003c/button\u003e \u003c/body\u003e \u003c/html\u003e bind() 解决兼容问题 function bind(obj,eventStr,callback){ if(obj.addEventListener){ obj.addEventListener(eventStr,callback,false); }else{ obj.attachEvent(\"on\"+eventStr,function(){ // 在匿名函数中调回调函数 callback(); }) } } ","date":"2020-03-26","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/:3:0","tags":[],"title":"前端-js-事件","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/"},{"categories":["前端"],"content":"鼠标事件 onclick 点击 onmousemove 鼠标移动 onmousedown 鼠标点住 onmouseup 鼠标松开 ","date":"2020-03-26","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/:4:0","tags":[],"title":"前端-js-事件","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BA%8B%E4%BB%B6/"},{"categories":["Spring"],"content":"后端-Spring-AOP，expression表达式(day5) ","date":"2020-03-26","objectID":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/:0:0","tags":[],"title":"后端-Spring-AOP，expression表达式(day5)","uri":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/"},{"categories":["Spring"],"content":"AOP 面向方面编程 ","date":"2020-03-26","objectID":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/:1:0","tags":[],"title":"后端-Spring-AOP，expression表达式(day5)","uri":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/"},{"categories":["Spring"],"content":"前置通知 实现在执行一个方法前自动执行某个方法 jar aopaliance.jar aspectjweaver.jar 配置 MethodBeforeAdvice LogBefore.java package org.jsh.aop; import java.lang.reflect.Method; import org.springframework.aop.MethodBeforeAdvice; //普通类 -\u003e 前置通知 implements MethodBeforeAdvice public class LogBefore implements MethodBeforeAdvice{ //前置通知的具体内容 @Override public void before(Method method, Object[] args, Object target) throws Throwable { // TODO Auto-generated method stub System.out.println(\"前置通知\"); } } applicationContext.xml \u003c!-- 配置前置通知 --\u003e \u003c!-- add方法所在类 --\u003e \u003cbean id=\"studentService\" class=\"org.jsh.service.impl.StudentServiceImpl\"\u003e \u003cproperty name=\"studentDao\" ref=\"studentDao\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- 通知所在类 --\u003e \u003cbean id=\"logBefore\" class=\"org.jsh.aop.LogBefore\"\u003e \u003c/bean\u003e \u003c!-- 将方法所在类 和 通知 进行关联 --\u003e \u003caop:config proxy-target-class=\"true\"\u003e \u003c!-- 配置切入点 --\u003e \u003caop:pointcut expression=\"execution(public void org.jsh.service.impl.StudentServiceImpl.deleteStudent(org.jsh.entiy.Student)) or execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\" id=\"poioncut\"/\u003e \u003c!-- 关联:advisor相当于链接切入点和切面的线 --\u003e \u003caop:advisor advice-ref=\"logBefore\" pointcut-ref=\"poioncut\"/\u003e \u003c/aop:config\u003e 使用 public static void testAOP() { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); StudentServiceImpl studentService = (StudentServiceImpl)context.getBean(\"studentService\"); Student student = (Student) context.getBean(\"student\"); studentService.addStudent(student); studentService.deleteStudent(student); } ","date":"2020-03-26","objectID":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/:2:0","tags":[],"title":"后端-Spring-AOP，expression表达式(day5)","uri":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/"},{"categories":["Spring"],"content":"后置通知 通知类 java AfterReturningAdvice 注意参数 package org.jsh.aop; import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class LogAfter implements AfterReturningAdvice { @Override public void afterReturning(Object arg0, Method arg1, Object[] arg2, Object arg3) throws Throwable { // TODO Auto-generated method stub System.out.println(\"后置通知。。。目标对象：\"+arg3+\"目标方法\"+arg1+\"参数个数\"+arg2.length+\"方法的返回值\"+arg0); } } ","date":"2020-03-26","objectID":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/:3:0","tags":[],"title":"后端-Spring-AOP，expression表达式(day5)","uri":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/"},{"categories":["Spring"],"content":"异常通知 需要实现 ThrowsAdvice 接口 package org.jsh.aop; import java.lang.reflect.Method; import org.springframework.aop.ThrowsAdvice; public class LogException implements ThrowsAdvice { public void afterThrowing(Method method,Object[] args,Object target,Throwable ThrowableSubclass) { System.out.println(\"异常通知\"); } } ","date":"2020-03-26","objectID":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/:4:0","tags":[],"title":"后端-Spring-AOP，expression表达式(day5)","uri":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/"},{"categories":["Spring"],"content":"环绕通知 实现了前三个通知的功能 MethodInterceptor 接口 注意参数 package org.jsh.aop; import org.aopalliance.intercept.MethodInterceptor; import org.aopalliance.intercept.MethodInvocation; public class LogAround implements MethodInterceptor { @Override public Object invoke(MethodInvocation arg0) throws Throwable { Object result = null; // 方法体一 try { // 方法体二 // 前置通知 System.out.println(\"环绕前置\"); result = arg0.proceed();//控制目标方法的执行 相当于 addStudent() // 后置通知 System.out.println(\"目标对象：\"+arg0.getThis()+\"目标方法\"+arg0.getMethod()+\"参数个数\"+arg0.getArguments().length+\"方法的返回值\"+result); System.out.println(\"环绕后置\"); }catch (Exception e) { // 异常通知 System.out.println(\"环绕异常\"); } // 目标方法的返回值 return result; } } applicationContext.xml \u003c!-- 通知所在类 --\u003e \u003cbean id=\"logBefore\" class=\"org.jsh.aop.LogBefore\"\u003e \u003c/bean\u003e \u003cbean id=\"logAfter\" class=\"org.jsh.aop.LogAfter\"\u003e \u003c/bean\u003e \u003cbean id=\"logException\" class=\"org.jsh.aop.LogException\"\u003e \u003c/bean\u003e \u003cbean id=\"logAround\" class=\"org.jsh.aop.LogAround\"\u003e \u003c/bean\u003e \u003c!-- 将方法所在类 和 通知 进行关联 --\u003e \u003caop:config proxy-target-class=\"true\"\u003e \u003c!-- 配置切入点 --\u003e \u003caop:pointcut expression=\"execution(public void org.jsh.service.impl.StudentServiceImpl.deleteStudent(org.jsh.entiy.Student)) or execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\" id=\"poioncut\"/\u003e \u003c!-- 关联:advisor相当于链接切入点和切面的线 --\u003e \u003caop:advisor advice-ref=\"logBefore\" pointcut-ref=\"poioncut\"/\u003e \u003c/aop:config\u003e \u003c!-- 后置 --\u003e \u003caop:config proxy-target-class=\"true\"\u003e \u003c!-- 配置切入点 --\u003e \u003caop:pointcut expression=\"execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\" id=\"poioncut2\"/\u003e \u003c!-- 关联:advisor相当于链接切入点和切面的线 --\u003e \u003caop:advisor advice-ref=\"logAfter\" pointcut-ref=\"poioncut2\"/\u003e \u003c/aop:config\u003e \u003c!-- 异常 --\u003e \u003caop:config proxy-target-class=\"true\"\u003e \u003c!-- 配置切入点 --\u003e \u003caop:pointcut expression=\"execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\" id=\"poioncut3\"/\u003e \u003c!-- 关联:advisor相当于链接切入点和切面的线 --\u003e \u003caop:advisor advice-ref=\"logException\" pointcut-ref=\"poioncut3\"/\u003e \u003c/aop:config\u003e \u003c!-- 环绕 --\u003e \u003caop:config proxy-target-class=\"true\"\u003e \u003c!-- 配置切入点 --\u003e \u003caop:pointcut expression=\"execution(public void org.jsh.service.impl.StudentServiceImpl.addStudent(org.jsh.entiy.Student))\" id=\"poioncut4\"/\u003e \u003c!-- 关联:advisor相当于链接切入点和切面的线 --\u003e \u003caop:advisor advice-ref=\"logAround\" pointcut-ref=\"poioncut4\"/\u003e \u003c/aop:config\u003e ","date":"2020-03-26","objectID":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/:5:0","tags":[],"title":"后端-Spring-AOP，expression表达式(day5)","uri":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/"},{"categories":["Spring"],"content":"expression expression=“execution(…)” 举例 含义 public boolean addStudent(org.jsh.entity.Student)) 所有返回类型为boolean、参数类型为org.jsh.entity.Student的addStudent()方法。 public boolean org.jsh.service.IStudentService. addStudent(org.jsh.entity.Student) org.jsh.service.IStudentService类（或接口）中的addStudent()方法，并且返回类型是boolean、参数类型是org.jsh.entity.Student public * addStudent(org.jsh.entity.Student) “*”代表任意返回类型 public void *( org.jsh.entity.Student) “*”代表任意方法名 public void addStudent(..) “..”代表任意参数列表 * org.jsh.service..(..) org.jsh.service.IStudentService包中，包含的所有方法（不包含子包中的方法） * org.jsh.service...(..) org.jsh.service.IStudentService包中，包含的所有方法（包含子包中的方法） ","date":"2020-03-26","objectID":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/:6:0","tags":[],"title":"后端-Spring-AOP，expression表达式(day5)","uri":"/%E5%90%8E%E7%AB%AF-spring-aopexpression%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5day5/"},{"categories":["Spring"],"content":"后端-spring-注解(day4) 使用 java @Component(“studentDao”) 相当于 如果要给属性赋值 自动装配byType 加入@Autowired 如果要根据名字 byName 加入@Qualifier(“属性id”) 每一个属性都需要 package org.jsh.dao; import org.jsh.entiy.Student; import org.springframework.stereotype.Component; @Component(\"studentDao\") public class StudentDaoImpl { @Autowired @Qualifier(\"stuDao\") private IStudentDao studentDao; public void addStudent(Student student) { System.out.println(\"...\"); } } applicationContext.xml context头文件 \u003c!-- 配置扫描器 --\u003e \u003ccontext:component-scan base-package=\"org.jsh.dao\"\u003e\u003c/context:component-scan\u003e @Component细化： dao层注解：@Repository service层注解：@Service 控制器层注解：@Controller ","date":"2020-03-24","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E6%B3%A8%E8%A7%A3day4/:0:0","tags":[],"title":"后端-spring-注解(day4)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E6%B3%A8%E8%A7%A3day4/"},{"categories":["Spring"],"content":"使用注解实现声明式事务 目标：通过事务 使以下方法 要么全成功、要么全失败 jar spring-tx-4.3.9.RELEASE 数据库jar commons-dbcp.jar 连接池使用到数据源 commons-pool.jar 连接池 spring-jdbc-4.3.9.RELEASE.jar aopalliance.jar 配置 \u003ctx:annotation-driven transaction-manager=“txManager” /\u003e \u003c!-- 配置数据库相关 事务--\u003e \u003cbean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"\u003e\u003c/property\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/testdata\"\u003e\u003c/property\u003e \u003cproperty name=\"username\" value=\"root\"\u003e\u003c/property\u003e \u003cproperty name=\"password\" value=\"123456\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- 配置事务管理器 \"txManager\"--\u003e \u003cbean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!-- 增加事务相关支持 --\u003e \u003ctx:annotation-driven transaction-manager=\"txManager\"/\u003e 使用 将需要 成为事务的方法 前增加注解： @Transactional(readOnly=false,propagation=Propagation.REQUIRED) package org.jsh.service.impl; import org.jsh.dao.IStudentDao; import org.jsh.dao.impl.StudentDaoImpl; import org.jsh.entiy.Student; import org.jsh.service.IStudentService; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; public class StudentServiceImpl implements IStudentService { IStudentDao studentDao; public void setStudentDao(IStudentDao studentDao) { this.studentDao = studentDao; } @Transactional( readOnly=false, propagation=Propagation.REQUIRED, rollbackForClassName={\"SQLException\",\"ArithmeticException\"}) public void addStudent(Student student) { studentDao.addStudent(student); } } Transactional属性 ","date":"2020-03-24","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E6%B3%A8%E8%A7%A3day4/:1:0","tags":[],"title":"后端-spring-注解(day4)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E6%B3%A8%E8%A7%A3day4/"},{"categories":["Spring"],"content":"后端-Spring-三种方式的依赖注入(day2) ","date":"2020-03-23","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/:0:0","tags":[],"title":"后端-Spring-三种方式的依赖注入(day2)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/"},{"categories":["Spring"],"content":"准备 加入两个实体类 Teacher.java package org.jsh.entiy; public class Teacher { private String name; private int age; public Teacher() { } public Teacher(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { // TODO Auto-generated method stub return name+age; } } Course.java package org.jsh.entiy; public class Course { private String courseName; private int courseHour; private Teacher teacher; public Course() { } public Course(String courseName, int courseHour, Teacher teacher) { super(); this.courseName = courseName; this.courseHour = courseHour; this.teacher = teacher; } public String getCourseName() { return courseName; } public void setCourseName(String courseName) { this.courseName = courseName; } public int getCourseHour() { return courseHour; } public void setCourseHour(int courseHour) { this.courseHour = courseHour; } public Teacher getTeacher() { return teacher; } public void setTeacher(Teacher teacher) { this.teacher = teacher; } @Override public String toString() { // TODO Auto-generated method stub return courseName+courseHour+teacher; } } 在ioc中定义bean的前提：该bean的类 必须提供了 无参构造 ","date":"2020-03-23","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/:1:0","tags":[],"title":"后端-Spring-三种方式的依赖注入(day2)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/"},{"categories":["Spring"],"content":"1.set方式 property 实际是调用实体类的set方法 基本类型 用 value 引用类型用 ref 指向 该类的id 给对象类型赋值null ： –\u003e注意 没有 赋空值 \"\" \u003cbean id=\"teacher\" class=\"org.jsh.entiy.Teacher\"\u003e \u003cproperty name=\"name\" value=\"zs\"\u003e\u003c/property\u003e \u003cproperty name=\"age\" value=\"22\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"course\" class=\"org.jsh.entiy.Course\"\u003e \u003c!-- 使用set方法 --\u003e \u003cproperty name=\"courseName\" value=\"java\"\u003e\u003c/property\u003e \u003cproperty name=\"courseHour\" value=\"200\"\u003e\u003c/property\u003e \u003c!-- 将teacher对象注入到course对象中 --\u003e \u003cproperty name=\"teacher\" ref=\"teacher\"\u003e\u003c/property\u003e \u003c/bean\u003e ","date":"2020-03-23","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/:2:0","tags":[],"title":"后端-Spring-三种方式的依赖注入(day2)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/"},{"categories":["Spring"],"content":"2.构造方法 constructor-arg 调用构造方法赋值 如果只用 value 需要与参数顺序一致 否则 需要使用 index name type 指定 \u003cbean id=\"course\" class=\"org.jsh.entiy.Course\"\u003e \u003cconstructor-arg value=\"c\" index=\"0\" name=\"courseName\" type=\"String\"\u003e\u003c/constructor-arg\u003e \u003cconstructor-arg value=\"100\"\u003e\u003c/constructor-arg\u003e \u003cconstructor-arg ref=\"teacher\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e ","date":"2020-03-23","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/:3:0","tags":[],"title":"后端-Spring-三种方式的依赖注入(day2)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/"},{"categories":["Spring"],"content":"3.p命名空间注入 简单类型： p:属性名=“属性值” 引用类型（除了String外）： p:属性名-ref=“引用的id” 注意多个 p赋值的时候 要有空格 \u003cbean id=\"teacher\" class=\"org.jsh.entiy.Teacher\" p:age=\"22\" p:name=\"zd\"\u003e \u003c/bean\u003e \u003cbean id=\"course\" class=\"org.jsh.entiy.Course\" p:courseName=\"hadoop\" p:courseHour=\"200\" p:teacher-ref=\"teacher\"\u003e \u003c/bean\u003e ","date":"2020-03-23","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/:4:0","tags":[],"title":"后端-Spring-三种方式的依赖注入(day2)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5day2/"},{"categories":["Spring"],"content":"后端-Spring-自动装配(day3) 自动装配： \u003cbean … class=“org.lanqiao.entity.Course” autowire=“byName|byType|constructor|no” \u003e byName本质是byId byName: 自动寻找：其他bean的id值=该Course类的属性名 byType: 其他bean的类型(class) 是否与 该Course类的ref属性类型一致 （注意，此种方式 必须满足：当前Ioc容器中 只能有一个Bean满足条件 ） constructor： 其他bean的类型(class) 是否与 该Course类的构造方法参数 的类型一致；此种方式的本质就是byType \u003c!-- autowire=\"byName\" Course类中有一个ref属性teacher(属性名)， 并且该ioc容器中恰好有一个bean的id bean的id=类的属性名 就会自动注入 --\u003e \u003cbean id=\"course\" class=\"org.jsh.entiy.Course\" autowire=\"byName\" \u003e \u003cproperty name=\"courseName\" value=\"java\"\u003e\u003c/property\u003e \u003cproperty name=\"courseHour\" value=\"200\"\u003e\u003c/property\u003e \u003c!-- \u003cproperty name=\"teacher\" ref=\"teacher\"\u003e\u003c/property\u003e --\u003e \u003c/bean\u003e ","date":"2020-03-23","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Dday3/:0:0","tags":[],"title":"后端-Spring-自动装配(day3)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Dday3/"},{"categories":["Spring"],"content":"设置全局自动装配 头文件 \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\" \u003e ","date":"2020-03-23","objectID":"/%E5%90%8E%E7%AB%AF-spring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Dday3/:1:0","tags":[],"title":"后端-Spring-自动装配(day3)","uri":"/%E5%90%8E%E7%AB%AF-spring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8Dday3/"},{"categories":["前端"],"content":"前端-js-使用DOM操作CSS ","date":"2020-03-21","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/:0:0","tags":[],"title":"前端-js-使用DOM操作CSS","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/"},{"categories":["前端"],"content":"内联样式 通过 元素.style.样式属性名 读取 修改 注意 ‘ - ’ 变为驼峰式命名 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle\u003e .box{ width: 200px; height: 200px; background-color: aquamarine; } \u003c/style\u003e \u003cscript\u003e window.onload= function(){ var box1 = document.getElementById(\"box1\"); var btn1 = document.getElementById(\"btn1\"); btn1.onclick = function(){ box1.style.width = \"300px\"; box1.style.height = \"300px\"; box1.style.backgroundColor = \"blue\"; alert(box1.style.backgroundColor); }; }; \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"box\" id=\"box1\"\u003e \u003c/div\u003e \u003cbutton id=\"btn1\" \u003e2222\u003c/button\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-21","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/:1:0","tags":[],"title":"前端-js-使用DOM操作CSS","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/"},{"categories":["前端"],"content":"读取当前样式 语法 var obj = getComputedStyle(元素对象名,null); alert(obj.width);‘ 该方法会返回一个对象 对象中封装了当前元素的样式 如果没有定义 会得到默认值 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle\u003e .box{ width: 200px; height: 200px; background-color: aquamarine; } \u003c/style\u003e \u003cscript\u003e window.onload= function(){ var box1 = document.getElementById(\"box1\"); var btn1 = document.getElementById(\"btn1\"); btn1.onclick = function(){ //alert(box1.currentStyle.width); var obj = getComputedStyle(box1,null); alert(obj.width); }; }; \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"box\" id=\"box1\"\u003e \u003c/div\u003e \u003cbutton id=\"btn1\" \u003e2222\u003c/button\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-21","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/:2:0","tags":[],"title":"前端-js-使用DOM操作CSS","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/"},{"categories":["前端"],"content":"getStyle（自定义）解决兼容问题 // obj元素对象 name属性名 function getStyle(obj,name){ if(window.getComputedStyle){ return getComputedStyle(obj,null)[name]; }else{ return obj.currentStyle[name]; } } ","date":"2020-03-21","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/:3:0","tags":[],"title":"前端-js-使用DOM操作CSS","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/"},{"categories":["前端"],"content":"其他 。。。。 ","date":"2020-03-21","objectID":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/:4:0","tags":[],"title":"前端-js-使用DOM操作CSS","uri":"/%E5%89%8D%E7%AB%AF-js-%E4%BD%BF%E7%94%A8dom%E6%93%8D%E4%BD%9Ccss/"},{"categories":["前端"],"content":"前端-DOM增删改 创建一个标签 var li = document.createElement(\"li\"); 创建文本 var text = document.createTextNode(\"文本\"); 将文本加入到标签中 把一个节点加入到另一个节点当中 li.appendChild(text); 在指定节点前加入新的子节点 insertBefore() 语法:父节点.insertBefore(新节点，旧节点)； city.insertBefore(li,bj); 替换节点 replaceChild() 使用指定子节点替换原有节点 语法:父节点.replaceChild(新节点，旧节点)； city.replaceChild(li,bj); 删除节点 removeChild() 删除字节点 语法:父节点.removeChild(节点)； 子节点.parentNode.removeChild(子节点); city.removeChild(bj); ","date":"2020-03-19","objectID":"/%E5%89%8D%E7%AB%AF-dom%E5%A2%9E%E5%88%A0%E6%94%B9/:0:0","tags":[],"title":"前端-DOM增删改","uri":"/%E5%89%8D%E7%AB%AF-dom%E5%A2%9E%E5%88%A0%E6%94%B9/"},{"categories":["Spring"],"content":"后端-Spring(day1) ","date":"2020-03-19","objectID":"/%E5%90%8E%E7%AB%AF-springday1/:0:0","tags":[],"title":"后端-Spring(day1)","uri":"/%E5%90%8E%E7%AB%AF-springday1/"},{"categories":["Spring"],"content":"搭建Spring环境 开发spring至少需要使用的jar(5个+1个): spring-aop.jar 开发AOP特性时需要的JAR spring-beans.jar 处理Bean的jar spring-context.jar 处理spring上下文的jar spring-core.jar spring核心jar spring-expression.jar spring表达式 三方提供的日志jar commons-logging.jar 日志 编写配置文件 为了编写时有一些提示、自动生成一些配置信息： 方式一：增加sts插件 可以给eclipse增加 支持spring的插件：spring tool suite(https://spring.io/tools/sts/all) 下载springsource-tool-suite-3.9.4.RELEASE-e4.7.3a-updatesite.zip,然后在Eclipse中安装：Help-Install new SoftWare.. - Add 方式二： 直接下载sts工具（相当于一个集合了Spring tool suite的Eclipse）: https://spring.io/tools/sts/ 新建：bean configuration .. - applicationContext.xml文件 ","date":"2020-03-19","objectID":"/%E5%90%8E%E7%AB%AF-springday1/:1:0","tags":[],"title":"后端-Spring(day1)","uri":"/%E5%90%8E%E7%AB%AF-springday1/"},{"categories":["Spring"],"content":"开发Spring程序(IOC) applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- 该文件中产生的所有对象，被spring放入了一个称之为spring ioc容器里 --\u003e \u003c!-- id 唯一标识符 calss 实体类全类名 --\u003e \u003c!-- name 属性值 value 值 --\u003e \u003cbean id=\"student\" class=\"org.jsh.entiy.Student\"\u003e \u003cproperty name=\"stuNo\" value=\"1\"\u003e\u003c/property\u003e \u003cproperty name=\"stuName\" value=\"zs\"\u003e\u003c/property\u003e \u003cproperty name=\"stuAge\" value=\"12\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e 新建实体类 package org.jsh.entiy; public class Student { private int stuNo; private String stuName; public int getStuNo() { return stuNo; } public void setStuNo(int stuNo) { this.stuNo = stuNo; } public String getStuName() { return stuName; } public void setStuName(String stuName) { this.stuName = stuName; } public int getStuAge() { return stuAge; } public void setStuAge(int stuAge) { this.stuAge = stuAge; } private int stuAge; @Override public String toString() { return super.toString(); } } 使用 package org.jsh.test; import org.jsh.entiy.Student; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[] args) { ApplicationContext conext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Student student = (Student) conext.getBean(\"student\"); System.out.println(student.getStuAge()); } } ioc 控制反转/依赖注入 IOC（控制反转）也可以称之为DI（依赖注入）： 控制反转：将 创建对象、属性值 的方式 进行了翻转，从new、setXxx() 翻转为了 从springIOC容器getBean() 依赖注入：将属性值 注入给了属性，将属性 注入给了bean，将bean注入给了ioc容器； 总结：ioc/di ，无论要什么对象，都可以直接去springioc容器中获取，而不需要自己操作（new\\setXxx()） ","date":"2020-03-19","objectID":"/%E5%90%8E%E7%AB%AF-springday1/:2:0","tags":[],"title":"后端-Spring(day1)","uri":"/%E5%90%8E%E7%AB%AF-springday1/"},{"categories":["Spring"],"content":"IOC超级工厂理解 创建java类 ICourse接口 package org.jsh.newinstance; public interface ICourse { void learn(); } 实现类 HtmlCourse.java 和 JavaCourse package org.jsh.newinstance; public class HtmlCourse implements ICourse{ @Override public void learn() { System.out.println(\"html\"); } } package org.jsh.newinstance; public class JavaCourse implements ICourse{ @Override public void learn() { System.out.println(\"java\"); } } 加入applicationContext.xml中 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- 该文件中产生的所有对象，被spring放入了一个称之为spring ioc容器里 --\u003e \u003c!-- id 唯一标识符 calss 实体类全类名 --\u003e \u003c!-- name 属性值 value 值 --\u003e \u003cbean id=\"student\" class=\"org.jsh.entiy.Student\"\u003e \u003cproperty name=\"stuNo\" value=\"1\"\u003e\u003c/property\u003e \u003cproperty name=\"stuName\" value=\"zs\"\u003e\u003c/property\u003e \u003cproperty name=\"stuAge\" value=\"12\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"javaCourse\" class=\"org.jsh.newinstance.JavaCourse\"\u003e \u003c/bean\u003e \u003cbean id=\"htmlCourse\" class=\"org.jsh.newinstance.HtmlCourse\"\u003e \u003c/bean\u003e \u003c/beans\u003e 在Student类中加入学习方法 public void learn(String name) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); ICourse course = (ICourse)context.getBean(name); course.learn(); } 使用 public static void learnCourseWithFactory() { ApplicationContext conext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Student student = (Student) conext.getBean(\"student\"); student.learn(\"htmlCourse\"); } ","date":"2020-03-19","objectID":"/%E5%90%8E%E7%AB%AF-springday1/:3:0","tags":[],"title":"后端-Spring(day1)","uri":"/%E5%90%8E%E7%AB%AF-springday1/"},{"categories":["前端"],"content":"前端-DOM查询 window.onload(在整个页面加载之后执行) \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function(){ var btn = document.getElementById(\"btn\"); btn.onclick = function(){ alert(\"ddd\"); }; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"btn\"\u003esss\u003c/button\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-17","objectID":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/:0:0","tags":[],"title":"前端-DOM查询","uri":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/"},{"categories":["前端"],"content":"获取元素节点对象 通过document对象调用 可以通过 innerHTML 属性获得元素内部的HTML代码 ​ innerTest 忽略html标签 元素对象.属性名 可以读取到元素的属性值 ​ 读取class属性时 需要使用className getElementById() 通过id获取一个元素节点对象 getElementsByTagName() 通过标签名获取一组元素节点对象 getElementsByName()通过name属性获取一组元素节点对象 ","date":"2020-03-17","objectID":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/:1:0","tags":[],"title":"前端-DOM查询","uri":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/"},{"categories":["前端"],"content":"获取元素节点的子节点 通过具体的元素节点调用 children 表示当前节点的所有子元素 childNodes 表示当前节点的所有子节点(包括文本节点) firstElementChild 表示当前节点的第一个子元素 firstChild 表示当前节点的第一个子节点 lastChild 表示当前节点的最后子节点 getElementsByTagName() 返回当前节点的指定标签名的后代节点 ","date":"2020-03-17","objectID":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/:2:0","tags":[],"title":"前端-DOM查询","uri":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/"},{"categories":["前端"],"content":"获取父节点和兄弟节点 通过具体的节点调用 parentNode 表示当前节点的父节点 previousElementSibling 表示当前节点的前一个兄弟元素 previousSibling 表示当前节点的前一个兄弟节点 nextElementSibling 表示当前节点的前一个兄弟元素 nextSibling 表示当前节点的后一个兄弟节点 ","date":"2020-03-17","objectID":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/:3:0","tags":[],"title":"前端-DOM查询","uri":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/"},{"categories":["前端"],"content":"其他 获取body标签 var body = document.body; 获取HTML根标签 var html = document.documentElement; all 页面中所有元素 var all = document.all; 根据元素的class属性查询一组元素的节点对象 var box1 = document.getElementsByClassName(\"box1\"); 根据一个CSS选择器的字符串作为参数，查询一个元素节点对象 只会返回第一个 var box1 = document.querySelector(\".box1 div\"); 根据一个CSS选择器的字符串作为参数，查询所有元素节点对象 数组 var box1 = document.querySelectorAll(\".box1 div\"); ","date":"2020-03-17","objectID":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/:4:0","tags":[],"title":"前端-DOM查询","uri":"/%E5%89%8D%E7%AB%AF-dom%E6%9F%A5%E8%AF%A2/"},{"categories":["Spring"],"content":"Mybatis基础总结 ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"一.配置 导入所需jar Mybatis-jar 数据库所需jar 在src下配置conf.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 通过environments的default值和environment的id值指定Mybatis运行时的数据库环境--\u003e \u003cenvironments default=\"development\"\u003e \u003c!-- 开发环境--\u003e \u003cenvironment id=\"development\"\u003e \u003c!-- 配置事务提交方式 JDBC：利用JDBC方式处理事务（commit rollback close）手工 MANAGED:将事务交由其他组件托管（spring,jobss）自动，默认关闭连接--\u003e \u003c!-- 默认不关闭--\u003e \u003c!-- \u003ctransactionManager type=\"MANAGED\"/\u003e--\u003e \u003c!-- \u003cproperty name=\"closeConnection\" value=\"false\"/\u003e--\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003c!-- 配置数据库信息--\u003e \u003c!-- 数据源类型： POOLED：使用数据库连接池（省略数据库的打开和关闭） UNPOOLED：传统的JDBC模式（不推荐：每次访问数据库都需要打开关闭数据库，消耗性能高） JNDI：从tomcat中获取一个内置的数据库连接池--\u003e \u003cdataSource type=\"POOLED\"\u003e \u003c!-- 数据库驱动--\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003c!-- 连接字符串--\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/testdata?useSSL=true\u0026amp;serverTimezone=UTC\"/\u003e \u003c!-- 数据库账号--\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003c!-- 数据库密码--\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c!-- 运行环境--\u003e \u003cenvironment id=\"start\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/testdata?useSSL=true\u0026amp;serverTimezone=UTC\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!-- 加载映射文件--\u003e \u003cmapper resource=\"org/jsh/entity/studentMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 创建数据库中表 创建java实体类 与表中属性一一对应 package org.jsh.entity; public class Student { private int stunum; private String name; private int age; public Student() { } public Student(int stunum, String name, int age) { this.stunum = stunum; this.name = name; this.age = age; } public int getStunum() { return stunum; } public void setStunum(int stunum) { this.stunum = stunum; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"stunum=\" + stunum + \", name='\" + name + '\\'' + \", age=\" + age + '}'; } } 映射文件xxxMapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- namespace:该mapper.xml映射文件的唯一标识--\u003e \u003cmapper namespace=\"org.jsh.entity.studentMapper\"\u003e \u003c!-- 通过id值定义标签 paparameterType:输入值类型 resultType返回值类型--\u003e \u003cselect id=\"selectStudentByNum\" parameterType=\"int\" resultType=\"org.jsh.entity.Student\"\u003e -- sql语句 select * from student where stunum = #{stunum} \u003c/select\u003e \u003c!-- Mybatis 规定输入输出在语法上只有一个 paparameterType，resultType只有一个 --\u003e \u003c!-- 如果输入参数是简单类型（8个基本类型+String）可以使用任何占位符--\u003e \u003c!-- 如果是对象类型。则必须是对象的属性 例：#{属性名}--\u003e \u003cinsert id=\"addStudent\" parameterType=\"org.jsh.entity.Student\" \u003e insert into student(stunum,name,age) values(#{stunum},#{name},#{age}) \u003c/insert\u003e \u003cupdate id=\"updateStudentByNum\" parameterType=\"org.jsh.entity.Student\"\u003e update student set name=#{name},age=#{age} where stunum=#{stunum} \u003c/update\u003e \u003cdelete id=\"deleteStudentByNum\" parameterType=\"int\"\u003e delete from student where stunum = #{stunum} \u003c/delete\u003e \u003c!-- 无论返回一个值还是一个列表 resultType不变--\u003e \u003cselect id=\"queryAllStudents\" resultType=\"org.jsh.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 测试 package org.jsh.entity; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.Reader; import java.util.List; public class TestMybatis { public static void main(String[] args) throws IOException { queryAllStudents(); // addStudent(); // deleteStudentByNum(); updateStudentByNum(); queryAllStudents(); } //查询单个学生 public static void queryStudentByNum() throws IOException { //","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:1:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"二.动态代理 接口开发 省略掉 statement ，即根据约定 直接定位出sql语句 约定优于配置 根据接口的方法名找到 xxxmapper.xml 文件中的sql标签（方法名 = sql标签的id值） 方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数) 方法的返回值 和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void） 习惯：SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径） package org.jsh.mapper; import org.jsh.entity.Student; import java.util.List; //操作Mybatis的接口 public interface StudentMapper { // 约定优于配置 // 1.方法名和mapper.xml中标签的id值一样 // 2.输入参数与mapper.xml文件中标签的parameterType类型一致 // 3.返回值与mapper.xml文件中标签的result类型一致 Student selectStudentByNum(int stunum); List\u003cStudent\u003e queryAllStudents(); void addStudent(Student student); void updateStudentByNum(Student student); void deleteStudentByNum(int stunum); } 使用 StudentMapper studentMapper=session.getMapper(StudentMapper.class); studentMapper.方法(); package org.jsh.test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.jsh.entity.Student; import org.jsh.mapper.StudentMapper; import java.io.IOException; import java.io.Reader; import java.util.List; public class TestMybatis { public static void main(String[] args) throws IOException { queryAllStudents(); //addStudent(); //deleteStudentByNum(); //updateStudentByNum(); //queryAllStudents(); } //查询单个学生 public static void queryStudentByNum() throws IOException { // 加载Mybatis配置文件 // conf.xml -\u003e reader Reader reader = Resources.getResourceAsReader(\"conf.xml\"); // reader - \u003e SqlSession // build的第二个参数 修改conf.xml中 \u003cenvironments default=\"development\"\u003e 的默认值 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); // SqlSession -\u003e connection SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); // 接口中的方法 Student student = studentMapper.selectStudentByNum(1); System.out.println(student); session.close(); } //查询多个学生 public static void queryAllStudents() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.queryAllStudents(); System.out.println(students); session.close(); } //增加学生 public static void addStudent() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Student student = new Student(3, \"wu\", 24,true); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.addStudent(student); session.commit();//提交数据 session.close(); } //删除学生 public static void deleteStudentByNum() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.deleteStudentByNum(3); session.commit();//提交数据 session.close(); } //修改 public static void updateStudentByNum() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); // 修改的参数 Student student = new Student(); // 修改哪个人，wehere stunum = 2 student.setStunum(2); // 修改成什么样子 student.setName(\"jsh\"); student.setAge(2); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.updateStudentByNum(student); session.commit();//提交数据 sess","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:2:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"三.分离配置信息 将配置信息放入 db.properties文件中 db.properties： k=v driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/testdata?useSSL=true\u0026serverTimezone=UTC username=root password=123456 动态引入 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 优化：引入properties文件--\u003e \u003cproperties resource=\"db.properties\" /\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!-- 加载映射文件--\u003e \u003cmapper resource=\"org/jsh/mapper/studentMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:3:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"四.Mybatis全局参数 \u003c!-- 全局变量设置--\u003e \u003csettings\u003e \u003csetting name=\"cacheEnabled\" value=\"false\"/\u003e \u003c/settings\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 优化：引入properties文件--\u003e \u003cproperties resource=\"db.properties\" /\u003e \u003c!-- 全局变量设置--\u003e \u003c!-- \u003csettings\u003e--\u003e \u003c!-- \u003csetting name=\"cacheEnabled\" value=\"false\"/\u003e--\u003e \u003c!-- \u003c/settings\u003e--\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!-- 加载映射文件--\u003e \u003cmapper resource=\"org/jsh/mapper/studentMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 参数 简介 有效值 cacheEnabled 在全局范围内，启用或禁用缓存 true（默认）、false lazyLoadingEnabled 在全局范围内启用或禁用延迟加载。当禁用时，所有相关联的对象都将立即加载（热加载）。 true（默认）、false aggressiveLazyLoading 启用时，有延迟加载属性的对象，在被调用时将会完全加载所有属性（立即加载）。否则，每一个属性都将按需加载（即延迟加载）。 true（默认）、false multipleResultSetsEnabled 允许或禁止执行一条单独的SQL语句后返回多条结果（结果集）；需要驱动程序的支持 true（默认）、false autoMappingBehavior 指定数据表字段和对象属性的映射方式。 NONE：禁止自动映射，只允许手工配置的映射 PARTIAL：只会自动映射简单的、没有嵌套的结果 FULL：自动映射任何结果（包含嵌套等） NONE、 PARTIAL（默认）、 FULL defaultExecutorType 指定默认的执行器。 SIMPLE：普通的执行器。 REUSE：可以重复使用prepared statements语句。 BATCH：可以重复执行语句和批量更新。 SIMPLE（默认）、 REUSE、 BATCH defaultStatementTimeout 设置驱动器等待数据库回应的最长时间 以秒为单位的，任意正整数。无默认值 safeRowBoundsEnabled 允许或禁止使用嵌套的语句 true、false（默认） mapUnderscoreToCamelCase 当在数据表中遇到有下划线的字段时，自动映射到相应驼峰式形式的Java属性名。例如，会自动将数据表中的stu_no字段，映射到POJO类的stuNo属性。 true、false（默认） lazyLoadTriggerMethods 指定触发延迟加载的对象的方法 equals、clone、hashCode、toString ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:4:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"五.别名设置 消除studentMapper.xml 中需要写全类名的繁琐形式 conf.xml : \u003cconfiguration\u003e ... \u003c!-- 定义单个/多个别名--\u003e \u003ctypeAliases\u003e \u003c!-- 单个别名 不区分大小写--\u003e \u003c!-- \u003ctypeAlias type=\"org.jsh.entity.student\" alias=\"student\" /\u003e--\u003e \u003c!-- 批量定义别名 不区分大小写 别名就是不带包名的类名--\u003e \u003cpackage name=\"org.jsh.entity\"/\u003e \u003c/typeAliases\u003e ... \u003c/configuration\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:5:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"六.类型转换器(不太懂) 自带 例如：int→number。。。 自定义 示例： 实体类Student : boolean stuSex true:男 false：女 表student： number stuSex 1:男 0：女 自定义类型转换器（boolean -number）步骤： 创建转换器：需要实现TypeHandler接口 实现接口TypeHandler接口 继承BaseTypeHandler package org.jsh.converter; import org.apache.ibatis.type.BaseTypeHandler; import org.apache.ibatis.type.JdbcType; import java.sql.CallableStatement; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; //BaseTypeHandler\u003cjava类型\u003e public class BooleanAndIntConverter extends BaseTypeHandler\u003cBoolean\u003e { // java -\u003e DB /* PreparedStatement : 操作的PreparedStatement i: PreparedStatement对象操作的位置 Boolean:Java值 JdbcType：数据库类型 */ @Override public void setNonNullParameter(PreparedStatement preparedStatement, int i, Boolean aBoolean, JdbcType jdbcType) throws SQLException { if(aBoolean){ preparedStatement.setInt(i,1); }else{ } } // DB -\u003e java @Override public Boolean getNullableResult(ResultSet resultSet, String s) throws SQLException { int sexNum = resultSet.getInt(s); return sexNum == 1?true:false; } // DB -\u003e java @Override public Boolean getNullableResult(ResultSet resultSet, int i) throws SQLException { int sexNum = resultSet.getInt(i); return sexNum == 1?true:false; } // DB -\u003e java @Override public Boolean getNullableResult(CallableStatement callableStatement, int i) throws SQLException { int sexNum = callableStatement.getInt(i); return sexNum == 1?true:false; } } 配置conf.xml \u003cconfiguration\u003e 。。。 \u003c!-- 配置转换器--\u003e \u003ctypeHandlers\u003e \u003ctypeHandler handler=\"org.jsh.converter.BooleanAndIntConverter\" javaType=\"Boolean\" jdbcType=\"INTEGER\" /\u003e \u003c/typeHandlers\u003e 。。。 \u003c/configuration\u003e 使用 查询 把select标签中resultType属性变为resultMap 值为id 创建resultMap标签 属性：id:传回select标签 属性： type: 返回值类型 子标签： 表中主键：标签为id 非主键result property:java实体类中属性名 column：数据表中属性名 javaType ：java实体类中属性类型 jdbcType ：数据表中属性类型 \u003cselect id=\"selectStudentByNumWithConverter\" parameterType=\"int\" resultMap=\"studentResult\"\u003e select * from student where stunum = #{stunum} \u003c/select\u003e \u003cresultMap id=\"studentResult\" type=\"student\"\u003e \u003c!-- 主键--\u003e \u003cid property=\"stunum\" column=\"stunum\"\u003e\u003c/id\u003e \u003c!-- 非主键--\u003e \u003cresult property=\"name\" column=\"name\" /\u003e \u003cresult property=\"age\" column=\"age\" /\u003e \u003cresult property=\"sex\" column=\"sex\" javaType=\"boolean\" jdbcType=\"INTEGER\" /\u003e \u003c/resultMap\u003e 增删改 \u003cinsert id=\"addStudentWithConverter\" parameterType=\"student\" \u003e insert into student(stunum,name,age,sex) values(#{stunum},#{name},#{age},#{sex,javaType=Boolean,jdbcType=INTEGER}) \u003c/insert\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:6:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"七.输入参数 parameterType 类型为 简单类型（8个基本类型+String) #{任意值} 自动给String类型加上 ’ ' 可以防止SQL注入 ${value} 其中标识符只能是value 原样输出 如果是String 类型 则需要在外加上单引号 ‘${value}’ 适合动态排序（动态字段） \u003cselect id=\"queryAllStudentsOrderByColumn\" parameterType=\"String\" resultType=\"student\"\u003e select * from student order by ${value} asc \u003c/select\u003e 不防止SQL注入 类型为对象： #{} #{对象属性名} 或者使用parameterMap \u003cselect id=\"queryStudentsOrderByColumn\" parameterType=\"student\" resultType=\"student\"\u003e select * from student where stunum = #{stunum} or name like #{name} \u003c/select\u003e 模糊查询需要在传递参数时加上 % public static void queryStudentsOrderByColumn() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Student student = new Student(3, \"%j%\", 24,true); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.queryStudentsOrderByColumn(student); System.out.println(students); session.close(); } ${} sql语句直接写好 \u003cselect id=\"queryStudentsOrderByColumn\" parameterType=\"student\" resultType=\"student\"\u003e select * from student where stunum = #{stunum} or name like '%${name}%' \u003c/select\u003e 传参 public static void queryStudentsOrderByColumn() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Student student = new Student(3, \"j\", 24,true); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.queryStudentsOrderByColumn(student); System.out.println(students); session.close(); } 嵌套属性 数据表加入schooladdress，homeaddress java实体类 Address 属性： schooladdress，homeaddress Student类中 加入Address 属性 方法一 xml \u003cselect id=\"selectStudentByaddress\" parameterType=\"address\" resultType=\"student\"\u003e select * from student where homeaddress = #{homeAddress} or schooladdress = '${schoolAddress}' \u003c/select\u003e java public static void selectStudentByaddress() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Address address = new Address(\"xa\",\"dl\"); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.selectStudentByaddress(address); System.out.println(students); session.close(); } 方法二，支持级联 xml \u003cselect id=\"selectStudentByaddress\" parameterType=\"student\" resultType=\"student\"\u003e select * from student where homeaddress = #{address.homeAddress} or schooladdress = '${address.schoolAddress}' \u003c/select\u003e java public static void selectStudentByaddress() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Address address = new Address(\"xa\",\"dl\"); Student student = new Student(); student.setAddress(address); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.selectStudentByaddress(student); System.out.println(students); session.close(); 输入对象为HashMap mapper.xml \u003cselect id=\"queryStudentsOrderByColumnWithHashMap\" parameterType=\"HashMap\" resultType=\"student\"\u003e select * from student where stunum = #{stunum} or name like '%${name}%' \u003c/select\u003e interface List\u003cStudent\u003e queryStudentsOrderByColumnWithHashMap(Map\u003cString,Object\u003e map); Test public static void queryStudentsOrderByColumnWithHashMap() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Map\u003cString,Object\u003e studentMap = new HashMap\u003c\u003e(); studentMap.put(\"stunum\",\"2\")","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:7:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"八.输出参数resultType 八个简单类型+String mapper.xml \u003c!--输出参数resultType--\u003e \u003cselect id=\"selectStudentCount\" resultType=\"int\"\u003e select count(*) from student \u003c/select\u003e interface int selectStudentCount(); test.java public static void selectStudentCount() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); int count = studentMapper.selectStudentCount(); System.out.println(count); session.close(); } 对象类型 mapper.xml \u003cselect id=\"queryStuByNum\" parameterType=\"int\" resultType=\"student\"\u003e select * from student where stunum = #{stunum} \u003c/select\u003e interface Student queryStuByNum(int stunum); test.java public static void queryStuByNum() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); Student student= studentMapper.queryStuByNum(2); System.out.println(student); session.close(); } 实体对象的集合类型 resultType不变 函数返回值变为列表 HashMap类型（起别名） 一个map一个学生 多人用list mapper.xml \u003cselect id=\"queryStudentOutByHashMap\" resultType=\"HashMap\"\u003e select stunum \"no\",name \"name\" from student \u003c/select\u003e interface //返回一个 HashMap\u003cString,Object\u003e queryStudentOutByHashMap(); //返回多个 List\u003cHashMap\u003cString,Object\u003e\u003e queryStudentOutByHashMap(); test public static void queryStudentOutByHashMap() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); //返回多个 List\u003cHashMap\u003cString,Object\u003e\u003e map = studentMapper.queryStudentOutByHashMap(); //返回一个 HashMap\u003cString,Object\u003e map = studentMapper.queryStudentOutByHashMap(); System.out.println(map); session.close(); } resultMap(实体类的属性和数据表的字段：类型，名字不同时) resultMap=“queryStudentByID” id=“queryStudentByID\"对应 property 实体类属性名（严格大小写） column 数据表属性名 \u003cselect id=\"queryStudentByID\" parameterType=\"int\" resultMap=\"queryStudentByID\"\u003e select stunum,name from student where stunum = #{stunum} \u003c/select\u003e \u003cresultMap id=\"queryStudentByID\" type=\"student\"\u003e \u003c!-- 主键--\u003e \u003cid property=\"stunum\" column=\"stuNum\"\u003e\u003c/id\u003e \u003c!-- 其他--\u003e \u003cresult column=\"name\" property=\"name\"\u003e\u003c/result\u003e \u003c/resultMap\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:8:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"九.动态SQL ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:9:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"where if mapper.xml \u003cselect id=\"queryStudentByNameOrAgeSQLTag\" parameterType=\"student\" resultType=\"student\"\u003e select stunum,name from student \u003cwhere\u003e \u003cif test=\"stunum != null and stunum!=''\"\u003e and name = #{name} \u003c/if\u003e \u003cif test=\"age != null and age!=0\"\u003e and age = #{age} \u003c/if\u003e \u003c/where\u003e \u003c/select\u003e where 语句用标签显示 if语句为条件 ​ test中表示属性存在且不为空 sql 语句前加and where标签会自动解析 ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:9:1","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"foreach 查询学号为1，2，3的学生信息 SQL：select * from student where stunum in(1,2,3) 作用：stunums = {1,2,3} foreach 迭代的类型：数组，集合，对象数组，对象属性 Grade.java package org.jsh.entity; import java.util.List; public class Grade { //学号 private List\u003cInteger\u003e stunums; public List\u003cInteger\u003e getStunums() { return stunums; } public void setStunums(List\u003cInteger\u003e stunums) { this.stunums = stunums; } // } mapper.xml collection: 对象的属性名 open：循环变量前边部分 close ：循环变量后边部分 separator： 循环变量的分隔符 \u003cselect id=\"queryStudentsWithGrade\" parameterType=\"Grade\" resultType=\"student\"\u003e select * from student \u003cwhere\u003e \u003cif test=\"stunums != null and stunums.size\u003e0\"\u003e \u003cforeach collection=\"stunums\" open=\" and stunum in (\" close=\")\" item=\"stunum\" separator=\",\"\u003e #{stunum} \u003c/foreach\u003e \u003c/if\u003e \u003c/where\u003e \u003c/select\u003e interface List\u003cStudent\u003e queryStudentsWithGrade(Grade grade); test public static void queryStudentsWithGrade() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); Grade grade = new Grade(); List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); grade.setStunums(list); List\u003cStudent\u003e students = studentMapper.queryStudentsWithGrade(grade); System.out.println(students); session.close(); } ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:9:2","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"十.关联查询 ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:10:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"业务扩展类 核心：用resultType指定类的属性 包含 多表查询的所有字段 StudentBusiness.java package org.jsh.entity; public class StudentBusiness extends Student{ private int cardID; private String cardInfo; public String getCardInfo() { return cardInfo; } public void setCardInfo(String cardInfo) { this.cardInfo = cardInfo; } public int getCardID() { return cardID; } public void setCardID(int cardID) { this.cardID = cardID; } @Override public String toString() { return \"StudentBusiness{\" + \"cardID=\" + cardID + super.toString()+ \", cardInfo='\" + cardInfo + '\\'' + '}'; } } mapper.xml \u003cselect id=\"queryStudentsByNumWithSAndC\" parameterType=\"int\" resultType=\"StudentBusiness\"\u003e SELECT s.*,c.* FROM student s INNER JOIN studentcard c ON s.`stucardid`=c.`cardid` WHERE s.`stunum` = #{stunum} \u003c/select\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:10:1","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"resultMap 通过属性成员将两个类建立起链接 StudentCard.java package org.jsh.entity; public class StudentCard { private int cardID; private String cardInfo; public String getCardInfo() { return cardInfo; } public void setCardInfo(String cardInfo) { this.cardInfo = cardInfo; } public int getCardID() { return cardID; } public void setCardID(int cardID) { this.cardID = cardID; } @Override public String toString() { return \"StudentCard{\" + \"cardID=\" + cardID + \", cardInfo='\" + cardInfo + '\\'' + '}'; } } Student.java package org.jsh.entity; public class Student { private int stunum; private String name; private int age; private boolean sex; private Address address; private StudentCard studentCard; public Student() { } public Student(int stunum, String name, int age, boolean sex) { this.stunum = stunum; this.name = name; this.age = age; this.sex = sex; } public Student(int stunum, String name, int age, boolean sex,Address address) { this.stunum = stunum; this.name = name; this.age = age; this.sex = sex; this.address = address; } public int getStunum() { return stunum; } public void setStunum(int stunum) { this.stunum = stunum; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"stunum=\" + stunum + \", name='\" + name + '\\'' + \", age=\" + age + \", sex=\" + sex + \", address=\" + address + \", studentBusiness=\" + studentCard + '}'; } public boolean isSex() { return sex; } public void setSex(boolean sex) { this.sex = sex; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } } mapper.xml 使用resultmap 一对一对象成员用 association 映射 javaType指定该属性的类型 \u003c学生\u003e ​ \u003c属性/\u003e ​ \u003c属性/\u003e ​ ​ \u003c属性/\u003e ​ \u003c属性/\u003e ​ \u003c/学生\u003e \u003cselect id=\"queryStudentsByNumWithSAndC\" parameterType=\"int\" resultMap=\"student_card_map\"\u003e SELECT s.*,c.* FROM student s INNER JOIN studentcard c ON s.`stucardid`=c.`cardid` WHERE s.`stunum` = #{stunum} \u003c/select\u003e \u003cresultMap id=\"student_card_map\" type=\"Student\"\u003e \u003c!-- 学生信息--\u003e \u003cid property=\"stunum\" column=\"stunum\"\u003e\u003c/id\u003e \u003cresult property=\"name\" column=\"name\"\u003e\u003c/result\u003e \u003cresult property=\"age\" column=\"age\"\u003e\u003c/result\u003e \u003c!-- 一对一对象成员用association映射 javaType指定该属性的类型 --\u003e \u003cassociation property=\"studentCard\" javaType=\"StudentCard\"\u003e \u003cid property=\"cardID\" column=\"cardID\"\u003e\u003c/id\u003e \u003cresult property=\"cardInfo\" column=\"cardInfo\"\u003e\u003c/result\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:10:2","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"一对多 studentclasss-\u003estudent 一对多 studentclass.java package org.jsh.entity; import java.util.List; public class StudentClass { private int classID; private String classname; private List\u003cStudent\u003e students; public StudentClass() { } public int getClassID() { return classID; } public void setClassID(int classID) { this.classID = classID; } public String getClassname() { return classname; } public void setClassname(String classname) { this.classname = classname; } public List\u003cStudent\u003e getStudents() { return students; } public void setStudents(List\u003cStudent\u003e students) { this.students = students; } @Override public String toString() { return \"StudentClass{\" + \"classID=\" + classID + \", classname='\" + classname + '\\'' + \", students=\" + students + '}'; } } mapper.xml 一对多用collection 映射 javatype指定的是user对象的属性的类型（例如id，posts），而oftype指定的是映射到list集合属性中pojo的类型 \u003c!-- 一对多--\u003e \u003cselect id=\"queryClassAndStudents\" parameterType=\"int\" resultMap=\"class_student_map\"\u003e SELECT c.*,s.* FROM student s INNER JOIN studentclass c ON c.`classid`=s.`classid` WHERE s.`classid` = #{classID} \u003c/select\u003e \u003cresultMap id=\"class_student_map\" type=\"StudentClass\"\u003e \u003cid property=\"classID\" column=\"classID\"/\u003e \u003cresult property=\"classname\" column=\"classname\"/\u003e \u003ccollection property=\"students\" ofType=\"student\"\u003e \u003cid property=\"stunum\" column=\"stunum\"\u003e\u003c/id\u003e \u003cresult property=\"name\" column=\"name\"\u003e\u003c/result\u003e \u003cresult property=\"age\" column=\"age\"\u003e\u003c/result\u003e \u003c/collection\u003e \u003c/resultMap\u003e \u003c/mapper\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:10:3","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"十一.日志(Log4j) 导入 Log4j.jar conf.xml配置 \u003csettings\u003e \u003c!-- 开启日志，并指定使用的具体日志--\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c/settings\u003e 如果不指定，Mybatis就会根据以下顺序寻找日志 SLF4J → Apache Commons Logging → Log4j 2 → Log4j → JDK logging 编写日志输出文件 log4j.properties log4j.rootLogger=debug,stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 日志级别 DEBUG\u003cINFO\u003cWARN\u003cERROR 如果设置为DEBUG 则只显示DEBUG及以上级别的信息 建议 在开发时设置为DEBUG 在运行时设置为INFO及以上 ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:11:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"十二.延迟加载 conf.xml 配置 \u003csettings\u003e \u003c!-- 开启日志，并指定使用的具体日志--\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c!-- 开启延迟加载--\u003e \u003csetting name=\"lazyLoadingEnabled\" value=\"true\"/\u003e \u003c!-- 关闭立即加载--\u003e \u003csetting name=\"aggressiveLazyLoading\" value=\"false\"/\u003e \u003c/settings\u003e mapper.xml \u003cselect id=\"queryStudentsByNumWithSAndC1\" parameterType=\"int\" resultMap=\"student_card_lazyload_map\"\u003e SELECT * FROM student \u003c/select\u003e \u003cresultMap id=\"student_card_lazyload_map\" type=\"Student\"\u003e \u003c!-- 学生信息--\u003e \u003cid property=\"stunum\" column=\"stunum\"\u003e\u003c/id\u003e \u003cresult property=\"name\" column=\"name\"\u003e\u003c/result\u003e \u003cresult property=\"age\" column=\"age\"\u003e\u003c/result\u003e \u003cassociation property=\"studentCard\" javaType=\"StudentCard\" select=\"org.jsh.mapper.studentCardMapper.queryCardByID\" column=\"cardID\"\u003e \u003c/association\u003e \u003c/resultMap\u003e \u003cmapper namespace=\"org.jsh.mapper.studentCardMapper\"\u003e \u003cselect id=\"queryCardByID\" parameterType=\"int\" resultType=\"studentCard\"\u003e select * from studnetCard where cardid = ${cardID} \u003c/select\u003e \u003c/mapper\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:12:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"十三.二级缓存 查询缓存 一级缓存 ：同一个SqlSession对象 MyBatis默认开启一级缓存，如果用同样的SqlSession对象查询相同的数据， 则只会在第一次 查询时 向数据库发送SQL语句，并将查询的结果 放入到SQLSESSION中（作为缓存在）； 后续再次查询该同样的对象时， 则直接从缓存中查询该对象即可（即省略了数据库的访问） 二级缓存 MyBatis默认情况没有开启二级缓存，需要手工打开。 conf.xml \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e .在具体的mapper.xml中声明开启(studentMapper.xml中) \u003ccache/\u003e MyBatis的二级缓存 是将对象 放入硬盘文件中 序列化：内存-\u003e硬盘 反序列化：硬盘-\u003e内存 准备缓存的对象，必须实现了序列化接口 （如果开启的缓存Namespace=“org.lanqiao.mapper.StudentMapper”），可知序列化对象为Student，因此需要将Student序列化 （序列化Student类，以及Student的级联属性、和父类） implements Serializable 触发将对象写入二级缓存的时机：SqlSession对象的close()方法。 test public static void queryStudentByStuno2() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\") ; SqlSessionFactory sessionFacotry = new SqlSessionFactoryBuilder().build(reader,\"development\") ; // 第一次查询 SqlSession session = sessionFacotry.openSession() ; StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.selectStudentByNum(1) ; session.close(); // 第二次查询 SqlSession session2 = sessionFacotry.openSession() ; StudentMapper studentMapper2 = session2.getMapper(StudentMapper.class) ; Student student2 = studentMapper2.selectStudentByNum(1) ;//接口中的方法-\u003eSQL语句 session2.close(); System.out.println(student.getStunum()+\",\"+student2.getStunum()); } –\u003enamespace决定了studentMapper对象的产生 结论：只要产生的xxxMapper对象 来自于同一个namespace，则 这些对象 共享二级缓存。 注意：二级缓存 的范围是同一个namespace, 如果有多个xxMapper.xml的namespace值相同，则通过这些xxxMapper.xml产生的xxMapper对象 仍然共享二级缓存。 禁用 ：select标签中useCache=“false” \u003cselect id=\"selectStudentByNum\" parameterType=\"int\" resultType=\"student\" useCache=\"false\"\u003e -- sql语句 select * from student where stunum = #{stunum} \u003c/select\u003e commit() 清理缓存 一级二级一样 ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:13:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"Ehcache 整合ehcache二级缓存 ehcache-core.jar mybatis-Ehcache.jar slf4j-api.jar 编写ehcache配置文件 Ehcache.xml \u003cehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"\u003e \u003c!--当二级缓存的对象 超过内存限制时（缓存对象的个数\u003emaxElementsInMemory），存放入的硬盘文件 --\u003e \u003cdiskStore path=\"F:\\Ehcache\"/\u003e \u003c!-- maxElementsInMemory:设置 在内存中缓存 对象的个数 maxElementsOnDisk：设置 在硬盘中缓存 对象的个数 eternal：设置缓存是否 永远不过期 overflowToDisk：当内存中缓存的对象个数 超过maxElementsInMemory的时候，是否转移到硬盘中 timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效 timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期） diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存 memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU --\u003e \u003cdefaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"1000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"100\" timeToLiveSeconds=\"100\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"\u003e \u003c/defaultCache\u003e \u003c/ehcache\u003e 开启EhCache二级缓存 在xxxMapper.xml中开启 \u003c!-- 开启ehcache--\u003e \u003ccache type=\"org.mybatis.caches.ehcache.EhcacheCache\"\u003e \u003c!-- 覆盖Ehcache.xml里的值--\u003e \u003cproperty name=\"maxElementsInMemory\" value=\"100\"/\u003e \u003c/cache\u003e ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:13:1","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Spring"],"content":"十四.逆向工程 表、类、接口、mapper.xml四者密切相关，因此 当知道一个的时候 其他三个应该可以自动生成。 表-\u003e其他三个 实现步骤： mybatis-generator-core.jar、mybatis.jar、ojdbc.jar 逆向工程的配置文件generator.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"DB2Tables\" targetRuntime=\"MyBatis3\"\u003e \u003ccommentGenerator\u003e \u003c!-- suppressAllComments属性值： true:自动生成实体类、SQL映射文件时没有注释 true:自动生成实体类、SQL映射文件，并附有注释 --\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\" /\u003e \u003c/commentGenerator\u003e \u003c!-- 数据库连接信息 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/testdata?useSSL=true\u0026amp;serverTimezone=UTC\" userId=\"root\" password=\"123456\"\u003e \u003c/jdbcConnection\u003e \u003c!-- forceBigDecimals属性值： true:把数据表中的DECIMAL和NUMERIC类型， 解析为JAVA代码中的java.math.BigDecimal类型 false(默认):把数据表中的DECIMAL和NUMERIC类型， 解析为解析为JAVA代码中的Integer类型 --\u003e \u003cjavaTypeResolver\u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\" /\u003e \u003c/javaTypeResolver\u003e \u003c!-- targetProject属性值:实体类的生成位置 targetPackage属性值：实体类所在包的路径 --\u003e \u003cjavaModelGenerator targetPackage=\"org.jsh.entity\" targetProject=\".\\src\"\u003e \u003c!-- trimStrings属性值： true：对数据库的查询结果进行trim操作 false(默认)：不进行trim操作 --\u003e \u003cproperty name=\"trimStrings\" value=\"true\" /\u003e \u003c/javaModelGenerator\u003e \u003c!-- targetProject属性值:SQL映射文件的生成位置 targetPackage属性值：SQL映射文件所在包的路径 --\u003e \u003csqlMapGenerator targetPackage=\"org.jsh.mapper\" targetProject=\".\\src\"\u003e \u003c/sqlMapGenerator\u003e \u003c!-- 生成动态代理的接口 --\u003e \u003cjavaClientGenerator type=\"XMLMAPPER\" targetPackage=\"org.jsh.mapper\" targetProject=\".\\src\"\u003e \u003c/javaClientGenerator\u003e \u003c!-- 指定数据库表 --\u003e \u003ctable tableName=\"Student\"\u003e \u003c/table\u003e \u003ctable tableName=\"studentCard\"\u003e \u003c/table\u003e \u003ctable tableName=\"studentClass\"\u003e \u003c/table\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e 执行 package org.jsh.test; import org.mybatis.generator.api.MyBatisGenerator; import org.mybatis.generator.config.Configuration; import org.mybatis.generator.config.xml.ConfigurationParser; import org.mybatis.generator.exception.InvalidConfigurationException; import org.mybatis.generator.exception.XMLParserException; import org.mybatis.generator.internal.DefaultShellCallback; import java.io.File; import java.io.IOException; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class Test { public static void main(String[] args) throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException { File file = new File(\"src/generator.xml\") ;//配置文件 List\u003cString\u003e warnings = new ArrayList\u003c\u003e(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(file); DefaultShellCallback callBack = new DefaultShellCallback(true); //逆向工程的核心类 MyBatisGenerator generator = new MyBatisGenerator(config, callBack,warnings ); generator.generate(null); } } ","date":"2020-03-16","objectID":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:14:0","tags":["框架"],"title":"Mybatis基础总结","uri":"/mybatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["前端"],"content":"前端-js-正则表达式（day4） 定义正则表达式 以及使用 // RegExp // 定义正则表达式（ “正则表达式”，“匹配模式”） // 匹配模式 // i:忽略大小写 // g:全局匹配模式 // 字符串中是否含有a var reg = new RegExp(\"a\"); var str = \"a\"; // test 测试 console.log(reg.test(str)); // 使用字面量创建正则表达式 // 语法 var 变量 = /正则表达式/匹配模式; var reg1 = /a/i; console.log(reg1.test(str)); 或 | // 创建一个正则表达式 判断一个字符串中是否含有a或b或c // | // [] 里边是或的关系 // [abc] == a|b|c var reg2 = /a|b|c/; var reg2 = /[abc]/; var str2 = \"a\"; console.log(reg2.test(str2)); // 判断是否含有字母 // [a-z]表示任意小写字母 // [A-Z]表示任意大写字母 // [A-z]表示任意字母 // [0-9]表示任意数字 var reg3 = /[a-z]/; var str3 = \"m\"; console.log(reg3.test(str3)); // 表达一个字符串中是否含有abc或adc或aec var reg4 = /a[bde]c/; var str4 = \"aec\"; 除了 [^] // [^ ] 除了 // 如果还有别的返回 true var reg5 = /[^bde]/; var str5 = \"bdef\"; console.log(reg5.test(str5)); 量词 {} // 量词 设置一个内容出现的次数 只对前一个内容起作用 // {n}正好出现n次 // {n,m} n到m次 // {n,} n次以上 var reg = /a{3}/; var str11 = \"aaa\"; console.log(reg.test(str11)); var reg = /(ab){3}/; var str11 = \"ababab\"; console.log(reg.test(str11)); // x+ 至少一个x 相当于{1,} var reng = /am+c/; console.log(reg.test(\"ammmmc\")); // x* 0个或多个 相当于{0,} var reg = /am*c/; console.log(reg.test(\"ammmmc\")); // x? 0个或一个 相当于{0,1} var reg = /am?c/; console.log(reg.test(\"ac\")); 开头结尾 // 检查一个字符串是否以a开头 var reg = /^a/; console.log(reg.test(\"ammmmc\")); // 检查一个字符串是否以a结尾 var reg = /a$/; console.log(reg.test(\"ammmm\")); 手机号的正则表达式 //手机号的正则表达式 var reg = /^1[3-9][0-9]{9}$/; console.log(reg.test(18235741168)); // 检查一个字符串中是否含有. // \\.表示. // \\\\表示\\ var reg = /\\./; console.log(reg.test(\".\")); // 字面量中 使用一个\\ // 在构造函数中 如果要使用\\ 需要用\\\\来代替 正则表达式 - 元字符 下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为： 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\" 而 “(” 则匹配 “(\"。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n \u003c= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，‘o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.|\\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(’ 或 ‘)’。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)“能匹配\"Windows2000\"中的\"Windows”，但不能匹配\"Windows3.1\"中的\"Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如\"Windows(?!95|98|NT|2000)“能匹配\"Windows3.1\"中的\"Windows”，但不能匹配\"Windows2000\"中的\"Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?\u003c=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，\"`(?\u003c=95 (?\u003c!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?\"能匹配\"3.1Windows\"中的\"Windows\"，但不能匹配\"2000Windows\"中的\"Windows`\"。 x|y 匹配 x 或 y。例如，‘z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、‘i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ’er\\b’ 可以匹配\"never\" 中的 ’er’，但不能匹配 “verb” 中的 ’er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ’er’，但不能匹配 “never” 中的 ’er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个","date":"2020-03-15","objectID":"/%E5%89%8D%E7%AB%AF-js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fday4/:0:0","tags":[],"title":"前端-js-正则表达式（day4）","uri":"/%E5%89%8D%E7%AB%AF-js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fday4/"},{"categories":["Spring"],"content":"后端-Mybatis-逆向工程(day10) 表、类、接口、mapper.xml四者密切相关，因此 当知道一个的时候 其他三个应该可以自动生成。 表-\u003e其他三个 实现步骤： mybatis-generator-core.jar、mybatis.jar、ojdbc.jar 逆向工程的配置文件generator.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"DB2Tables\" targetRuntime=\"MyBatis3\"\u003e \u003ccommentGenerator\u003e \u003c!-- suppressAllComments属性值： true:自动生成实体类、SQL映射文件时没有注释 true:自动生成实体类、SQL映射文件，并附有注释 --\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\" /\u003e \u003c/commentGenerator\u003e \u003c!-- 数据库连接信息 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/testdata?useSSL=true\u0026amp;serverTimezone=UTC\" userId=\"root\" password=\"123456\"\u003e \u003c/jdbcConnection\u003e \u003c!-- forceBigDecimals属性值： true:把数据表中的DECIMAL和NUMERIC类型， 解析为JAVA代码中的java.math.BigDecimal类型 false(默认):把数据表中的DECIMAL和NUMERIC类型， 解析为解析为JAVA代码中的Integer类型 --\u003e \u003cjavaTypeResolver\u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\" /\u003e \u003c/javaTypeResolver\u003e \u003c!-- targetProject属性值:实体类的生成位置 targetPackage属性值：实体类所在包的路径 --\u003e \u003cjavaModelGenerator targetPackage=\"org.jsh.entity\" targetProject=\".\\src\"\u003e \u003c!-- trimStrings属性值： true：对数据库的查询结果进行trim操作 false(默认)：不进行trim操作 --\u003e \u003cproperty name=\"trimStrings\" value=\"true\" /\u003e \u003c/javaModelGenerator\u003e \u003c!-- targetProject属性值:SQL映射文件的生成位置 targetPackage属性值：SQL映射文件所在包的路径 --\u003e \u003csqlMapGenerator targetPackage=\"org.jsh.mapper\" targetProject=\".\\src\"\u003e \u003c/sqlMapGenerator\u003e \u003c!-- 生成动态代理的接口 --\u003e \u003cjavaClientGenerator type=\"XMLMAPPER\" targetPackage=\"org.jsh.mapper\" targetProject=\".\\src\"\u003e \u003c/javaClientGenerator\u003e \u003c!-- 指定数据库表 --\u003e \u003ctable tableName=\"Student\"\u003e \u003c/table\u003e \u003ctable tableName=\"studentCard\"\u003e \u003c/table\u003e \u003ctable tableName=\"studentClass\"\u003e \u003c/table\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e 执行 package org.jsh.test; import org.mybatis.generator.api.MyBatisGenerator; import org.mybatis.generator.config.Configuration; import org.mybatis.generator.config.xml.ConfigurationParser; import org.mybatis.generator.exception.InvalidConfigurationException; import org.mybatis.generator.exception.XMLParserException; import org.mybatis.generator.internal.DefaultShellCallback; import java.io.File; import java.io.IOException; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class Test { public static void main(String[] args) throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException { File file = new File(\"src/generator.xml\") ;//配置文件 List\u003cString\u003e warnings = new ArrayList\u003c\u003e(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(file); DefaultShellCallback callBack = new DefaultShellCallback(true); //逆向工程的核心类 MyBatisGenerator generator = new MyBatisGenerator(config, callBack,warnings ); generator.generate(null); } } ","date":"2020-03-15","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8Bday10/:0:0","tags":[],"title":"后端-Mybatis-逆向工程(day10)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8Bday10/"},{"categories":["前端"],"content":"前端-js-(day3) ","date":"2020-03-14","objectID":"/%E5%89%8D%E7%AB%AF-js-day3/:0:0","tags":[],"title":"前端-js-(day3)","uri":"/%E5%89%8D%E7%AB%AF-js-day3/"},{"categories":["前端"],"content":"数组 var arr = [\"sss\",\"ss\",\"sss\"]; 数据的方法 push() 向数组中最后添加元素 一个或多个 pop() 删除数据中最后一个元素并返回 unshift() 向数组中前边添加元素 一个或多个 并返回数组长度 shift() 删除数据中第一个元素并返回 slice(开始位置，结束位置) 从数组中提取指定元素 不会改变原数组 包含开始 不包含结束 第二个参数可以不写（从开始位置截取到末尾） 可以写负数 从末尾开始算 splice(开始位置，删除的数量) 会改变原数组 并返回删除的内容 第三个参数及以后可以传递一些新元素，这些元素自动插入到开始位置 ","date":"2020-03-14","objectID":"/%E5%89%8D%E7%AB%AF-js-day3/:1:0","tags":[],"title":"前端-js-(day3)","uri":"/%E5%89%8D%E7%AB%AF-js-day3/"},{"categories":["前端"],"content":"arguments 在调用函数时，传递的参数都会在arguments中保存 arguments.lenght arguments[0]; 不定义形参也可以使用实参 callee: 就是当前正在使用的函数的对象 function fun(){ console.log(arguments.length); console.log(arguments[0]); console.log(arguments.callee); } fun(1,2); JavaScript Date 对象 ","date":"2020-03-14","objectID":"/%E5%89%8D%E7%AB%AF-js-day3/:2:0","tags":[],"title":"前端-js-(day3)","uri":"/%E5%89%8D%E7%AB%AF-js-day3/"},{"categories":["前端"],"content":"Date 对象 Date 对象用于处理日期和时间。 ","date":"2020-03-14","objectID":"/%E5%89%8D%E7%AB%AF-js-day3/:3:0","tags":[],"title":"前端-js-(day3)","uri":"/%E5%89%8D%E7%AB%AF-js-day3/"},{"categories":["前端"],"content":"创建 Date 对象的语法： var myDate=new Date() **注释：**Date 对象会自动把当前日期和时间保存为其初始值。 ","date":"2020-03-14","objectID":"/%E5%89%8D%E7%AB%AF-js-day3/:3:1","tags":[],"title":"前端-js-(day3)","uri":"/%E5%89%8D%E7%AB%AF-js-day3/"},{"categories":["前端"],"content":"Date 对象属性 属性 描述 constructor 返回对创建此对象的 Date 函数的引用。 prototype 使您有能力向对象添加属性和方法。 ","date":"2020-03-14","objectID":"/%E5%89%8D%E7%AB%AF-js-day3/:4:0","tags":[],"title":"前端-js-(day3)","uri":"/%E5%89%8D%E7%AB%AF-js-day3/"},{"categories":["前端"],"content":"Date 对象方法 方法 描述 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 toSource() 返回该对象的源代码。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 请使用 toUTCString() 方法代替。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 ","date":"2020-03-14","objectID":"/%E5%89%8D%E7%AB%AF-js-day3/:5:0","tags":[],"title":"前端-js-(day3)","uri":"/%E5%89%8D%E7%AB%AF-js-day3/"},{"categories":["Spring"],"content":"后端-Mybatis-二级缓存(day9) 查询缓存 一级缓存 ：同一个SqlSession对象 MyBatis默认开启一级缓存，如果用同样的SqlSession对象查询相同的数据， 则只会在第一次 查询时 向数据库发送SQL语句，并将查询的结果 放入到SQLSESSION中（作为缓存在）； 后续再次查询该同样的对象时， 则直接从缓存中查询该对象即可（即省略了数据库的访问） 二级缓存 MyBatis默认情况没有开启二级缓存，需要手工打开。 conf.xml 开启二级缓存 .在具体的mapper.xml中声明开启(studentMapper.xml中) 声明次namespace开启二级缓存 MyBatis的二级缓存 是将对象 放入硬盘文件中 序列化：内存-\u003e硬盘 反序列化：硬盘-\u003e内存 准备缓存的对象，必须实现了序列化接口 （如果开启的缓存Namespace=“org.lanqiao.mapper.StudentMapper”），可知序列化对象为Student，因此需要将Student序列化 （序列化Student类，以及Student的级联属性、和父类） implements Serializable 触发将对象写入二级缓存的时机：SqlSession对象的close()方法。 test public static void queryStudentByStuno2() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\") ; SqlSessionFactory sessionFacotry = new SqlSessionFactoryBuilder().build(reader,\"development\") ; // 第一次查询 SqlSession session = sessionFacotry.openSession() ; StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.selectStudentByNum(1) ; session.close(); // 第二次查询 SqlSession session2 = sessionFacotry.openSession() ; StudentMapper studentMapper2 = session2.getMapper(StudentMapper.class) ; Student student2 = studentMapper2.selectStudentByNum(1) ;//接口中的方法-\u003eSQL语句 session2.close(); System.out.println(student.getStunum()+\",\"+student2.getStunum()); } –\u003enamespace决定了studentMapper对象的产生 结论：只要产生的xxxMapper对象 来自于同一个namespace，则 这些对象 共享二级缓存。 注意：二级缓存 的范围是同一个namespace, 如果有多个xxMapper.xml的namespace值相同，则通过这些xxxMapper.xml产生的xxMapper对象 仍然共享二级缓存。 禁用 ：select标签中useCache=“false” \u003cselect id=\"selectStudentByNum\" parameterType=\"int\" resultType=\"student\" useCache=\"false\"\u003e -- sql语句 select * from student where stunum = #{stunum} \u003c/select\u003e commit() 清理缓存 一级二级一样 ","date":"2020-03-14","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98day9/:0:0","tags":[],"title":"后端-Mybatis-二级缓存(day9)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98day9/"},{"categories":["Spring"],"content":"Ehcache 整合ehcache二级缓存 ehcache-core.jar mybatis-Ehcache.jar slf4j-api.jar 编写ehcache配置文件 Ehcache.xml \u003cehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"\u003e \u003c!--当二级缓存的对象 超过内存限制时（缓存对象的个数\u003emaxElementsInMemory），存放入的硬盘文件 --\u003e \u003cdiskStore path=\"F:\\Ehcache\"/\u003e \u003c!-- maxElementsInMemory:设置 在内存中缓存 对象的个数 maxElementsOnDisk：设置 在硬盘中缓存 对象的个数 eternal：设置缓存是否 永远不过期 overflowToDisk：当内存中缓存的对象个数 超过maxElementsInMemory的时候，是否转移到硬盘中 timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效 timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期） diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存 memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU --\u003e \u003cdefaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"1000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"100\" timeToLiveSeconds=\"100\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"\u003e \u003c/defaultCache\u003e \u003c/ehcache\u003e 开启EhCache二级缓存 在xxxMapper.xml中开启 \u003c!-- 开启ehcache--\u003e \u003ccache type=\"org.mybatis.caches.ehcache.EhcacheCache\"\u003e \u003c!-- 覆盖Ehcache.xml里的值--\u003e \u003cproperty name=\"maxElementsInMemory\" value=\"100\"/\u003e \u003c/cache\u003e ","date":"2020-03-14","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98day9/:1:0","tags":[],"title":"后端-Mybatis-二级缓存(day9)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98day9/"},{"categories":["前端"],"content":"前端-js-(day2) ","date":"2020-03-13","objectID":"/%E5%89%8D%E7%AB%AF-js-day2/:0:0","tags":[],"title":"前端-js-(day2)","uri":"/%E5%89%8D%E7%AB%AF-js-day2/"},{"categories":["前端"],"content":"Null 表示空对象 ","date":"2020-03-13","objectID":"/%E5%89%8D%E7%AB%AF-js-day2/:1:0","tags":[],"title":"前端-js-(day2)","uri":"/%E5%89%8D%E7%AB%AF-js-day2/"},{"categories":["前端"],"content":"Undefined 声明变量但不给变量赋值 ","date":"2020-03-13","objectID":"/%E5%89%8D%E7%AB%AF-js-day2/:2:0","tags":[],"title":"前端-js-(day2)","uri":"/%E5%89%8D%E7%AB%AF-js-day2/"},{"categories":["前端"],"content":"强制类型转换 转为String 1.toString() 不能转换null和undefind 2.String() var a = 123; a = a.toString(); a = String(a); 转换为Number 1.Number() ​ 字符串（数字）直接转换 ​ 如果有非数字内容 转换为NaN ​ true 1 false 0 ​ null 0 ​ undefind NaN 2.parseInt() 把字符串转换成整数 ​ 取出有效整数 只取第一个 ​ parseFloat() 可以取得有效小数 var a = \"123\"; a = Number(a); ","date":"2020-03-13","objectID":"/%E5%89%8D%E7%AB%AF-js-day2/:3:0","tags":[],"title":"前端-js-(day2)","uri":"/%E5%89%8D%E7%AB%AF-js-day2/"},{"categories":["前端"],"content":"对象 //新建对象 var obj = new Object(); //添加属性 obj.name = \"sss\"; //读取属性 console.log(obj.name); 检查对象中是否有属性 cosole.log(\"name\" in obj); 创建对象 var obj2 = { name:\"sss\", age:14, sex:true }; ","date":"2020-03-13","objectID":"/%E5%89%8D%E7%AB%AF-js-day2/:4:0","tags":[],"title":"前端-js-(day2)","uri":"/%E5%89%8D%E7%AB%AF-js-day2/"},{"categories":["前端"],"content":"函数 var fun = function(){ } 立即执行函数 (function(a,b){ console.log(a); console.log(b); })(123,456); 对象中定义方法 var obj2 = { name:\"sss\", age:14, sex:true, fun:function(){ } }; 枚举对象中的属性，值 for(var a in obj){ console.log(a); console.log(obj[a]); } ","date":"2020-03-13","objectID":"/%E5%89%8D%E7%AB%AF-js-day2/:5:0","tags":[],"title":"前端-js-(day2)","uri":"/%E5%89%8D%E7%AB%AF-js-day2/"},{"categories":["Spring"],"content":"后端-Mybatis-日志(Log4j)和延迟加载(day8) ","date":"2020-03-13","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E6%97%A5%E5%BF%97log4j%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDday8/:0:0","tags":[],"title":"后端-Mybatis-日志(Log4j)和延迟加载(day8)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E6%97%A5%E5%BF%97log4j%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDday8/"},{"categories":["Spring"],"content":"Log4j.jar ","date":"2020-03-13","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E6%97%A5%E5%BF%97log4j%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDday8/:1:0","tags":[],"title":"后端-Mybatis-日志(Log4j)和延迟加载(day8)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E6%97%A5%E5%BF%97log4j%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDday8/"},{"categories":["Spring"],"content":"开启日志 导入 Log4j.jar conf.xml配置 \u003csettings\u003e \u003c!-- 开启日志，并指定使用的具体日志--\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c/settings\u003e 如果不指定，Mybatis就会根据以下顺序寻找日志 SLF4J → Apache Commons Logging → Log4j 2 → Log4j → JDK logging 编写日志输出文件 log4j.properties log4j.rootLogger=debug,stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 日志级别 DEBUG\u003cINFO\u003cWARN\u003cERROR 如果设置为DEBUG 则只显示DEBUG及以上级别的信息 建议 在开发时设置为DEBUG 在运行时设置为INFO及以上 ","date":"2020-03-13","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E6%97%A5%E5%BF%97log4j%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDday8/:1:1","tags":[],"title":"后端-Mybatis-日志(Log4j)和延迟加载(day8)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E6%97%A5%E5%BF%97log4j%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDday8/"},{"categories":["Spring"],"content":"延迟加载 conf.xml 配置 \u003csettings\u003e \u003c!-- 开启日志，并指定使用的具体日志--\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c!-- 开启延迟加载--\u003e \u003csetting name=\"lazyLoadingEnabled\" value=\"true\"/\u003e \u003c!-- 关闭立即加载--\u003e \u003csetting name=\"aggressiveLazyLoading\" value=\"false\"/\u003e \u003c/settings\u003e mapper.xml \u003cselect id=\"queryStudentsByNumWithSAndC1\" parameterType=\"int\" resultMap=\"student_card_lazyload_map\"\u003e SELECT * FROM student \u003c/select\u003e \u003cresultMap id=\"student_card_lazyload_map\" type=\"Student\"\u003e \u003c!-- 学生信息--\u003e \u003cid property=\"stunum\" column=\"stunum\"\u003e\u003c/id\u003e \u003cresult property=\"name\" column=\"name\"\u003e\u003c/result\u003e \u003cresult property=\"age\" column=\"age\"\u003e\u003c/result\u003e \u003cassociation property=\"studentCard\" javaType=\"StudentCard\" select=\"org.jsh.mapper.studentCardMapper.queryCardByID\" column=\"cardID\"\u003e \u003c/association\u003e \u003c/resultMap\u003e \u003cmapper namespace=\"org.jsh.mapper.studentCardMapper\"\u003e \u003cselect id=\"queryCardByID\" parameterType=\"int\" resultType=\"studentCard\"\u003e select * from studnetCard where cardid = ${cardID} \u003c/select\u003e \u003c/mapper\u003e ","date":"2020-03-13","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E6%97%A5%E5%BF%97log4j%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDday8/:2:0","tags":[],"title":"后端-Mybatis-日志(Log4j)和延迟加载(day8)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E6%97%A5%E5%BF%97log4j%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDday8/"},{"categories":["Spring"],"content":"关联查询 准备 建立StudentCard表（cardid，cardinfo） 建立外键连接 ","date":"2020-03-12","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/:0:0","tags":[],"title":"关联查询","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/"},{"categories":["Spring"],"content":"一对一 ","date":"2020-03-12","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/:1:0","tags":[],"title":"关联查询","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/"},{"categories":["Spring"],"content":"业务扩展类 核心：用resultType指定类的属性 包含 多表查询的所有字段 StudentBusiness.java package org.jsh.entity; public class StudentBusiness extends Student{ private int cardID; private String cardInfo; public String getCardInfo() { return cardInfo; } public void setCardInfo(String cardInfo) { this.cardInfo = cardInfo; } public int getCardID() { return cardID; } public void setCardID(int cardID) { this.cardID = cardID; } @Override public String toString() { return \"StudentBusiness{\" + \"cardID=\" + cardID + super.toString()+ \", cardInfo='\" + cardInfo + '\\'' + '}'; } } mapper.xml \u003cselect id=\"queryStudentsByNumWithSAndC\" parameterType=\"int\" resultType=\"StudentBusiness\"\u003e SELECT s.*,c.* FROM student s INNER JOIN studentcard c ON s.`stucardid`=c.`cardid` WHERE s.`stunum` = #{stunum} \u003c/select\u003e ","date":"2020-03-12","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/:1:1","tags":[],"title":"关联查询","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/"},{"categories":["Spring"],"content":"resultMap 通过属性成员将两个类建立起链接 StudentCard.java package org.jsh.entity; public class StudentCard { private int cardID; private String cardInfo; public String getCardInfo() { return cardInfo; } public void setCardInfo(String cardInfo) { this.cardInfo = cardInfo; } public int getCardID() { return cardID; } public void setCardID(int cardID) { this.cardID = cardID; } @Override public String toString() { return \"StudentCard{\" + \"cardID=\" + cardID + \", cardInfo='\" + cardInfo + '\\'' + '}'; } } Student.java package org.jsh.entity; public class Student { private int stunum; private String name; private int age; private boolean sex; private Address address; private StudentCard studentCard; public Student() { } public Student(int stunum, String name, int age, boolean sex) { this.stunum = stunum; this.name = name; this.age = age; this.sex = sex; } public Student(int stunum, String name, int age, boolean sex,Address address) { this.stunum = stunum; this.name = name; this.age = age; this.sex = sex; this.address = address; } public int getStunum() { return stunum; } public void setStunum(int stunum) { this.stunum = stunum; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"stunum=\" + stunum + \", name='\" + name + '\\'' + \", age=\" + age + \", sex=\" + sex + \", address=\" + address + \", studentBusiness=\" + studentCard + '}'; } public boolean isSex() { return sex; } public void setSex(boolean sex) { this.sex = sex; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } } mapper.xml 使用resultmap 一对一对象成员用 association 映射 javaType指定该属性的类型 \u003c学生\u003e ​ \u003c属性/\u003e ​ \u003c属性/\u003e ​ ​ \u003c属性/\u003e ​ \u003c属性/\u003e ​ \u003c/学生\u003e \u003cselect id=\"queryStudentsByNumWithSAndC\" parameterType=\"int\" resultMap=\"student_card_map\"\u003e SELECT s.*,c.* FROM student s INNER JOIN studentcard c ON s.`stucardid`=c.`cardid` WHERE s.`stunum` = #{stunum} \u003c/select\u003e \u003cresultMap id=\"student_card_map\" type=\"Student\"\u003e \u003c!-- 学生信息--\u003e \u003cid property=\"stunum\" column=\"stunum\"\u003e\u003c/id\u003e \u003cresult property=\"name\" column=\"name\"\u003e\u003c/result\u003e \u003cresult property=\"age\" column=\"age\"\u003e\u003c/result\u003e \u003c!-- 一对一对象成员用association映射 javaType指定该属性的类型 --\u003e \u003cassociation property=\"studentCard\" javaType=\"StudentCard\"\u003e \u003cid property=\"cardID\" column=\"cardID\"\u003e\u003c/id\u003e \u003cresult property=\"cardInfo\" column=\"cardInfo\"\u003e\u003c/result\u003e \u003c/association\u003e \u003c/resultMap\u003e ","date":"2020-03-12","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/:1:2","tags":[],"title":"关联查询","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/"},{"categories":["Spring"],"content":"一对多 studentclasss-\u003estudent 一对多 studentclass.java package org.jsh.entity; import java.util.List; public class StudentClass { private int classID; private String classname; private List\u003cStudent\u003e students; public StudentClass() { } public int getClassID() { return classID; } public void setClassID(int classID) { this.classID = classID; } public String getClassname() { return classname; } public void setClassname(String classname) { this.classname = classname; } public List\u003cStudent\u003e getStudents() { return students; } public void setStudents(List\u003cStudent\u003e students) { this.students = students; } @Override public String toString() { return \"StudentClass{\" + \"classID=\" + classID + \", classname='\" + classname + '\\'' + \", students=\" + students + '}'; } } mapper.xml 一对多用collection 映射 javatype指定的是user对象的属性的类型（例如id，posts），而oftype指定的是映射到list集合属性中pojo的类型 \u003c!-- 一对多--\u003e \u003cselect id=\"queryClassAndStudents\" parameterType=\"int\" resultMap=\"class_student_map\"\u003e SELECT c.*,s.* FROM student s INNER JOIN studentclass c ON c.`classid`=s.`classid` WHERE s.`classid` = #{classID} \u003c/select\u003e \u003cresultMap id=\"class_student_map\" type=\"StudentClass\"\u003e \u003cid property=\"classID\" column=\"classID\"/\u003e \u003cresult property=\"classname\" column=\"classname\"/\u003e \u003ccollection property=\"students\" ofType=\"student\"\u003e \u003cid property=\"stunum\" column=\"stunum\"\u003e\u003c/id\u003e \u003cresult property=\"name\" column=\"name\"\u003e\u003c/result\u003e \u003cresult property=\"age\" column=\"age\"\u003e\u003c/result\u003e \u003c/collection\u003e \u003c/resultMap\u003e \u003c/mapper\u003e ","date":"2020-03-12","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/:2:0","tags":[],"title":"关联查询","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2day7/"},{"categories":["前端"],"content":"前端-js-(day1) javaScript 包括： ECMAScript DOM BOM JS特点 解释型语言 类似C的语法结构 动态语言 基于原型的面向对象 ","date":"2020-03-12","objectID":"/%E5%89%8D%E7%AB%AF-js-day1/:0:0","tags":[],"title":"前端-js-(day1)","uri":"/%E5%89%8D%E7%AB%AF-js-day1/"},{"categories":["前端"],"content":"JS的 Hello World // 控制浏览器弹出警告框 alert(“这是我的第一行JS代码”); // 让计算机在页面中输出一个内容 document.write(“Hello World”); //向控制台输出一个内容 console.log(“11111111111”); \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003e\u003c/title\u003e \u003c!-- js代码需要编写在script标签中 --\u003e \u003cscript type=\"text/javascript\"\u003e // 控制浏览器弹出警告框 alert(\"这是我的第一行JS代码\"); // 让计算机在页面中输出一个内容 document.write(\"Hello World\"); //向控制台输出一个内容 console.log(\"11111111111\"); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-12","objectID":"/%E5%89%8D%E7%AB%AF-js-day1/:1:0","tags":[],"title":"前端-js-(day1)","uri":"/%E5%89%8D%E7%AB%AF-js-day1/"},{"categories":["前端"],"content":"JS的编写位置 标签属性中 \u003c!-- 虽然可以写在标签的属性中，但是行为耦合，不方便维护，不推荐使用 --\u003e \u003c!-- 可以将JS代码编写到标签的onclick属性中 --\u003e \u003cbutton onclick=\"alert('点我')\"\u003e点我\u003c/button\u003e \u003c!-- 可以将JS代码写在超链接的href属性中，点击时 会执行js代码 --\u003e \u003ca href=\"javascript:alert('.....')\"\u003e.....\u003c/a\u003e \u003ca href=\"javascript:;\"\u003e.....\u003c/a\u003e script标签中 \u003c!-- 可以将js代码写道script标签中 --\u003e \u003cscript type=\"text/javascript\"\u003e \u003c/script\u003e 外部文件 \u003c!-- script标签一旦用于引入外部文件 ，就不能在编写代码，编写了也不生效 --\u003e \u003cscript type=\"text/javascript\" src=\"js/script.js\"\u003e alert(\"内部\"); \u003c/script\u003e 总体代码 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003c!-- 可以将js代码编写到外部的js文件中，然后引入 可以在不同的文件中引入，也可以利用到浏览器的缓存机制 推荐使用 --\u003e \u003c!-- script标签一旦用于引入外部文件 ，就不能在编写代码，编写了也不生效 --\u003e \u003cscript type=\"text/javascript\" src=\"js/script.js\"\u003e alert(\"内部\"); \u003c/script\u003e \u003c!-- 可以将js代码写道script标签中 --\u003e \u003cscript type=\"text/javascript\"\u003e \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 虽然可以写在标签的属性中，但是行为耦合，不方便维护，不推荐使用 --\u003e \u003c!-- 可以将JS代码编写到标签的onclick属性中 --\u003e \u003cbutton onclick=\"alert('点我')\"\u003e点我\u003c/button\u003e \u003c!-- 可以将JS代码写在超链接的href属性中，点击时 会执行js代码 --\u003e \u003ca href=\"javascript:alert('.....')\"\u003e.....\u003c/a\u003e \u003ca href=\"javascript:;\"\u003e.....\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-12","objectID":"/%E5%89%8D%E7%AB%AF-js-day1/:2:0","tags":[],"title":"前端-js-(day1)","uri":"/%E5%89%8D%E7%AB%AF-js-day1/"},{"categories":["前端"],"content":"JS中的基本语法 严格区分大小写 每一条语句以分号结尾 如果不写分号 浏览器会自动添加（有时候会加错） JS中会忽略多个空格和换行 ","date":"2020-03-12","objectID":"/%E5%89%8D%E7%AB%AF-js-day1/:3:0","tags":[],"title":"前端-js-(day1)","uri":"/%E5%89%8D%E7%AB%AF-js-day1/"},{"categories":["前端"],"content":"JS定义变量 关键字 var ","date":"2020-03-12","objectID":"/%E5%89%8D%E7%AB%AF-js-day1/:4:0","tags":[],"title":"前端-js-(day1)","uri":"/%E5%89%8D%E7%AB%AF-js-day1/"},{"categories":["前端"],"content":"标识符 标识符：在JS中可以由我们自主命名的都可以称为标识符 命名规则 可以有数字，字母，_，$，UTF-8中的所有字符 不能以数字开头 不能是ES中的关键字或保留字 驼峰命名法（规范） ","date":"2020-03-12","objectID":"/%E5%89%8D%E7%AB%AF-js-day1/:5:0","tags":[],"title":"前端-js-(day1)","uri":"/%E5%89%8D%E7%AB%AF-js-day1/"},{"categories":["前端"],"content":"数据类型 JS中一共有六种数据类型 基本数据类型 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 对象数据类型 Object 对象 ","date":"2020-03-12","objectID":"/%E5%89%8D%E7%AB%AF-js-day1/:6:0","tags":[],"title":"前端-js-(day1)","uri":"/%E5%89%8D%E7%AB%AF-js-day1/"},{"categories":["前端"],"content":"String String 使用单引号或双引号引起来（不能混用） 引号不能嵌套 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e // String 使用单引号或双引号引起来（不能混用） // 引号不能嵌套 var str = \"Hello\"; // 字符串中可以使用\\作为转义字符 /* \\n 换行 \\t 制表符 \\\\ 表示一个\\ */ var str1 = \"hello\\\"ssss\\\"\"; alert(str1); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-12","objectID":"/%E5%89%8D%E7%AB%AF-js-day1/:6:1","tags":[],"title":"前端-js-(day1)","uri":"/%E5%89%8D%E7%AB%AF-js-day1/"},{"categories":["Spring"],"content":"后端-Mybatis-day6 ","date":"2020-03-11","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81sqlday6/:0:0","tags":[],"title":"后端-Mybatis-day6","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81sqlday6/"},{"categories":["Spring"],"content":"动态SQL ","date":"2020-03-11","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81sqlday6/:1:0","tags":[],"title":"后端-Mybatis-day6","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81sqlday6/"},{"categories":["Spring"],"content":"where if mapper.xml \u003cselect id=\"queryStudentByNameOrAgeSQLTag\" parameterType=\"student\" resultType=\"student\"\u003e select stunum,name from student \u003cwhere\u003e \u003cif test=\"stunum != null and stunum!=''\"\u003e and name = #{name} \u003c/if\u003e \u003cif test=\"age != null and age!=0\"\u003e and age = #{age} \u003c/if\u003e \u003c/where\u003e \u003c/select\u003e where 语句用标签显示 if语句为条件 ​ test中表示属性存在且不为空 sql 语句前加and where标签会自动解析 ","date":"2020-03-11","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81sqlday6/:1:1","tags":[],"title":"后端-Mybatis-day6","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81sqlday6/"},{"categories":["Spring"],"content":"foreach 查询学号为1，2，3的学生信息 SQL：select * from student where stunum in(1,2,3) 作用：stunums = {1,2,3} foreach 迭代的类型：数组，集合，对象数组，对象属性 对象属性 Grade.java package org.jsh.entity; import java.util.List; public class Grade { //学号 private List\u003cInteger\u003e stunums; public List\u003cInteger\u003e getStunums() { return stunums; } public void setStunums(List\u003cInteger\u003e stunums) { this.stunums = stunums; } // } mapper.xml collection: 对象的属性名 open：循环变量前边部分 close ：循环变量后边部分 separator： 循环变量的分隔符 \u003cselect id=\"queryStudentsWithGrade\" parameterType=\"Grade\" resultType=\"student\"\u003e select * from student \u003cwhere\u003e \u003cif test=\"stunums != null and stunums.size\u003e0\"\u003e \u003cforeach collection=\"stunums\" open=\" and stunum in (\" close=\")\" item=\"stunum\" separator=\",\"\u003e #{stunum} \u003c/foreach\u003e \u003c/if\u003e \u003c/where\u003e \u003c/select\u003e interface List\u003cStudent\u003e queryStudentsWithGrade(Grade grade); test public static void queryStudentsWithGrade() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); Grade grade = new Grade(); List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(3); grade.setStunums(list); List\u003cStudent\u003e students = studentMapper.queryStudentsWithGrade(grade); System.out.println(students); session.close(); } ","date":"2020-03-11","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81sqlday6/:1:2","tags":[],"title":"后端-Mybatis-day6","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81sqlday6/"},{"categories":["前端"],"content":"前端-CSS-FLEX(day6) Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:0:0","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"父组件属性 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:1:0","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"flex-direction(子组件排列方向) row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:1:1","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"flex-wrap（换行） nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:1:2","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 flex-flow: \u003cflex-direction\u003e || \u003cflex-wrap\u003e; ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:1:3","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"justify-content（主轴方向上对齐方式） flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:1:4","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"align-items（交叉轴上对起方向） flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:1:5","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"align-content（多根轴线对齐方式） 不是很懂 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:1:6","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"子组件属性 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:2:0","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:2:1","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"flex-grow flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:2:2","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:2:3","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:2:4","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"flex属性(重要) flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ \u003c'flex-grow'\u003e \u003c'flex-shrink'\u003e? || \u003c'flex-basis'\u003e ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:2:5","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"align-self align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:2:6","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"练习 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle\u003e .father{ width: 500px; height: 500px; background-color: aqua; display: flex; justify-content: space-between; /* flex-direction: column; */ align-items: center; flex-wrap: wrap; overflow-y:scroll; } .son{ width: 200px; height: 200px; background-color: aliceblue; margin: 20px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"father\"\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003cdiv class=\"son\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:3:0","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"网站 flex演示 lex布局实例(阮一峰) ","date":"2020-03-10","objectID":"/%E5%89%8D%E7%AB%AF-css-flexday6/:4:0","tags":[],"title":"前端-CSS-FLEX(day6)","uri":"/%E5%89%8D%E7%AB%AF-css-flexday6/"},{"categories":["前端"],"content":"前端-CSS-动画(day5) 浏览器兼容问题 （部分浏览器 不支持）： 旧版本浏览器都不支持 过渡浏览器：需要加一些参数 - IE9: -ms- - firefox: -moz- - chrome/safari: -webkit- - Opera: -o- 如果有@，则兼容性前缀增加到@的后面 @-webkit-keyframes x 新浏览器一般都支持 ","date":"2020-03-08","objectID":"/%E5%89%8D%E7%AB%AF-css-%E5%8A%A8%E7%94%BBday5/:0:0","tags":[],"title":"前端-CSS-动画(day5)","uri":"/%E5%89%8D%E7%AB%AF-css-%E5%8A%A8%E7%94%BBday5/"},{"categories":["前端"],"content":"变形函数：transform:xx() 值 描述 测试 none 定义不进行转换。 测试 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 测试 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y) 定义 2D 转换。 测试 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 测试 translateY(y) 定义转换，只是用 Y 轴的值。 测试 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 测试 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 测试 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 测试 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 测试 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 测试 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 测试 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 测试 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 测试 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 测试 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 测试 perspective(n) 为 3D 转换元素定义透视视图。 测试 ","date":"2020-03-08","objectID":"/%E5%89%8D%E7%AB%AF-css-%E5%8A%A8%E7%94%BBday5/:1:0","tags":[],"title":"前端-CSS-动画(day5)","uri":"/%E5%89%8D%E7%AB%AF-css-%E5%8A%A8%E7%94%BBday5/"},{"categories":["前端"],"content":"过渡：transition div { width:100px; transition: width 2s; -moz-transition: width 2s; /* Firefox 4 */ -webkit-transition: width 2s; /* Safari 和 Chrome */ -o-transition: width 2s; /* Opera */ } div:hover { width:300px; } transition: property duration timing-function delay; 值 描述 transition-property 规定设置过渡效果的 CSS 属性的名称。 transition-duration 规定完成过渡效果需要多少秒或毫秒。 transition-timing-function 规定速度效果的速度曲线。 transition-delay 定义过渡效果何时开始。 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e动画\u003c/title\u003e \u003cstyle\u003e #mybox img { transition: all 2s ease-in-out ; } #mybox img:hover { transform:rotate(360deg) scale(1.5) } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"mybox\"\u003e \u003cimg src=\"imgs/1.jpg\" width=\"50px\" height=\"50px\"/\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-08","objectID":"/%E5%89%8D%E7%AB%AF-css-%E5%8A%A8%E7%94%BBday5/:2:0","tags":[],"title":"前端-CSS-动画(day5)","uri":"/%E5%89%8D%E7%AB%AF-css-%E5%8A%A8%E7%94%BBday5/"},{"categories":["前端"],"content":"animation: 动画 https://www.w3school.com.cn/css3/css3_animation.asp 属性 描述 CSS @keyframes 规定动画。 3 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 3 animation-name 规定 @keyframes 动画的名称。 3 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 3 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 3 animation-delay 规定动画何时开始。默认是 0。 3 animation-iteration-count 规定动画被播放的次数。默认是 1。 3 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 3 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 3 animation-fill-mode 规定对象动画时间之外的状态。 3 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e动画\u003c/title\u003e \u003cstyle\u003e div{ width:100px ; height:100px ; background:blue ; animation: x 2s linear infinite ; } @keyframes x{ 0%{ width:0px ; transform:translateX(100px); } 25%{ width:20px ; transform:translateX(200px); } 50%{ width:50px ; transform:translateX(300px); } 75%{ width:75px ; transform:translateX(400px); } 100%{ width:100px ; transform:translateX(500px); } } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-08","objectID":"/%E5%89%8D%E7%AB%AF-css-%E5%8A%A8%E7%94%BBday5/:3:0","tags":[],"title":"前端-CSS-动画(day5)","uri":"/%E5%89%8D%E7%AB%AF-css-%E5%8A%A8%E7%94%BBday5/"},{"categories":["Spring"],"content":"后端-Mybatis-输出参数resultType(day5) ","date":"2020-03-08","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/:0:0","tags":[],"title":"后端-Mybatis-输出参数resultType(day5)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/"},{"categories":["Spring"],"content":"八个简单类型+String mapper.xml \u003c!--输出参数resultType--\u003e \u003cselect id=\"selectStudentCount\" resultType=\"int\"\u003e select count(*) from student \u003c/select\u003e interface int selectStudentCount(); test.java public static void selectStudentCount() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); int count = studentMapper.selectStudentCount(); System.out.println(count); session.close(); } ","date":"2020-03-08","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/:1:0","tags":[],"title":"后端-Mybatis-输出参数resultType(day5)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/"},{"categories":["Spring"],"content":"对象类型 mapper.xml \u003cselect id=\"queryStuByNum\" parameterType=\"int\" resultType=\"student\"\u003e select * from student where stunum = #{stunum} \u003c/select\u003e interface Student queryStuByNum(int stunum); test.java public static void queryStuByNum() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); Student student= studentMapper.queryStuByNum(2); System.out.println(student); session.close(); } ","date":"2020-03-08","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/:2:0","tags":[],"title":"后端-Mybatis-输出参数resultType(day5)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/"},{"categories":["Spring"],"content":"实体对象的集合类型 resultType不变 函数返回值变为列表 ","date":"2020-03-08","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/:3:0","tags":[],"title":"后端-Mybatis-输出参数resultType(day5)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/"},{"categories":["Spring"],"content":"HashMap类型（起别名） 一个map一个学生 多人用list mapper.xml \u003cselect id=\"queryStudentOutByHashMap\" resultType=\"HashMap\"\u003e select stunum \"no\",name \"name\" from student \u003c/select\u003e interface //返回一个 HashMap\u003cString,Object\u003e queryStudentOutByHashMap(); //返回多个 List\u003cHashMap\u003cString,Object\u003e\u003e queryStudentOutByHashMap(); test public static void queryStudentOutByHashMap() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); //返回多个 List\u003cHashMap\u003cString,Object\u003e\u003e map = studentMapper.queryStudentOutByHashMap(); //返回一个 HashMap\u003cString,Object\u003e map = studentMapper.queryStudentOutByHashMap(); System.out.println(map); session.close(); } ","date":"2020-03-08","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/:4:0","tags":[],"title":"后端-Mybatis-输出参数resultType(day5)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/"},{"categories":["Spring"],"content":"resultMap(实体类的属性和数据表的字段：类型，名字不同时) //resultMap=“queryStudentByID” id=“queryStudentByID\"对应 property 实体类属性名（严格大小写） column 数据表属性名 \u003cselect id=\"queryStudentByID\" parameterType=\"int\" resultMap=\"queryStudentByID\"\u003e select stunum,name from student where stunum = #{stunum} \u003c/select\u003e \u003cresultMap id=\"queryStudentByID\" type=\"student\"\u003e \u003c!-- 主键--\u003e \u003cid property=\"stunum\" column=\"stuNum\"\u003e\u003c/id\u003e \u003c!-- 其他--\u003e \u003cresult column=\"name\" property=\"name\"\u003e\u003c/result\u003e \u003c/resultMap\u003e ","date":"2020-03-08","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/:5:0","tags":[],"title":"后端-Mybatis-输出参数resultType(day5)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0resulttypeday5/"},{"categories":["前端"],"content":"前端-CSS-标准文档流，定位(day4) ","date":"2020-03-05","objectID":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/:0:0","tags":[],"title":"前端-CSS-标准文档流，定位(day4)","uri":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/"},{"categories":["前端"],"content":"标准文档流 ","date":"2020-03-05","objectID":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/:1:0","tags":[],"title":"前端-CSS-标准文档流，定位(day4)","uri":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/"},{"categories":["前端"],"content":"组成 块级元素（block level）：自带换行 div ，可以设置宽和高 内联元素 (inline level) ：不换行 span, a ，没有宽和高 （内敛元素不遵守盒子模型） inline-block：1.如果inline失效，可以尝试inline-block ​ 2.可以设置宽和高 块级元素可以包含内敛，反之不行。 正确： \u003cdiv\u003e begin.. \u003cspan\u003espan\u003c/span\u003e \u003cspan\u003espan\u003c/span\u003e end... \u003c/div\u003e 错误： \u003cspan\u003e begin.. \u003cdiv\u003edivdiv\u003c/div\u003e \u003cdiv\u003edivdiv\u003c/div\u003e end... \u003c/span\u003e 内敛元素和块级元素相互切换： display: block | inline |none |inline-block ; \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003e网站导航\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e *{ margin: 0px ; padding: 0px ; } a{ text-decoration: none ; } .nav-header { width: 100% ; height:85px ; background: rgba(0,0,0,0.7); } .head-contain { width: 700px ; height: 85px ; margin:0 auto ; text-align:center ; } .top-logo,.top-nav,.top-nav li,.top-right { display: inline-block ; vertical-align:top ; margin-top: 15px ; } .top-nav li { width: 90px ; } .top-nav li a { font-size: 17px ; color: #fff ; } .top-nav li a:hover { color: blue ; } .top-right a { display:inline-block ;/*将内敛元素 转为 块级元素，使之遵循盒子模型*/ font-size: 17px ; margin-top: 10px ; border-radius:30px ; } .top-right a:first-of-type { width:75px ; height: 35px ; border:1px orange solid ; line-height:35px ; } .top-right a:first-of-type:hover { color:red ; background: orange; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cheader class=\"nav-header\"\u003e \u003cdiv class=\"head-contain\"\u003e \u003ca href=\"#\" class=\"top-logo\"\u003e\u003cimg src=\"imgs/fd1.png\" height=\"50px\" width=\"50px\"/\u003e\u003c/a\u003e \u003cnav class=\"top-nav\"\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"#\"\u003e旅游天地\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003e美食城\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003e成长体系\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003e当地特色\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003e重点推荐\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003cdiv class=\"top-right\"\u003e \u003ca href=\"#\"\u003e登录\u003c/a\u003e \u003ca href=\"#\"\u003e开通会员\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/header\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-05","objectID":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/:2:0","tags":[],"title":"前端-CSS-标准文档流，定位(day4)","uri":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/"},{"categories":["前端"],"content":"浮动（float） 块级元素 -\u003e 内敛元素 ：将不同行的元素放置到一行 浮动 ：将不同行的元素放置到一行 float: none | left | right 浮动（压缩）：压缩的是自己的空间 clear: 清除浮动（清除一半，还原了 块级元素的 换行特性，但没有还原空间） clear:清除的是上一个元素（不是自己） clear:left | right |both \u003chtml\u003e \u003chead\u003e \u003cmeta charset=utf-8/\u003e \u003ctitle\u003e浮动\u003c/title\u003e \u003cstyle type=\"text/css\" \u003e #father div { border: 2px solid red ; margin: 10px 0 ; background-color:yellow ; } #father .mydiv1{ float:left ; } #father .mydiv2{ clear: left ; } #father .mydiv3{ } #father .mydiv3{ } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"father\"\u003e \u003cdiv class=\"mydiv1\"\u003e\u003cimg src=\"imgs/fd1.png\" /\u003e\u003c/div\u003e \u003cdiv class=\"mydiv2\"\u003e\u003cimg src=\"imgs/fd2.png\" /\u003e\u003c/div\u003e \u003cdiv class=\"mydiv3\"\u003e\u003cimg src=\"imgs/fd3.png\" /\u003e\u003c/div\u003e \u003cdiv class=\"mydiv4\"\u003e 这是浮动的演示案例...这是浮动的演示案例...这是浮动的演示案例...这是浮动的演示案例...这是浮动的演示案例... 这是浮动的演示案例...这是浮动的演示案例...这是浮动的演示案例...这是浮动的演示案例...这是浮动的演示案例... \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 浮动的元素：不在标准文档流之中 （网页无法识别原有的空间），脱离原有空间 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=utf-8/\u003e \u003ctitle\u003e商品列表\u003c/title\u003e \u003cstyle type=\"text/css\" \u003e *{ margin: 0 ; padding: 0 ; } .shangpin ul li { list-style: none ; } .shangpin{ width: 720px ; /* background-color: yellow ; */ margin:10px auto ; } .shangpin h1 { font-size:25px ; } .shangpin h1 span { float:right ; margin-right:20px ; color: gray ; font-size: 18px ; } .shangpin ul li { float:left ; margin:20px ; } .shangpin ul li p { font-size: 15px; color: blue ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"shangpin\"\u003e \u003ch1\u003e商品列表\u003cspan\u003e更多\u003c/span\u003e\u003c/h1\u003e \u003cul\u003e \u003cli\u003e \u003cimg src =\"imgs/1.png\" /\u003e \u003cp\u003e推荐商品 | 1024节爆款电脑\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cimg src =\"imgs/2.png\" /\u003e \u003cp\u003e推荐商品 | 程序员节鼠标\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cimg src =\"imgs/1.png\" /\u003e \u003cp\u003e推荐商品 | 程序猿节背包\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cimg src =\"imgs/1.png\" /\u003e \u003cp\u003e推荐商品 | 程序节员笔记本\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e display: block | inline |none | inline-block; float: left | right ; ","date":"2020-03-05","objectID":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/:3:0","tags":[],"title":"前端-CSS-标准文档流，定位(day4)","uri":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/"},{"categories":["前端"],"content":"溢出overflow overflow: visible | hidden |scroll |auto; scroll: 不论是否超出，都有滚动条 auto:如果超出，有滚动条；否则没有 \u003chtml \u003e \u003chead\u003e \u003cmeta charset=utf-8 /\u003e \u003ctitle\u003eoverflow\u003c/title\u003e \u003cstyle type=\"text/css\" \u003e body { } #content { width:400px; height:350px; border:1px red solid; overflow:auto ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"content\"\u003e \u003cimg src=\"imgs/fd3.png\" /\u003e \u003cp \u003e111111这是一些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是一 些文是一些文是一些文是\u003c/p\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-05","objectID":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/:4:0","tags":[],"title":"前端-CSS-标准文档流，定位(day4)","uri":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/"},{"categories":["前端"],"content":"定位 position: static(默认值，没有定位) | relative(相对定位) | absolute(绝对定位) |fixed（固定定位，个别版本浏览器不支持） relative：相对于自身 注意位置：left是指往右偏移；top是下；其他同理 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=utf-8/\u003e \u003ctitle\u003e浮动\u003c/title\u003e \u003cstyle type=\"text/css\" \u003e div { border: 1px solid red ; margin:20px ; } #father div { height:150px ; background:lightgray ; } .mydiv1 { position: relative ; right:-50px ; bottom:-50px ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"father\"\u003e \u003cdiv class=\"mydiv1\"\u003e第一个div\u003c/div\u003e \u003cdiv class=\"mydiv2\"\u003e第一个di2\u003c/div\u003e \u003cdiv class=\"mydiv3\"\u003e第一个div3\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=utf-8/\u003e \u003ctitle\u003e浮动\u003c/title\u003e \u003cstyle type=\"text/css\" \u003e #father{ border: 1px solid blue ; } #father div { background-color: yellow ; } #father { width: 300px ; height:300px ; margin:50px auto ; } #father div { width: 100px ; height:100px ; } .mydiv2,.mydiv4{ position:relative ; left:200px ; top :-100px ; } .mydiv5 { position: relative ; top: -300px ; right:-100px ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"father\"\u003e \u003cdiv class=\"mydiv1\"\u003e第一个div1\u003c/div\u003e \u003cdiv class=\"mydiv2\"\u003e第一个di2\u003c/div\u003e \u003cdiv class=\"mydiv3\"\u003e第一个div3\u003c/div\u003e \u003cdiv class=\"mydiv4\"\u003e第一个div4\u003c/div\u003e \u003cdiv class=\"mydiv5\"\u003e第一个div5\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 绝对定位： position: absolute 是否存在 “已经定位的祖先元素” 存在 ：则参照 “已经定位的祖先元素”定位 不存在： 则参照浏览器定位 绝对定位：会脱离文档流（释放空间，会让网页无法识别） \u003chtml\u003e \u003chead\u003e \u003cmeta charset=utf-8/\u003e \u003ctitle\u003e绝对定位（没有已经定位的祖先元素）\u003c/title\u003e \u003cstyle type=\"text/css\" \u003e div { width:100px ; height:100px ; background: yellow ; position:absolute ; right :30px ; bottom: 30px ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv \u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=utf-8/\u003e \u003ctitle\u003e绝对定位（有已经定位的祖先元素）\u003c/title\u003e \u003cstyle type=\"text/css\" \u003e #father { width:600px ; height:600px ; border:1px solid blue ; position: relative; top :30px ; left: 30px ; } #father div { height:100px ; width: 200px ; } .mydiv1 { background-color: red ; } .mydiv2 { background-color: yellow ; position: absolute ; right: 100px ; } .mydiv3 { background-color: blue ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"father\"\u003e \u003cdiv class=\"mydiv1\"\u003ered\u003c/div\u003e \u003cdiv class=\"mydiv2\"\u003eyellow\u003c/div\u003e \u003cdiv class=\"mydiv3\"\u003eblue\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e position:fixed 参照浏览器定位 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=utf-8/\u003e \u003ctitle\u003e绝对定位（有已经定位的祖先元素）\u003c/title\u003e \u003cstyle type=\"text/css\" \u003e .mydiv1 { background-color: red ; height:200px ; width:200px ; position:fixed ; right:10px ; top:100px ; } .mydiv2 { background-color: yellow ; height:80px ; width:100% ; position:fixed ; bottom:0 ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"mydiv1\"\u003ered\u003c/div\u003e \u003ca href=\"https://www.baidu.com\"\u003e\u003cdiv class=\"mydiv2\"\u003eyellow\u003c/div\u003e\u003c/a\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003cp\u003exxxxxxxxxx\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 定位： 相对：relative ，相对于自身定位 绝对：absolute，（如果有已定位的祖先：参照祖先 ；如果没有，参照浏览器） fixed: 参照浏览器 ","date":"2020-03-05","objectID":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/:5:0","tags":[],"title":"前端-CSS-标准文档流，定位(day4)","uri":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/"},{"categories":["前端"],"content":"透明度 opacity:0.5 filter:alpha(opacity=50) 浏览器兼容性问题，部分浏览器支持opacity，部分支持filter:alpha(opacity=50) . ","date":"2020-03-05","objectID":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/:6:0","tags":[],"title":"前端-CSS-标准文档流，定位(day4)","uri":"/%E5%89%8D%E7%AB%AF-css-%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81%E5%AE%9A%E4%BD%8Dday4/"},{"categories":["Spring"],"content":"后端-Mybatis-(day4) ","date":"2020-03-05","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-day4/:0:0","tags":[],"title":"后端-Mybatis-(day4)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-day4/"},{"categories":["Spring"],"content":"parameterType 输入对象为HashMap mapper.xml \u003cselect id=\"queryStudentsOrderByColumnWithHashMap\" parameterType=\"HashMap\" resultType=\"student\"\u003e select * from student where stunum = #{stunum} or name like '%${name}%' \u003c/select\u003e interface List\u003cStudent\u003e queryStudentsOrderByColumnWithHashMap(Map\u003cString,Object\u003e map); Test public static void queryStudentsOrderByColumnWithHashMap() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Map\u003cString,Object\u003e studentMap = new HashMap\u003c\u003e(); studentMap.put(\"stunum\",\"2\"); studentMap.put(\"name\",\"jsh\"); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.queryStudentsOrderByColumnWithHashMap(studentMap); System.out.println(students); session.close(); } ","date":"2020-03-05","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-day4/:1:0","tags":[],"title":"后端-Mybatis-(day4)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-day4/"},{"categories":["Spring"],"content":"通过调用【存储过程】 实现查询 statementType=“CALLABLE” mapper.xml statementType=“CALLABLE” parameterType必须是HashMap 没有返回值 \u003c!-- 通过调用【存储过程】 实现查询，statementType=\"CALLABLE\"--\u003e \u003cselect id=\"queryCountByGradeWithProcedure\" parameterType=\"HashMap\" statementType=\"CALLABLE\"\u003e {CALL queryCountByGradeWithProcedure(#{gName,jdbcType=VARCHAR,mode=IN},#{scount,jdbcType=INTEGER,mode=OUT})} \u003c/select\u003e \u003c/mapper\u003e interface void queryCountByGradeWithProcedure(Map\u003cString,Object\u003e map); Test.java 通过Map传值 输出过程需要另行接收 (通过Map的形式) public static void queryCountByGradeWithProcedure() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Map\u003cString,Object\u003e studentMap = new HashMap\u003c\u003e(); studentMap.put(\"gName\",\"s1\"); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.queryCountByGradeWithProcedure(studentMap); // 获取存储过程输出 Object count = studentMap.get(\"sCount\"); session.close(); } ","date":"2020-03-05","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-day4/:2:0","tags":[],"title":"后端-Mybatis-(day4)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-day4/"},{"categories":["前端"],"content":"前端-CSS标签与样式（day3） ","date":"2020-03-04","objectID":"/%E5%89%8D%E7%AB%AF-css%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%A0%B7%E5%BC%8Fday3/:0:0","tags":[],"title":"前端-CSS标签与样式（day3）","uri":"/%E5%89%8D%E7%AB%AF-css%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%A0%B7%E5%BC%8Fday3/"},{"categories":["前端"],"content":"标签 div：块级元素，换行 span： 内联元素，不换行 ","date":"2020-03-04","objectID":"/%E5%89%8D%E7%AB%AF-css%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%A0%B7%E5%BC%8Fday3/:1:0","tags":[],"title":"前端-CSS标签与样式（day3）","uri":"/%E5%89%8D%E7%AB%AF-css%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%A0%B7%E5%BC%8Fday3/"},{"categories":["前端"],"content":"CSS样式（有些样式存在浏览器兼容问题） font-size:字体大小 px em rem cm mm pt pc font-style:normal(默认)， italic/oblique font-weight: bold bolder normal lighter 100-900 text-indent:缩进 2em line-height: 100px text-decoration: underline/overline/text-though color:英语单词red 十六进制（3位或6位） rgbcolor : rgb(11,192,15) rgba(1,27,182,0.5) ; 其中a代表透明度 0-1之间的小数，0.3代表显示程度是30% 阴影text-shadow: 横坐标 纵坐标 发散程度 a:hover 悬浮 a:link 未访问 a:visited 已经访问过了 a:active 点击鼠标时 设置的顺序： link -\u003e visitied \u003e hover \u003e active 一般建议： 只写 hover 即可 鼠标样式：cursor:pointer https://www.w3school.com.cn/cssref/pr_class_cursor.asp list-style-type: disc/none/square/decimal/circle background-image:url(图片地址) background:blue url(imgs/fuzhuang.png) right top no-repeat ; repeat-x repeat-y background:url(imgs/bg.png) no-repeat ; background-size:cover ; cover:铺满整个区域 background-size: 50% 60% ; 表示 宽占整个网页的50% ，高占整个网页的60% auto:默认，原图大小 边框的圆角：圆角边框 border-raduis: \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003e圆角边框\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e div{ /*box-shadow:横坐标 纵坐标 范围 颜色*/ box-shadow: 10px 20px 10px gray ; width: 100px ; height: 50px ; border: 3px solid red ; /* border-radius: 10px 50px 80px 100px ; border-radius: 50px ; border-radius: 50px 100px ; border-radius: 50px 100px 10px ;*/ margin: 50px 0 ; } .divclass2 { width: 50px ; height: 100px ; border: 3px solid red ; } div:nth-of-type(2){ border-radius: 50px 50px 0 0 ; } div:nth-of-type(3){ border-radius: 0 0 50px 50px ; } div:nth-of-type(4){ border-radius: 0 50px 50px 0 ; } div:nth-of-type(5){ border-radius: 50px 0 0 50px ; } #sx div { height: 50px ; width: 50px ; border: 3px blue solid ; } #sx div:nth-of-type(1){ border-radius:50px 0 0 0 ; } #sx div:nth-of-type(2){ border-radius: 0 50px 0 0 ; } #sx div:nth-of-type(3){ border-radius: 0 0 50px 0 ; } #sx div:nth-of-type(4){ border-radius: 0 0 0 50px ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e\u003c/div\u003e \u003cdiv\u003e\u003c/div\u003e \u003cdiv \u003e\u003c/div\u003e \u003cdiv class=\"divclass2\"\u003e\u003c/div\u003e \u003cdiv class=\"divclass2\"\u003e\u003c/div\u003e \u003cdiv id=\"sx\"\u003e \u003cdiv\u003e\u003c/div\u003e \u003cdiv\u003e\u003c/div\u003e \u003cdiv\u003e\u003c/div\u003e \u003cdiv\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-04","objectID":"/%E5%89%8D%E7%AB%AF-css%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%A0%B7%E5%BC%8Fday3/:2:0","tags":[],"title":"前端-CSS标签与样式（day3）","uri":"/%E5%89%8D%E7%AB%AF-css%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%A0%B7%E5%BC%8Fday3/"},{"categories":["Spring"],"content":"后端-Mybatis-${}和#{}(day3) ","date":"2020-03-04","objectID":"/%E5%90%8E%E7%AB%AF-mybatisday3/:0:0","tags":[],"title":"后端-Mybatis-${}和{}(day3)","uri":"/%E5%90%8E%E7%AB%AF-mybatisday3/"},{"categories":["Spring"],"content":"输入参数：parameterType 类型为 简单类型（8个基本类型+String) #{任意值} 自动给String类型加上 ’ ' 可以防止SQL注入 ${value} 其中标识符只能是value 原样输出 如果是String 类型 则需要在外加上单引号 ‘${value}’ 适合动态排序（动态字段） \u003cselect id=\"queryAllStudentsOrderByColumn\" parameterType=\"String\" resultType=\"student\"\u003e select * from student order by ${value} asc \u003c/select\u003e 不防止SQL注入 类型为对象： #{} #{对象属性名} 或者使用parameterMap \u003cselect id=\"queryStudentsOrderByColumn\" parameterType=\"student\" resultType=\"student\"\u003e select * from student where stunum = #{stunum} or name like #{name} \u003c/select\u003e - 模糊查询需要在传递参数时加上 % ```java public static void queryStudentsOrderByColumn() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Student student = new Student(3, \"%j%\", 24,true); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.queryStudentsOrderByColumn(student); System.out.println(students); session.close(); } ${} sql语句直接写好 \u003cselect id=\"queryStudentsOrderByColumn\" parameterType=\"student\" resultType=\"student\"\u003e select * from student where stunum = #{stunum} or name like '%${name}%' \u003c/select\u003e 传参 public static void queryStudentsOrderByColumn() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Student student = new Student(3, \"j\", 24,true); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.queryStudentsOrderByColumn(student); System.out.println(students); session.close(); } 嵌套属性 数据表加入schooladdress，homeaddress java实体类 Address 属性： schooladdress，homeaddress Student类中 加入Address 属性 方法一 xml \u003cselect id=\"selectStudentByaddress\" parameterType=\"address\" resultType=\"student\"\u003e select * from student where homeaddress = #{homeAddress} or schooladdress = '${schoolAddress}' \u003c/select\u003e java public static void selectStudentByaddress() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Address address = new Address(\"xa\",\"dl\"); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.selectStudentByaddress(address); System.out.println(students); session.close(); } 方法二，支持级联 xml \u003cselect id=\"selectStudentByaddress\" parameterType=\"student\" resultType=\"student\"\u003e select * from student where homeaddress = #{address.homeAddress} or schooladdress = '${address.schoolAddress}' \u003c/select\u003e java public static void selectStudentByaddress() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Address address = new Address(\"xa\",\"dl\"); Student student = new Student(); student.setAddress(address); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.selectStudentByaddress(student); System.out.println(students); session.close(); ","date":"2020-03-04","objectID":"/%E5%90%8E%E7%AB%AF-mybatisday3/:1:0","tags":[],"title":"后端-Mybatis-${}和{}(day3)","uri":"/%E5%90%8E%E7%AB%AF-mybatisday3/"},{"categories":["前端"],"content":"前端-CSS盒子模型（day2） 作用/意义： 决定不同类型元素之间的位置关系（平面位置、空间位置） 空间位置的 覆盖关系： 从下往上： 背景色\u003c背景图片\u003c元素内容 ","date":"2020-03-03","objectID":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/:0:0","tags":[],"title":"前端-CSS盒子模型（day2）","uri":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/"},{"categories":["前端"],"content":"边框：border 边框颜色：border-color ; border-color : red ; 代表上下左右四个边框 全是红色 border-color : red yellow; 上下：red 左右:yellow border-color : red yellow blue; 上 “左右” 下 border-color : red yellow blue green; 上 右 下 左 （顺时针） border-top-color :blue ; border-bottom-color :yellow; border-left-color :red; border-right-color :green; 边框粗细 border -width ; border-width: medium ; border-width: thin ; border-width: thick ; border-width: 10px ; border-width: thick thin 10px 100px; border-top-width: 100px ; 边框样式border-style ; border-style : solid double dotted dashed; border-top-style : solid; 边框可以缩写： border: solid 1px red ; 缩写： border - top : ","date":"2020-03-03","objectID":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/:1:0","tags":[],"title":"前端-CSS盒子模型（day2）","uri":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/"},{"categories":["前端"],"content":"外边距：margin /*margin-top:100px; margin-bottom:100px; margin:100px 0 100px 1 ; ​ margin:10px 0 ; ​ margin-top: 100px; ","date":"2020-03-03","objectID":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/:2:0","tags":[],"title":"前端-CSS盒子模型（day2）","uri":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/"},{"categories":["前端"],"content":"内边距：padding padding-top:30px; padding-bottom:10px; padding-right:0px; padding-left:130px; ","date":"2020-03-03","objectID":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/:3:0","tags":[],"title":"前端-CSS盒子模型（day2）","uri":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/"},{"categories":["前端"],"content":"盒子模型案例1： \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eCSS\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e li { list-style: none ; } body,ul,li,h1 { margin:0px ; padding:0px ; } #games_list ul li a{ text-decoration: none ; color: #000 ; } /*a:hover 表示鼠标悬浮的样式*/ #games_list ul li a:hover{ color:lightgray ; } #games_list { /*solid:实线 gray:颜色 灰色 1px：边框促销 */ border:solid gray 1px; width:124px; /*内边距*/ padding-bottom: 10px ; background-color: #c0d4ef ; /*外边距*/ margin:10px auto ; } .title{ background:url(imgs/title_icon.png) 5px 8px no-repeat ; padding-left : 20px ; color: gray ; line-height:30px; font-size: 15px ; } #games_list\u003eul { padding-left:10px ; padding-right:15px ; } #games_list\u003eul\u003eli { background: url(imgs/right.png) right -5px no-repeat ; border-top:solid 1px blue ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"games_list\"\u003e \u003ch1 class=\"title\"\u003e游戏列表\u003c/h1\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"#\"\u003e超级玛丽\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003e贪吃蛇\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003e红色警戒\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003e魂斗罗\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003e蜘蛛纸牌\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-03","objectID":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/:3:1","tags":[],"title":"前端-CSS盒子模型（day2）","uri":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/"},{"categories":["前端"],"content":"案例二： \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003e盒子模型-商品列表\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e body,div,h1,dl,dt,dd{ margin: 0px; padding: 0px ; } #production{ background-color: #fffff2 ; width: 195px ; } #production\u003eh1 { font-size: 25px ; font-weight: bold ; line-height: 40px ; text-indent: 1em ; } #production\u003edl\u003edt{ padding-left: 25px ; line-height: 30px ; font-size: 15px ; } #production\u003edl\u003edd{ padding-left: 25px ; line-height: 25px ; font-size: 13px ; border-bottom: 1px dashed lightgray ; } #production .dianzi { background: url(imgs/dianzi.png) 4px 5px no-repeat } #production .fuzhuang { background: url(imgs/fuzhuang.png) 4px 5px no-repeat } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"production\"\u003e \u003ch1\u003e全部分类\u003c/h1\u003e \u003cdl\u003e \u003cdt class=\"dianzi\"\u003e电子设备\u003c/dt\u003e \u003cdd\u003e 手机/电脑/笔记本/鼠标\u003cbr/\u003e 手机/电脑/笔记本/鼠标\u003cbr/\u003e 手机/电脑/笔记本/鼠标\u003cbr/\u003e 手机/电脑/笔记本/鼠标\u003cbr/\u003e 手机/电脑/笔记本/鼠标\u003cbr/\u003e \u003c/dd\u003e \u003c/dl\u003e \u003cdl\u003e \u003cdt class=\"fuzhuang\"\u003e服装\u003c/dt\u003e \u003cdd\u003e 男装/女装/春装/秋装\u003cbr/\u003e 男装/女装/春装/秋装\u003cbr/\u003e 男装/女装/春装/秋装\u003cbr/\u003e 男装/女装/春装/秋装\u003cbr/\u003e 男装/女装/春装/秋装\u003cbr/\u003e \u003c/dd\u003e \u003c/dl\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-03","objectID":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/:3:2","tags":[],"title":"前端-CSS盒子模型（day2）","uri":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/"},{"categories":["前端"],"content":"案例：图片列表 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003e盒子模型-商品列表\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e div,h1,ul,li,a { /*为了防止各个浏览器的内边距、外边距不兼容情况，一般在开发时 第一步将边距全设置为0 */ margin: 0px ; padding:0px ; } ul,li { list-style-type: none ; } #production { /* background-color: yellow ; */ width: 318px ; } #production\u003eh1{ margin-left: 5px ; background-color: #24221e ; font-family: SimHei, Georgia, 'New York', Times, TimesNR, 'New Century Schoolbook', serif; font-weight: 700; font-size: 24px; color: #FFF ; line-height: 32px; padding-left: 18px; } ul li a img { border: 5px solid #FFF; } ul li a:hover img { border: 5px solid rgba(255,144,0, 0.3); } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"production\"\u003e \u003ch1\u003e1F 电子设备\u003c/h1\u003e \u003cul\u003e \u003cli\u003e \u003ca href=\"#\"\u003e \u003cimg src=\"imgs/1.png\" title=\"xxx\" alt=\"替换文字\"\u003e \u003c/img\u003e \u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca href=\"#\"\u003e \u003cimg src=\"imgs/2.png\" title=\"xxx\" alt=\"替换文字\"\u003e \u003c/img\u003e \u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca href=\"#\"\u003e \u003cimg src=\"imgs/3.png\" title=\"xxx\" alt=\"替换文字\"\u003e \u003c/img\u003e \u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-03","objectID":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/:3:3","tags":[],"title":"前端-CSS盒子模型（day2）","uri":"/%E5%89%8D%E7%AB%AF-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8Bday2/"},{"categories":["Spring"],"content":"后端-Mybatis-动态代理、类型转化器、resultMap(day2) ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:0:0","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"mapper动态代理方式的crud(Mybatis接口开发) 基础环境 ： mybatis.jar conf.xml mapper.xml 不同之处 ：省略掉 statement ，即根据约定 直接定位出sql语句 ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:1:0","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"约定优于配置 根据接口名找到mapper.xml文件 （namepace=接口全类sssss名） 根据接口的方法名找到 mapper.xml 文件中的sql标签（方法名 = sql标签的id值） 方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数) 方法的返回值 和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void） 习惯：SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径） package org.jsh.mapper; import org.jsh.entity.Student; import java.util.List; //操作Mybatis的接口 public interface StudentMapper { // 约定优于配置 // 1.方法名和mapper.xml中标签的id值一样 // 2.输入参数与mapper.xml文件中标签的parameterType类型一致 // 3.返回值与mapper.xml文件中标签的result类型一致 Student selectStudentByNum(int stunum); List\u003cStudent\u003e queryAllStudents(); void addStudent(Student student); void updateStudentByNum(Student student); void deleteStudentByNum(int stunum); } \u003c!-- studentMapper.xml --\u003e \u003cmapper namespace=\"org.jsh.mapper.StudentMapper\"\u003e \u003c!-- 通过id值定义标签 paparameterType:输入值类型 resultType返回值类型--\u003e \u003cselect id=\"selectStudentByNum\" parameterType=\"int\" resultType=\"student\"\u003e -- sql语句 select * from student where stunum = #{stunum} \u003c/select\u003e \u003cinsert id=\"addStudent\" parameterType=\"org.jsh.entity.Student\" \u003e insert into student(stunum,name,age) values(#{stunum},#{name},#{age}) \u003c/insert\u003e \u003cinsert id=\"addStudentWithConverter\" parameterType=\"org.jsh.entity.Student\" \u003e insert into student(stunum,name,age,sex) values(#{stunum},#{name},#{age},#{sex,javaType=Boolean,jdbcType=INTEGER}) \u003c/insert\u003e \u003cupdate id=\"updateStudentByNum\" parameterType=\"org.jsh.entity.Student\"\u003e update student set name=#{name},age=#{age} where stunum=#{stunum} \u003c/update\u003e \u003cdelete id=\"deleteStudentByNum\" parameterType=\"int\"\u003e delete from student where stunum = #{stunum} \u003c/delete\u003e \u003c!-- 无论返回一个值还是一个列表 resultType不变--\u003e \u003cselect id=\"queryAllStudents\" resultType=\"org.jsh.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:1:1","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"使用 StudentMapper studentMapper =session.getMapper(StudentMapper.class) ; studentMapper.方法(); 通过session对象获取接口（session.getMapper(接口.class);），再调用该接口中的方法，程序会自动执行该方法对应的SQL。 package org.jsh.test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.jsh.entity.Student; import org.jsh.mapper.StudentMapper; import java.io.IOException; import java.io.Reader; import java.util.List; public class TestMybatis { public static void main(String[] args) throws IOException { queryAllStudents(); //addStudent(); //deleteStudentByNum(); //updateStudentByNum(); //queryAllStudents(); } //查询单个学生 public static void queryStudentByNum() throws IOException { // 加载Mybatis配置文件 // conf.xml -\u003e reader Reader reader = Resources.getResourceAsReader(\"conf.xml\"); // reader - \u003e SqlSession // build的第二个参数 修改conf.xml中 \u003cenvironments default=\"development\"\u003e 的默认值 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); // SqlSession -\u003e connection SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); // 接口中的方法 Student student = studentMapper.selectStudentByNum(1); System.out.println(student); session.close(); } //查询多个学生 public static void queryAllStudents() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u003cStudent\u003e students = studentMapper.queryAllStudents(); System.out.println(students); session.close(); } //增加学生 public static void addStudent() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Student student = new Student(3, \"wu\", 24,true); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.addStudent(student); session.commit();//提交数据 session.close(); } //删除学生 public static void deleteStudentByNum() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.deleteStudentByNum(3); session.commit();//提交数据 session.close(); } //修改 public static void updateStudentByNum() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); // 修改的参数 Student student = new Student(); // 修改哪个人，wehere stunum = 2 student.setStunum(2); // 修改成什么样子 student.setName(\"jsh\"); student.setAge(2); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.updateStudentByNum(student); session.commit();//提交数据 session.close(); } } ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:1:2","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"优化 ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:2:0","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"分离配置信息 将配置信息放入 db.properties文件中 db.properties： k=v driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/testdata?useSSL=true\u0026serverTimezone=UTC username=root password=123456 动态引入 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 优化：引入properties文件--\u003e \u003cproperties resource=\"db.properties\" /\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!-- 加载映射文件--\u003e \u003cmapper resource=\"org/jsh/mapper/studentMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:2:1","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"MyBatis全局参数(轻易不要修改) \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 优化：引入properties文件--\u003e \u003cproperties resource=\"db.properties\" /\u003e \u003c!-- 全局变量设置--\u003e \u003c!-- \u003csettings\u003e--\u003e \u003c!-- \u003csetting name=\"cacheEnabled\" value=\"false\"/\u003e--\u003e \u003c!-- \u003c/settings\u003e--\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!-- 加载映射文件--\u003e \u003cmapper resource=\"org/jsh/mapper/studentMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 参数 简介 有效值 cacheEnabled 在全局范围内，启用或禁用缓存 true（默认）、false lazyLoadingEnabled 在全局范围内启用或禁用延迟加载。当禁用时，所有相关联的对象都将立即加载（热加载）。 true（默认）、false aggressiveLazyLoading 启用时，有延迟加载属性的对象，在被调用时将会完全加载所有属性（立即加载）。否则，每一个属性都将按需加载（即延迟加载）。 true（默认）、false multipleResultSetsEnabled 允许或禁止执行一条单独的SQL语句后返回多条结果（结果集）；需要驱动程序的支持 true（默认）、false autoMappingBehavior 指定数据表字段和对象属性的映射方式。 NONE：禁止自动映射，只允许手工配置的映射 PARTIAL：只会自动映射简单的、没有嵌套的结果 FULL：自动映射任何结果（包含嵌套等） NONE、 PARTIAL（默认）、 FULL defaultExecutorType 指定默认的执行器。 SIMPLE：普通的执行器。 REUSE：可以重复使用prepared statements语句。 BATCH：可以重复执行语句和批量更新。 SIMPLE（默认）、 REUSE、 BATCH defaultStatementTimeout 设置驱动器等待数据库回应的最长时间 以秒为单位的，任意正整数。无默认值 safeRowBoundsEnabled 允许或禁止使用嵌套的语句 true、false（默认） mapUnderscoreToCamelCase 当在数据表中遇到有下划线的字段时，自动映射到相应驼峰式形式的Java属性名。例如，会自动将数据表中的stu_no字段，映射到POJO类的stuNo属性。 true、false（默认） lazyLoadTriggerMethods 指定触发延迟加载的对象的方法 equals、clone、hashCode、toString ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:2:2","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"别名设置（实用） 消除studentMapper.xml 中需要写全类名的繁琐形式 conf.xml : \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 优化：引入properties文件--\u003e \u003cproperties resource=\"db.properties\" /\u003e \u003c!-- 定义单个/多个别名--\u003e \u003ctypeAliases\u003e \u003c!-- 单个别名 不区分大小写--\u003e \u003c!-- \u003ctypeAlias type=\"org.jsh.entity.student\" alias=\"student\" /\u003e--\u003e \u003c!-- 批量定义别名 不区分大小写 别名就是不带包名的类名--\u003e \u003cpackage name=\"org.jsh.entity\"/\u003e \u003c/typeAliases\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!-- 加载映射文件--\u003e \u003cmapper resource=\"org/jsh/mapper/studentMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e studentMapper.xml : \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- namespace:该mapper.xml映射文件的唯一标识--\u003e \u003c!--约定 对应接口全类名--\u003e \u003cmapper namespace=\"org.jsh.mapper.StudentMapper\"\u003e \u003c!-- 通过id值定义标签 paparameterType:输入值类型 resultType返回值类型--\u003e \u003cselect id=\"selectStudentByNum\" parameterType=\"int\" resultType=\"student\"\u003e -- sql语句 select * from student where stunum = #{stunum} \u003c/select\u003e \u003cinsert id=\"addStudent\" parameterType=\"student\" \u003e insert into student(stunum,name,age) values(#{stunum},#{name},#{age}) \u003c/insert\u003e \u003cupdate id=\"updateStudentByNum\" parameterType=\"student\"\u003e update student set name=#{name},age=#{age} where stunum=#{stunum} \u003c/update\u003e \u003cdelete id=\"deleteStudentByNum\" parameterType=\"int\"\u003e delete from student where stunum = #{stunum} \u003c/delete\u003e \u003c!-- 无论返回一个值还是一个列表 resultType不变--\u003e \u003cselect id=\"queryAllStudents\" resultType=\"student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:2:3","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"类型转换器 1.MyBatis自带一些常见的类型处理器 int - number 2.自定义MyBatis类型处理器 示例： 实体类Student : boolean stuSex true:男 false：女 表student： number stuSex 1:男 0：女 自定义类型转换器（boolean -number）步骤： ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:3:0","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"创建转换器：需要实现TypeHandler接口 ​ 通过阅读源码发现，此接口有一个实现类 BaseTypeHandler ，因此 要实现转换器有2种选择： ​ i.实现接口TypeHandler接口 ​ ii.继承BaseTypeHandler package org.jsh.converter; import org.apache.ibatis.type.BaseTypeHandler; import org.apache.ibatis.type.JdbcType; import java.sql.CallableStatement; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; //BaseTypeHandler\u003cjava类型\u003e public class BooleanAndIntConverter extends BaseTypeHandler\u003cBoolean\u003e { // java -\u003e DB /* PreparedStatement : 操作的PreparedStatement i: PreparedStatement对象操作的位置 Boolean:Java值 JdbcType：数据库类型 */ @Override public void setNonNullParameter(PreparedStatement preparedStatement, int i, Boolean aBoolean, JdbcType jdbcType) throws SQLException { if(aBoolean){ preparedStatement.setInt(i,1); }else{ } } // DB -\u003e java @Override public Boolean getNullableResult(ResultSet resultSet, String s) throws SQLException { int sexNum = resultSet.getInt(s); return sexNum == 1?true:false; } // DB -\u003e java @Override public Boolean getNullableResult(ResultSet resultSet, int i) throws SQLException { int sexNum = resultSet.getInt(i); return sexNum == 1?true:false; } // DB -\u003e java @Override public Boolean getNullableResult(CallableStatement callableStatement, int i) throws SQLException { int sexNum = callableStatement.getInt(i); return sexNum == 1?true:false; } } b.配置conf.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 优化：引入properties文件--\u003e \u003cproperties resource=\"db.properties\" /\u003e \u003ctypeAliases\u003e \u003cpackage name=\"org.jsh.entity\"/\u003e \u003c/typeAliases\u003e \u003c!-- 配置转换器--\u003e \u003ctypeHandlers\u003e \u003ctypeHandler handler=\"org.jsh.converter.BooleanAndIntConverter\" javaType=\"Boolean\" jdbcType=\"INTEGER\" /\u003e \u003c/typeHandlers\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!-- 加载映射文件--\u003e \u003cmapper resource=\"org/jsh/mapper/studentMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:3:1","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"使用 studentMapper.xml: 查询 把select标签中resultType属性变为resultMap 值为id 创建resultMap标签 属性：id:传回select标签 属性： type: 返回值类型 子标签： 表中主键：标签为id 非主键result property:java实体类中属性名 column：数据表中属性名 javaType ：java实体类中属性类型 jdbcType ：数据表中属性类型 \u003cselect id=\"selectStudentByNumWithConverter\" parameterType=\"int\" resultMap=\"studentResult\"\u003e select * from student where stunum = #{stunum} \u003c/select\u003e \u003cresultMap id=\"studentResult\" type=\"student\"\u003e \u003c!-- 主键--\u003e \u003cid property=\"stunum\" column=\"stunum\"\u003e\u003c/id\u003e \u003c!-- 非主键--\u003e \u003cresult property=\"name\" column=\"name\" /\u003e \u003cresult property=\"age\" column=\"age\" /\u003e \u003cresult property=\"sex\" column=\"sex\" javaType=\"boolean\" jdbcType=\"INTEGER\" /\u003e \u003c/resultMap\u003e 查询 \u003cinsert id=\"addStudentWithConverter\" parameterType=\"student\" \u003e insert into student(stunum,name,age,sex) values(#{stunum},#{name},#{age},#{sex,javaType=Boolean,jdbcType=INTEGER}) \u003c/insert\u003e ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:3:2","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"result resultMap可以实现2个功能： 1.类型转换 2.属性-字段的映射关系(当java实体类中属性名与数据表中属性名不同时) 忽略大小写 \u003cselect id=\"queryStudentByStuno\" parameterType=\"int\" resultMap=\"studentMapping\" \u003e select * from student where stuno = #{stuno} \u003c/select\u003e \u003cresultMap type=\"student\" id=\"studentMapping\"\u003e \u003c!-- 分为主键id 和非主键 result--\u003e \u003cid property=\"id\" column=\"stuno\" /\u003e \u003cresult property=\"stuName\" column=\"stuname\" /\u003e \u003cresult property=\"stuAge\" column=\"stuage\" /\u003e \u003cresult property=\"graName\" column=\"graname\" /\u003e \u003cresult property=\"stuSex\" column=\"stusex\" javaType=\"boolean\" jdbcType=\"INTEGER\"/\u003e \u003c/resultMap\u003e ","date":"2020-03-03","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/:4:0","tags":[],"title":"后端-Mybatis-动态代理、类型转化器、resultMap(day2)","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%99%A8resultmapday2/"},{"categories":["Spring"],"content":"Mybatis-配置及入门 ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:0:0","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"简介 ibatis:apache 2010 ibatis -\u003e google colde ,Mybatis ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:1:0","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"作用 简化JDBC操作，实现数据的持久化（包存到数据库）。 ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:2:0","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"ORM（是一个概念） ORM：Object Relational(关系) Mapping person对象(java) \u003c=\u003e person表(数据库) 映射 Mybatis是ORM的一个实现 ORM可以使开发人员像操作对象一样 操作数据库表 ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:2:1","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"开发Mybatis程序步骤： ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:3:0","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"下载Mybatis-jar导入集成工具 ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:3:1","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"conf.xml : 配置数据库信息 和 需要加载的映射文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 通过environments的default值和environment的id值指定Mybatis运行时的数据库环境--\u003e \u003cenvironments default=\"development\"\u003e \u003c!-- 开发环境--\u003e \u003cenvironment id=\"development\"\u003e \u003c!-- 配置事务提交方式 JDBC：利用JDBC方式处理事务（commit rollback close）手工 MANAGED:将事务交由其他组件托管（spring,jobss）自动，默认关闭连接--\u003e \u003c!-- 默认不关闭--\u003e \u003c!-- \u003ctransactionManager type=\"MANAGED\"/\u003e--\u003e \u003c!-- \u003cproperty name=\"closeConnection\" value=\"false\"/\u003e--\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003c!-- 配置数据库信息--\u003e \u003c!-- 数据源类型： POOLED：使用数据库连接池（省略数据库的打开和关闭） UNPOOLED：传统的JDBC模式（不推荐：每次访问数据库都需要打开关闭数据库，消耗性能高） JNDI：从tomcat中获取一个内置的数据库连接池--\u003e \u003cdataSource type=\"POOLED\"\u003e \u003c!-- 数据库驱动--\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003c!-- 连接字符串--\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/testdata?useSSL=true\u0026amp;serverTimezone=UTC\"/\u003e \u003c!-- 数据库账号--\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003c!-- 数据库密码--\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c!-- 运行环境--\u003e \u003cenvironment id=\"start\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/testdata?useSSL=true\u0026amp;serverTimezone=UTC\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!-- 加载映射文件--\u003e \u003cmapper resource=\"org/jsh/entity/studentMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:3:2","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"数据库中 表(和类属性一一对应) ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:3:3","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"Java 类 package org.jsh.entity; public class Student { private int stunum; private String name; private int age; public Student() { } public Student(int stunum, String name, int age) { this.stunum = stunum; this.name = name; this.age = age; } public int getStunum() { return stunum; } public void setStunum(int stunum) { this.stunum = stunum; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"stunum=\" + stunum + \", name='\" + name + '\\'' + \", age=\" + age + '}'; } } ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:3:4","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"映射文件 xxMapper,xml: \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- namespace:该mapper.xml映射文件的唯一标识--\u003e \u003cmapper namespace=\"org.jsh.entity.studentMapper\"\u003e \u003c!-- 通过id值定义标签 paparameterType:输入值类型 resultType返回值类型--\u003e \u003cselect id=\"selectStudentByNum\" parameterType=\"int\" resultType=\"org.jsh.entity.Student\"\u003e -- sql语句 select * from student where stunum = #{stunum} \u003c/select\u003e \u003c!-- Mybatis 规定输入输出在语法上只有一个 paparameterType，resultType只有一个 --\u003e \u003c!-- 如果输入参数是简单类型（8个基本类型+String）可以使用任何占位符--\u003e \u003c!-- 如果是对象类型。则必须是对象的属性 例：#{属性名}--\u003e \u003cinsert id=\"addStudent\" parameterType=\"org.jsh.entity.Student\" \u003e insert into student(stunum,name,age) values(#{stunum},#{name},#{age}) \u003c/insert\u003e \u003cupdate id=\"updateStudentByNum\" parameterType=\"org.jsh.entity.Student\"\u003e update student set name=#{name},age=#{age} where stunum=#{stunum} \u003c/update\u003e \u003cdelete id=\"deleteStudentByNum\" parameterType=\"int\"\u003e delete from student where stunum = #{stunum} \u003c/delete\u003e \u003c!-- 无论返回一个值还是一个列表 resultType不变--\u003e \u003cselect id=\"queryAllStudents\" resultType=\"org.jsh.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:3:5","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"测试类 package org.jsh.entity; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.Reader; import java.util.List; public class TestMybatis { public static void main(String[] args) throws IOException { queryAllStudents(); // addStudent(); // deleteStudentByNum(); updateStudentByNum(); queryAllStudents(); } //查询单个学生 public static void queryStudentByNum() throws IOException { // 加载Mybatis配置文件 // conf.xml -\u003e reader Reader reader = Resources.getResourceAsReader(\"conf.xml\"); // reader - \u003e SqlSession // build的第二个参数 修改conf.xml中 \u003cenvironments default=\"development\"\u003e 的默认值 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); // SqlSession -\u003e connection SqlSession session = sessionFactory.openSession(); // (\"namespace.id\",\"sql参数\") // 动态代理 自动将返回值变为Student Student student = session.selectOne(\"org.jsh.entity.studentMapper.selectStudentByNum\", 1); System.out.println(student); session.close(); } //查询多个学生 public static void queryAllStudents() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); List\u003cStudent\u003e students = session.selectList(\"org.jsh.entity.studentMapper.queryAllStudents\"); System.out.println(students); session.close(); } //增加学生 public static void addStudent() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); Student student = new Student(3, \"wu\", 24); int count = session.insert(\"org.jsh.entity.studentMapper.addStudent\", student); session.commit();//提交数据 System.out.println(count); session.close(); } //增加学生 public static void deleteStudentByNum() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); int count = session.delete(\"org.jsh.entity.studentMapper.deleteStudentByNum\", 3); session.commit();//提交数据 System.out.println(count); session.close(); } //修改 public static void updateStudentByNum() throws IOException { Reader reader = Resources.getResourceAsReader(\"conf.xml\"); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, \"development\"); SqlSession session = sessionFactory.openSession(); // 修改的参数 Student student = new Student(); // 修改哪个人，wehere stunum = 2 student.setStunum(2); // 修改成什么样子 student.setName(\"jsh\"); student.setAge(22); int count = session.update(\"org.jsh.entity.studentMapper.updateStudentByNum\", student); session.commit();//提交数据 System.out.println(count); session.close(); } } ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:3:6","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["Spring"],"content":"注意事项 如果事务提交方式为JDBC 则需要手动commit ","date":"2020-03-02","objectID":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/:4:0","tags":[],"title":"Mybatis-配置及入门","uri":"/%E5%90%8E%E7%AB%AF-mybatis-%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%A5%E9%97%A8day-1/"},{"categories":["前端"],"content":"前端-CSS基本语法与选择器（day1） html： 内容 (文本框) css: 样式 （给文本框设置 长度、宽度、颜色） css优势： 内容与样式相分离 css样式更加丰富 提高浏览器的加载速度、节约网络带宽，减少代码量 利于SEO优化 ","date":"2020-03-02","objectID":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/:0:0","tags":[],"title":"前端-CSS基本语法与选择器（day1）","uri":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/"},{"categories":["前端"],"content":"基本语法 选择器 { ​ 样式名：样式值 ; ​ 样式名：样式值 ; ​ 样式名：样式值 ; ​ … } 颜色：支持英文单词、#6个或3个十六进制 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eCSS\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e h1 { color: red; /* #154245 */ font-size : 20px ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eh1标签\u003c/h1\u003e \u003ch1\u003eh1标签\u003c/h1\u003e \u003ch2\u003eh2标签\u003c/h2\u003e \u003ch3\u003eh3标签\u003c/h3\u003e \u003ch1\u003eh1标签\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 选择器： 标签选择器：直接编写标签名 h1 , p 类选择器： .class值 ，可以用于多个元素 id选择器： #id值，只能用于一个元素 ","date":"2020-03-02","objectID":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/:1:0","tags":[],"title":"前端-CSS基本语法与选择器（day1）","uri":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/"},{"categories":["前端"],"content":"引入CSS样式的方式 行内样式 内部样式 head style 外部样式 建议：在开发时 用内部样式；编写完毕后 改造成外部 ； 行内：不推荐， 赶时间、应急 行内： \u003ch4 style=\"color:red;background-color:green;\"\u003e h4样式\u003c/h4\u003e 内部 \u003chead\u003e \u003ctitle\u003eCSS\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e h1 { color: red; /* #154245 */ font-size : 20px ; } \u003c/style\u003e \u003c/head\u003e 外部： 先将样式独立保存在一个.css文件中，然后再在html文件中引入该.css文件 \u003chead\u003e \u003c!--外部样式：推荐做法link --\u003e \u003clink href=\"文件名.css\" type=\"text/css\" rel=\"stylesheet\"/\u003e \u003c/head\u003e 了解（不推荐）： \u003cstyle type=\"text/css\"\u003e \u003c!-- 外部样式--\u003e @import url(\"mycss.css\") ; \u003c/style\u003e 外部导入的两种方式（链接式,link； 导入式,@import）区别 ： 推荐link link属于xhtml规范； @import属于css2.1标准 link将css预先加载到网页中，再进行编译显示 @import：先显示网页结构，然后再加载CSS内容 @import是css2.1独有的 提示： 注释：html ，在css中注释 /* */ CSS优先级问题： 行内优先级 \u003e外部 \u003e内部 id选择器\u003e类选择器 \u003e标签选择器 ","date":"2020-03-02","objectID":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/:2:0","tags":[],"title":"前端-CSS基本语法与选择器（day1）","uri":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/"},{"categories":["前端"],"content":"复合选择器 提前：样式会继承，例如选择 ul，会给ul下面的li 起作用 ","date":"2020-03-02","objectID":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/:3:0","tags":[],"title":"前端-CSS基本语法与选择器（day1）","uri":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/"},{"categories":["前端"],"content":"CSS2.1 后代选择器： 空格 交集选择器：连续书写 （没有继承性），要防止歧义 并集选择器：逗号 , ","date":"2020-03-02","objectID":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/:4:0","tags":[],"title":"前端-CSS基本语法与选择器（day1）","uri":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/"},{"categories":["前端"],"content":"CSS3 （类似jquery） 层次选择器 后代选择器 ： 空格 子选择器： \u003e 相邻同辈选择器（只对 后面的元素有效）: + 通用同辈选择器（只对 后面的元素有效）: ~ 结构伪类选择器 \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eCSS\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e /* 层次 ul\u003eli { color : red ; } h4+h1 { color:blue ; } h4~h1 { color:blue ; } */ /* 伪类选择器 */ /* 每一个ul ol中 */ li:first-child { color :yellow ; } li:last-child { color :red ; } li:nth-child(3) { color: green ; } /*全局*/ p:first-of-type{ background-color : purple ; } p:last-of-type{ background-color : pink ; } p:nth-of-type(2){ background-color : red ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003ep1p1\u003c/p\u003e \u003cp\u003ep2p2\u003c/p\u003e \u003cp\u003ep3p3\u003c/p\u003e \u003cp\u003ep4p4\u003c/p\u003e \u003cul\u003e \u003cli\u003eaaa\u003c/li\u003e \u003cli\u003ebbb\u003c/li\u003e \u003cli\u003eccc\u003c/li\u003e \u003cli\u003eddd\u003c/li\u003e \u003c/ul\u003e \u003ch1\u003e1111\u003c/h1\u003e \u003ch1\u003e1111\u003c/h1\u003e \u003ch4\u003eh4h4h4\u003c/h4\u003e \u003ch1\u003eAAAA111\u003c/h1\u003e \u003ch1\u003eAAAA222\u003c/h1\u003e \u003ch1\u003e1111\u003c/h1\u003e \u003ch4\u003eh4h4h4\u003c/h4\u003e \u003ch1\u003eBBBB11\u003c/h1\u003e \u003ch1\u003eBBBB22\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 属性选择器[] \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eCSS\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e /* 层次 ul\u003eli { color : red ; } h4+h1 { color:blue ; } h4~h1 { color:blue ; } */ /* 伪类选择器 */ li:first-child { color :yellow ; } li:last-child { color :red ; } li:nth-child(3) { color: green ; } p:first-of-type{ background-color : purple ; } p:last-of-type{ background-color : pink ; } p:nth-of-type(2){ background-color : red ; } /*选择有name属性，且标签是input的 input[name]{ background-color: yellow ; }*/ /*input，有name，且name的值是username input[name=\"username\"]{ background-color: yellow ; } */ /*name是以user开头的元素 input[name^=user] { background-color:green ; }*/ /*以name结尾 input[name$=name] { background-color: purple; } */ /*包含i的*/ input[name*=i]{ background-color: pink ; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cform\u003e id:\u003cinput type=\"text\" name=\"uid\" /\u003e\u003cbr/\u003e 用户名:\u003cinput type=\"text\" name=\"usernickname\" /\u003e\u003cbr/\u003e 真实名字:\u003cinput type=\"text\" name=\"username\" /\u003e\u003cbr/\u003e 密码：\u003cinput type=\"password\" name=\"pwd\"/\u003e\u003cbr/\u003e \u003c/form\u003e \u003cp\u003ep1p1\u003c/p\u003e \u003cp\u003ep2p2\u003c/p\u003e \u003cp\u003ep3p3\u003c/p\u003e \u003cp\u003ep4p4\u003c/p\u003e \u003cul\u003e \u003cli\u003eaaa\u003c/li\u003e \u003cli\u003ebbb\u003c/li\u003e \u003cli\u003eccc\u003c/li\u003e \u003cli\u003eddd\u003c/li\u003e \u003c/ul\u003e \u003ch1\u003e1111\u003c/h1\u003e \u003ch1\u003e1111\u003c/h1\u003e \u003ch4\u003eh4h4h4\u003c/h4\u003e \u003ch1\u003eAAAA111\u003c/h1\u003e \u003ch1\u003eAAAA222\u003c/h1\u003e \u003ch1\u003e1111\u003c/h1\u003e \u003ch4\u003eh4h4h4\u003c/h4\u003e \u003ch1\u003eBBBB11\u003c/h1\u003e \u003ch1\u003eBBBB22\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-02","objectID":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/:5:0","tags":[],"title":"前端-CSS基本语法与选择器（day1）","uri":"/%E5%89%8D%E7%AB%AF-css%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8day1/"},{"categories":["前端"],"content":"1.HTML ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:0:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"1.1 简介 html: hyper text markup language ，超文本标记语言 html 1.0 - 1993-06 html2.0 - 1995-11 html 3.x - 1997-01 html 4.0 -1997-12 html 4.01 - 1999-12 html 5 - 2014-10 ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:1:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"1.2 Html基本网页结构 格式： xxx.html(推荐) xxx.htm \u003c!DOCTYPE html\u003e doctype声明 不区分大小写，容错性很强 乱码问题： 英文和数字在任何编码格式下 都不会有乱码（正常显示的）；其他的 都依赖于编码类型。 w3c规定：标准写法有两种 ​ \u003c标签\u003e\u003c/标签\u003e ​ \u003c标签 /\u003e w3c标准 ： 具体的实现产品html css javascript html版本 html和xhtml的区别 html内容的语义化 \u003chtml\u003e \u003c!-- 声明式：不能显示 --\u003e \u003chead\u003e \u003c!-- 设置网页编码 --\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003c!-- 关键词： 是否能被搜索引擎搜到 --\u003e \u003cmeta name=\"keywords\" content=\"学习html\" /\u003e \u003c!-- 描述：当搜到本网页时，展示的简介内容... --\u003e \u003cmeta name=\"description\" content=\"学习html非常的好，好啊啊啊啊啊啊....\" /\u003e \u003ctitle\u003e我的标题 html...\u003c/title\u003e \u003c/head\u003e \u003c!-- 能够显示的 --\u003e \u003cbody\u003e my context... 我的内容您好 \u003c/body\u003e \u003c/html\u003e ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:2:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"1.3基本标签（重点） 标题标签 \u003ch1\u003e … \u003ch6\u003e 段落标签 \u003cp\u003e ..\u003c/p\u003e 换行标签 \u003cbr/\u003e 水平线\u003chr\u003e 样式标签 ​ 加粗\u003cstrong\u003e\u003c/strong\u003e 或者\u003cb\u003e \u003c/b\u003e 倾斜\u003cem\u003e\u003c/em\u003e \u003c!-- 能够显示的 --\u003e \u003cbody\u003e \u003cp\u003e11111111111111111...\u003c/p\u003e \u003cp\u003e2222222\u003c/p\u003e \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e2级标题\u003c/h2\u003e \u003ch3\u003e3级标题\u003c/h3\u003e \u003ch4\u003e4级标题\u003c/h4\u003e \u003ch6\u003e6级标题\u003c/h6\u003e \u003chr/\u003e hello world \u003cstrong\u003ehello world\u003c/strong\u003e hello \u003cb\u003eworld\u003c/b\u003e \u003cem\u003ehello\u003c/em\u003e \u003cem\u003e\u003cstrong\u003eworld\u003c/strong\u003e\u003c/em\u003e \u003cstrong\u003e \u003cem\u003e world \u003c/em\u003e \u003c/strong\u003e \u003c/body\u003e ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:3:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"1.4 特殊符号、注释 注释 特殊符号 \u0026 … ; ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:4:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"图片 img ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:5:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"链接 普通超链接 锚链接 功能性链接: 邮件 ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:6:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"调试 chrome: F12 ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:7:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"列表 无序列表 ​ ul , li \u003cul type=\"circle\"\u003e \u003cli\u003e苹果\u003c/li\u003e \u003cli type=\"disc\"\u003e香蕉\u003c/li\u003e \u003cli\u003e橘子\u003c/li\u003e \u003c/ul\u003e type=“disc|circle|square” \u003cul\u003e \u003cli\u003e \u003cul\u003e .. \u003c/ul\u003e \u003c/li\u003e \u003c/ul\u003e ul中的元素可以嵌套，li中可以嵌套ul 经验： \u003cul\u003e \u003cli\u003e \u003c/li\u003e \u003cul\u003e .. \u003c/ul\u003e \u003c/ul\u003e 有序列表 ol , li \u003col type=\"I\"\u003e \u003cli\u003e苹果\u003c/li\u003e \u003cli type=\"1\"\u003e香蕉\u003c/li\u003e \u003cli\u003e橘子\u003c/li\u003e \u003c/ol\u003e type=“1|a|A|i|I” \u003col\u003e \u003cli\u003e \u003col\u003e\u003c/ol\u003e \u003c/li\u003e \u003col\u003e\u003c/ol\u003e \u003cul\u003e ... \u003c/ul\u003e \u003c/ol\u003e 定义列表 \u003cdl\u003e \u003cdt\u003e标题\u003c/dt\u003e \u003cdd\u003e正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容正文内容\u003c/dd\u003e \u003c/dl\u003e ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:8:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"表格 \u003ctable border=\"1px\" \u003e \u003c!--表格table，行tr ，列 td --\u003e \u003ctr align=\"right\"\u003e \u003ctd rowspan=\"2\"\u003e1-1\u003c/td\u003e \u003ctd colspan=\"2\" align=\"center\"\u003ea\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd valign=\"middle\"\u003e2-2\u003c/td\u003e \u003ctd\u003e2-3\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e3-1\u003c/td\u003e \u003ctd\u003e3-2\u003c/td\u003e \u003ctd align=\"center\"\u003ec\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 水平移动 align=“left|center|right” 垂直移动valign=“top|middle|bottom” 跨行 rowspan=“n” 跨列colspan=“n” ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:9:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"表单 \u003c!--method:表单提交方式 get（地址栏显示参数值，默认） , post（不显示，推荐） size: 文本框/密码显示的长度 maxlength:实际能够输入内容的长度 文件：2个一起写， input type=\"file\" enctype=\"multipart/form-data\" 隐藏域：type=\"hidden\"。前台不显示，但真实存在 --\u003e \u003cform action=\"result.html\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003c!--表单元素的标注 --\u003e \u003clabel for=\"xa\"\u003e西安\u003c/label\u003e \u003cinput type=\"checkbox\" id=\"xa\"/\u003e \u003c!-- 语义化表单--\u003e \u003cfieldset\u003e \u003clegend\u003e用户信息\u003c/legend\u003e Helo\u003cinput /\u003e Helo\u003cinput /\u003e \u003c/fieldset\u003e \u003cbr/\u003e \u003cbr/\u003e \u003cbr/\u003e \u003cinput type=\"file\" name=\"file1\" /\u003e \u003cinput type=\"hidden\" value=\"1\"\u003e 认证名:\u003cinput readonly=\"readonly\" name=\"realname\" value=\"颜群\" type=\"text\"/\u003e \u003cbr/\u003e 用户名:\u003cinput name=\"username\" size=\"10\" maxlength=\"4\" value=\"张三\" type=\"text\"/\u003e \u003cbr/\u003e 密码:\u003cinput name=\"pwd\" size=\"2\" type=\"password\"/\u003e\u003cbr/\u003e 兴趣爱好：\u003cbr/\u003e 足球\u003cinput checked=\"checked\" name=\"hobby\" type=\"checkbox\"\u003e 篮球\u003cinput name=\"hobby\" type=\"checkbox\"\u003e 乒乓球\u003cinput name=\"hobby\" checked=\"checked\" type=\"checkbox\"\u003e \u003cbr/\u003e 计划旅游的城市\u003cbr/\u003e 西安\u003cinput name=\"city\" type=\"checkbox\"\u003e 北京\u003cinput name=\"city\" checked=\"checked\" type=\"checkbox\"\u003e 上海\u003cinput name=\"city\" type=\"checkbox\"\u003e \u003cbr/\u003e 性别：\u003cbr/\u003e 男\u003cinput name=\"sex\" checked=\"checked\" type=\"radio\" /\u003e 女\u003cinput name=\"sex\" type=\"radio\" /\u003e \u003cinput value=\"注册\" type=\"submit\" /\u003e \u003cinput value=\"恢复默认值\" type=\"reset\" /\u003e\u003cbr/\u003e \u003cinput type=\"button\" value=\"按钮\" disabled=\"disabled\" /\u003e \u003cselect\u003e \u003coption\u003e西安\u003c/option\u003e \u003coption selected=\"selected\"\u003e成都\u003c/option\u003e \u003coption\u003e深圳\u003c/option\u003e \u003c/select\u003e \u003cbr/\u003e 个人说明:\u003cbr/\u003e \u003ctextarea cols=\"30\" rows=\"5\"\u003e 这是编写默认值的地方.... \u003c/textarea\u003e \u003c/form\u003e ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:10:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"html5新支持的表单标签 视频： \u003cvideo\u003e:每一个\u003cvideo\u003e对应一个视频文件； 如果考虑浏览器兼容问题，则可以编写多个视频资源，然后嵌套在一个\u003cvideo\u003e中 \u003c!-- \u003cvideo src=\"resources/4.第一个MQ案例.webm\" controls \u003e\u003c/video\u003e \u003cvideo src=\"resources/4.第一个MQ案例.wvm\" controls \u003e\u003c/video\u003e \u003cvideo src=\"resources/4.第一个MQ案例.mp4\" controls \u003e\u003c/video\u003e --\u003e \u003cvideo controls \u003e \u003csource src=\"resources/4.第一个MQ案例.webm\" type=\"video/webm\"/\u003e \u003csource src=\"resources/4.第一个MQ案例.mp4\" type=\"webm/mp4\" /\u003e \u003c/video\u003e 音频： \u003caudio\u003e 注意type问题： 一般而言，文件的后缀 就是type，但个别不一致，如下 \u003caudio controls autoplay \u003e \u003csource src=\"resources/恭喜发财.mp3\" type=\"audio/mpeg\" /\u003e \u003csource src=\"resources/恭喜发财.ogg\" type=\"audio/ogg\" /\u003e \u003c/audio\u003e html5有很多标签自带正则校验 \u003cform action=\"resources/b.html\"\u003e 用户名（必填）：\u003cinput type=\"text\" required /\u003e\u003cbr/\u003e 电话（必填）：\u003cinput type=\"text\" required pattern=\"^1[358]\\d{9}$\" /\u003e \u003cbr/\u003e \u003c!--type=\"email\"会初步校验 内容是否为邮箱，如果不是 就会终止提交 --\u003e 邮箱（必填）：\u003cinput type=\"email\" required /\u003e\u003cbr/\u003e 请输入网址：\u003cinput type=\"url\" /\u003e\u003cbr/\u003e 请输入数字：\u003cinput type=\"number\" min=\"0\" max=\"100\" step=\"10\"/\u003e\u003cbr/\u003e 数字滑块：\u003cinput type=\"range\" min=\"0\" max=\"100\" step=\"10\"/\u003e\u003cbr/\u003e 搜索：\u003cinput type=\"search\" placeholder=\"请输入商品名\" /\u003e\u003cbr/\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e 正则表达式：https://www.runoob.com/regexp/regexp-syntax.html ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:11:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"页面布局 \u003cbody\u003e \u003cheader\u003e \u003ch1\u003e表示网页的头部 \u003c/h1\u003e\u003c/header\u003e \u003csection\u003e\u003ch1\u003e网页中的某一块区域\u003c/h1\u003e\u003c/section\u003e \u003carticle\u003e网页的文章\u003c/article\u003e \u003caside\u003e网页的侧边栏\u003c/aside\u003e \u003cnav\u003e网页的导航\u003c/nav\u003e \u003cfooter\u003e\u003ch1\u003e表示网页的底部\u003c/h1\u003e\u003c/footer\u003e \u003c/body\u003e ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:12:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["前端"],"content":"内联框架iframe \u003ca href=\"https://www.baidu.com\" target=\"my_iframe\"\u003e点我进百度\u003c/a\u003e \u003ca href=\"https://www.163.com\" target=\"my_iframe\"\u003e点我进网易\u003c/a\u003e \u003ca href=\"resources/b.html\" target=\"my_iframe\"\u003e点我进b.html\u003c/a\u003e --- \u003ciframe src=\"https://www.baidu.com\" name=\"my_iframe\" width=\"1200px\" height=\"500px\"\u003e\u003c/iframe\u003e \u003cbr/\u003e --- \u003cbr/\u003e \u003cbr/\u003e \u003cbr/\u003e \u003cbr/\u003e \u003cbr/\u003e \u003ca href=\"https://www.baidu.com\" target=\"_self\"\u003e点我进百度\u003c/a\u003e \u003cbr/\u003e \u003ca href=\"https://www.baidu.com\" target=\"_self\"\u003e点我进百度（在当前页面打开）\u003c/a\u003e \u003ca href=\"https://www.baidu.com\" target=\"_blank\"\u003e点我进百度（在新窗口中打开）\u003c/a\u003e \u003cbr/\u003e\u003cbr/\u003e\u003cbr/\u003e \u003ciframe src=\"https://www.baidu.com\" name=\"iframe1\" width=\"1200px\" height=\"500px\"\u003e\u003c/iframe\u003e \u003cbr/\u003e \u003ciframe src=\"https://www.163.com/\" name=\"iframe2\"\u003e\u003c/iframe\u003e\u003cbr/\u003e \u003ciframe src=\"resources/b.html\" name=\"iframe3\"\u003e\u003c/iframe\u003e a标签的值： _blank:新打开一个窗口 _self:在当前页面打开（默认值） iframe的name值：把当前a的href值赋值给 iframe的src值 ","date":"2020-03-01","objectID":"/%E5%89%8D%E7%AB%AF-html/:13:0","tags":[],"title":"html","uri":"/%E5%89%8D%E7%AB%AF-html/"},{"categories":["Spring"],"content":"后端-MyBatis准备（JDBC回顾） jdbc（Java DataBase Donnectivity）可以为多种关系型数据库 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:0:0","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"JDBC 通过操作java程序 操作 JDBC DriverManager 操作 数据库驱动程序 操作 数据库 JDBC API ：提供各种操作访问接口，Connection Statement PreparedStatement ResultSet JDBC DriverManager 管理不同的数据库驱动 各种数据库驱动：相应数据库厂商提供 作用：链接或者直接操作数据库 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:1:0","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"JDBC API ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:2:0","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"作用 建立连接 发送sql语句 返回处理结果 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:2:1","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"DriverManager : 管理JDBC驱动 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:2:2","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"Connection : 连接 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:2:3","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"Statement (PreparedStatement) : 增删改 查 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:2:4","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"CallableStatement : 调用数据库中的存储函数 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:2:5","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"ResultSet : 返回的结果集 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:2:6","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"JDBC访问数据库具体步骤 导入数据库，加载具体驱动类 与数据库建立连接 发送sql，执行 处理结果集 import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Scanner; public class JDBCDemo2 { private static final String URL = \"jdbc:mysql://localhost:3306/testdata\"; private static final String USERNAME = \"root\"; private static final String PWD = \"123456\"; public static void update() {// 增删改 Connection connection = null; Statement stmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\"com.mysql.jdbc.Driver\");// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) stmt = connection.createStatement(); //String sql = \"insert into student values(1,'zs',23,'s1')\"; // String sql = \"update student set STUNAME='ls' where stuno=1\"; String sql = \"delete from student where stuno=1\"; // 执行SQL int count = stmt.executeUpdate(sql); // 返回值表示 增删改 几条数据 // d.处理结果 if (count \u003e 0) { System.out.println(\"操作成功！\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } } public static void query() { Connection connection = null; Statement stmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\"com.mysql.jdbc.Driver\");// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、【查】) stmt = connection.createStatement(); // String sql = \"select stuno,stuname from student\"; Scanner input= new Scanner(System.in); System.out.println(\"请输入用户名：\"); String name = input.nextLine() ; System.out.println(\"请输入密码：\"); String pwd = input.nextLine() ; String sql = \"select count(*) from login where uname='\"+name+\"' and upwd ='\"+pwd+\"' \" ; // String sql = \"select * from student where stuname like '%\"+name+\"%'\"; // 执行SQL(增删改executeUpdate()，查询executeQuery()) rs = stmt.executeQuery(sql); // 返回值表示 增删改 几条数据 // d.处理结果 int count = -1; if(rs.next()) { count = rs.getInt(1) ; } if(count\u003e0) { System.out.println(\"登陆成功！\"); }else { System.out.println(\"登陆失败！\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(rs!=null) rs.close(); if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } } public static void main(String[] args) { // update() ; query() ; } } ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:3:0","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["Spring"],"content":"数据库驱动 数据库 具体驱动类 连接字符串 mysql com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/数据库名称 oracle oracle.jdbc.OracleDriver jdbc:oracle:thin:@localhost:1521:数据库名称 sqlserver com.microsoft.sqlserver.jdbc.SQLServerDriver jdbc:microsoft.sqlserver:localhost:1433;databasename=数据库名称 ","date":"2020-03-01","objectID":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/:4:0","tags":[],"title":"后端-MyBatis准备（JDBC回顾）","uri":"/%E5%90%8E%E7%AB%AF-mybatis%E5%87%86%E5%A4%87jdbc%E5%9B%9E%E9%A1%BE/"},{"categories":["工具"],"content":"hexo框架个人博客搭建 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1 环境准备 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1.1 Node.js和npm安装 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:1","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1.2(选) npm 淘宝镜像 npm install -g cnpm --registry.npm.taobao.org ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:2","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1.3 hexo框架安装 cnpm install -g hexo-cli ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:3","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1.4git安装配置 git官网 下载对应系统安装包 运行安装包 一路下一步 开始菜单运行 Git Bash(运行成功表示git安装成功) git安装好去GitHub上注册一个账号 设置git：在Git Bush命令行中输入 # 配置用户名 git config --global user.name \"username\" //（ \"username\"是自己的账户名） # 配置邮箱 git config --global user.email \"username@email.com\" //(\"username@email.com\"注册账号时用的邮箱) ​ 以上命令执行结束后，可用 git config –global –list 命令查看配置是否OK 6. 生成ssh,在命令框中输入以下命令 ssh-keygen -t rsa ​ 连续敲三次回车，结束后去系统盘目录下（一般在 C:\\Users\\你的用户名.ssh）(mac: /Users/用户/.ssh）查看是否有：ssh文件夹生成 7. 将ssh文件夹中的公钥（ id_rsa.pub）添加到GitHub管理平台中，在GitHub的个人账户的设置中找到如下界面 title随便起一个，将公钥（ id_rsa.pub）文件中内容复制粘贴到key中，然后点击Ass SSH key就好啦 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:4","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2 建立本地网站 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2.1 在本地建立一个文件夹 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:1","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2.2 cmd命令进入这个文件夹 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:2","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2.3 hxeo生成博客 sudo hexo init ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:3","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2.4 启动博客 hexo s ​ 进入网站 说明建立成功 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:4","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3 上传至github ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.1 建立仓库 登录github 新建一个仓库 仓库名必须是 “«你的username».github.io” ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:1","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.2 网站根目录安装git插件 cnpm install --save hexo-deployer-git ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:2","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.3 设置文件“_config.yml”（最底部） deploy: type: git repo: //你的仓库地址 branch: master ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.4 部署到远端 hexo d //需要登陆 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:4","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.5 访问 ​ ”https://«你的username».github.io“ ​ 成功 END ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:5","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"补充 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"主题可以更改 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:1","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"其他指令 hexo clean hexo g ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:2","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["数据库"],"content":"Mysql权限 ","date":"0001-01-01","objectID":"/mysql%E6%9D%83%E9%99%90/:0:0","tags":["MySQL"],"title":"Mysql权限","uri":"/mysql%E6%9D%83%E9%99%90/"},{"categories":["数据库"],"content":"一.用户管理 新建用户 用户地址： ’localhost’:本地主机 ‘%’:任何主机 ‘%.mysql.com’:mysql.com域的所有主机 只有user没有@’\u003c用户地址\u003e’:代表% create user '\u003c用户名\u003e'@'\u003c用户地址\u003e' identified by '\u003c密码\u003e'; 更改用户 rename user '\u003c旧用户名\u003e'@'\u003c旧用户地址\u003e' to '\u003c新用户名\u003e'@'\u003c新用户地址\u003e'; 更改密码 # root用户更改别的用户密码 set password for '\u003c用户名\u003e'@'\u003c用户地址\u003e' = password('\u003c新密码\u003e'); # 非root用户修改自身密码 set password = password('\u003c新密码\u003e'); # 使用 alter user alter user '\u003c用户名\u003e'@'\u003c用户地址\u003e' identified by '\u003c新密码\u003e'; 删除用户 drop user '\u003c用户名\u003e'@'\u003c用户地址\u003e'; ","date":"0001-01-01","objectID":"/mysql%E6%9D%83%E9%99%90/:1:0","tags":["MySQL"],"title":"Mysql权限","uri":"/mysql%E6%9D%83%E9%99%90/"},{"categories":["数据库"],"content":"二.权限管理 查询mysql有哪些权限 show privileges ; 授权(在用户创建好的前提下) 权限:(常用) ​ all: 以下所有权限 ​ select: 查询 ​ insert: 插入 ​ update: 修改 ​ detete: 删除 on \u003c数据库.表\u003e: ‘*‘代表所有 [with grant option]: ​ 代表此用户可以将授给此用户的权限给别的用户 grant \u003c权限列表\u003e on \u003c数据库.表\u003e to '\u003c用户名\u003e'@'\u003c用户地址\u003e' [with grant option]; 查看权限 # 查看当前用户的权限 show grants; # 查看其他用户权限 show grants for '\u003c用户名\u003e'@'\u003c用户地址\u003e'; 回收权限 revoke \u003c权限列表\u003e on \u003c数据库.表\u003e from '\u003c用户名\u003e'@'\u003c用户地址\u003e'; ","date":"0001-01-01","objectID":"/mysql%E6%9D%83%E9%99%90/:2:0","tags":["MySQL"],"title":"Mysql权限","uri":"/mysql%E6%9D%83%E9%99%90/"},{"categories":["数据库"],"content":"三.日期函数 获取当前时间 select now(); 日期时间 Extract（选取） 函数 SELECT TIME('2017-05-15 10:37:14');-- 获取时间：10:37:14 SELECT YEAR('2017-05-15 10:37:14');-- 获取年份 SELECT MONTH('2017-05-15 10:37:14');-- 获取月份 SELECT DAY('2017-05-15 10:37:14');-- 获取日 SELECT HOUR('2017-05-15 10:37:14');-- 获取时 SELECT MINUTE('2017-05-15 10:37:14');-- 获取分 SELECT SECOND('2017-05-15 10:37:14');-- 获取秒 SELECT MICROSECOND('2017-05-15 10:37:14');-- 获取毫秒 SELECT QUARTER('2017-05-15 10:37:14');-- 获取季度 SELECT WEEK('2017-05-15 10:37:14');-- 20 (获取周) SELECT WEEK('2017-05-15 10:37:14', 7);-- ****** 测试此函数在MySQL5.6下无效 SELECT WEEKOFYEAR('2017-05-15 10:37:14');-- 同week() SELECT DAYOFYEAR('2017-05-15 10:37:14');-- 135 (日期在年度中第几天) SELECT DAYOFMONTH('2017-05-15 10:37:14');-- 5 (日期在月度中第几天) SELECT DAYOFWEEK('2017-05-15 10:37:14');-- 2 (日期在周中第几天；周日为第一天) SELECT WEEKDAY('2017-05-15 10:37:14');-- 0 SELECT WEEKDAY('2017-05-21 10:37:14');-- 6(与dayofweek()都表示日期在周的第几天，只是参考标准不同，weekday()周一为第0天，周日为第6天) SELECT YEARWEEK('2017-05-15 10:37:14');-- 201720(年和周) 时间加减 -- DATE_ADD(date,INTERVAL expr type) 从日期加上指定的时间间隔 -- type参数可参考：http://www.w3school.com.cn/sql/func_date_sub.asp SELECT DATE_ADD('2017-05-15 10:37:14',INTERVAL 1 YEAR);-- 表示：2018-05-15 10:37:14 SELECT DATE_ADD('2017-05-15 10:37:14',INTERVAL 1 QUARTER);-- 表示：2017-08-15 10:37:14 SELECT DATE_ADD('2017-05-15 10:37:14',INTERVAL 1 MONTH);-- 表示：2017-06-15 10:37:14 SELECT DATE_ADD('2017-05-15 10:37:14',INTERVAL 1 WEEK);-- 表示：2017-05-22 10:37:14 SELECT DATE_ADD('2017-05-15 10:37:14',INTERVAL 1 DAY);-- 表示：2017-05-16 10:37:14 SELECT DATE_ADD('2017-05-15 10:37:14',INTERVAL 1 HOUR);-- 表示：2017-05-15 11:37:14 SELECT DATE_ADD('2017-05-15 10:37:14',INTERVAL 1 MINUTE);-- 表示：2017-05-15 10:38:14 SELECT DATE_ADD('2017-05-15 10:37:14',INTERVAL 1 SECOND);-- 表示：2017-05-15 10:37:15 -- DATE_SUB(date,INTERVAL expr type) 从日期减去指定的时间间隔 SELECT DATE_SUB('2017-05-15 10:37:14',INTERVAL 1 YEAR);-- 表示：2016-05-15 10:37:14 SELECT DATE_SUB('2017-05-15 10:37:14',INTERVAL 1 QUARTER);-- 表示：2017-02-15 10:37:14 SELECT DATE_SUB('2017-05-15 10:37:14',INTERVAL 1 MONTH);-- 表示：2017-04-15 10:37:14 SELECT DATE_SUB('2017-05-15 10:37:14',INTERVAL 1 WEEK);-- 表示：2017-05-08 10:37:14 SELECT DATE_SUB('2017-05-15 10:37:14',INTERVAL 1 DAY);-- 表示：2017-05-14 10:37:14 SELECT DATE_SUB('2017-05-15 10:37:14',INTERVAL 1 HOUR);-- 表示：2017-05-15 09:37:14 SELECT DATE_SUB('2017-05-15 10:37:14',INTERVAL 1 MINUTE);-- 表示：2017-05-15 10:36:14 SELECT DATE_SUB('2017-05-15 10:37:14',INTERVAL 1 SECOND);-- 表示：2017-05-15 10:37:13 -- 经特殊日期测试，DATE_SUB(date,INTERVAL expr type)可放心使用 SELECT DATE_SUB(CURDATE(),INTERVAL 1 DAY);-- 前一天：2017-05-11 SELECT DATE_SUB(CURDATE(),INTERVAL -1 DAY);-- 后一天：2017-05-13 SELECT DATE_SUB(CURDATE(),INTERVAL 1 MONTH);-- 一个月前日期：2017-04-12 SELECT DATE_SUB(CURDATE(),INTERVAL -1 MONTH);-- 一个月后日期：2017-06-12 SELECT DATE_SUB(CURDATE(),INTERVAL 1 YEAR);-- 一年前日期：2016-05-12 SELECT DATE_SUB(CURDATE(),INTERVAL -1 YEAR);-- 一年后日期：20178-06-12 -- MySQL date_sub() 日期时间函数 和 date_add() 用法一致，并且可以用INTERNAL -1 xxx的形式互换使用； -- 另外，MySQL 中还有两个函数 subdate(), subtime()，建议，用 date_sub() 来替代。 -- MySQL 另类日期函数：period_add(P,N), period_diff(P1,P2) -- 函数参数“P” 的格式为“YYYYMM” 或者 “YYMM”，第二个参数“N” 表示增加或减去 N month（月）。 -- MySQL period_add(P,N)：日期加/减去N月。 SELECT PERIOD_ADD(201705,2), PERIOD_ADD(201705,-2);-- 201707 20170503 -- period_diff(P1,P2)：日期 P1-P2，返回 N 个月。 SELECT PERIOD_DIFF(201706, 201703);-- -- datediff(date1,date2)：两个日期相减 date1 - date2，返回天数 SELECT DATEDIFF('2017-06-05','2017-05-29');-- 7 -- TIMEDIFF(time1,time2)：两个日期相减 time1 - time2，返回 TIME 差值 SELECT TIMEDIFF('2017-06-05 19:28:37', '2017-06-05 17:00:00');-- 02:28:37 ","date":"0001-01-01","objectID":"/mysql%E6%9D%83%E9%99%90/:3:0","tags":["MySQL"],"title":"Mysql权限","uri":"/mysql%E6%9D%83%E9%99%90/"}]