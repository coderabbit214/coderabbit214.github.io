[{"categories":["go"],"content":"Golang 分布式事务 使用两阶段提交（2PC）协议实现分布式事务 ","date":"2024-01-14","objectID":"/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:0:0","tags":["go"],"title":"Golang 分布式事务","uri":"/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["go"],"content":"1. 数据库设置 创建两个数据库 CREATE DATABASE test1; CREATE DATABASE test2; create table user ( id bigint auto_increment primary key, username varchar(255) not null, password varchar(255) not null, created_at timestamp null, updated_at timestamp null ); ","date":"2024-01-14","objectID":"/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:1:0","tags":["go"],"title":"Golang 分布式事务","uri":"/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["go"],"content":"2. 实现2PC协议 coordinator type Coordinator struct{} // ExecuteDistributedTransaction runs the distributed transaction using 2PC func (c *Coordinator) ExecuteDistributedTransaction(ctx context.Context, prepareFun func(db *gorm.DB) error, participants []*Participant) error { // Phase 1: Prepare var preparedTransactions []*gorm.DB for _, p := range participants { tx := p.db.Begin() err := p.Prepare(ctx, tx, prepareFun) if err != nil { return err } preparedTransactions = append(preparedTransactions, tx) } // Phase 2: Commit for i, p := range participants { err := p.Commit(ctx, preparedTransactions[i]) if err != nil { // Rollback transactions if commit fails for _, tx := range preparedTransactions { _ = p.Rollback(ctx, tx) } return err } } return nil } participant type Participant struct { db *gorm.DB } // Prepare prepares the transaction in the participant func (p *Participant) Prepare(ctx context.Context, tx *gorm.DB, prepareFun func(db *gorm.DB) error) error { return prepareFun(tx) } // Commit commits the transaction in the participant func (p *Participant) Commit(ctx context.Context, tx *gorm.DB) error { err := tx.Commit().Error if err != nil { return err } return nil } // Rollback rolls back the transaction in the participant func (p *Participant) Rollback(ctx context.Context, tx *gorm.DB) error { err := tx.Rollback().Error if err != nil { return err } return nil } ","date":"2024-01-14","objectID":"/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:2:0","tags":["go"],"title":"Golang 分布式事务","uri":"/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["go"],"content":"3. 测试 func TestCoordinator_ExecuteDistributedTransaction(t *testing.T) { db1, err := gorm.Open(mysql.Open(fmt.Sprintf( \"%s:%s@tcp(%s:%v)/%s?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\", \"root\", \"123456\", \"127.0.0.1\", \"3306\", \"test1\", ))) db2, err := gorm.Open(mysql.Open(fmt.Sprintf( \"%s:%s@tcp(%s:%v)/%s?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\", \"root\", \"123456\", \"127.0.0.1\", \"3306\", \"test2\", ))) c := \u0026Coordinator{} p1 := \u0026Participant{ db: db1, } p2 := \u0026Participant{ db: db2, } err = c.ExecuteDistributedTransaction(context.Background(), func(db *gorm.DB) error { return db.Model(\u0026model.User{}).Create(\u0026model.User{ Username: \"test\", Password: \"123456\", }).Error }, []*Participant{p1, p2}) if err != nil { t.Error(err) } fmt.Println(\"success\") } ","date":"2024-01-14","objectID":"/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:3:0","tags":["go"],"title":"Golang 分布式事务","uri":"/golang-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["笔记"],"content":"Next.js 学习笔记 ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"数据抓取 ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"getServerSideProps 什么时候使用： ​ 仅当需要呈现其数据必须在请求时获取的页面时，才应使用 getServerSideProps 。这可能是由于请求的数据或属性的性质（例如 authorization 标头或地理位置）。使用 getServerSideProps 的页面将在请求时在服务器端呈现，并且只有在配置了缓存控制标头时才会被缓存。不能与getStaticProps同时使用 什么时候运行： ​ 仅在服务器端运行，进入界面就会执行。 使用举例： function Page({ data }) { // Render data... } // This gets called on every request export async function getServerSideProps() { // Fetch data from external API const res = await fetch(`https://.../data`) const data = await res.json() // Pass data to the page via props return { props: { data } } } export default Page ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"getStaticProps 什么时候使用： ​ 用户请求之前数据是确定的。 ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"创建项目 npx create-next-app ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"路由 ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"1.可以使用目录直接导航 在pages目录下新建psots文件夹 在./pages/psots下新建文件 first-post.tsx文件 export default function FirstPost() { return ( \u003c\u003e \u003ch1\u003eFirst Post\u003c/h1\u003e \u003c/\u003e ) } 访问http://localhost:3000/posts/first-post即可 ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"2.使用Link导航 href中写明路径即可，以pages目录为跟路径。 import Link from \"next/link\"; \u003cLink href=\"/posts/first-post\"\u003ethis page!\u003c/Link\u003e index.tsx import Head from 'next/head' import Link from \"next/link\"; export default function Home() { return ( \u003c\u003e \u003cHead\u003e \u003ctitle\u003eCreate Next App\u003c/title\u003e \u003cmeta name=\"description\" content=\"Generated by create next app\"/\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/\u003e \u003clink rel=\"icon\" href=\"/favicon.ico\"/\u003e \u003c/Head\u003e Hello Next Read \u003cLink href=\"/posts/first-post\"\u003ethis page!\u003c/Link\u003e \u003c/\u003e ) } /psots/first-post.tsx import Link from \"next/link\"; export default function FirstPost() { return ( \u003c\u003e \u003ch1\u003eFirst Post\u003c/h1\u003e \u003ch2\u003e \u003cLink href=\"/\"\u003e Back to home \u003c/Link\u003e \u003c/h2\u003e \u003c/\u003e ) } ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"3.使用函数导航 const toPost = (id: string) =\u003e { router.push( \"/posts/\" + id, //跳转url \"/posts/\" + id, //在浏览器URL栏中显示的路径 { scroll: true, // 可选布尔值，控制导航后滚动到页面顶部。默认为 true shallow: false, // 更新当前页面的路径而不重新运行 getStaticProps 、 getServerSideProps 或 getInitialProps 。默认为 false locale: \"zh\" // 可选字符串，表示新页面的语言环境 }) } //使用 \u003ca onClick={() =\u003e toPost(id)}\u003e {title} \u003c/a\u003e ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"静态资源 在顶级 public 公共目录下提供静态文件 在public文件夹下有文件next.svg index.tsx,src以public为跟路径 \u003cImage src=\"/next.svg\" alt=\"Next.js Logo\" width={180} height={37} /\u003e ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"图像优化 图片组件 import Image from 'next/image' 本地图片使用 import Image from 'next/image' import profilePic from '../assets/me.png' function Home() { return ( \u003c\u003e \u003cImage src={profilePic} alt=\"Picture of the author\" /\u003e \u003c/\u003e ) } 远程图片必须填写width和height \u003cImage src=\"/me.png\" alt=\"Picture of the author\" width={500} height={500} /\u003e ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"元数据 在pages/index.tsx下Head组件中编写 import Head from 'next/head' \u003cHead\u003e \u003ctitle\u003eCreate Next App\u003c/title\u003e \u003clink rel=\"icon\" href=\"/favicon.ico\"/\u003e \u003c/Head\u003e 如果在其他界面中添加Head组件则会出现覆盖效果，比如在/psots/first-post.tsx中添加Head组件 import Link from \"next/link\"; import Head from \"next/head\"; export default function FirstPost() { return ( \u003c\u003e \u003cHead\u003e \u003ctitle\u003eONE\u003c/title\u003e \u003c/Head\u003e \u003ch1\u003eFirst Post\u003c/h1\u003e \u003ch2\u003e \u003cLink href=\"/\"\u003e Back to home \u003c/Link\u003e \u003c/h2\u003e \u003c/\u003e ) } ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"CSS Module 在跟路径下创建components文件夹用来存放组件 在components文件夹中创建 layout.tsx import React from \"react\"; type Props = { children: React.ReactNode } export default function Layout({children}: Props) { return ( \u003cdiv\u003e{children}\u003c/div\u003e ) } 在 pages/posts/first-post.tsx 中，导入 Layout 并使其成为最外层的组件 import Link from \"next/link\"; import Head from \"next/head\"; import Layout from \"@/components/layout\"; export default function FirstPost() { return ( \u003cLayout\u003e \u003cHead\u003e \u003ctitle\u003eONE\u003c/title\u003e \u003c/Head\u003e \u003ch1\u003eFirst Post\u003c/h1\u003e \u003ch2\u003e \u003cLink href=\"/\"\u003e Back to home \u003c/Link\u003e \u003c/h2\u003e \u003c/Layout\u003e ) } 在components文件夹中创建layout.module.css .container { max-width: 36rem; padding: 0 1rem; margin: 3rem auto 6rem; } 在 layout.tsx中使用css文件 import React from \"react\"; import styles from './layout.module.css' type Props = { children: React.ReactNode } export default function Layout({children}: Props) { return ( \u003cdiv className={styles.container}\u003e{children}\u003c/div\u003e ) } 观察界面效果 ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Global CSS 在 pages 下创建 _app.tsx， App 组件是顶级组件，它将在所有不同的页面中通用，在next.js中只能在pages/_app.tsx中添加全局css import type {AppProps} from 'next/app' export default function App({Component, pageProps}: AppProps) { return ( \u003cComponent {...pageProps} /\u003e ) } 在跟路径下创建styles文件夹 在styles文件夹下创建global.css html, body { padding: 0; margin: 0; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif; line-height: 1.6; font-size: 18px; } * { box-sizing: border-box; } a { color: #0070f3; text-decoration: none; } a:hover { text-decoration: underline; } img { max-width: 100%; display: block; } 在 _app.tsx中引入 import '@/styles/globals.css' 观察页面Link变化 ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"预渲染 可以带来更好的性能和 SEO ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"构建时实现带数据的静态生成 在跟路径下创建posts文件夹 在posts文件夹创建一个md文件 --- title: 'Two Forms of Pre-rendering' date: '2020-01-01' --- Next.js has two forms of pre-rendering: **Static Generation** and **Server-side Rendering**. The difference is in **when** it generates the HTML for a page. - **Static Generation** is the pre-rendering method that generates the HTML at **build time**. The pre-rendered HTML is then _reused_ on each request. - **Server-side Rendering** is the pre-rendering method that generates the HTML on **each request**. Importantly, Next.js lets you **choose** which pre-rendering form to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others. 实现解析文件获取title和date 安装gray-matte解析markdown 文件中的元数据 npm install gray-matter 在跟路径下创建lib文件夹 创建posts.js文件 import fs from 'fs' import path from 'path' import matter from 'gray-matter' const postsDirectory = path.join(process.cwd(), 'posts') export function getSortedPostsData() { // Get file names under /posts const fileNames = fs.readdirSync(postsDirectory) const allPostsData = fileNames.map(fileName =\u003e { // Remove \".md\" from file name to get id const id = fileName.replace(/\\.md$/, '') // Read markdown file as string const fullPath = path.join(postsDirectory, fileName) const fileContents = fs.readFileSync(fullPath, 'utf8') // Use gray-matter to parse the post metadata section const matterResult = matter(fileContents) // Combine the data with the id return { id, ...matterResult.data } }) // Sort posts by date return allPostsData.sort((a, b) =\u003e { if (a.date \u003c b.date) { return 1 } else { return -1 } }) } index.tsx界面处理 import Head from 'next/head' import Layout, {siteTitle} from '../components/layout' import utilStyles from '../styles/utils.module.css' import {getSortedPostsData} from '@/lib/posts' type PostsData = { id: string, date: string, title: string } type AllPostsData = { allPostsData: PostsData[] } export default function Home({allPostsData}: AllPostsData) { return ( \u003cLayout home={true}\u003e \u003cHead\u003e \u003ctitle\u003e{siteTitle}\u003c/title\u003e \u003c/Head\u003e \u003csection className={utilStyles.headingMd}\u003e \u003cp\u003e自我介绍\u003c/p\u003e \u003c/section\u003e \u003csection className={`${utilStyles.headingMd} ${utilStyles.padding1px}`}\u003e \u003ch2 className={utilStyles.headingLg}\u003eBlog\u003c/h2\u003e \u003cul className={utilStyles.list}\u003e {allPostsData.map(({id, date, title}) =\u003e ( \u003cli className={utilStyles.listItem} key={id}\u003e {title} \u003cbr/\u003e {id} \u003cbr/\u003e {date} \u003c/li\u003e ))} \u003c/ul\u003e \u003c/section\u003e \u003c/Layout\u003e ) } export async function getStaticProps() { const allPostsData = getSortedPostsData() return { props: { allPostsData } } } ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:1","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"请求时 使用getServerSideProps ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"动态路由 在目录中或文件中使用[xx]或 [xx].tsx即可通过url访问 多级：[...all].tsx 创建pages/posts/[id].tsx文件， getStaticPaths方法需要返回所有可能有的id的列表 getStaticProps方法需要返回指定id的数据 import Layout from '../../components/layout' export default function Post() { return \u003cLayout\u003e...\u003c/Layout\u003e } export async function getStaticPaths() { } export async function getStaticProps({ params }) { } 在lib/posts.js中添加功能 export function getAllPostIds() { const fileNames = fs.readdirSync(postsDirectory) return fileNames.map(fileName =\u003e { return { params: { id: fileName.replace(/\\.md$/, '') } } }) } 完善pages/posts/[id].tsx中getStaticPaths方法 import { getAllPostIds } from '../../lib/posts' export async function getStaticPaths() { const paths = getAllPostIds() return { paths, fallback: false } } 在lib/posts.js中添加功能 npm install remark remark-html import {remark} from 'remark' import html from 'remark-html' export async function getPostData(id) { const fullPath = path.join(postsDirectory, `${id}.md`) const fileContents = fs.readFileSync(fullPath, 'utf8') // Use gray-matter to parse the post metadata section const matterResult = matter(fileContents) // Use remark to convert markdown into HTML string const processedContent = await remark() .use(html) .process(matterResult.content) const contentHtml = processedContent.toString() // Combine the data with the id and contentHtml return { id, contentHtml, ...matterResult.data } } 完善pages/posts/[id].tsx中getStaticProps方法 export async function getStaticProps({params}: any) { const postData = await getPostData(params.id) return { props: { postData } } } 完善pages/posts/[id].tsx export default function Post({postData}: any) { return ( \u003cLayout home={false}\u003e \u003cHead\u003e \u003ctitle\u003e{postData.title}\u003c/title\u003e \u003c/Head\u003e \u003carticle\u003e \u003ch1 className={utilStyles.headingXl}\u003e{postData.title}\u003c/h1\u003e \u003cdiv className={utilStyles.lightText}\u003e {postData.date} \u003c/div\u003e \u003cdiv dangerouslySetInnerHTML={{ __html: postData.contentHtml }} /\u003e \u003c/article\u003e \u003c/Layout\u003e ) } ","date":"2023-04-05","objectID":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["react","笔记","Next"],"title":"Next.js 学习笔记","uri":"/next.js-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["机器学习"],"content":"llama模型本地Running ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:0:0","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["机器学习"],"content":"代码准备 下载代码 git@github.com:coderabbit214/llama.cpp.git 编译代码 cd llama.cpp make ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:1:0","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["机器学习"],"content":"Python环境准备 本机环境Python 3.10 可以使用 pipenv shell --python 3.10 创建一个环境 安装依赖 pip3 install torch numpy sentencepiece 把模型文件放到当前目录下 ./models/7B/consolidated.00.pth 文件大小应该是13GB 将模型转化为\"ggml FP16 format\" python3 convert-pth-to-ggml.py models/7B/ 1 生成文件： ./models/7B/ggml-model-f16.bin 大小：13GB 将模型转化为4-bits 注意 ：如果是多个模型，例如13B，则需要给每个模型运行命令 ./quantize ./models/13B/ggml-model-f16.bin ./models/13B/ggml-model-q4_0.bin 2 ./quantize ./models/13B/ggml-model-f16.bin.1 ./models/13B/ggml-model-q4_0.bin.1 2 ./quantize ./models/7B/ggml-model-f16.bin ./models/7B/ggml-model-q4_0.bin 2 生成文件： ./models/7B/ggml-model-q4_0.bin 大小：3.9GB ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:2:0","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["机器学习"],"content":"Running ./main -m ./models/7B/ggml-model-q4_0.bin \\ -t 8 \\ -n 128 \\ -p 'The first man on the moon was ' ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:3:0","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["机器学习"],"content":"参数说明 -t:线程数 -n:令牌数 -p:提示 帮助： ./main -h usage: ./main [options] options: -h, --help show this help message and exit -i, --interactive run in interactive mode --interactive-start run in interactive mode and poll user input at startup -r PROMPT, --reverse-prompt PROMPT in interactive mode, poll user input upon seeing PROMPT --color colorise output to distinguish prompt and user input from generations -s SEED, --seed SEED RNG seed (default: -1) -t N, --threads N number of threads to use during computation (default: 4) -p PROMPT, --prompt PROMPT prompt to start generation with (default: random) -f FNAME, --file FNAME prompt file to start generation. -n N, --n_predict N number of tokens to predict (default: 128) --top_k N top-k sampling (default: 40) --top_p N top-p sampling (default: 0.9) --repeat_last_n N last n tokens to consider for penalize (default: 64) --repeat_penalty N penalize repeat sequence of tokens (default: 1.3) --temp N temperature (default: 0.8) -b N, --batch_size N batch size for prompt processing (default: 8) -m FNAME, --model FNAME model path (default: models/llama-7B/ggml-model.bin) ","date":"2023-03-15","objectID":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/:3:1","tags":["llama","cpu","模型","机器学习"],"title":"llama模型本地Running","uri":"/llama%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0running/"},{"categories":["数据库"],"content":"Neo4j实践 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"关于 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"是什么 图形数据库管理系统，是一个高性能、面向对象的数据库系统，用于存储、管理和查询大规模的图形数据。它是一个开源的、ACID兼容的数据库，采用了图形模型来表示数据，这使得它在处理复杂的关系数据方面表现出色。Neo4j是目前最受欢迎的图形数据库之一，它可以被用于许多应用程序领域，包括社交网络、推荐系统、网络安全、生物信息学等。它支持多种编程语言和平台，并且具有良好的可扩展性和高可用性。 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"为什么使用 更适合处理复杂关系型数据：Neo4j采用图形模型来表示数据，可以很好地处理复杂的关系型数据。与传统的关系型数据库相比，Neo4j更加灵活和高效。 更快的查询速度：Neo4j是一个面向对象的数据库系统，它使用了索引和缓存技术来提高查询性能。在查询图形数据时，Neo4j可以使用遍历算法来优化查询性能，从而实现更快的查询速度。 更好的可扩展性：Neo4j可以轻松地扩展到多个节点，可以实现分布式计算，因此可以处理更大的数据集。 更适合处理实时数据：Neo4j是一个内存数据库，支持实时数据处理，适用于实时应用程序和实时数据分析。 更容易理解和使用：Neo4j使用基于图形模型的查询语言Cypher，这种查询语言与现代应用程序的数据结构更加相似，因此更容易理解和使用。 综上所述，如果你需要处理复杂关系型数据，需要更快的查询速度、更好的可扩展性和实时数据处理能力，Neo4j可能是更好的选择。而如果你需要处理传统的关系型数据，或者需要使用SQL查询语言，那么传统的关系型数据库可能更适合你的需求。 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"实践 ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"安装 version: '3' services: neo4j: image: neo4j:4.3.7 volumes: - $PWD/data:/data #把容器内的数据目录挂载到宿主机的对应目录下 - $PWD/logs:/logs #挂载日志目录 - $PWD/conf:/var/lib/neo4j/conf #挂载配置目录 - $PWD/import:/var/lib/neo4j/import #挂载数据导入目录 - $PWD/plugins:/plugins environment: - NEO4J_dbms_memory_heap_maxSize=4G - NEO4J_AUTH=neo4j/123456 #修改默认用户密码 ports: - \"7474:7474\" #映射容器的端口号到宿主机的端口号 - \"7687:7687\" restart: always ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Cypher 简介 用法 CREATE 创建 创建节点，关系和属性 MATCH 匹配 检索有关节点，关系和属性数据 RETURN 返回 返回查询结果 WHERE 哪里 提供条件过滤检索数据 DELETE 删除 删除节点和关系 REMOVE 移除 删除节点和关系的属性 ORDER BY 以…排序 排序检索数据 SET 添加或更新标签 设置属性 LOAD load cv from \"file:///xxx.csv\" as line create (:xiyouRelation (from: line[1],relation:line[3],to: line[0]}) MATCH // 查询某个标签全部节点 match (n:xiyouRelation) return n // 查询所有数量 match (n:xiyouRelation) return count(n) // 条件查询 in,is null match (n:xiyouRelation {from:\"孙悟空\"}) return n match (n:xiyouRelation) where n.from in[\"孙悟空\",\"猪八戒\"] return n //关系查询 [:西游关系*n] n确定层级 0只返回自己 MATCH (n:person {name:'孙悟空'})-[:西游关系*2]-\u003e(b:person) return n,b MATCH (n:person {name:'孙悟空'})\u003c-[:西游关系*2]-(b:person) return n,b // 查询其他参数 // ORDER BY MATCH (n:person {name:'孙悟空'})-[:西游关系*2]-\u003e(b:person) return n,b ORDER BY n.name // LIMIT MATCH (n:person {name:'孙悟空'})-[:西游关系*2]-\u003e(b:person) return n,b LIMIT 10 // SKIP MATCH (n:person {name:'孙悟空'})-[:西游关系*2]-\u003e(b:person) return n,b SKIP 10 CREATE // 创建一个标签为person的节点，节点有一个name属性，属性值为'小红' create (n:person {name:\"小红\"}) return n // 属性设置 match (n:person {name:\"小红\"}) set n.age=18 return n // 给某个标签对外的所有关系增加属性 MATCH p=(person {name:'孙悟空'})-[r:西游关系]-\u003e() SET r={since:\"2017-01-02\"} RETURN p; DELETE // 删除a节点 match (n:person {name:\"小红\"}) delete n //删除关系属性 match (n:person {name:'孙悟空'})-[r:西游关系]-\u003e(m:person) REMOVE r.since ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Springboot 集成 springboot版本 3.0.4 引入依赖 implementation 'org.springframework.boot:spring-boot-starter-data-neo4j' 配置 spring: neo4j: uri: bolt://localhost:7687 authentication: username: neo4j password: 123456 data: neo4j: database: neo4j logging: level: org: springframework: data: neo4j: debug 创建实体 @Data @Node(\"person\") public class Person { @Id @GeneratedValue private Long id; @Property private String name; } Repository @Repository public interface PersonRepository extends Neo4jRepository\u003cPerson, Long\u003e { /** * 根据名称查询 * @param name * @return */ Person findByName(String name); /** * 创建关系 * * @param from * @param relation * @param to */ @Query(\"MATCH (n:person {name:$from}),(m:person {name:$to}) CREATE (n)-[:西游关系{relation:$relation}]-\u003e(m)\") void createRelation(String from, String relation, String to); } 测试 @Test public void testFindAll() { List\u003cPerson\u003e all = personRepository.findAll(); for (Person person : all) { System.out.println(person); } } @Test public void testFindById() { Optional\u003cPerson\u003e person = personRepository.findById(295L); person.ifPresent(System.out::println); } @Test public void testDelete() { personRepository.deleteById(295L); } @Test public void testCreateObject() { Person person = new Person(); person.setName(\"牛魔王\"); Person save = personRepository.save(person); System.out.println(save); } 关系 简单关系 在自身中存储 @Data @Node(\"person\") public class Person { @Id @GeneratedValue private Long id; @Property private String name; @Relationship(type = \"师傅\") public Set\u003cPerson\u003e masters; @Relationship(type = \"师兄\") public Set\u003cPerson\u003e brothers; //指定师傅关系 public void masters(Person person) { if (masters == null) { masters = new HashSet\u003c\u003e(); } masters.add(person); } public void brothers(Person person) { if (brothers == null) { brothers = new HashSet\u003c\u003e(); } brothers.add(person); } public String toString() { return this.name + \" 师傅 =\u003e \" + Optional.ofNullable(this.masters).orElse( Collections.emptySet()).stream().map( Person::getName).collect(Collectors.toList()) + \" 师兄 =\u003e \" + Optional.ofNullable(this.brothers).orElse( Collections.emptySet()).stream().map( Person::getName).collect(Collectors.toList()); } } test @Test public void testCreateRelation() { Person san = new Person(); san.setName(\"张三\"); Person si = new Person(); si.setName(\"李四\"); Person wu = new Person(); wu.setName(\"王武\"); san.masters(si); san.brothers(wu); personRepository.save(san); // 张三 师傅 =\u003e [李四] 师兄 =\u003e [王武] Person name = personRepository.findByName(\"张三\"); System.out.println(name); } 复杂关系(关系中有一些其他属性) 创建关系类 @RelationshipProperties : 指定是一个关系类 @TargetNode : 指定关联对象 @RelationshipProperties @Data public class XiYouRelationPerson { @RelationshipId private Long id; private String relation; @TargetNode private Person property; } 使用 @Data @Node(\"person\") public class Person { @Id @GeneratedValue private Long id; @Property private String name; @Relationship(type = \"西游关系\") public List\u003cXiYouRelationPerson\u003e xiYouRelationPeople; } ","date":"2023-03-11","objectID":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","tags":["Neo4j","图数据库"],"title":"Neo4j实践","uri":"/neo4j-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["go"],"content":"Go-WebAssembly实践 在网页端实现一个json转struct ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:0:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"Hello Word 创建项目目录 Documents/ └── webassembly ├── assets └── cmd ├── server └── wasm 在 webassembly初始化go项目 go mod init teswebassembly 在webassembly/cmd/wasm下创建main.go package main import ( \"fmt\" ) func main() { fmt.Println(\"Go Web Assembly\") } 编译 cd webassembly/cmd/wasm/ GOOS=js GOARCH=wasm go build -o ../../assets/json.wasm 生成了在浏览器中运行的二进制文件 获取wasm_exec.js用来调用json.wasm cp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" webassembly/assets/ 在webassembly/cmd/wasm下创建index.html \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003cscript src=\"wasm_exec.js\"\u003e\u003c/script\u003e \u003cscript\u003e const go = new Go(); WebAssembly.instantiateStreaming(fetch(\"json.wasm\"), go.importObject).then((result) =\u003e { go.run(result.instance); }); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e\u003c/body\u003e \u003c/html\u003e 目前目录 Documents/ └── webassembly ├── assets │ ├── index.html │ ├── json.wasm │ └── wasm_exec.js └── cmd ├── server └── wasm └── main.go └── go.mod 做一个简单服务器用来运行index.html,编译器自带也可以 在webassembly/cmd/server下创建main.go package main import ( \"fmt\" \"net/http\" ) func main() { err := http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\"../../assets\"))) if err != nil { fmt.Println(\"Failed to start server\", err) return } } 运行 cd webassembly/cmd/server/ go run main.go 在控制台中可以看到打印 ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:1:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"功能实现 Json2Go 使用的是 github.com/m-zajac/json2go 在webassembly/cmd/wasm/main.go中添加 添加功能代码 import ( \"github.com/m-zajac/json2go\" ) func Json2Go(input string) string { parser := json2go.NewJSONParser(\"Document\") parser.FeedBytes([]byte(input)) res := parser.String() return res } 将函数暴露到Javascript import ( \"syscall/js\" ) func main() { fmt.Println(\"Go Web Assembly\") js.Global().Set(\"json2Go\", Json2GoWrapper()) //避免 Error: Go program has already exited \u003c-make(chan bool) } func Json2GoWrapper() js.Func { jsonFunc := js.FuncOf(func(this js.Value, args []js.Value) any { if len(args) != 1 { return \"Invalid no of arguments passed\" } inputJSON := args[0].String() res := Json2Go(inputJSON) return res }) return jsonFunc } syscall/js 编译器报错设置 编写ui \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003cscript src=\"wasm_exec.js\"\u003e\u003c/script\u003e \u003cscript\u003e const go = new Go(); WebAssembly.instantiateStreaming(fetch(\"json.wasm\"), go.importObject).then((result) =\u003e { go.run(result.instance); }); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ctextarea id=\"jsoninput\" name=\"jsoninput\" cols=\"80\" rows=\"20\"\u003e\u003c/textarea\u003e \u003cinput id=\"button\" type=\"submit\" name=\"button\" value=\"pretty json\" onclick=\"json(jsoninput.value)\"/\u003e \u003ctextarea id=\"jsonoutput\" name=\"jsonoutput\" cols=\"80\" rows=\"20\"\u003e\u003c/textarea\u003e \u003c/body\u003e \u003cscript\u003e var json = function (input) { jsonoutput.value = json2Go(input) } \u003c/script\u003e \u003c/html\u003e 测试 ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:2:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"DOM操作 修改webassembly/cmd/wasm/main.go中Json2GoWrapper方法 func Json2GoWrapper() js.Func { jsonfunc := js.FuncOf(func(this js.Value, args []js.Value) any { if len(args) != 1 { result := map[string]any{ \"error\": \"Invalid no of arguments passed\", } return result } jsDoc := js.Global().Get(\"document\") if !jsDoc.Truthy() { result := map[string]any{ \"error\": \"Invalid no of arguments passed\", } return result } jsonOuputTextArea := jsDoc.Call(\"getElementById\", \"jsonoutput\") if !jsonOuputTextArea.Truthy() { result := map[string]any{ \"error\": \"Invalid no of arguments passed\", } return result } inputJSON := args[0].String() res := Json2Go(inputJSON) jsonOuputTextArea.Set(\"value\", res) return nil }) return jsonfunc } 修改webassembly/assets/index.html \u003cscript\u003e var json = function (input) { var result = json2Go(input) if (( result != null) \u0026\u0026 ('error' in result)) { console.log(\"Go return value\", result) jsonoutput.value = \"\" alert(result.error) } // jsonoutput.value = json2Go(input) } \u003c/script\u003e ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:3:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"错误处理 由于js无法处理error类型，对应表：https://pkg.go.dev/syscall/js#ValueOf 所以错误处理返回map[string]interface{} result := map[string]any{ \"error\": \"error message\", } ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:4:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"Json参数传递 index.html \u003cscript\u003e var json = function (input) { jsonoutput.value = json2Go({\"json\": input}) } \u003c/script\u003e Go接收 func Json2GoWrapper() js.Func { jsonFunc := js.FuncOf(func(this js.Value, args []js.Value) any { if len(args) != 1 { return \"Invalid no of arguments passed\" } inputJSON := args[0].Get(\"json\").String() res := Json2Go(inputJSON) return res }) return jsonFunc } ","date":"2023-02-06","objectID":"/go-webassembly-%E5%AE%9E%E8%B7%B5/:5:0","tags":["go","WebAssembly"],"title":"Go WebAssembly 实践","uri":"/go-webassembly-%E5%AE%9E%E8%B7%B5/"},{"categories":["go"],"content":"gin基础 ","date":"2022-11-13","objectID":"/gin/:0:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"HelloWord func main() { // 1.创建路由 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 2.绑定路由规则，执行的函数 // gin.Context，封装了request和response r.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") }) // 监听端口，默认在8080 // Run(\"里面不指定端口号默认为8080\") r.Run(\":8000\") } ","date":"2022-11-13","objectID":"/gin/:1:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"请求接收 ","date":"2022-11-13","objectID":"/gin/:2:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"路由参数 : 匹配一个 * 匹配0个或多个 127.0.0.1:8888/user/1/1234 匹配 127.0.0.1:8888/user/1/1234/1234 匹配 127.0.0.1:8888/user/1 匹配 //api 参数 Param 方法 r.GET(\"/user/:name/*action\", func(c *gin.Context) { name := c.Param(\"name\") action := c.Param(\"action\") //截取/ action = strings.Trim(action, \"/\") c.String(http.StatusOK, name+\" is \"+action) }) ","date":"2022-11-13","objectID":"/gin/:2:1","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"URL参数 DefaultQuery : 获取不到取默认值 Query : 获取参数 127.0.0.1:8888/user?action=1234 //url参数 DefaultQuery Query r.GET(\"/user\", func(c *gin.Context) { name := c.DefaultQuery(\"name\", \"哈哈哈\") action := c.Query(\"action\") c.String(http.StatusOK, name+\" is \"+action) }) ","date":"2022-11-13","objectID":"/gin/:2:2","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"表单参数 //表单参数 表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencoded或from-data格式的参数 r.POST(\"/form\", func(c *gin.Context) { types := c.DefaultPostForm(\"type\", \"post\") username := c.PostForm(\"username\") password := c.PostForm(\"userpassword\") c.String(http.StatusOK, fmt.Sprintf(\"username:%s,password:%s,type:%s\", username, password, types)) }) ","date":"2022-11-13","objectID":"/gin/:2:3","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"JSON参数 //json参数 // 定义接收数据的结构体 type Login struct { // binding:\"required\"修饰的字段，若接收为空值，则报错，是必须字段 // form：表单 // json：json // uri：url参数 User string `form:\"username\" json:\"user\" uri:\"user\" xml:\"user\" binding:\"required\"` Password string `form:\"password\" json:\"password\" uri:\"password\" xml:\"password\" binding:\"required\"` } //数据绑定 r.POST(\"/loginJSON\", func(c *gin.Context) { // 声明接收的变量 var json Login // c.ShouldBindJSON 将request的body中的数据，自动按照json格式解析到结构体 // c.ShouldBindUri 解析url参数 // c.Bind Bind()默认解析并绑定form格式 根据请求头中content-type自动推断 if err := c.Bind(\u0026json); err != nil { // 返回错误信息 // gin.H封装了生成json数据的工具 c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) return } // 判断用户名密码是否正确 if json.User != \"root\" || json.Password != \"admin\" { c.JSON(http.StatusBadRequest, gin.H{\"status\": \"304\"}) return } c.JSON(http.StatusOK, gin.H{\"status\": \"200\"}) }) ","date":"2022-11-13","objectID":"/gin/:2:4","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"文件上传 //文件上传大小限制 单位k r.MaxMultipartMemory = 8 \u003c\u003c 20 //单文件上传 r.POST(\"/upload\", func(c *gin.Context) { file, err := c.FormFile(\"file\") if err != nil { c.String(500, \"上传图片出错\") } //文件存储 c.SaveUploadedFile(file, \"/Users/mr_j/\"+file.Filename) c.String(http.StatusOK, file.Filename) }) //多文件 r.POST(\"/uploadBatch\", func(c *gin.Context) { form, err := c.MultipartForm() if err != nil { c.String(http.StatusBadRequest, fmt.Sprintf(\"get err %s\", err.Error())) } // 获取所有图片 files := form.File[\"files\"] // 遍历所有图片 for _, file := range files { // 逐个存 if err := c.SaveUploadedFile(file, \"/Users/mr_j/\"+file.Filename); err != nil { c.String(http.StatusBadRequest, fmt.Sprintf(\"upload err %s\", err.Error())) return } } c.String(200, fmt.Sprintf(\"upload ok %d files\", len(files))) }) ","date":"2022-11-13","objectID":"/gin/:2:5","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"响应 ","date":"2022-11-13","objectID":"/gin/:3:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"JSON r.GET(\"/someJSON\", func(c *gin.Context) { c.JSON(200, gin.H{\"message\": \"someJSON\", \"status\": 200}) }) ","date":"2022-11-13","objectID":"/gin/:3:1","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"结构体 r.GET(\"/someStruct\", func(c *gin.Context) { var msg struct { Name string Message string Number int } //是否可以添加构造方法 msg.Name = \"root\" msg.Message = \"message\" msg.Number = 123 c.JSON(200, msg) }) ","date":"2022-11-13","objectID":"/gin/:3:2","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"其他 // 3.XML r.GET(\"/someXML\", func(c *gin.Context) { c.XML(200, gin.H{\"message\": \"abc\"}) }) // 4.YAML响应 r.GET(\"/someYAML\", func(c *gin.Context) { c.YAML(200, gin.H{\"name\": \"zhangsan\"}) }) // 5.protobuf格式,谷歌开发的高效存储读取的工具 // 数组？切片？如果自己构建一个传输格式，应该是什么格式？ r.GET(\"/someProtoBuf\", func(c *gin.Context) { reps := []int64{int64(1), int64(2)} // 定义数据 label := \"label\" // 传protobuf格式数据 data := \u0026protoexample.Test{ Label: \u0026label, Reps: reps, } c.ProtoBuf(200, data) }) ","date":"2022-11-13","objectID":"/gin/:3:3","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"路由拆分 ","date":"2022-11-13","objectID":"/gin/:4:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"同文件拆分 func main() { r := gin.Default() //路由分组 // 路由组1 ，处理GET请求 v1 := r.Group(\"/v1\") // {} 是书写规范 { v1.GET(\"/login\", login) v1.GET(\"/submit\", submit) } v2 := r.Group(\"/v2\") { v2.POST(\"/login\", login) v2.POST(\"/submit\", submit) } // 监听端口，默认在8080 // Run(\"里面不指定端口号默认为8080\") r.Run(\":8000\") } func login(c *gin.Context) { name := c.DefaultQuery(\"name\", \"jack\") c.String(200, fmt.Sprintf(\"hello %s\\n\", name)) } func submit(c *gin.Context) { name := c.DefaultQuery(\"name\", \"lily\") c.String(200, fmt.Sprintf(\"hello %s\\n\", name)) } ","date":"2022-11-13","objectID":"/gin/:4:1","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"单独拆分路由文件 ./main.go func main() { r := setupRouter() if err := r.Run(\":8000\"); err != nil { fmt.Printf(\"startup service failed, err:%v\\n\", err) } } ./routers.go func helloHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello www.topgoer.com!\", }) } func setupRouter() *gin.Engine { r := gin.Default() r.GET(\"/topgoer\", helloHandler) return r } ","date":"2022-11-13","objectID":"/gin/:4:2","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"按照包拆分路由文件 ./main.go package main // 按照包拆分路由文件 func main() { r := routers.SetupRouter() if err := r.Run(\":8000\"); err != nil { fmt.Printf(\"startup service failed, err:%v\\n\", err) } } ./routers/routers.go package routers func helloHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello www.topgoer.com!\", }) } func SetupRouter() *gin.Engine { r := gin.Default() r.GET(\"/topgoer\", helloHandler) return r } ","date":"2022-11-13","objectID":"/gin/:4:3","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"路由拆分成多个文件 ./main.go package main // 路由拆分成多个文件 func main() { r := gin.Default() //加载路由 routers.LoadUser(r) routers.LoadBlog(r) if err := r.Run(\":8000\"); err != nil { fmt.Printf(\"startup service failed, err:%v\\n\", err) } } ./routers/user.go package routers func LoadUser(e *gin.Engine) { loadUser := e.Group(\"/user\") { loadUser.GET(\"/:id\", getById) loadUser.DELETE(\"/:id\", deleteById) } } func deleteById(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") } func getById(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") } ./routers/blog.go package routers func LoadBlog(e *gin.Engine) { loadBlog := e.Group(\"/blog\") { loadBlog.GET(\"/:id\", getBlogById) loadBlog.DELETE(\"/:id\", deleteBlogById) } } func getBlogById(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") } func deleteBlogById(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") } ","date":"2022-11-13","objectID":"/gin/:4:4","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"中间件 // MiddleWare 定义 func MiddleWare() gin.HandlerFunc { return func(c *gin.Context) { fmt.Println(\"中间件开始执行了\") req := c.Query(\"request\") // 设置变量到Context的key中，可以通过Get()取 c.Set(\"request\", \"成功\") if req == \"1\" { //执行处理 c.Next() } else { c.JSON(500, gin.H{\"error\": req}) //不执行处理 但是这个中间件中代码会执行完 c.Abort() } fmt.Println(\"返回时执行\") } } func main() { // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 注册中间件 r.Use(MiddleWare()) // {}为了代码规范 { r.GET(\"/ce\", func(c *gin.Context) { // 取值 req, _ := c.Get(\"request\") fmt.Println(\"request:\", req) // 页面接收 c.JSON(200, gin.H{\"request\": req}) }) } r.Run() } ","date":"2022-11-13","objectID":"/gin/:5:0","tags":["gin","go"],"title":"gin基础","uri":"/gin/"},{"categories":["go"],"content":"gRPC ","date":"2022-11-13","objectID":"/grpc/:0:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"环境准备 brew install grpc brew install protobuf brew install protoc-gen-go brew install protoc-gen-go-grpc ","date":"2022-11-13","objectID":"/grpc/:1:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"HelloWord 创建文件./pb/hello_grpc.proto syntax = \"proto3\"; package hello_grpc; option go_package = \"./;hello_grpc\"; message Req { string message = 1; } message Res { string message = 1; } service HelloGRPC { rpc SayHi(Req) returns (Res); } 生成文件 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative ./pb/hello_grpc.proto 创建服务端文件./server/main.go package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"net\" hello_grpc2 \"test/grpc/01hello_word/pb\" ) //1.取出server //2.挂载方法 //3.注册服务 //4.创建监听 // 1取出server type server struct { hello_grpc2.UnimplementedHelloGRPCServer } // SayHi 2挂载方法 func (s *server) SayHi(ctx context.Context, req *hello_grpc2.Req) (res *hello_grpc2.Res, err error) { fmt.Println(req.GetMessage()) return \u0026hello_grpc2.Res{Message: \"我是从服务端返回的信息\"}, nil } func main() { // 3注册服务 listen, err := net.Listen(\"tcp\", \":8888\") if err != nil { fmt.Println(\"net.Listen err:\", err) return } defer listen.Close() s := grpc.NewServer() hello_grpc2.RegisterHelloGRPCServer(s, \u0026server{}) // 4创建监听 s.Serve(listen) } 创建客户端文件./client/main.go package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" hello_grpc2 \"test/grpc/01hello_word/pb\" ) //1.创建链接 //2.new client //3.调用client //4.获取返回值 func main() { dial, err := grpc.Dial(\"127.0.0.1:8888\", grpc.WithInsecure()) if err != nil { fmt.Println(\"grpc.Dial err:\", err) } defer dial.Close() client := hello_grpc2.NewHelloGRPCClient(dial) hi, err := client.SayHi(context.Background(), \u0026hello_grpc2.Req{Message: \"我从客户端来\"}) if err != nil { fmt.Println(\"client.SayHi err:\", err) } fmt.Println(hi.GetMessage()) } 测试 ","date":"2022-11-13","objectID":"/grpc/:2:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"proto文件详解 ","date":"2022-11-13","objectID":"/grpc/:3:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"目录格式 ","date":"2022-11-13","objectID":"/grpc/:3:1","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"基本格式 syntax = \"proto3\"; //告诉编辑器 用 proto3 解读 package person; //包名 // go_package= \"包路径(从mod下开始写);别名\" option go_package = \"test/grpc/02proto/pb/person;person\"; //引入 import \"home/home.proto\"; //类似结构体 信息传递的媒介 message Person{ } //定义服务 请求返回定义 service SearchService { //即时响应 rpc Search(Person) returns (Person); } ","date":"2022-11-13","objectID":"/grpc/:3:2","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"message //类似结构体 message Person{ // 类型 名称 = 唯一标识; string name = 1; int32 age = 2; // bool sex = 3; //数组 切片 repeated string test = 4; //map map\u003cstring, string\u003e test_map = 5; //枚举 必须要有0 enum SEX { //如果有的值需要一样则需要设置 option allow_alias = true; MAN = 0; WOMAN = 1; GIRL = 1; OTHER = 2; } SEX sex = 3; //不同类型相同名称使用 oneof TestOneOf{ string one = 6; string two = 7; string three = 8; } home.Home i_home = 9; //设置保留关键字 不允许定义 // reserved \"test_map\",\"test\"; // reserved 2; } //message 嵌套 message Home{ repeated Person persons = 1; //定义 message V { string name = 1; } //声明 V v = 2; } oneof 使用说明 proto //省略前边 message Person { oneof TestOneOf{ string one = 6; string two = 7; string three = 8; } } service SearchService { rpc Search(Person) returns (Person); } server func (s *spaceServer) Search(context context.Context, req *space.SpaceReq) (res *space.SpaceRes, err error) { name := req.GetName() fmt.Println(name) oneOf := req.TestOneOf switch v := oneOf.(type) { case *space.SpaceReq_One: fmt.Println(v.One) case *space.SpaceReq_Two: fmt.Println(v.Two) case *space.SpaceReq_Three: fmt.Println(v.Three) } res = \u0026space.SpaceRes{ Name: \"服务端\", } return res, nil } client dial, err := grpc.Dial(\"127.0.0.1:8888\", grpc.WithInsecure()) if err != nil { fmt.Println(\"grpc.Dial err:\", err) } defer dial.Close() client := space.NewSearchServiceClient(dial) //及时相应 var p = space.SpaceReq{Name: \"asdf\", TestOneOf: \u0026space.SpaceReq_One{One: \"asdfasdf\"}} hi, err := client.Search(context.Background(), \u0026p) if err != nil { fmt.Println(\"client.SayHi err:\", err) } fmt.Println(hi.GetName()) ","date":"2022-11-13","objectID":"/grpc/:3:3","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"import引入其他proto 创建需要引入的proto./pb/home/home.proto syntax = \"proto3\"; //告诉编辑器 用 proto3 解读 package home; //包名 // go_package= \"包路径(从mod下开始写);别名\" option go_package = \"test/grpc/02proto/pb/home;home\"; message Home{ string name = 1; } 在需要引入文件中引入 //引入 import \"home/home.proto\"; message Person { //使用 home.Home i_home = 9; } 编译 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative ./person/person.proto protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative ./home/home.proto ","date":"2022-11-13","objectID":"/grpc/:3:4","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"service 使用 space包下文件 proto./pb/space/space.proto syntax = \"proto3\"; package space; option go_package = \"test/grpc/02proto/pb/space;space\"; message SpaceReq{ string name = 1; } message SpaceRes{ string name = 1; } //定义服务 service SearchService { //即时响应 rpc Search(SpaceReq) returns (SpaceRes); //入参为流 rpc SearchIn(stream SpaceReq) returns (SpaceRes); //相应为流 rpc SearchOut(SpaceReq) returns (stream SpaceRes); //出入都为流 rpc SearchIO(stream SpaceReq) returns (stream SpaceRes); } service package main import ( \"context\" \"fmt\" \"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\" \"google.golang.org/grpc\" \"net\" \"net/http\" \"test/grpc/02proto/pb/space\" ) type spaceServer struct { space.UnimplementedSearchServiceServer } func (s *spaceServer) Search(context context.Context, req *space.SpaceReq) (res *space.SpaceRes, err error) { name := req.GetName() fmt.Println(name) res = \u0026space.SpaceRes{ Name: \"服务端\", } return res, nil } func (s *spaceServer) SearchIn(server space.SearchService_SearchInServer) error { for { req, err := server.Recv() //传输结束 if err != nil { server.SendAndClose(\u0026space.SpaceRes{Name: \"完成了\"}) break } fmt.Println(req) } return nil } func (s *spaceServer) SearchOut(req *space.SpaceReq, server space.SearchService_SearchOutServer) error { name := req.Name fmt.Println(name) for i := 0; i \u003c 10; i++ { server.Send(\u0026space.SpaceRes{Name: \"服务端\"}) } return nil } func (s *spaceServer) SearchIO(server space.SearchService_SearchIOServer) error { strChan := make(chan string, 1) go func() { for { recv, err := server.Recv() if err != nil { fmt.Println(err) strChan \u003c- \"结束\" break } fmt.Println(recv) strChan \u003c- recv.Name } }() for { name := \u003c-strChan if \"结束\" == name { break } server.Send(\u0026space.SpaceRes{Name: name}) } return nil } func main() { listen, err := net.Listen(\"tcp\", \":8888\") if err != nil { fmt.Println(\"net.Listen err\", err) return } s := spaceServer{} server := grpc.NewServer() space.RegisterSearchServiceServer(server, \u0026s) server.Serve(listen) } client package main import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"sync\" \"test/grpc/02proto/pb/space\" ) func main() { dial, err := grpc.Dial(\"127.0.0.1:8888\", grpc.WithInsecure()) if err != nil { fmt.Println(\"grpc.Dial err:\", err) } defer dial.Close() client := space.NewSearchServiceClient(dial) //及时相应 //var p = space.SpaceReq{Name: \"asdf\", TestOneOf: \u0026space.SpaceReq_One{One: \"asdfasdf\"}} //hi, err := client.Search(context.Background(), \u0026p) //if err != nil { // fmt.Println(\"client.SayHi err:\", err) //} //fmt.Println(hi.GetName()) //输入为流 //c, _ := client.SearchIn(context.Background()) //for i := 0; i \u003c 10; i++ { // c.Send(\u0026space.SpaceReq{Name: \"哈哈哈\"}) // time.Sleep(1 * time.Second) //} //recv, _ := c.CloseAndRecv() //fmt.Println(recv) //输出为流 //out, _ := client.SearchOut(context.Background(), \u0026space.SpaceReq{Name: \"1324\"}) //for { // recv, err := out.Recv() // if err != nil { // fmt.Println(err) // break // } // fmt.Println(recv) //} //输入输出为流 group := sync.WaitGroup{} group.Add(1) io, _ := client.SearchIO(context.Background()) go func() { for { recv, err2 := io.Recv() if err2 != nil { fmt.Println(err2) group.Done() break } fmt.Println(\"服务端返回：\", recv) } }() for i := 0; i \u003c 10; i++ { err := io.Send(\u0026space.SpaceReq{Name: \"1324\"}) if err != nil { fmt.Println(err) break } } io.CloseSend() group.Wait() } ","date":"2022-11-13","objectID":"/grpc/:3:5","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"grpc-gateway ","date":"2022-11-13","objectID":"/grpc/:4:0","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"安装插件 go install \\ github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway ","date":"2022-11-13","objectID":"/grpc/:4:1","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"代码编写 proto service SearchService { //即时响应 rpc Search(SpaceReq) returns (SpaceRes){ option(google.api.http) = { post:\"/api/space\", body:\"*\" }; }; } 编译 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative --grpc-gateway_out . --grpc-gateway_opt paths=source_relative ./space/space.proto server func main() { go registerGetaway() listen, err := net.Listen(\"tcp\", \":8888\") if err != nil { fmt.Println(\"net.Listen err\", err) return } s := spaceServer{} server := grpc.NewServer() space.RegisterSearchServiceServer(server, \u0026s) server.Serve(listen) } //具体实现 func registerGetaway() { mux := runtime.NewServeMux() conn, _ := grpc.DialContext( context.Background(), \"127.0.0.1:8888\", grpc.WithBlock(), grpc.WithInsecure(), ) gwServer := \u0026http.Server{ Handler: mux, Addr: \":8090\", } space.RegisterSearchServiceHandler(context.Background(), mux, conn) gwServer.ListenAndServe() } 发送post请求测试 ","date":"2022-11-13","objectID":"/grpc/:4:2","tags":["gRPC","go"],"title":"gRPC","uri":"/grpc/"},{"categories":["go"],"content":"Go使用cobra构建命令行工具 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:0:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"安装CLI go install github.com/spf13/cobra-cli@latest ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:1:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"创建项目并引入依赖 # 创建go项目 mkdir my_command cd my_command go mod init my_command # 使用cobra-cli初始化项目 cobra-cli init ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:2:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"测试 go build main.go main root ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:3:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"开发 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:0","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"命令 # 添加命令 cobra-cli add version 添加后在cmd下生成一个新的文件 version.go 文件内容略微修改后如下 /* Copyright © 2022 NAME HERE \u003cEMAIL ADDRESS\u003e */ package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) // versionCmd represents the version command var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"一个简短介绍\", Long: `一个长介绍`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version命令操作\") }, } func init() { rootCmd.AddCommand(versionCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // versionCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\") // Cobra supports local flags which will only run when this command // is called directly, e.g.: // versionCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } 执行命令 接受参数 存储在 args中 ... var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"一个简短介绍\", Long: `一个长介绍`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version命令操作\") fmt.Println(args) }, } ... ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:1","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"flag 局部flag 定义变量 /* 定义局部变量 */ var all string 在对应文件的init方法中添加flag versionCmd.Flags().StringVarP(\u0026all, \"all\", \"a\", \"这是默认值\", \"这是一条介绍\") 使用 在run方法中 fmt.Println(\"a参数：\"+all) 完整代码 /* Copyright © 2022 NAME HERE \u003cEMAIL ADDRESS\u003e */ package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) /* 定义局部变量 */ var all string // versionCmd represents the version command var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"一个简短介绍\", Long: `一个长介绍`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version命令操作\") fmt.Println(args) fmt.Println(\"a参数：\"+all) }, } func init() { rootCmd.AddCommand(versionCmd) versionCmd.Flags().StringVarP(\u0026all, \"all\", \"a\", \"这是默认值\", \"这是一条介绍\") //是否必填 默认可以不填 versionCmd.MarkFlagRequired(\"all\") } 演示 全局flag 在root中编写，代码与局部flag相同 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:2","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"嵌套命令 cobra-cli add -p \"父命令Cmd\" # 举例 cobra-cli add show -p \"versionCmd\" 使用 代码解释 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:3","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["go"],"content":"获取命令行参数 常用 MinimumNArgs(int) 当参数数目低于配置的最小参数个数时报错 MaximumNArgs(int) 当参数数目大于配置的最大参数个数时报错 ExactArgs(int) 如果参数数目不是配置的参数个数时报错 NoArgs 没有参数则报错 使用 ... var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"一个简短介绍\", Long: `一个长介绍`, Args: cobra.ExactArgs(1), Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version命令操作\") fmt.Println(args) fmt.Println(\"a参数：\"+all) }, } ... 测试 ","date":"2022-09-29","objectID":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/:4:4","tags":["go","命令行"],"title":"Go使用cobra构建命令行工具","uri":"/go%E4%BD%BF%E7%94%A8cobra%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"categories":["云原生"],"content":"Kubernetes ","date":"2022-07-13","objectID":"/kubernetes/:0:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"命令 # 查看节点状态 kubectl get nodes # ---后缀--- -oyaml 获取yaml # ---pod--- # 创建pod kubectl run mynginx --image=nginx # 跟根据yaml添加pod kubectl apply -f calico.yaml # 查看default名称空间的Pod kubectl get pod watch -n 1 kubectl get pods #使用标签检索Pod kubectl get pod -l app=my-dep # 查看集群部署了哪些应 kubectl get pods -A # 根据命名空间 kubectl get pods -n kubernetes-dashboard # 描述(可以看到具体执行以及在哪个节点上运行) kubectl describe pod 你自己的Pod名字 # 删除 kubectl delete pod Pod名字 # 查看Pod的运行日志 kubectl logs Pod名字 # 获取详细信息 kubectl get pod -owide # 进入容器内部 kubectl exec -it myapp -- /bin/bash # ---命名空间--- # 查看命名空间 kubectl get ns # 创建命名空间 kubectl create ns a # 删除命名空间 kubectl delete ns a # ---deployment--- # 创建 kubectl create deployment mytomcat --image=tomcat:8.5.68 # 查看 kubectl get deploy # 删除 kubectl delete deploy mytomcat # 修改 kubectl edit deployment my-dep # 多副本 --replicas=3 kubectl create deployment my-dep --image=nginx --replicas=3 # 扩缩容 kubectl scale --replicas=5 deployment/my-dep # 版本更新 kubectl set image deployment/my-dep nginx=nginx:1.16.1 --record kubectl set image deployment/[deployment名字] [容器名字]=nginx:1.16.1 --record # 查看容器名字 kubectl get deploy -oyaml # --版本回退-- # 查看状态 kubectl rollout status deployment/my-dep # 历史记录 kubectl rollout history deployment/my-dep # 查看某个历史详情 kubectl rollout history deployment/my-dep --revision=2 # 回滚(回到上次) kubectl rollout undo deployment/my-dep # 回滚(回到指定版本) kubectl rollout undo deployment/my-dep --to-revision=2 # service,ingress 等资源都是可以用get，edit，-oyaml等命令 ","date":"2022-07-13","objectID":"/kubernetes/:1:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"yaml快速编写 使用kubectl create生成yaml文件 # 生成文件内容到控制台 kubectl create deployment web --image=nginx -o yaml --dry-run # 输出内容到文件 kubectl create deployment web --image=nginx -o yaml --dry-run \u003e my.yaml 使用kubectl get命令导出yaml文件 kubectl get deploy nginx -o=yaml --export \u003e my2.yaml ","date":"2022-07-13","objectID":"/kubernetes/:2:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"定义 服务发现和负载均衡 Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。 存储编排 Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。 自动部署和回滚 你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。 自动完成装箱计算 Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。 自我修复 Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。 密钥与配置管理 Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 ","date":"2022-07-13","objectID":"/kubernetes/:3:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"架构 ","date":"2022-07-13","objectID":"/kubernetes/:3:1","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"工作方式 Kubernetes Cluster = N Master Node + N Worker Node：N主节点+N工作节点； N\u003e=1 ","date":"2022-07-13","objectID":"/kubernetes/:3:2","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"组件架构 ","date":"2022-07-13","objectID":"/kubernetes/:4:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"控制平面组件（Control Plane Components） 控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 replicas 字段时，启动新的 pod）。 控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅使用 kubeadm 构建高可用性集群 中关于多 VM 控制平面设置的示例。 kube-apiserver API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。 Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。 etcd etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。 您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。 要了解 etcd 更深层次的信息，请参考 etcd 文档。 kube-scheduler 控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。 调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。 kube-controller-manager 在主节点上运行 控制器 的组件。 从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应 任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod) 服务帐户和令牌控制器（Service Account \u0026 Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌 cloud-controller-manager 云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器允许您链接集群到云提供商的应用编程接口中， 并把和该云平台交互的组件与只和您的集群交互的组件分离开。 cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。 与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。 下面的控制器都包含对云平台驱动的依赖： 节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除 路由控制器（Route Controller）: 用于在底层云基础架构中设置路由 服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器 ","date":"2022-07-13","objectID":"/kubernetes/:4:1","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Node 组件 节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。 kubelet 一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。 kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。 kube-proxy kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。 kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。 如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。 ","date":"2022-07-13","objectID":"/kubernetes/:4:2","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"kubeadm创建集群 ","date":"2022-07-13","objectID":"/kubernetes/:5:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"环境准备 配置yum源 sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo Docker安装 sudo yum install -y docker-ce docker-ce-cli containerd.io sudo yum remove docker* yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6 # 启动 systemctl enable docker --now # 配置加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://lu9qvzo1.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker linux设置 一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux 发行版以及一些不提供包管理器的发行版提供通用的指令 每台机器 2 GB 或更多的 RAM （如果少于这个数字将会影响你应用的运行内存) 2 CPU 核或更多 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以) 设置防火墙放行规则 节点之中不可以有重复的主机名、MAC 地址或 product_uuid。请参见这里了解更多详细信息。 设置不同hostname 开启机器上的某些端口。请参见这里 了解更多详细信息。 内网互信 禁用交换分区。为了保证 kubelet 正常工作，你 必须 禁用交换分区。 永久关闭 #各个机器设置自己的域名 hostnamectl set-hostname xxxx # 将 SELinux 设置为 permissive 模式（相当于将其禁用） sudo setenforce 0 sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config #关闭swap swapoff -a sed -ri 's/.*swap.*/#\u0026/' /etc/fstab #允许 iptables 检查桥接流量 cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system ","date":"2022-07-13","objectID":"/kubernetes/:5:1","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"安装kubelet、kubeadm、kubectl（每台服务器） cat \u003c\u003cEOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes sudo systemctl enable --now kubelet 查看kubelet状态 systemctl status kubelet ","date":"2022-07-13","objectID":"/kubernetes/:5:2","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"使用kubeadm引导集群 下载各个机器需要的镜像 sudo tee ./images.sh \u003c\u003c-'EOF' #!/bin/bash images=( kube-apiserver:v1.20.9 kube-proxy:v1.20.9 kube-controller-manager:v1.20.9 kube-scheduler:v1.20.9 coredns:1.7.0 etcd:3.4.13-0 pause:3.2 ) for imageName in ${images[@]} ; do docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageName done EOF chmod +x ./images.sh \u0026\u0026 ./images.sh 初始化主节点 #所有机器添加master域名映射，以下需要修改为自己的 echo \"172.16.1.3 cluster-endpoint\" \u003e\u003e /etc/hosts #主节点初始化 kubeadm init \\ --apiserver-advertise-address=172.16.1.3 \\ --control-plane-endpoint=cluster-endpoint \\ --image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \\ --kubernetes-version v1.20.9 \\ --service-cidr=10.96.0.0/16 \\ --pod-network-cidr=192.168.0.0/16 #所有网络范围不重叠 成功后提示 Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ You can now join any number of control-plane nodes by copying certificate authorities and service account keys on each node and then running the following as root: kubeadm join cluster-endpoint:6443 --token 9o3q1b.z2sxmoppiqf9yh5j \\ --discovery-token-ca-cert-hash sha256:f5cee157412f35851006863d1d26478ae692c3eaa03486604c4493118e47d39a \\ --control-plane Then you can join any number of worker nodes by running the following on each as root: kubeadm join cluster-endpoint:6443 --token 9o3q1b.z2sxmoppiqf9yh5j \\ --discovery-token-ca-cert-hash sha256:f5cee157412f35851006863d1d26478ae692c3eaa03486604c4493118e47d39a 根据提示操作 创建 .kube mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 配置网络插件 # 注意版本 curl https://docs.projectcalico.org/manifests/calico.yaml -O curl https://docs.projectcalico.org/v3.18/manifests/calico.yaml -O kubectl apply -f calico.yaml 在其他节点加入 新令牌 kubeadm token create –print-join-command master kubeadm join cluster-endpoint:6443 --token 9o3q1b.z2sxmoppiqf9yh5j \\ --discovery-token-ca-cert-hash sha256:f5cee157412f35851006863d1d26478ae692c3eaa03486604c4493118e47d39a \\ --control-plane node kubeadm join cluster-endpoint:6443 --token 9o3q1b.z2sxmoppiqf9yh5j \\ --discovery-token-ca-cert-hash sha256:f5cee157412f35851006863d1d26478ae692c3eaa03486604c4493118e47d39a 验证 kubectl get nodes ","date":"2022-07-13","objectID":"/kubernetes/:5:3","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"部署dashboard 启动 curl https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml -O kubectl apply -f recommended.yaml 设置访问端口 # type: ClusterIP 改为 type: NodePort kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard ## 找到端口，在安全组放行 kubectl get svc -A |grep kubernetes-dashboard 创建访问账号 #创建访问账号，准备一个yaml文件； vi dash.yaml apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard kubectl apply -f dash.yaml 获取访问令牌 kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=\"{.secrets[0].name}\") -o go-template=\"{{.data.token | base64decode}}\" 隐私错误 ，直接输入thisisunsafe ","date":"2022-07-13","objectID":"/kubernetes/:5:4","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"安装文件系统 安装nfs # 在每个机器。 yum install -y nfs-utils # 在master 执行以下命令 echo \"/nfs/data/ *(insecure,rw,sync,no_root_squash)\" \u003e /etc/exports # 执行以下命令，启动 nfs 服务;创建共享目录 mkdir -p /nfs/data # 在master执行 systemctl enable rpcbind systemctl enable nfs-server systemctl start rpcbind systemctl start nfs-server # 使配置生效 exportfs -r #检查配置是否生效 exportfs 从节点 showmount -e [masterip] mkdir -p /nfs/data mount -t nfs [masterip]:/nfs/data /nfs/data 配置默认存储 注意修改ip ## 创建了一个存储类 apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-storage annotations: storageclass.kubernetes.io/is-default-class: \"true\" provisioner: k8s-sigs.io/nfs-subdir-external-provisioner parameters: archiveOnDelete: \"true\" ## 删除pv的时候，pv的内容是否要备份 --- apiVersion: apps/v1 kind: Deployment metadata: name: nfs-client-provisioner labels: app: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default spec: replicas: 1 strategy: type: Recreate selector: matchLabels: app: nfs-client-provisioner template: metadata: labels: app: nfs-client-provisioner spec: serviceAccountName: nfs-client-provisioner containers: - name: nfs-client-provisioner image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/nfs-subdir-external-provisioner:v4.0.2 # resources: # limits: # cpu: 10m # requests: # cpu: 10m volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME value: k8s-sigs.io/nfs-subdir-external-provisioner - name: NFS_SERVER value: 172.31.0.4 ## 指定自己nfs服务器地址 - name: NFS_PATH value: /nfs/data ## nfs服务器共享的目录 volumes: - name: nfs-client-root nfs: server: 172.31.0.4 path: /nfs/data --- apiVersion: v1 kind: ServiceAccount metadata: name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-client-provisioner-runner rules: - apiGroups: [\"\"] resources: [\"nodes\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"\"] resources: [\"persistentvolumes\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"delete\"] - apiGroups: [\"\"] resources: [\"persistentvolumeclaims\"] verbs: [\"get\", \"list\", \"watch\", \"update\"] - apiGroups: [\"storage.k8s.io\"] resources: [\"storageclasses\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"\"] resources: [\"events\"] verbs: [\"create\", \"update\", \"patch\"] --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: run-nfs-client-provisioner subjects: - kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default roleRef: kind: ClusterRole name: nfs-client-provisioner-runner apiGroup: rbac.authorization.k8s.io --- kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: leader-locking-nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default rules: - apiGroups: [\"\"] resources: [\"endpoints\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\"] --- kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: leader-locking-nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default subjects: - kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default roleRef: kind: Role name: leader-locking-nfs-client-provisioner apiGroup: rbac.authorization.k8s.io ","date":"2022-07-13","objectID":"/kubernetes/:5:5","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"安装metrics-server 集群指标监控组件 apiVersion: v1 kind: ServiceAccount metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: k8s-app: metrics-server rbac.authorization.k8s.io/aggregate-to-admin: \"true\" rbac.authorization.k8s.io/aggregate-to-edit: \"true\" rbac.authorization.k8s.io/aggregate-to-view: \"true\" name: system:aggregated-metrics-reader rules: - apiGroups: - metrics.k8s.io resources: - pods - nodes verbs: - get - list - watch --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: k8s-app: metrics-server name: system:metrics-server rules: - apiGroups: - \"\" resources: - pods - nodes - nodes/stats - namespaces - configmaps verbs: - get - list - watch --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: labels: k8s-app: metrics-server name: metrics-server-auth-reader namespace: kube-system roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: extension-apiserver-authentication-reader subjects: - kind: ServiceAccount name: metrics-server namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: labels: k8s-app: metrics-server name: metrics-server:system:auth-delegator roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:auth-delegator subjects: - kind: ServiceAccount name: metrics-server namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: labels: k8s-app: metrics-server name: system:metrics-server roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:metrics-server subjects: - kind: ServiceAccount name: metrics-server namespace: kube-system --- apiVersion: v1 kind: Service metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system spec: ports: - name: https port: 443 protocol: TCP targetPort: https selector: k8s-app: metrics-server --- apiVersion: apps/v1 kind: Deployment metadata: labels: k8s-app: metrics-server name: metrics-server namespace: kube-system spec: selector: matchLabels: k8s-app: metrics-server strategy: rollingUpdate: maxUnavailable: 0 template: metadata: labels: k8s-app: metrics-server spec: containers: - args: - --cert-dir=/tmp - --kubelet-insecure-tls - --secure-port=4443 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-use-node-status-port image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/metrics-server:v0.4.3 imagePullPolicy: IfNotPresent livenessProbe: failureThreshold: 3 httpGet: path: /livez port: https scheme: HTTPS periodSeconds: 10 name: metrics-server ports: - containerPort: 4443 name: https protocol: TCP readinessProbe: failureThreshold: 3 httpGet: path: /readyz port: https scheme: HTTPS periodSeconds: 10 securityContext: readOnlyRootFilesystem: true runAsNonRoot: true runAsUser: 1000 volumeMounts: - mountPath: /tmp name: tmp-dir nodeSelector: kubernetes.io/os: linux priorityClassName: system-cluster-critical serviceAccountName: metrics-server volumes: - emptyDir: {} name: tmp-dir --- apiVersion: apiregistration.k8s.io/v1 kind: APIService metadata: labels: k8s-app: metrics-server name: v1beta1.metrics.k8s.io spec: group: metrics.k8s.io groupPriorityMinimum: 100 insecureSkipTLSVerify: true service: name: metrics-server namespace: kube-system version: v1beta1 versionPriority: 100 ","date":"2022-07-13","objectID":"/kubernetes/:5:6","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"核心 ","date":"2022-07-13","objectID":"/kubernetes/:6:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"总结 资源创建两种方式 命令行 yaml文件 ","date":"2022-07-13","objectID":"/kubernetes/:6:1","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Namespace 命令行 # 查看命名空间 kubectl get ns # 创建命名空间 kubectl create ns a # 删除命名空间 kubectl delete ns a # 如果是使用文件创建的，还可以治直接使用文件删除 kubectl delete -f hello.yaml yaml文件 apiVersion: v1 kind: Namespace metadata: name: hello ","date":"2022-07-13","objectID":"/kubernetes/:6:2","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Pod 运行中的一组容器，Pod是kubernetes中应用的最小单位 命令行 kubectl run mynginx --image=nginx # 查看default名称空间的Pod kubectl get pod # 描述(可以看到具体执行以及在哪个节点上运行) kubectl describe pod 你自己的Pod名字 # 删除 kubectl delete pod Pod名字 # 查看Pod的运行日志 kubectl logs Pod名字 # 每个Pod - k8s都会分配一个ip kubectl get pod -owide # 进入容器内部 kubectl exec -it myapp -- /bin/bash # 集群中的任意一个机器以及任意的应用都能通过Pod分配的ip来访问这个Pod 配置文件 apiVersion: v1 kind: Pod metadata: labels: run: mynginx name: mynginx # namespace: default spec: containers: - image: nginx name: mynginx apiVersion: v1 kind: Pod metadata: labels: run: myapp name: myapp spec: containers: - image: nginx name: nginx - image: tomcat:8.5.68 name: tomcat 特性 同一个pod中的容器共享网络(同ip，端口) 同一个pod中的容器共享存储 镜像拉取策略 IfNotPresent:默认值，镜像不存在时拉取 Always:每次都拉取 Never:永远不主动拉取 apiVersion: v1 kind: Pod metadata: name: myapp spec: containers: - image: nginx name: nginx imagePullPolicy: Always 资源限制 sepc: containers: - name: db image: mysql resources: # 调度资源限制(最大) requests: memory: \"64Mi\" # 1核 = 1000m cpu: \"250m\" # 运行时资源限制(最大) limits: memory: \"128Mi\" cpu: \"500m\" restartPolicy: Always 重启机制 Always:总是重启(默认) OnFailure:异常退出（状态码非0），才重启 Never:从不重启 sepc: containers: - name: db image: mysql restartPolicy: Always 健康检查 检查方式 livenessProbe(存活检查) readinessProbe(就绪检查) 检查方法 httpGet exec topSocket 调度策略 影响调度的属性 资源限制 节点选择器 对节点打标签 # 打标签 kubectl label node node01 env_role=prod # 查看标签 kubectl get node --show-labels 使用 apiVersion: v1 kind: Pod metadata: name: myapp spec: nodeSelector: env_role: prod containers: - image: nginx name: nginx imagePullPolicy: Always 节点亲和性 硬亲和性(约束条件必须满足) 软亲和性(尝试满足) 污点和污点容忍(节点属性) 查看污点情况 kubectl describe node k8s-master01 | grep Taint 三种情况 NoSchedule:一定不被调度 PreferNoSchdule:尽量不被调度 NoExecute:不会被调度，而且还会驱逐Node已有Pod 创建污点 kubeclt taint node [node] [key]=[value]:[污点的三种情况] ## 举例 kubeclt taint node k8s-master01 env_role=yes:NoSchedule 删除污点 kubeclt taint node [node] key:[污点的三种情况]- ## 举例 kubeclt taint node k8s-master01 key:NoSchedule- 污点容忍 spec: tolerations: - key: \"key1\" operator: \"Equal\" value: \"value1\" effect: \"NoSchedule\" - key: \"key1\" operator: \"Equal\" value: \"value1\" effect: \"NoExecute\" - key: \"node.alpha.kubernetes.io/unreachable\" operator: \"Exists\" effect: \"NoExecute\" tolerationSeconds: 6000 ","date":"2022-07-13","objectID":"/kubernetes/:6:3","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Deployment(一种工作负载) 控制Pod，使Pod拥有多副本，自愈，扩缩容等能力 操作 命令行 # 创建 kubectl create deployment mytomcat --image=tomcat:8.5.68 # 查看 kubectl get deploy # 删除 kubectl delete deploy mytomcat # 修改 kubectl edit deployment my-dep # 多副本 --replicas=3 kubectl create deployment my-dep --image=nginx --replicas=3 # 扩缩容 kubectl scale --replicas=5 deployment/my-dep # 版本更新 kubectl set image deployment/my-dep nginx=nginx:1.16.1 --record kubectl set image deployment/[deployment名字] [容器名字]=nginx:1.16.1 --record # 查看容器名字 kubectl get deploy -oyaml # --版本回退-- # 查看状态 kubectl rollout status deployment/my-dep # 历史记录 kubectl rollout history deployment/my-dep # 查看某个历史详情 kubectl rollout history deployment/my-dep --revision=2 # 回滚(回到上次) kubectl rollout undo deployment/my-dep # 回滚(回到指定版本) kubectl rollout undo deployment/my-dep --to-revision=2 yaml apiVersion: apps/v1 kind: Deployment metadata: labels: app: my-dep name: my-dep spec: replicas: 3 selector: matchLabels: app: my-dep template: metadata: labels: app: my-dep spec: containers: - image: nginx name: nginx 特性 自愈 多副本 扩缩容 滚动更新 版本回退 ","date":"2022-07-13","objectID":"/kubernetes/:6:4","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Service 统一多个pod对外统一暴露端口，负载均衡 使用ip或者域名访问 域名只能在pod(可以不在一个service中)中使用，不可以在主机上使用 域名规则：服务名.所在空间名称.svc(my-dep.default.svc) 命令 #创建 默认 --type=ClusterIP kubectl expose deployment my-dep --port=8000 --target-port=80 #对外暴露端口 kubectl expose deployment my-dep --port=8000 --target-port=80 --type=NodePort # 获取列表 kubectl get service # 删除 kubectl delete svc my-dep yaml apiVersion: v1 kind: Service metadata: labels: app: my-dep name: my-dep spec: selector: app: my-dep ports: - port: 8000 protocol: TCP targetPort: 80 ClusterIP 不对外暴露，只有集群内部可以访问 NodePort 对外暴露端口 ","date":"2022-07-13","objectID":"/kubernetes/:6:5","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"Ingress 官网 安装 wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml kubectl apply deploy.yaml 使用 #获取网关端口 kubectl get svc -A 创建测试环境 vi test.yaml kubectl apply -f test.yaml test.yaml apiVersion: apps/v1 kind: Deployment metadata: name: hello-server spec: replicas: 2 selector: matchLabels: app: hello-server template: metadata: labels: app: hello-server spec: containers: - name: hello-server image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server ports: - containerPort: 9000 --- apiVersion: apps/v1 kind: Deployment metadata: labels: app: nginx-demo name: nginx-demo spec: replicas: 2 selector: matchLabels: app: nginx-demo template: metadata: labels: app: nginx-demo spec: containers: - image: nginx name: nginx --- apiVersion: v1 kind: Service metadata: labels: app: nginx-demo name: nginx-demo spec: selector: app: nginx-demo ports: - port: 8000 protocol: TCP targetPort: 80 --- apiVersion: v1 kind: Service metadata: labels: app: hello-server name: hello-server spec: selector: app: hello-server ports: - port: 8000 protocol: TCP targetPort: 9000 需求： 访问sit.jsh.com转给服务nginx-demo,访问uat.jsh.com转给服务hello-server 实现： apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ingress-host-bar spec: ingressClassName: nginx rules: - host: \"uat.jsh.com\" http: paths: - pathType: Prefix path: \"/\" backend: service: name: hello-server port: number: 8000 - host: \"sit.jsh.com\" http: paths: - pathType: Prefix path: \"/nginx\" # 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404 backend: service: name: nginx-demo ## java，比如使用路径重写，去掉前缀nginx port: number: 8000 路径重写 - host: \"sit.jsh.com\" http: paths: - pathType: Prefix path: \"/nginx(/|$)(.*)\" # backend: service: name: nginx-demo ## java，比如使用路径重写，去掉前缀nginx port: number: 8000 ","date":"2022-07-13","objectID":"/kubernetes/:6:6","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"存储 环境准备 所有节点 #所有机器安装 yum install -y nfs-utils 主节点:暴露目录 #nfs主节点 echo \"/nfs/data/ *(insecure,rw,sync,no_root_squash)\" \u003e /etc/exports mkdir -p /nfs/data systemctl enable rpcbind --now systemctl enable nfs-server --now #配置生效 exportfs -r 从节点 showmount -e 172.16.1.3 #执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount mkdir -p /nfs/data mount -t nfs 172.16.1.3:/nfs/data /nfs/data # 写入一个测试文件 echo \"hello nfs server\" \u003e /nfs/data/test.txt 原生方式数据挂载 Pod 删除后数据不会自动删除 apiVersion: apps/v1 kind: Deployment metadata: labels: app: nginx-pv-demo name: nginx-pv-demo spec: replicas: 2 selector: matchLabels: app: nginx-pv-demo template: metadata: labels: app: nginx-pv-demo spec: containers: - image: nginx name: nginx volumeMounts: - name: html mountPath: /usr/share/nginx/html volumes: - name: html nfs: server: 172.16.1.3 path: /nfs/data/nginx-pv PV\u0026PVC PV：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置 PVC：持久卷申明（Persistent Volume Claim），申明需要使用的持久卷规格 创建pv池 准备 #nfs主节点 mkdir -p /nfs/data/01 mkdir -p /nfs/data/02 mkdir -p /nfs/data/03 创建 apiVersion: v1 kind: PersistentVolume metadata: name: pv01-10m spec: capacity: storage: 10M accessModes: - ReadWriteMany storageClassName: nfs nfs: path: /nfs/data/01 server: 172.16.1.3 --- apiVersion: v1 kind: PersistentVolume metadata: name: pv02-1gi spec: capacity: storage: 1Gi accessModes: - ReadWriteMany storageClassName: nfs nfs: path: /nfs/data/02 server: 172.16.1.3 --- apiVersion: v1 kind: PersistentVolume metadata: name: pv03-3gi spec: capacity: storage: 3Gi accessModes: - ReadWriteMany storageClassName: nfs nfs: path: /nfs/data/03 server: 172.16.1.3 创建pvc kind: PersistentVolumeClaim apiVersion: v1 metadata: name: nginx-pvc spec: accessModes: - ReadWriteMany resources: requests: storage: 200Mi storageClassName: nfs 绑定pvc和pod apiVersion: apps/v1 kind: Deployment metadata: labels: app: nginx-deploy-pvc name: nginx-deploy-pvc spec: replicas: 2 selector: matchLabels: app: nginx-deploy-pvc template: metadata: labels: app: nginx-deploy-pvc spec: containers: - image: nginx name: nginx volumeMounts: - name: html mountPath: /usr/share/nginx/html volumes: - name: html persistentVolumeClaim: claimName: nginx-pvc ConfigMap 主要存放配置，可以实时更新 创建配置文件redis.conf appendonly yes 创建配置集 kubectl create cm redis-conf --from-file=redis.conf # 查看详情 kubectl get cm redis-conf -oyaml 创建pod apiVersion: v1 kind: Pod metadata: name: redis spec: containers: - name: redis image: redis command: - redis-server - \"/redis-master/redis.conf\" #指的是redis容器内部的位置 ports: - containerPort: 6379 volumeMounts: - mountPath: /data name: data - mountPath: /redis-master name: config volumes: - name: data emptyDir: {} - name: config configMap: name: redis-conf items: - key: redis.conf path: redis.conf 进入pod验证 kubectl exec -it redis -- redis-cli CONFIG GET appendonly Secret Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 Pod 的定义或者 容器镜像 中来说更加安全和灵活。 定义 kubectl create secret docker-registry my-docker \\ --docker-username=xxx \\ --docker-password=xxx \\ --docker-email=xxx@xxxx ##命令格式 kubectl create secret docker-registry regcred \\ --docker-server=\u003c你的镜像仓库服务器\u003e \\ --docker-username=\u003c你的用户名\u003e \\ --docker-password=\u003c你的密码\u003e \\ --docker-email=\u003c你的邮箱地址\u003e 使用 apiVersion: v1 kind: Pod metadata: name: private-nginx spec: containers: - name: private-nginx image: xxxxxxxx imagePullSecrets: - name: my-docker ","date":"2022-07-13","objectID":"/kubernetes/:6:7","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"安全机制 官网 ","date":"2022-07-13","objectID":"/kubernetes/:6:8","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"监控 Prometheus+Grafana ","date":"2022-07-13","objectID":"/kubernetes/:6:9","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"附录 ","date":"2022-07-13","objectID":"/kubernetes/:7:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["云原生"],"content":"微服务javaDockerFile docker build -t loca-dup:1.0 . FROM openjdk:8-jdk LABEL maintainer=coderabbit #docker run -e PARAMS=\"--server.port 9090\" ENV PARAMS=\"--server.port=8080 --spring.profiles.active=prod --spring.cloud.nacos.discovery.server-addr=his-nacos.his:8848 --spring.cloud.nacos.config.server-addr=his-nacos.his:8848 --spring.cloud.nacos.config.namespace=prod --spring.cloud.nacos.config.file-extension=yml\" RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026\u0026 echo 'Asia/Shanghai' \u003e/etc/timezone COPY target/*.jar /app.jar EXPOSE 8080 # ENTRYPOINT [\"/bin/sh\",\"-c\",\"java -Dfile.encoding=utf8 -Djava.security.egd=file:/dev/./urandom -jar app.jar ${PARAMS}\"] $ docker login --username=xxxx registry.cn-hangzhou.aliyuncs.com #把本地镜像，改名，成符合阿里云名字规范的镜像。 $ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/镜像名:[镜像版本号] ## docker tag 393f2ccae8fb registry.cn-hangzhou.aliyuncs.com/jsh_aliyun/f-dup:1.2.6 $ docker push registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/镜像名:[镜像版本号] ## docker push registry.cn-hangzhou.aliyuncs.com/lfy_ruoyi/ruoyi-visual-monitor:v1 ","date":"2022-07-13","objectID":"/kubernetes/:8:0","tags":["k8s"],"title":"Kubernetes","uri":"/kubernetes/"},{"categories":["工具"],"content":"FRP 内网穿透 ","date":"2022-05-29","objectID":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:0:0","tags":["frp"],"title":"FRP 内网穿透","uri":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["工具"],"content":"准备 一台拥有公网ip的服务器 ","date":"2022-05-29","objectID":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:0","tags":["frp"],"title":"FRP 内网穿透","uri":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["工具"],"content":"服务器端安装配置FRPS 下载文件 github地址 wget https://github.com/fatedier/frp/releases/download/v0.43.0/frp_0.43.0_linux_amd64.tar.gz 解压 tar -zxvf frp_0.43.0_linux_amd64.tar.gz 配置 frps.ini [common] # 端口 bind_port = 7000 # 密码token token = xxxxxxx 创建Systemctl后台启动 vim /lib/systemd/system/frps.service [Unit] Description=fraps service After=network.target syslog.target Wants=network.target [Service] Type=simple ExecStart=/root/frp/frps -c /root/frp/frps.ini # 根据实际情况修改 [Install] WantedBy=multi-user.target 启动服务设置随系统启动 //设置随系统启动 systemctl enable frps //启动 systemctl start frps //查看启动情况:查看进程 ps auxw ","date":"2022-05-29","objectID":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:2:0","tags":["frp"],"title":"FRP 内网穿透","uri":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["工具"],"content":"客户端安装配置FRPC 下载对应系统的文件 配置frpc.ini [common] //服务器ip server_addr = 123.57.48.176 //服务器端口 server_port = 7000 //密码 token = xxxxx //服务一 [mysql] type = tcp local_ip = 127.0.0.1 local_port = 3306 //映射到服务器的端口 remote_port = 9999 //服务二 不能重名 [mysql2] type = tcp local_ip = 127.0.0.1 local_port = xxxx remote_port = 9999 启动 ./frpc -c frpc.ini Mac 开机自启动 编写脚本 sudo vim /Library/LaunchDaemons/frpc.plist \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//EN http://www.apple.com/DTDs/PropertyList-1.0.dtd \u003e \u003cplist version=\"1.0\"\u003e \u003cdict\u003e \u003ckey\u003eLabel\u003c/key\u003e \u003cstring\u003efrpc\u003c/string\u003e \u003ckey\u003eProgramArguments\u003c/key\u003e \u003carray\u003e \u003cstring\u003e/Users/mr_j/frpc/frpc\u003c/string\u003e \u003cstring\u003e-c\u003c/string\u003e \u003cstring\u003e/Users/mr_j/frpc/frpc.ini\u003c/string\u003e \u003c/array\u003e \u003ckey\u003eKeepAlive\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eRunAtLoad\u003c/key\u003e \u003ctrue/\u003e \u003c/dict\u003e \u003c/plist\u003e 赋权并让生效 sudo chown root /Library/LaunchDaemons/frpc.plist sudo launchctl load -w /Library/LaunchDaemons/frpc.plist 取消自启动 sudo launchctl unload -w /Library/LaunchDaemons/frpc.plist ","date":"2022-05-29","objectID":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:3:0","tags":["frp"],"title":"FRP 内网穿透","uri":"/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["Spring","SpringCloud"],"content":"spring-cloud-stream 3.x 开发 ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:0:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"基本使用 ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:1:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"基本配置 依赖 implementation 'org.springframework.cloud:spring-cloud-stream:3.2.3' 配置 spring: rabbitmq: host: 127.0.0.1 port: 5672 username: username password: password ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:1:1","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"生产者 配置 注意：analysePdf-out-0，analysePdf发送消息，接收消息都需要使用 spring: cloud: stream: rabbit: bindings: analysePdf-out-0: producer: destination: analysePdf content-type: application/json bindings: analysePdf-out-0: destination: analysePdf 代码 @Autowired private StreamBridge streamBridge; public void sendMethod() { //与配置文件中相同 streamBridge.send(\"analysePdf-out-0\", \"pdf\"+i); } ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:1:2","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"消费者 配置 spring: cloud: stream: rabbit: bindings: analysePdf-in-0: consumer: destination: analysePdf content-type: application/json bindings: analysePdf-in-0: destination: analysePdf 代码 注意：方法名需要和配置中心中相同 @Configuration public class Test { @Bean(\"analysePdf\") //方法名与配置中相同 public Consumer\u003cString\u003e analysePdf() { return str -\u003e { System.out.println(\"analysePdf: \" + str); }; } } ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:1:3","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"消息分组(多实例下避免重复消费) 消费者配置：group: in，配置后同组消费者下只能消费一次 spring: cloud: stream: rabbit: bindings: analysePdf-in-0: consumer: destination: analysePdf content-type: application/json bindings: analysePdf-in-0: group: in destination: analysePdf ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:2:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"ack配置 消费者配置：acknowledge-mode: auto spring: cloud: stream: rabbit: bindings: analysePdf-in-0: consumer: destination: analysePdf content-type: application/json #ack模式 acknowledge-mode: auto #重试次数 max-attempts: 5 bindings: analysePdf-in-0: group: in destination: analysePdf ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:3:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring","SpringCloud"],"content":"多消息使用 注意配置,其他配置重复一遍 spring: cloud: function: definition: 完整配置 spring: cloud: function: definition: analysePdf;jsh stream: rabbit: bindings: analysePdf-in-0: consumer: destination: analysePdf content-type: application/json #ack模式 acknowledge-mode: auto #重试次数 max-attempts: 5 analysePdf-out-0: producer: destination: analysePdf content-type: application/json jsh-in-0: consumer: destination: jsh content-type: application/json jsh-out-0: producer: destination: jsh content-type: application/json bindings: analysePdf-in-0: group: in destination: analysePdf analysePdf-out-0: destination: analysePdf jsh-in-0: group: in destination: jsh jsh-out-0: destination: jsh Spring Cloud Stream 官网 源码地址 ","date":"2022-05-16","objectID":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/:4:0","tags":["spring-cloud-stream"],"title":"spring-cloud-stream 3.x 开发","uri":"/spring-cloud-stream-3.x-%E5%BC%80%E5%8F%91/"},{"categories":["Spring"],"content":"springboot自定义异步线程池 ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:0:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Spring"],"content":"自定义线程池 @Configuration @EnableAsync public class SyncConfiguration{ @Bean(name = \"asyncPoolTaskExecutor\") public ThreadPoolTaskExecutor executor() { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); //核心线程数 taskExecutor.setCorePoolSize(1); //线程池维护线程的最大数量,只有在缓冲队列满了之后才会申请超过核心线程数的线程 taskExecutor.setMaxPoolSize(2); //缓存队列 taskExecutor.setQueueCapacity(2); //许的空闲时间,当超过了核心线程出之外的线程在空闲时间到达之后会被销毁 taskExecutor.setKeepAliveSeconds(200); //异步方法内部线程名称 taskExecutor.setThreadNamePrefix(\"async-\"); /** * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略 * 通常有以下四种策略： * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） * ThreadPoolExecutor.CallerRunsPolicy：直接主线程执行 */ taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); taskExecutor.initialize(); return taskExecutor; } } ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:1:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Spring"],"content":"使用 在注解中添加bean名称 @Async(\"asyncPoolTaskExecutor\") public void doTask1() throws InterruptedException { long t1 = System.currentTimeMillis(); Thread.sleep(2000); long t2 = System.currentTimeMillis(); log.info(\"task1 cost {} ms\" , t2-t1); } ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Spring"],"content":"设置为Async默认线程池 继承AsyncConfigurer，重写getAsyncExecutor方法 @Configuration @EnableAsync public class SyncConfiguration implements AsyncConfigurer{ private final Logger log = LoggerFactory.getLogger(SyncConfiguration.class); @Bean(name = \"asyncPoolTaskExecutor\") public ThreadPoolTaskExecutor executor() { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); //核心线程数 taskExecutor.setCorePoolSize(1); //线程池维护线程的最大数量,只有在缓冲队列满了之后才会申请超过核心线程数的线程 taskExecutor.setMaxPoolSize(2); //缓存队列 taskExecutor.setQueueCapacity(2); //许的空闲时间,当超过了核心线程出之外的线程在空闲时间到达之后会被销毁 taskExecutor.setKeepAliveSeconds(200); //异步方法内部线程名称 taskExecutor.setThreadNamePrefix(\"async-\"); /** * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略 * 通常有以下四种策略： * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） * ThreadPoolExecutor.CallerRunsPolicy：直接主线程执行 */ taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); taskExecutor.initialize(); return taskExecutor; } /** * 指定默认线程池 */ @Override public Executor getAsyncExecutor() { return executor(); } @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return (ex, method, params) -\u003e log.error(\"线程池执行任务发送未知错误,执行方法：{}\",method.getName(),ex); } } ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Spring"],"content":"备注 如果使用AbortPolicy处理策略，可以增加异常处理器，捕获RejectedExecutionException异常处理 ","date":"2022-04-08","objectID":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/:4:0","tags":["框架"],"title":"springboot自定义异步线程池","uri":"/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":["Java"],"content":"使用Enum和异常控制器 目的：避免定义各种异常类 基础：已经做了统一返回处理 Enum public enum ResultCodeEnum { /** * 成功 */ SUCCESS(200, \"操作成功\"), /** * 系统错误 */ ERROR(500, \"系统错误\"), /** * 操作失败 */ FAILED(101, \"操作失败\"), /** * 参数错误 */ PARAM_ERROR(103, \"参数错误\"), /** * 参数错误-已存在 */ INVALID_PARAM_EXIST(104, \"请求参数已存在\"), /** * 参数错误 */ INVALID_PARAM_EMPTY(105, \"请求参数为空\"), /** * 参数错误 */ PARAM_TYPE_MISMATCH(106, \"参数类型不匹配\"), /** * 参数错误 */ PARAM_VALID_ERROR(107, \"参数校验失败\"), /** * 参数错误 */ ILLEGAL_REQUEST(108, \"非法请求\"); public int code; public String msg; ResultCodeEnum(int code, String msg) { this.code = code; this.msg = msg; } public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } 自定义业务异常类 public class BusinessException extends RuntimeException { private int code; private String msg; public BusinessException() { this.code = ResultCodeEnum.FAILED.code; this.msg = ResultCodeEnum.FAILED.msg; } public BusinessException(String message) { this.code = ResultCodeEnum.FAILED.code; this.msg = message; } public BusinessException(ResultCodeEnum resultCodeEnum){ this.code = resultCodeEnum.code; this.msg = resultCodeEnum.msg; } public BusinessException(int code, String msg) { this.code = code; this.msg = msg; } public BusinessException(Throwable cause) { super(cause); } public BusinessException(String message, Throwable cause) { super(message, cause); } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public int getCode() { return code; } public void setCode(int code) { this.code = code; } } 异常控制器 @ControllerAdvice public class RestResultExceptionHandler { @ResponseBody @ExceptionHandler(value = RuntimeException.class) public RestResult\u003c?\u003e handleRunTimeException(RuntimeException e) { return RestResultUtils.failedWithMsg(500, e.getMessage()); } /** * 自定义业务异常-BusinessException */ @ResponseBody @ExceptionHandler(value = {BusinessException.class}) public AjaxResult handlerCustomException(BusinessException exception) { return AjaxResult.error(exception.getCode(), exception.getMsg()); } } ","date":"2022-03-18","objectID":"/%E4%BD%BF%E7%94%A8enum%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E5%99%A8/:0:0","tags":[],"title":"使用Enum和异常控制器","uri":"/%E4%BD%BF%E7%94%A8enum%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["Java"],"content":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:0:0","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"需求 无缝(通过配置，不改代码)切换外网模式和内网模式(阿里云和MINIO) 文件前端直传(需要后端签名)，节约自己服务器的网络资源 私有读写，如果需要向后端发起请求获取签名 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:1:0","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"实现 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:0","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"UML图 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:1","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"工厂模式实现(后端代码) 配置 oss: # 使用oss的模式 # 1. ALIYUN # 2. MINIO mode: ALIYUN # 上传目录，这里如果不想加，别的地方到处加 dir: test/ # 上传url过期时间 单位 s updateExpiryTime: 600 # 查看过期时间 单位 s downloadExpiryTime: 600 #阿里oss配置 aliyun: endpoint: keyid: keysecret: bucketname: #minio配置 minio: endpoint: keyid: keysecret: bucketName: 编写OSS接口，每一种oss模式都需要实现其所有方法 public interface OssInterface { /** * 文件上传 * @param file * @param objectName * @return */ String uploadFile(MultipartFile file, String objectName); /** * 判断文件是否存在 * @param objectName * @return */ boolean existFile(String objectName); /** * 获取上传签名 * @return */ OssRequestData getPolicy(String dir,String fileName); /** * 获取查看签名 */ String getExpiration(String objectName); } 编写实现类 AliOssService @Service public class AliOssService implements OssInterface { String endpoint = AliyunConstantPropertiesUtils.END_POINT; String accessKeyId = AliyunConstantPropertiesUtils.KEY_ID; String accessKeySecret = AliyunConstantPropertiesUtils.KEY_SECRET; String bucketName = AliyunConstantPropertiesUtils.BUCKET_NAME; /** * 文件上传 * * @param file * @return */ @Override public String uploadFile(MultipartFile file, String objectName) { OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { // 上传文件流。 InputStream inputStream = file.getInputStream(); //获取文件名称 //第一个参数 Bucket名称 //第二个参数 文件路径和文件名称 //第三个参数 文件输入流 ossClient.putObject(bucketName, objectName, inputStream); // 关闭OSSClient。 ossClient.shutdown(); //上传之后的文件路径返回 //需要手动拼接 return \"https://\" + bucketName + \".\" + endpoint + \"/\" + objectName; } catch (Exception e) { e.printStackTrace(); return null; } } /** * 判断文件是否存在 */ @Override public boolean existFile(String objectName) { // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); boolean found = ossClient.doesObjectExist(bucketName, objectName); ossClient.shutdown(); return found; } /** * 签名 */ @Override public OssRequestData getPolicy(String dir,String fileName){ fileName = UUID.randomUUID()+\"_\"+fileName; String host = \"https://\" + bucketName + \".\" + endpoint; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); OssRequestData ossRequestData =null; try { long expireEndTime = System.currentTimeMillis() + OssConstantPropertiesUtils.UPDATE_EXPIRY_TIME * 1000; Date expiration = new Date(expireEndTime); // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。 PolicyConditions policyConds = new PolicyConditions(); policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000); policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir+fileName); String postPolicy = ossClient.generatePostPolicy(expiration, policyConds); byte[] binaryData = postPolicy.getBytes(StandardCharsets.UTF_8); String encodedPolicy = BinaryUtil.toBase64String(binaryData); String postSignature = ossClient.calculatePostSignature(postPolicy); FormData formData = new FormData(accessKeyId,encodedPolicy,postSignature,dir,dir+fileName,fileName,String.valueOf(expireEndTime / 1000)); ossRequestData = new OssRequestData(host,\"file\",true,\"post\",formData); } catch (Exception e) { System.out.println(e.getMessage()); } finally { ossClient.shutdown(); } return ossRequestData; } /** * 获取签名授权访问 * @param objectName * @return */ @Override public String getExpiration(String objectName){ OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); Date expiration = new Date(System.currentTimeMillis() + OssConstantPropertiesUtils.DOWNLOAD_EXPIRY_TIME * 1000); URL url = ossClient.generatePresignedUrl(bucketName, objectName, expiration); ossClient.shutdown(); return url.toString(); } } MinIOOssService @Service public class MinIOOssService implements OssInterface { String endpoint = MinIOConstantPropertiesUtils.END_POINT; String accessKeyId = MinIOConstantPropertiesUtils.KEY_ID; String accessKeySecret = MinIOConstantPropertiesUtils.KEY_SECRET; String bucketName = MinIOConstantProperties","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:2","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"前端适配 \u003ctemplate\u003e \u003cdiv class=\"home\" style=\"height: 100%\"\u003e \u003cel-upload :action=\"123\" :data=\"dataObj\" :http-request=\"upload\" list-type=\"picture\" :multiple=\"false\" :file-list=\"fileList\" \u003e \u003cel-button size=\"small\" type=\"primary\"\u003e点击上传\u003c/el-button\u003e \u003c/el-upload\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import axios from 'axios' export default { name: 'Home', props: { value: String }, data() { return { fileList: [], } }, methods: { //向后端请求上传签名 upload(item) { //请求参数 let data; //文件 let file = item.file; axios.get(\"http://127.0.0.1:8081/getPolicy?fileName=\" + file.name).then(res =\u003e { res = res.data; //后端传递的请求参数 let formData = res.formData; //文件oss上的根路径+文件名 let key = formData.key; //判断是否需要formData if (res.withFormData) { data = new FormData(); for (let param in formData) { data.append(param, formData[param]) } data.append(res.fileFieldName, file); } else { data = file; } //存储 axios({ url: res.host, data: data, method: res.method, headers: { 'Content-Type': 'multipart/form-data' } }).then(res =\u003e { //向后端存储（伪代码）： /** * save({ * ... * url: this.dataObj.host + '/' + this.dataObj.key * ... * }) */ //前端使用： axios.get(\"http://127.0.0.1:8081/getExpiration?objectName=\" + key).then(res =\u003e { this.fileList.push({ name: file.name, url: res.data }) }) }) }); }, } } \u003c/script\u003e ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:3","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"关于签名直传 流程图 文件上传以及文件查看预览都是这个流程 ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:2:4","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Java"],"content":"项目地址 https://github.com/coderabbit214/parent-demo/tree/main/oss_demo ","date":"2022-03-11","objectID":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/:3:0","tags":["设计模式"],"title":"使用策略模式实现阿里云OSS和MINIO后端签名前端直传","uri":"/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8Cminio%E5%90%8E%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9B%B4%E4%BC%A0/"},{"categories":["Spring"],"content":"AOP 和 注解 结合使用 aop的切面可以定义为注解，用打印接口访问时间举例 注解 @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface CountTime { } aop @Component @Aspect @Slf4j public class CountTimeAspect { //定义切入点（也可以直接写在下边） @Pointcut(\"@annotation(com.coderabbit.utildemo.annotation.CountTime)\") public void countTime(){ } @Around(\"countTime()\") public Object doAround(ProceedingJoinPoint joinPoint) { Object object = null; try { long beginTime = System.currentTimeMillis(); object = joinPoint.proceed(); String serviceName = joinPoint.getSignature().getName(); String className = joinPoint.getSignature().getDeclaringTypeName(); log.info(\"\\nController Name:{}\\nService Name:{}\\n响应耗时{}\",className,serviceName,System.currentTimeMillis() - beginTime +\"ms\"); } catch (Throwable throwable) { throwable.printStackTrace(); } return object; } } ","date":"2021-12-21","objectID":"/aop%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/:0:0","tags":["AOP","注解"],"title":"AOP和注解结合使用","uri":"/aop%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/"},{"categories":["云原生"],"content":"Docker ","date":"2021-12-19","objectID":"/docker/:0:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"概述 基于Go 应用 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 优势 快速 响应式部署和扩展 同一硬件上运行更多工作负载 虚拟化技术和容器化技术比较 传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。 Docker容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟硬件。 每个容器都是相互隔离的，每个容器都有属于自己的文件系统，互不影响。 ","date":"2021-12-19","objectID":"/docker/:1:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"安装 mac,win 直接官网下载安装 下面为centos7 安装gcc yum -y install gcc yum -y install gcc-c++ 卸载旧版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 下载需要的安装包 yum install -y yum-utils 设置阿里云仓库（可以不设置，本人没有设置） yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #国外的地址 # 设置阿里云的Docker镜像仓库 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #国外的地址 更新yum索引 yum makecache fast 安装docker yum install docker-ce docker-ce-cli containerd.io ","date":"2021-12-19","objectID":"/docker/:2:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"Docker常用命令 ","date":"2021-12-19","objectID":"/docker/:3:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"基础命令 docker version #查看docker的版本信息 docker info #查看docker的系统信息,包括镜像和容器的数量 docker 命令 --help #帮助命令(可查看可选的参数) docker COMMAND --help #启动docker systemctl start docker #查看状态 systemctl status docker ","date":"2021-12-19","objectID":"/docker/:3:1","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"镜像命令 docker images 查看本地主机的所有镜像 docker images #查看本地主机的所有镜像 # 可选参数 -a/--all 列出所有镜像 -q/--quiet 只显示镜像的id docker search 搜索镜像 # 举例： docker search mysql #搜索收藏数大于3000的镜像 docker search mysql --filter=STARS=3000 docker pull 镜像名[:tag] 拉取镜像 分层下载，联合文件系统 docker pull mysql #如果不写tag默认就是latest docker pull mysql:5.7 #5.7版本 docker rmi 删除镜像 docker rmi -f 镜像id/REPOSITORY docker rmi -f $(docker images -aq) #删除所有 -f #强制 ","date":"2021-12-19","objectID":"/docker/:3:2","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"容器命令 docker run [可选参数] 启动容器 --name=\"名字\" #指定容器名字 -d #后台方式运行 -it #使用交互方式运行,进入容器查看内容 -p #指定容器的端口 ( -p ip:主机端口:容器端口 #配置主机端口映射到容器端口 -p 主机端口:容器端口 -p 容器端口 ) -P #随机指定端口(大写的P) 退出容器(使用-it方式启动) #停止并退出容器（后台方式运行则仅退出） exit #不停止容器退出 #Ctrl+P+Q docker ps 查看容器 docker ps # 默认列出正在运行的容器 -a # 列出所有容器的运行记录 -n=? # 显示最近创建的n个容器 -q # 只显示容器的编号 docker rm 删除容器 docker rm 容器id #删除指定的容器,不能删除正在运行的容器,强制删除使用 rm -f docker rm -f $(docker ps -aq) #删除所有的容器 docker ps -a -q|xargs docker rm #删除所有的容器 启动停止 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止当前运行的容器 docker kill 容器id #强制停止当前容器 ","date":"2021-12-19","objectID":"/docker/:3:3","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"常用命令 docker run -d 镜像名 后台启动 docker run -d centos # 问题：docker ps 发现centos停止了 # 常见问题：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 #nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了 docker logs 容器id 查看日志 docker logs --help docker logs -tf 容器id -t 跟踪 -f 带时间戳 docker logs --tail number 容器id #num为要显示的日志条数 docker top 容器id 查看容器中进程信息 docker top dbaa4ae1699 docker inspect 容器id 查看容器的元数据 # 可以看到启动时带的参数，网卡信息等 docker inspect dbaa4ae1699 进入正在运行的容器 # docker exec 进入容器后开启一个新的终端，可以在里面操作 docker exec -it c703b5b1911f /bin/bash # docker attach 进入容器正在执行的终端，不会启动新的进程 docker attach c703b5b1911f 拷贝操作 #拷贝容器的文件到主机中 docker cp 容器id:容器内路径 目的主机路径 #拷贝宿主机的文件到容器中 docker cp 目的主机路径 容器id:容器内路径 查看容器状态 docker stats 容器id ","date":"2021-12-19","objectID":"/docker/:3:4","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"镜像 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。 ","date":"2021-12-19","objectID":"/docker/:4:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"联合文件系统（分层） 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最終的 文件系统会包含所有底层的文件和目录 所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的项部！这一层就是我们通常说的容器层，容器之下的都叫镜像层！ ","date":"2021-12-19","objectID":"/docker/:4:1","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"创建镜像命令(本地) # docker commit # -a 作者 # -m 提交信息 docker commit -a=\"coderabbit214\" -m=\"es have ik\" df6f751eddc4 elasticsearchik:6.5.4 ","date":"2021-12-19","objectID":"/docker/:4:2","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"容器数据卷 相当于数据同步，本机与容器中的文件相互同步 -v 主机目录:容器目录 举例： docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 容器删除后，本地依然保存 ","date":"2021-12-19","objectID":"/docker/:5:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"常用命令 创建数据卷 docker volume create my-vol 查看所有的数据卷 $ docker volume ls local my-vol 查看指定数据卷的信息 $ docker volume inspect my-vol 删除数据卷 docker volume rm … $ docker volume rm my-vol 删除容器之时删除相关的卷 $ docker rm -v ... ","date":"2021-12-19","objectID":"/docker/:5:1","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"具名挂载和匿名挂载 匿名挂载，具名挂载，指定路径挂载的命令区别如下： -v 容器内路径 #匿名挂载（匿名挂载会在/var/lib/docker/volumes/目录下随机生成文件夹） -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 ","date":"2021-12-19","objectID":"/docker/:5:2","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"读写 指定数据卷映射的相关参数： ro —— readonly 只读。设置了只读则只能操作宿主机的路径，不能操作容器中的对应路径。 rw —– readwrite 可读可写 举例 docker run -d -P --name nginx -v juming-nginx:/etc/nginx:ro nginx docker run -d -P --name nginx -v juming-nginx:/etc/nginx:rw nginx ","date":"2021-12-19","objectID":"/docker/:5:3","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"容器间数据同步实现 –volumes-from 过参数--volumes-from，设置容器2和容器1建立数据卷挂载关系 docker run -it --name 容器名称 --volumes-from 被同步数据容器 镜像id /bin/bash 容器间数据同步与本机和容器挂载卷相同，都是备份操作。 ","date":"2021-12-19","objectID":"/docker/:5:4","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"Dockerfile 用来构建docker镜像的脚本命令 ","date":"2021-12-19","objectID":"/docker/:6:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"初体验 新建文件 dockerfile01 FROM centos VOLUME [\"volume01\",\"volume02\"] CMD echo \"----end----\" CMD /bin/bash 使用命令构建镜像 docker build --name 01 -f dockerfile01 -t coderabbit214/centos:1.0 . 启动自己构建的容器(容器内跟路径下出现volume01、volume02目录) docker run -it 镜像id /bin/bash ","date":"2021-12-19","objectID":"/docker/:6:1","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"指令 指令 说明 FROM 指定基础镜像 MAINTAINER 镜像是谁写的，姓名+邮箱 RUN 镜像构建的时候需要运行的命令 ADD 将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget WORKDIR 镜像的工作目录 VOLUME 挂载的目录 EXPOSE 保留端口配置 CMD 指定这个容器启动的时候要运行的命令（只有最后一个会生效） EMTRYPOINT 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD 当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令，触发指令 COPY 功能类似ADD，但是是不会自动解压文件，也不能访问网络资源 ENV 构建的时候设置环境变量 ","date":"2021-12-19","objectID":"/docker/:6:2","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"实战（制作tomcat并发布） 准备镜像文件tomcat压缩包 编写dockerfile文件，文件名使用官方命名：Dockerfile ，build的时候会默认寻找当前目录下的文件，不需要使用-f参数指定 FROM centos MAINTAINER coderabbit214\u003c1157237955@qq.com\u003e COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.56.tar.gz /usr/local/ RUN yum -y install vim RUN yum install -y java-1.8.0-openjdk-devel.x86_64 ENV MYPATH /usr/local WORKDIR $MYPATH ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.56 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.56 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.56/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.56/bin/logs/catalina.out 使用该Dockerfile构建镜像 docker build -t diytomcat:1.0 . 启动生成的镜像，构建Tomcat容器 docker run -d -p 8088:8080 --name diytomcat -v /home/dockerfile/tomcat/test:/usr/local/apache-tomcat-9.0.56/webapps/test diytomcat:1.0 打开网页查看正确 发布镜像到DockerHub 登陆：docker login -u 用户名 Push:docker push coderabbit214/diytomcat:1.0 用户名➕镜像名➕版本 ","date":"2021-12-19","objectID":"/docker/:6:3","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"本地存储和加载 docker commit docker commit -a \"作者\" -m \"描述\" 容器id xxx:latest(自定义新镜像名) docker save docker save 48b142d6d753 -o /Users/Mr_J/mytomcat.tar docker load docker load -i /Users/Mr_J/mytomcat.tar ","date":"2021-12-19","objectID":"/docker/:6:4","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"docker网络 docker network 查看所有的docker网络 docker network ls Docker默认提供了四个网络模式，说明： bridge：容器默认的网络是桥接模式(自己搭建的网络默认也是使用桥接模式,启动容器默认也是使用桥接模式)。此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 none：不配置网络，容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。 host：容器和宿主机共享Network namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 container：创建的容器不会创建自己的网卡，配置自己的IP容器网络连通。容器和另外一个容器共享Network namespace（共享IP、端口范围）。 docker 创建容器默认使用桥接模式（在同一网段下，可以ping通） 举例： # 创建容器 docker run --name tomcat2 -p 8081:8080 -d tomcat:9.0 docker run --name tomcat1 -p 8080:8080 -d tomcat:9.0 # 查看ip（可以查看文件也可以安装ping命令） docker exec -it tomcat1 cat /etc/hosts 172.17.0.2 fca3c33ef5e3 docker exec -it tomcat2 cat /etc/hosts 172.17.0.3 f49de8901a1e # 使用ping（如果没有就先安装）命令查看是否可以连通 docker exec -it tomcat1 ping 172.17.0.3 # 可以连通 ","date":"2021-12-19","objectID":"/docker/:7:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"容器互联 –link --link的原理是在指定运行的容器上的/etc/hosts文件中添加容器名和ip地址的映射 举例： # 创建容器 连接2 docker run --name tomcat3 --link tomcat2 -p 8082:8080 -d tomcat:9.0 # 尝试ping docker exec -it tomcat3 ping tomcat2 可以ping通 但是反过来容器Tomcat02通过容器名Tomcat03直接ping容器Tomcat03是不行的 原因： 查看tomcat3的/etc/hosts 有host配置，所以可以ping通 查看tomcat2的/etc/hosts 没有host配置，所以不可以ping通 ","date":"2021-12-19","objectID":"/docker/:7:1","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"自定义网络（常用） 命令 docker network --help # 查看网络列表 docker network ls # 查看网络详细信息 docker inspect \u003c网络名称或者id\u003e # 创建网络 docker network create --help --driver bridge #指定bridge驱动程序来管理网络 --subnet 192.168.0.0/16 #指定网段的CIDR格式的子网 --gateway 192.168.0.1 #指定主子网的IPv4或IPv6网关 实例 # 创建网络 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet # 启动容器1 docker run --network mynet -d -P --name tomcat01 tomcat:8.0 # 启动容器2(后配置网络) docker run -d -P --name tomcat02 tomcat:8.0 docker network connect mynet tomcat02 # 配置网络 # 查看网络 docker inspect mynet 网络截图 Docker网络实战练习 Redis集群部署 通过以下脚本创建六个Redis 的配置信息： for port in $(seq 1 6); \\ do \\ mkdir -p redis/node-${port}/conf touch redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003eredis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 192.167.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done 创建六个容器 #第1个Redis容器 for port in $(seq 1 6); \\ do \\ docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\ -v /Users/Mr_J/redis/node-${port}/data:/data \\ -v /Users/Mr_J/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 192.167.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done 创建分片集群 redis-cli --cluster create 192.167.0.11:6379 192.167.0.12:6379 192.167.0.13:6379 192.167.0.14:6379 192.167.0.15:6379 192.167.0.16:6379 --cluster-replicas 1 查看集群信息 SpringBoot项目打包镜像 本地测试无误，打jar包 Dockerfile FROM java:8 COPY actuator-demo-0.0.1-SNAPSHOT.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] 启动 docker run -d -p 8080:8080 demo 测试 ","date":"2021-12-19","objectID":"/docker/:7:2","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"Docker Compose 容器编排 定义和运行多个容器 命令 docker-compose build #构建（重新构建）项目 docker-compose up #启动 docker-compose down #停止 ","date":"2021-12-19","objectID":"/docker/:8:0","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"三步骤 Dockerfile保证我们的项目在任何地方都可以运行。 docker-compose.yml文件编写 docker-compose up启动项目 ","date":"2021-12-19","objectID":"/docker/:8:1","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"安装 查看官网 Install Docker Compose | Docker Documentation ","date":"2021-12-19","objectID":"/docker/:8:2","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"体验 Get started with Docker Compose | Docker Documentation 创建项目目录 mkdir composetest cd composetest 准备项目 app.py import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) requirements.txt flask redis 编写Dockerfile # syntax=docker/dockerfile:1 FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] 编写docker-compose.yml version: \"3.9\" services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 运行 docker-compose up 注意 docker生成两个镜像，启动了两个容器 网络规则：项目中的内容在同一个网络下 ","date":"2021-12-19","objectID":"/docker/:8:3","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"详解docker-compose.yml 版本对应Compose file | Docker Documentation 第三部分命令查询Compose file version 3 reference | Docker Documentation # 第一部分：版本 version: \"3.9\" # 第二部分：服务 services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" # 第三部分：其他 # 网络 # 卷 # 。。。 注意的命令 depends_on (注意依赖关系) version: \"3.9\" services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres ","date":"2021-12-19","objectID":"/docker/:8:4","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"开源项目 Quickstart: Compose and WordPress | Docker Documentation docker-compose.yml version: \"3.9\" services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - wordpress_data:/var/www/html ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} wordpress_data: {} 启动命令 docker-compose up -d ","date":"2021-12-19","objectID":"/docker/:8:5","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["云原生"],"content":"微服务项目部署 编写项目 编写Dockerfile FROM java:8 COPY demo-0.0.1-SNAPSHOT.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] 编写docker-compose.yml version: '3.9' services: demo: build: . depends_on: - redis ports: - \"8080:8080\" redis: image: \"library/redis:alpine\" 启动 ","date":"2021-12-19","objectID":"/docker/:8:6","tags":["容器化"],"title":"Docker","uri":"/docker/"},{"categories":["数据库"],"content":"MyCat ","date":"2021-11-14","objectID":"/mycat/:0:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"本次使用虚拟机 172.16.140.8：mycat 172.16.140.9：master1 172.16.140.10：slave1 172.16.140.11：master2 172.16.140.12：slave2 ","date":"2021-11-14","objectID":"/mycat/:1:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"作用 读写分离 数据分片：垂直拆分(分库)，水平拆分(分表) 多数据源 ","date":"2021-11-14","objectID":"/mycat/:2:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"安装配置 下载地址 解压 tar -zxvf software/Mycat-server-1.6.7.5-release-20200410174409-linux.tar.gz -C /usr/local/ ","date":"2021-11-14","objectID":"/mycat/:3:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"配置 server.xml schema.xml ","date":"2021-11-14","objectID":"/mycat/:3:1","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"启动 /usr/local/mycat/bin/mycat console 启动MyCat： ./mycat start 查看启动状态： ./mycat status 停止： ./mycat stop 重启： ./mycat restart ","date":"2021-11-14","objectID":"/mycat/:3:2","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"连接 mysql -umyCat -p123456 -h 172.16.140.8 -P 8066 ","date":"2021-11-14","objectID":"/mycat/:4:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"读写分离 ","date":"2021-11-14","objectID":"/mycat/:5:0","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"一主一从 主机配置（master1） 修改配置文件：vim /etc/my.cnf #主服务器唯一ID server-id=1 #启用二进制日志 log-bin=mysql-bin # 设置不要复制的数据库(可设置多个) binlog-ignore-db=mysql binlog-ignore-db=information_schema #设置需要复制的数据库 binlog-do-db=需要复制的主数据库名字 #设置logbin格式 binlog_format=MIXED #binlog日志文件 记得给mysql开启权限 log-bin=/data/mysql/mysql-bin.log #binlog过期清理时间 expire_logs_days=7 #binlog每个日志文件大小 max_binlog_size=100m #binlog缓存大小 binlog_cache_size=4m #最大binlog缓存大小 max_binlog_cache_size=512m logbin格式 STATEMENT:直接复制语句 问题：例如now()这种函数会导致数据不同 ROW:直接修改结果 问题：如果修改语句一次性修改一万条，由于性能原因会导致同步慢，日志膨胀 MIXED：会自动选择前两种 从机配置（slave1） 修改配置文件:vim /etc/my.cnf #从服务器唯一ID server-id=2 #启用中继日志 relay-log=mysql-relay 重启主机，从机mysql（防火墙要关闭） 在主机上建立帐户并授权 slave GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' IDENTIFIED BY 'Mm_123456'; #查询master的状态 show master status; #记录下File和Position的值 #执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化 在从机上配置需要复制的主机 #复制主机的命令 CHANGE MASTER TO MASTER_HOST='主机的IP地址', MASTER_USER='slave', MASTER_PASSWORD='123123', MASTER_LOG_FILE='mysql-bin.具体数字',MASTER_LOG_POS=具体值; #启动从服务器复制功能 start slave; #查看从服务器状态 show slave status; #下面两个参数都是Yes，则说明主从配置成功! # Slave_IO_Running: Yes # Slave_SQL_Running: Yes 如果配置错误检查Error 我遇到的错误 两个mysqluuid相同 解决 清除主从 stop slave ; reset master ; 删除其中一个的uuid，重启mysql 重新配置主从 测试 测试mycat，发现读也在writeHost 修改\u003cdataHost\u003e的balance属性，通过此属性配置读写分离的类型 balance=“0”, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上 balance=“1”，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从 模式(M1-\u003eS1，M2-\u003eS2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均衡 balance=“2”，所有读操作都随机的在 writeHost、readhost 上分发 balance=“3”，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力 测试读写分离 ","date":"2021-11-14","objectID":"/mycat/:5:1","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["数据库"],"content":"双主双从 数据库配置 先清除原先一主一从的关系 两个master配置 master1 #主服务器唯一ID server-id=1 #启用二进制日志 log-bin=mysql-bin # 设置不要复制的数据库(可设置多个) binlog-ignore-db=mysql binlog-ignore-db=information_schema #设置需要复制的数据库 binlog-do-db=需要复制的主数据库名字 #设置logbin格式 binlog_format=MIXED # 在作为从数据库的时候，有写入操作也要更新二进制日志文件 log-slave-updates #防止主键冲突 #表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535 auto-increment-increment=2 # 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535 auto-increment-offset=1 master2 #主服务器唯一ID server-id=3 #启用二进制日志 log-bin=mysql-bin # 设置不要复制的数据库(可设置多个) binlog-ignore-db=mysql binlog-ignore-db=information_schema #设置需要复制的数据库 binlog-do-db=需要复制的主数据库名字 #设置logbin格式 binlog_format=MIXED # 在作为从数据库的时候，有写入操作也要更新二进制日志文件 log-slave-updates #防止主键冲突 #表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535 auto-increment-increment=2 # 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535 auto-increment-offset=2 双从机配置 slave1 修改配置文件:vim /etc/my.cnf #从服务器唯一ID server-id=2 #启用中继日志 relay-log=mysql-relay slave2 修改配置文件:vim /etc/my.cnf #从服务器唯一ID server-id=4 #启用中继日志 relay-log=mysql-relay 重启mysql 两个master建立salve账户 GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' IDENTIFIED BY 'Mm_123456'; 两个slave分别与两个master建立主从关系 两个master互相建立主从关系 关系图 MyCat schema.xml balance=“1”: 全部的readHost与stand by writeHost参与select语句的负载均衡。 writeType=“0”: 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个 writeType=“1”，所有写操作都随机的发送到配置的 writeHost，1.5 以后废弃不推荐 writeHost，重新启动后以切换后的为准，切换记录在配置文件中:dnindex.properties switchType=“1”: 1 默认值，自动切换。 -1 表示不自动切换 2 基于 MySQL 主从同步的状态决定是否切换。 \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE mycat:schema SYSTEM \"schema.dtd\"\u003e \u003cmycat:schema xmlns:mycat=\"http://io.mycat/\"\u003e \u003cschema name=\"TESTDB\" checkSQLschema=\"false\" sqlMaxLimit=\"100\" randomDataNode=\"dn1\" dataNode=\"dn1\"\u003e \u003c/schema\u003e \u003cdataNode name=\"dn1\" dataHost=\"host1\" database=\"testMyCat\" /\u003e \u003c!-- --\u003e \u003cdataHost name=\"host1\" maxCon=\"1000\" minCon=\"10\" balance=\"1\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"jdbc\" switchType=\"1\" slaveThreshold=\"100\"\u003e \u003cheartbeat\u003eselect user()\u003c/heartbeat\u003e \u003cwriteHost host=\"hostM1\" url=\"jdbc:mysql://172.16.140.9:3306\" user=\"root\" password=\"Mm_123456\"\u003e \u003creadHost host=\"hostS1\" url=\"jdbc:mysql://172.16.140.10:3306\" user=\"root\" password=\"Mm_123456\" /\u003e \u003c/writeHost\u003e \u003cwriteHost host=\"hostM2\" url=\"jdbc:mysql://172.16.140.11:3306\" user=\"root\" password=\"Mm_123456\"\u003e \u003creadHost host=\"hostS2\" url=\"jdbc:mysql://172.16.140.12:3306\" user=\"root\" password=\"Mm_123456\" /\u003e \u003c/writeHost\u003e \u003c/dataHost\u003e \u003c/mycat:schema\u003e 改完配置记得重启 测试 读写分离 关闭(master1)写入功能正常 ","date":"2021-11-14","objectID":"/mycat/:5:2","tags":["集群","分布式"],"title":"MyCat","uri":"/mycat/"},{"categories":["Java"],"content":"Java反射框架reflections ","date":"2021-10-30","objectID":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/:0:0","tags":["反射"],"title":"Java反射框架reflections","uri":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/"},{"categories":["Java"],"content":"前言 ​ 最近做项目的时候，需要实现一个需求客户要求获取每个接口的具体访问信息，导出到Excel，需要获取到swagger中注解的信息，刚开始想了两种实现方式，一种是请求swagger接口获取信息，另一种是通过反射直接获取，最后采用了反射，在网上浏览资料时发现了这个框架，比较简洁。 ","date":"2021-10-30","objectID":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/:1:0","tags":["反射"],"title":"Java反射框架reflections","uri":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/"},{"categories":["Java"],"content":"依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.reflections\u003c/groupId\u003e \u003cartifactId\u003ereflections\u003c/artifactId\u003e \u003cversion\u003e0.9.11\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-10-30","objectID":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/:2:0","tags":["反射"],"title":"Java反射框架reflections","uri":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/"},{"categories":["Java"],"content":"代码实例 /** * @Author: Mr_J * @Date: 2021/10/29 6:47 下午 */ @Component @Slf4j public class InterfaceStatisticsInitListener implements ApplicationListener\u003cContextRefreshedEvent\u003e { @Override public void onApplicationEvent(ContextRefreshedEvent event) { log.info(\"读取接口层信息开始\"); //构建 反射条件 根据需要添加 Reflections reflections = new Reflections( new ConfigurationBuilder(). //指定路径 setUrls(ClasspathHelper.forPackage(\"com.jsh.reflections.controller\")) .setScanners( //添加方法参数扫描 new MethodParameterScanner() //添加属性注解扫描 ,new FieldAnnotationsScanner() //添加子类扫描 ,new SubTypesScanner() //添加注解扫描 ,new TypeAnnotationsScanner() //添加方法注解扫描 ,new MethodAnnotationsScanner()) ); //根据注解获取类 Set\u003cClass\u003c?\u003e\u003e classes = reflections.getTypesAnnotatedWith(Api.class); classes.forEach(clazz -\u003e { //处理单个类 //反射 Method[] methods = clazz.getMethods(); for (Method method : methods) { ApiOperation annotation = method.getAnnotation(ApiOperation.class); //输出类上注解信息 if (annotation == null) { continue; } System.out.println(annotation.value()); String name = method.getName(); //输出方法名 System.out.println(name); } }); // 反射出子类 Set\u003cClass\u003c? extends TestController\u003e\u003e set = reflections.getSubTypesOf( TestController.class ) ; // 获取带有特定注解对应的方法 Set\u003cMethod\u003e methods = reflections.getMethodsAnnotatedWith( ApiOperation.class ) ; System.out.println(\"m\"+methods); // 获取带有特定注解对应的字段 Set\u003cField\u003e fields = reflections.getFieldsAnnotatedWith( Autowired.class ) ; System.out.println(\"f\"+fields); // 获取特定参数对应的方法 Set\u003cMethod\u003e someMethods = reflections.getMethodsMatchParams(long.class, int.class); System.out.println(\"s\"+someMethods); // 获取特定返回值的方法 Set\u003cMethod\u003e voidMethods = reflections.getMethodsReturn(void.class); System.out.println(\"v\"+voidMethods); //获取参数带有某个注解的方法 Set\u003cMethod\u003e pathParamMethods =reflections.getMethodsWithAnyParamAnnotated(RequestParam.class); System.out.println(\"p\"+pathParamMethods); } } ","date":"2021-10-30","objectID":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/:3:0","tags":["反射"],"title":"Java反射框架reflections","uri":"/java%E5%8F%8D%E5%B0%84%E6%A1%86%E6%9E%B6reflections/"},{"categories":["Java"],"content":"Drools 规则引擎 规则引擎，全称为业务规则管理系统，英文名为BRMS(即Business Rule Management System)。规则引擎的主要思想是将应用程序中的业务决策部分分离出来，并使用预定义的语义模块编写业务决策（业务规则），由用户或开发者在需要时进行配置、管理。 ","date":"2021-10-21","objectID":"/drools/:0:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"优点 1、业务规则与系统代码分离，实现业务规则的集中管理 2、在不重启服务的情况下可随时对业务规则进行扩展和维护 3、可以动态修改业务规则，从而快速响应需求变更 4、规则引擎是相对独立的，只关心业务规则，使得业务分析人员也可以参与编辑、维护系统的业务规则 5、减少了硬编码业务规则的成本和风险 6、使用规则引擎提供的规则编辑工具，使复杂的业务规则实现变得的简单 ","date":"2021-10-21","objectID":"/drools/:1:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"应用场景 对于一些存在比较复杂的业务规则并且业务规则会频繁变动的系统比较适合使用规则引擎 ","date":"2021-10-21","objectID":"/drools/:2:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"初体验 ","date":"2021-10-21","objectID":"/drools/:3:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"spring方式 新建maven项目 pom \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-compiler\u003c/artifactId\u003e \u003cversion\u003e7.10.0.Final\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 测试 --\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e 根据drools要求创建resources/META-INF/kmodule.xml配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003ckmodule xmlns=\"http://www.drools.org/xsd/kmodule\"\u003e \u003c!-- name:指定kbase的名称，可以任意，但是需要唯一 packages:指定规则文件的目录，需要根据实际情况填写，否则无法加载到规则文件 default:指定当前kbase是否为默认 --\u003e \u003ckbase name=\"myKbase1\" packages=\"rules\" default=\"true\"\u003e \u003c!-- name:指定ksession名称，可以任意，但是需要唯一 default:指定当前session是否为默认 --\u003e \u003cksession name=\"ksession-rule\" default=\"true\"/\u003e \u003c/kbase\u003e \u003c/kmodule\u003e 创建实体类 /** * 订单 */ public class Order { private Double originalPrice;//订单原始价格，即优惠前价格 private Double realPrice;//订单真实价格，即优惠后价格 public String toString() { return \"Order{\" + \"originalPrice=\" + originalPrice + \", realPrice=\" + realPrice + '}'; } public Double getOriginalPrice() { return originalPrice; } public void setOriginalPrice(Double originalPrice) { this.originalPrice = originalPrice; } public Double getRealPrice() { return realPrice; } public void setRealPrice(Double realPrice) { this.realPrice = realPrice; } } 创建规则文件resources/rules/bookDiscount.drl //图书优惠规则 package book.discount import com.itheima.drools.entity.Order //规则一：所购图书总价在100元以下的没有优惠 rule \"book_discount_1\" when $order:Order(originalPrice \u003c 100) then $order.setRealPrice($order.getOriginalPrice()); System.out.println(\"成功匹配到规则一：所购图书总价在100元以下的没有优惠\"); end //规则二：所购图书总价在100到200元的优惠20元 rule \"book_discount_2\" when $order:Order(originalPrice \u003c 200 \u0026\u0026 originalPrice \u003e= 100) then $order.setRealPrice($order.getOriginalPrice() - 20); System.out.println(\"成功匹配到规则二：所购图书总价在100到200元的优惠20元\"); end //规则三：所购图书总价在200到300元的优惠50元 rule \"book_discount_3\" when $order:Order(originalPrice \u003c= 300 \u0026\u0026 originalPrice \u003e= 200) then $order.setRealPrice($order.getOriginalPrice() - 50); System.out.println(\"成功匹配到规则三：所购图书总价在200到300元的优惠50元\"); end //规则四：所购图书总价在300元以上的优惠100元 rule \"book_discount_4\" when $order:Order(originalPrice \u003e= 300) then $order.setRealPrice($order.getOriginalPrice() - 100); System.out.println(\"成功匹配到规则四：所购图书总价在300元以上的优惠100元\"); end 测试 @Test public void test1(){ KieServices kieServices = KieServices.Factory.get(); KieContainer kieClasspathContainer = kieServices.getKieClasspathContainer(); //会话对象，用于和规则引擎交互 KieSession kieSession = kieClasspathContainer.newKieSession(); //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 Order order = new Order(); order.setOriginalPrice(210D); //将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配 kieSession.insert(order); //激活规则引擎，如果规则匹配成功则执行规则 kieSession.fireAllRules(); //关闭会话 kieSession.dispose(); System.out.println(\"优惠前原始价格：\" + order.getOriginalPrice() + \"，优惠后价格：\" + order.getRealPrice()); } //使用字符串 @Test public void test2(){ String myRule = \"//图书优惠规则\\n\" + \"package book.discount\\n\" + \"import com.jsh.droolsdemo.entity.Order\\n\" + \"\\n\" + \"//规则一：所购图书总价在100元以下的没有优惠\\n\" + \"rule \\\"book_discount_1\\\"\\n\" + \" when\\n\" + \" $order:Order(originalPrice \u003c 100)\\n\" + \" then\\n\" + \" $order.setRealPrice($order.getOriginalPrice());\\n\" + \" System.out.println(\\\"成功匹配到规则一：所购图书总价在100元以下的没有优惠\\\");\\n\" + \"end\\n\" + \"\\n\" + \"//规则二：所购图书总价在100到200元的优惠20元\\n\" + \"rule \\\"book_discount_2\\\"\\n\" + \" when\\n\" + \" $order:Order(originalPrice \u003c 200 \u0026\u0026 originalPrice \u003e= 100)\\n\" + \" then\\n\" + \" $order.setRealPrice($order.getOriginalPrice() - 20);\\n\" + \" System.out.println(\\\"成功匹配到规则二：所购图书总价在100到200元的优惠20元\\\");\\n\" + \"end\\n\" + \"\\n\" + \"//规则三：所购图书总价在200到300元的优惠50元\\n\" + \"rule \\\"book_discount_3\\\"\\n\" + \" when\\n\" + \" $order:Order(originalPrice \u003c= 300 \u0026\u0026 originalPrice \u003e= 200)\\n\" + \" then\\n\" + \" $order.setRealPrice($order.getOriginalPrice() - 50);\\n\" + \" System.out.println(\\\"成功匹配到规则三：所购图书总价在200到300元的优惠50元\\\");\\n\" + \"end\\n\" + \"\\n\" + \"//规则四：所购图书总价在300元以上的优惠100元\\n\" + \"rule \\\"book_discount_4\\\"\\n\" + \" when\\n\" + \" $order:Order(originalPrice \u003e= 300)\\n\" + \" then\\n\" + \" $order.setRealPrice($order.getOriginalPrice() - 100);\\n\" + \" System.out.println(\\\"成功匹配到规则四：所购图书总价在300元以上的优惠100元\\\");\\n","date":"2021-10-21","objectID":"/drools/:3:1","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"springboot方式 新建springboot项目 pom \u003cproperties\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003cdrools.version\u003e7.14.0.Final\u003c/drools.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003c!-- drools依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-core\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-compiler\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 决策表 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-decisiontables\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 模板 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.drools\u003c/groupId\u003e \u003cartifactId\u003edrools-templates\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.kie\u003c/groupId\u003e \u003cartifactId\u003ekie-api\u003c/artifactId\u003e \u003cversion\u003e${drools.version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e config @Configuration public class KiaSessionConfig { private static final String RULES_PATH = \"rules/\"; @Bean public KieFileSystem kieFileSystem() throws IOException { KieFileSystem kieFileSystem = getKieServices().newKieFileSystem(); for (Resource file : getRuleFiles()) { kieFileSystem.write(ResourceFactory.newClassPathResource(RULES_PATH + file.getFilename(), \"UTF-8\")); } return kieFileSystem; } private Resource[] getRuleFiles() throws IOException { ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver(); final Resource[] resources = resourcePatternResolver.getResources(\"classpath*:\" + RULES_PATH + \"**/*.*\"); return resources; } @Bean public KieContainer kieContainer() throws IOException { final KieRepository kieRepository = getKieServices().getRepository(); kieRepository.addKieModule(new KieModule() { @Override public ReleaseId getReleaseId() { return kieRepository.getDefaultReleaseId(); } }); KieBuilder kieBuilder = getKieServices().newKieBuilder(kieFileSystem()); kieBuilder.buildAll(); return getKieServices().newKieContainer(kieRepository.getDefaultReleaseId()); } private KieServices getKieServices() { return KieServices.Factory.get(); } @Bean public KieBase kieBase() throws IOException { return kieContainer().getKieBase(); } @Bean public KieSession kieSession() throws IOException { return kieContainer().newKieSession(); } } 创建实体类 /** * 订单 */ public class Order { private Double originalPrice;//订单原始价格，即优惠前价格 private Double realPrice;//订单真实价格，即优惠后价格 public String toString() { return \"Order{\" + \"originalPrice=\" + originalPrice + \", realPrice=\" + realPrice + '}'; } public Double getOriginalPrice() { return originalPrice; } public void setOriginalPrice(Double originalPrice) { this.originalPrice = originalPrice; } public Double getRealPrice() { return realPrice; } public void setRealPrice(Double realPrice) { this.realPrice = realPrice; } } 创建规则文件resources/rules/bookDiscount.drl //图书优惠规则 package book.discount import com.itheima.drools.entity.Order //规则一：所购图书总价在100元以下的没有优惠 rule \"book_discount_1\" when $order:Order(originalPrice \u003c 100) then $order.setRealPrice($order.getOriginalPrice()); System.out.println(\"成功匹配到规则一：所购图书总价在100元以下的没有优惠\"); end //规则二：所购图书总价在100到200元的优惠20元 rule \"book_discount_2\" when $order:Order(originalPrice \u003c 200 \u0026\u0026 originalPrice \u003e= 100) then $order.setRealPrice($order.getOriginalPrice() - 20); System.out.println(\"成功匹配到规则二：所购图书总价在100到200元的优惠20元\"); end //规则三：所购图书总价在200到300元的优惠50元 rule \"book_discount_3\" when $order:Order(originalPrice \u003c= 300 \u0026\u0026 originalPrice \u003e= 200) then $order.setRealPrice($order.getOriginalPrice() - 50); System.out.println(\"成功匹配到规则三：所购图书总价在200到300元的优惠50元\"); end //规则四：所购图书总价在300元以上的优惠100元 rule \"book_discount_4\" when $order:Order(originalPrice \u003e= 300) then $order.setRealPrice($order.getOriginalPrice() - 100); System.out.println(\"成功匹配到规则四：所购图书总价在300元以上的优惠100元\"); end 测试 @SpringBootTest class DroolsDemoApplicationTests2 { @Autowired private KieSession session; @Autowired private KieBase kieBase; @Test public void test1(){ //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 Order order = new Order(); order.setOriginalPrice","date":"2021-10-21","objectID":"/drools/:3:2","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"匹配规则 规则格式（举例） rule \"book_discount_1\" when $order:Order(originalPrice \u003c 100) then $order.setRealPrice($order.getOriginalPrice()); System.out.println(\"成功匹配到规则一：所购图书总价在100元以下的没有优惠\"); end When(匹配规则) 没有约束（只匹配类型） when Order() 条件约束 when Order(originalPrice \u003c 100) 匹配规则并绑定数据 when $order:Order(originalPrice \u003c 100) 可以多个类 @Test public void test2(){ //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 Cat cat = new Cat(); cat.setSex(0); Order order = new Order(); order.setOriginalPrice(99D); //将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配 session.insert(order); session.insert(cat); //激活规则引擎，如果规则匹配成功则执行规则 session.fireAllRules(); //关闭会话 session.dispose(); } when $order:Order(originalPrice \u003c 100) and $cat:Cat(sex == 0) ","date":"2021-10-21","objectID":"/drools/:4:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"约束 约束 描述 !. 使用此运算符可以以空安全的方式取消引用属性。!.运算符左侧的值不能为null（解释为!= null） [] 按List索引访问值或Map按键访问值 \u003c，\u003c=，\u003e，\u003e= 在具有自然顺序的属性上使用这些运算符 ==, != 在约束中使用这些运算符作为equals()和!equals()方法 \u0026\u0026，|| 组合关系条件 matches，not matches 使用这些运算符可以指示字段与指定的Java正则表达式匹配或不匹配 contains，not contains 使用这些运算符可以验证Array或字段是否包含或不包含指定值 memberOf，not memberOf 使用这些运算符可以验证字段是否为定义为变量Array的成员 soundslike 使用英语发音来验证单词是否具有与给定值几乎相同的声音（类似于该matches运算符） in，notin 使用这些运算符可以指定一个以上的可能值来匹配约束（复合值限制） from 取集合中的元素 例： 实体类 @Data public class Animal { private List\u003cCat\u003e cats; } @Data public class Cat { private int sex; private String name; } drl package com.jsh.animal import com.jsh.droolsdemo.entity.Animal import com.jsh.droolsdemo.entity.Cat rule \"from\" when $an : Animal() $p : Cat(sex != 3) from $an.cats then System.out.println($p); end 测试 //测试from @Test public void test3(){ //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 List\u003cCat\u003e cats = new ArrayList\u003c\u003e(); Cat cat = new Cat(); cat.setSex(0); cat.setName(\"11\"); Cat cat1 = new Cat(); cat1.setSex(0); cat1.setName(\"22\"); Cat cat2 = new Cat(); cat2.setSex(0); cat2.setName(\"33\"); Cat cat3 = new Cat(); cat3.setSex(0); cat3.setName(\"44\"); cats.add(cat); cats.add(cat1); cats.add(cat2); cats.add(cat3); Animal animal = new Animal(); animal.setCats(cats); session.insert(animal); //激活规则引擎，如果规则匹配成功则执行规则 session.fireAllRules(); //关闭会话 session.dispose(); } 输出 collect 获取集合 ","date":"2021-10-21","objectID":"/drools/:4:1","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"RHS动作 ","date":"2021-10-21","objectID":"/drools/:5:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"主要操作 动作 描述 set 给属性赋值 modify 将改变通知drolls引擎 update 将改变通知drolls引擎 insert 将新实事插入到drools引擎的工作 insertLogical insert增强版，需声明撤回事件，或待不在匹配条件后自动撤回 delete 删除实事 update Update用于将数据的更改更新到引擎，并通知引擎重新匹配该事实 rule \"update\" when $an : Cat(sex == 0) then System.out.println($an); $an.setSex(1); update($an) end rule \"update2\" when $an : Cat(sex == 1) then System.out.println($an); end 测试 // 测试update @Test public void test4(){ Cat cat = new Cat(); cat.setSex(0); session.insert(cat); //激活规则引擎，如果规则匹配成功则执行规则 session.fireAllRules(); //关闭会话 session.dispose(); } 输出 modify 和update功能一样 rule \"update\" when $an : Cat(sex == 0) then System.out.println($an); // $an.setSex(1); // update($an) modify($an){ setSex(1) } end ","date":"2021-10-21","objectID":"/drools/:5:1","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"核心算法Rete 拉丁语单词\"rete\"的意思是\"网络\"或\"网络\"。Rete 算法可分为两个部分：规则编译和运行时间执行。 原文链接 ","date":"2021-10-21","objectID":"/drools/:6:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"ReteNode 是所有对象进入网络的入口，然后进入到TypeNode ","date":"2021-10-21","objectID":"/drools/:6:1","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"ObjectTypeNode 是我们规则所用到的pojo，ObjectTypeNode就是类型检查，引擎只让匹配Object 类型的对象到达节点 ","date":"2021-10-21","objectID":"/drools/:6:2","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"AlphaNode Drools 通过散列法优化了从 ObjectTypeNode 到 AlphaNode 的传播。每次一个 AlphaNode 被加到一个 ObjectTypeNode 的时候，就以字面值（ literal value ）作为 key ，以 AlphaNode 作为 value 加入 HashMap 。当一个新的实例进入 ObjectTypeNode 的时候，不用传递到每一个 AlphaNode ，它可以直接从 HashMap 中获得正确的 AlphaNode ，避免了不必要的字面检查。 例如：Cheese （name＝”cheddar” ,strengh==”strong”) ","date":"2021-10-21","objectID":"/drools/:6:3","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"JoinNode 用来对2个对象进行对比、检查。约定JoinNode的2个输入称为左边和右边。左边通常是一个运算后的结果（LeftInputNodeAdapter），右边通常是一个ObjectTypeNode。 举例： rule when Cheese( $chedddar : name == \"cheddar\" ) $person : Person( favouriteCheese == $cheddar ) then System.out.println( $person.getName() + \" likes cheddar\" ); end rule when Cheese( $chedddar : name == \"cheddar\" ) $person : Person( favouriteCheese != $cheddar ) then System.out.println( $person.getName() + \" does not like cheddar\" ); end 这里就共用了一个Cheese( $chedddar : name == \"cheddar\" )的结果 ","date":"2021-10-21","objectID":"/drools/:6:4","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"问题 同一规则有多个或的判断条件，如何分组、指定优先级呢? 分组(如果传入的是列表，只会触发列表中的一个数据) activation-group(同一个组内只有一个会执行) agenda-group(同一个组内，要不都执行，要不都不执行) 优先级 salience：数值越大越先执行 规则的数量会影响Drools的执行效率? 不会 Rete算法是一种前向规则快速匹配算法，其匹配速度与规则数目无关 规则会在项目启动时创建rete网络 在运行时只会运行匹配的规则 用空间换时间 Drools的function、global属性的作用？能运用到什么场景？ global：定义全局变量 用于多个规则都需要使用的变量 规则内部使用的类无法得到的变量 function：定义方法（和java一样） 使用静态类对外赋值 如何指定特定规则运行？ 在fireAllRules中传入过滤器（AgendaFilter的子类） 如何动态管理规则？因为在实际业务中，规则条件极有可能发生变化。【思考题】 当存在大量的规则编写时，如何提高规则编写的效率。【开发问题】 通过规则分组，或者通过指标编号分组 Drools为什么快？核心算法及其原理是什么？【进阶】 Rete(拉丁语,英语:net)算法 原理： 通过规则条件生成了一个网络，每个规则条件是网络中的一个节点 rete可以被分为两部分：规则编译和运行时执行。规则编译是指根据规则集生成推理网络的过程，运行时执行指将数据送入推理网络进行筛选的过程 ","date":"2021-10-21","objectID":"/drools/:7:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Java"],"content":"使用心得 如何调用外界的方法（类似放入需要规则判断的数据，在drools文件中可以调用方法） 在kieSession中放入类（java） kieSession.insert(); 声明类，调用方法（drools文件） //声明 $fs: financialServiceImpl() //使用（对别的类的参数进行判断） $fs.getcompAveBvSecuritvCode(参数...) 如何在Drools中对外（Java）写出。（使用静态方法） 声明及静态方法（java） public class MessageList { public static List\u003cString\u003e testList = new Vector\u003c\u003e(); public static void init(){ testList.clear(); } public static void add(Object result){ if (result != null) { if (result instanceof String) { testList.add((String) result); } } } } 调用方法进行操作(java) @Test public void test1(){ //构造订单对象，设置原始价格，由规则引擎根据优惠规则计算优惠后的价格 Order order = new Order(); order.setOriginalPrice(59D); //将数据提供给规则引擎，规则引擎会根据提供的数据进行规则匹配 Order order1 = new Order(); order1.setOriginalPrice(91D); MessageList.init(); session.insert(order); // session.fireAllRules(); session.insert(order1); //激活规则引擎，如果规则匹配成功则执行规则 session.fireAllRules(); //关闭会话 session.dispose(); System.out.println(\"优惠前原始价格：\" + order.getOriginalPrice() + \"，优惠后价格：\" + order.getRealPrice()); System.out.println(\"优惠前原始价格：\" + order1.getOriginalPrice() + \"，优惠后价格：\" + order1.getRealPrice()); for (String s : MessageList.testList) { System.out.println(s); } } drools //添加方法 function void setString(String s) { MessageList.add(s); } //规则一：所购图书总价在100元以下的没有优惠 rule \"book_discount_1\" when $order:Order(originalPrice \u003c 100) then $order.setRealPrice($order.getOriginalPrice() - 10); setString($order.getOriginalPrice().toString()); end 单条数据对应单个规则可以批量传入数据，如果对应多段规则必须分组单条传入 ","date":"2021-10-21","objectID":"/drools/:8:0","tags":["规则引擎"],"title":"Drools","uri":"/drools/"},{"categories":["Spring"],"content":"Springboot自动装配 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:0:0","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"Springboot自动装配 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:1:0","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"怎么给spring容器添加组件 原来的SSM使用xml文件 \u003cbean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"\u003e \u003cproperty name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/\u003e \u003cproperty name=\"url\" value=\"${jdbc.url}\"/\u003e \u003cproperty name=\"username\" value=\"${jdbc.username}\"/\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"/\u003e \u003c/bean\u003e Springboot 方式 @Configuration 等同于配置文件 参数：proxyBeanMethods: true单实例(别人依赖时使用) false多实例(别人不依赖时使用) @Bean 等同于原来的bean 把返回值放在spring容器中 默认单实例 @ConditionalOnBean(条件) 可以加在方法上和类上，满足条件后才会加载 @Import({class, class…}) 可以自动创建出这几个类型的组件，默认是全类名(包名➕类名) @ImportResource(“资源路径”) 解析xml文件到spring容器中 @ConfigurationProperties(“j j j”) 获取配置的变量 需要和一下两个注解结合使用 @Configuration 和@ConfigurationProperties在一起使用 @EnableConfigurationProperties(XXXProperties.class) 引用时使用 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:1:1","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"自动配置原理 SpringBootApplication @SpringBootConfiguration表示是一个配置类 @ComponentScan 包扫描 @EnableAutoConfiguration 重要 自动装配 @AutoConfigurationPackage @Import(AutoConfigurationPackages.Registrar.class) 利用Registrar给容器中导入一系列组件 将指定的（MainApplication）包下的所有组件倒入容器中 @Import(AutoConfigurationImportSelector.class) AutoConfigurationImportSelector.class 主要是这句获取容器中所有组件 List\u003cString\u003e configurations = getCandidateConfigurations(annotationMetadata, attributes); 一路找下去 最后到 这个方法扫描spring-boot-autoconfigure自动配置类 文件里边写死了springboot一启动就要加载的组件默认全部加载，最终会按需配置（@ConditionalXXX） ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:1:2","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"自定义starter starter:是一种开发场景，可以引入很多autoconfigure autoconfigure：自动装配 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:2:0","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"代码实现 starter 只需要引入autoconfigure即可 pom \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.jsh\u003c/groupId\u003e \u003cartifactId\u003ejsh-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.jsh\u003c/groupId\u003e \u003cartifactId\u003ejsh-spring-boot-starter-autoconfigure\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e autoconfigure 编写XXXProperties引入配置的变量 @ConfigurationProperties(\"jsh\") public class JshProperties { private String prefix; private String suffix; public JshProperties() { } public JshProperties(String prefix, String suffix) { this.prefix = prefix; this.suffix = suffix; } public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } } 编写具体的业务或者配置 service /** * 默认不要放在容器中 */ public class HelloService { @Autowired JshProperties jshProperties; public String sayHello(String userName){ return jshProperties.getPrefix()+\":\"+userName+\":\"+jshProperties.getSuffix(); } } XXXAutoConfiguration @Configuration @EnableConfigurationProperties(JshProperties.class) //默认JshProperties放在容器中 public class JshServiceAutoConfiguration { @Bean @ConditionalOnMissingBean(HelloService.class) public HelloService helloService(){ return new HelloService(); } } META-INF spring.factories # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.jsh.auto.JshServiceAutoConfiguration ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:2:1","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"使用 引入依赖 配置 使用 ","date":"2021-10-06","objectID":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/:2:2","tags":["框架","原理"],"title":"Springboot自动装配","uri":"/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"},{"categories":["中间件"],"content":"RocketMQ ","date":"2021-09-13","objectID":"/rocketmq/:0:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"应用场景 异步解藕 削峰填谷 消息分发 ","date":"2021-09-13","objectID":"/rocketmq/:1:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"环境搭建 上传rocketmq-all-4.4.0-bin-release.zip 到家目录 使用解压命令进行解压 unzip /usr/local/rocketmq-all-4.4.0-bin-release.zip 软件重命名 mv /usr/local/rocketmq-all-4.4.0-bin-release/ /usr/local/rocketmq-4.4/ 修改启动参数配置 JAVA_OPT=\"${JAVA_OPT} -server -Xms1g -Xmx1g -Xmn1g\" 两个文件 vi /usr/local/rocketmq-4.4/bin/runbroker.sh vi /usr/local/rocketmq-4.4/bin/runserver.sh 启动名字服务和代理服务 nohup sh /usr/local/rocketmq-4.4/bin/mqnamesrv \u0026 # -n localhost:9876 指定名称服务的地址, 类似于zk的地址 nohup sh /usr/local/rocketmq-4.4/bin/mqbroker -n localhost:9876 -c /usr/local/rocketmq-4.4/conf/broker.conf \u0026 检验是否启动正常 使用java的内置命令: jps 可以看到BrokerStartup和NamesrvStartup进程 使用Linux命令**: netstat-ntlp 可以看到9876的端口和10911的端口** 使用ps-ef |grep java 查看启动日志: tail -100f ~/logs/rocketmqlogs/namesrv.log tail -100f ~/logs/rocketmqlogs/broker.log 关闭RocketMQ # 1.关闭NameServer sh /usr/local/rocketmq-4.4/bin/mqshutdown namesrv # 2.关闭Broker sh /usr/local/rocketmq-4.4/bin/mqshutdown broker ","date":"2021-09-13","objectID":"/rocketmq/:2:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"编写sh脚本文件 启动(startRocketMQ.sh) # !/bin/bash echo '------------------rocketmq-nameServer-starter-------------------------' nohup sh /usr/local/rocketmq-4.4/bin/mqnamesrv \u0026 echo '------------------rocketmq-nameServer-started-------------------------' echo '------------------rocketmq-brokerServer-starter-----------------------' nohup sh /usr/local/rocketmq-4.4/bin/mqbroker -n localhost:9876 -c /usr/local/rocketmq-4.4/conf/broker.conf \u0026 echo '------------------rocketmq-brokerServer-started-----------------------' 关闭(stutdownRocketMQ.sh) # !/bin/bash echo '------------------rocketmq-nameServer-shutdown-------------------------' sh /usr/local/rocketmq-4.4/bin/mqshutdown namesrv echo '------------------rocketmq-nameServer-shutdowned-------------------------' echo '------------------rocketmq-brokerServer-shutdown-----------------------' sh /usr/local/rocketmq-4.4/bin/mqshutdown broker echo '------------------rocketmq-brokerServer-shutdowned-----------------------' ","date":"2021-09-13","objectID":"/rocketmq/:2:1","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"监控平台 使用jar nohup java -jar rocketmq-console-ng-1.0.1.jar \u0026 ","date":"2021-09-13","objectID":"/rocketmq/:3:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"SpringBoot集成 ","date":"2021-09-13","objectID":"/rocketmq/:4:0","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.rocketmq\u003c/groupId\u003e \u003cartifactId\u003erocketmq-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.0.3\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-09-13","objectID":"/rocketmq/:4:1","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"配置 生产者 rocketmq.name-server=127.0.0.1:9876 rocketmq.producer.group=my-group 消费者 rocketmq.name-server=127.0.0.1:9876 ","date":"2021-09-13","objectID":"/rocketmq/:4:2","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["中间件"],"content":"编码 生产者 @RestController public class HelloController { @Autowired private RocketMQTemplate rocketMQTemplate; @RequestMapping(\"01-hello\") public String sendMsg(String message,String age) throws Exception{ //发送消息 SendResult sendResult = rocketMQTemplate.syncSend(\"01-boot:\", message); System.out.println(sendResult.getMsgId()); System.out.println(sendResult.getSendStatus()); return \"success\"; } } 消费者 @Component @RocketMQMessageListener( topic = \"01-boot\", consumerGroup = \"wolfcode-consumer\" ) public class HelloConsumer implements RocketMQListener\u003cMessageExt\u003e { @Override public void onMessage(MessageExt messageExt) { System.out.println(\"消费消息\"+messageExt); } } 发送消息方式(生产者) 发送类型 同步消息 SendResult sendResult = rocketMQTemplate.syncSend(\"020-boot\", msg); System.out.println(sendResult.getMsgId()); System.out.println(sendResult.getSendStatus()); 异步消息 rocketMQTemplate.asyncSend(\"020-boot\", msg, new SendCallback() { @Override public void onSuccess(SendResult sendResult) { System.out.println(sendResult.getMsgId()); System.out.println(sendResult.getSendStatus()); } @Override public void onException(Throwable throwable) { System.out.println(throwable); } }); 一次性消息 rocketMQTemplate.sendOneWay(\"020-boot\", msg); 发送时间 默认立即发送 延时发送 // 参数1:主题 2:消息 3:rocket发送最大允许时间 4:延时级别(18级) SendResult sendResult = rocketMQTemplate.syncSend(\"020-boot\", MessageBuilder.withPayload(msg).build(),100000,3); 消费模式(消费者) 以组为单位 默认为集群模式 集群模式(每组只有一个可以收到) @Component @RocketMQMessageListener( topic = \"020-boot\", messageModel = MessageModel.CLUSTERING, consumerGroup = \"wolfcode-consumer\" ) public class MqListenner implements RocketMQListener\u003cString\u003e { @Override public void onMessage(String s) { System.out.println(\"今天上映:\"+s); } } 广播模式(每组的所有消费者都可以收到) @Component @RocketMQMessageListener( topic = \"020-boot\", messageModel = MessageModel.BROADCASTING, consumerGroup = \"wolfcode-consumer\" ) public class MqListenner implements RocketMQListener\u003cString\u003e { @Override public void onMessage(String s) { System.out.println(\"今天上映:\"+s); } } 消息过滤 Tag标签模式 在发送的消息Topic:Tag 中间使用冒号隔开 生产者 @RequestMapping(\"/sendTagMsg\") public String sendTagMsg(String msg) { rocketMQTemplate.convertAndSend(\"020-boot:TagB\",msg); return \"success\"; } 消费者 @Component @RocketMQMessageListener( topic = \"020-boot\", selectorType = SelectorType.TAG, //接收TagB或TagA secretKey = \"TagB || TagA\", consumerGroup = \"wolfcode-consumer\" ) public class MqListenner implements RocketMQListener\u003cString\u003e { @Override public void onMessage(String s) { System.out.println(\"今天上映:\"+s); } } SQL92过滤 注意: 在使用SQL过滤的时候, 需要配置参数enablePropertyFilter=true 生产者 //Sql92过滤 @RequestMapping(\"/sendSQLMsg\") public String sendSQLMsg(int age,String msg) { Map\u003cString,Object\u003e map=new HashMap\u003c\u003e(); //用户自定义属性 map.put(\"age\", age); map.put(\"name\", \"hesj\"); //也可以设置系统属性 map.put(MessageConst.PROPERTY_KEYS,age); template.convertAndSend(\"02-RocketMQ-Top7\",msg,map); return \"success\"; } 消费者 @Component @RocketMQMessageListener( topic = \"02-RocketMQ-Top7\", messageModel = MessageModel.CLUSTERING, selectorType = SelectorType.SQL92, selectorExpression = \"age \u003e 16\", consumerGroup= \"wolfcode-consumer7\" ) public class MqListiner7 implements RocketMQListener\u003cString\u003e { @Override public void onMessage(String msg) { System.out.println(\"消费消息SQl92\"+msg); } } ​ ","date":"2021-09-13","objectID":"/rocketmq/:4:3","tags":["消息队列"],"title":"RocketMQ","uri":"/rocketmq/"},{"categories":["SpringCloud"],"content":"SpringCloud ","date":"2021-09-04","objectID":"/springcloud/:0:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Nacos 注册服务中心 ","date":"2021-09-04","objectID":"/springcloud/:1:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"启动命令 //单机 sh startup.sh -m standalone ","date":"2021-09-04","objectID":"/springcloud/:1:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"简介 为什么叫Nacos 前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service。 是什么 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Nacos: Dynamic Naming and Configuration Service Nacos就是注册中心＋配置中心的组合 -\u003e Nacos = Eureka+Config+Bus 核心功能点: 服务注册: Nacos Client会通过发送REST请求想Nacos Server注册自己的服务，提供自身的元数据，比如IP地址，端口等信息。Nacos Server接收到注册请求后，就会把这些元数据存储到一个双层的内存Map中。 服务心跳: 在服务注册后，Nacos Client会维护一个定时心跳来维持统治Nacos Server,说明服务一致处于可用状态，防止被剔除，默认5s发送一次心跳 服务同步: Nacos Server集群之间会相互同步服务实例，用来保证服务信息的一致性。 服务发现： 服务消费者(Nacos Client)在调用服务提供的服务时，会发送一个REST请求给Nacos Server,获取上面注册的服务清单，并且缓存在Nacos Client本地,同时会在Nacos Client本地开启一个定时任务拉取服务最新的注册表信息更新到本地缓存。 服务健康检查: Nacos Server 会开启一个定时任务来检查注册服务实例的健康情况，对于超过15s没有收到客户端心跳的实例会将他的healthy属性设置为false(客户端服务发现时不会发现)，如果某个实例超过30s没有收到心跳，直接剔除该实例(被剔除的实例如果恢复发送心跳则会重新注册) ","date":"2021-09-04","objectID":"/springcloud/:1:2","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"搭建 pom \u003c!--nacos客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e yml（添加注册中心地址） spring: cloud: nacos: discovery: server-addr: localhost:8848 在主类上添加**@EnableDiscoveryClient**注解 @SpringBootApplication @EnableDiscoveryClient public class ProductServer { public static void main(String[] args) { SpringApplication.run(ProductServer.class,args); } } 查看nacos控制台出现服务 ","date":"2021-09-04","objectID":"/springcloud/:1:3","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"配置中心 Nacos Confifig入门 Nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则 说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。 在 Nacos Spring Cloud中,dataId的完整格式如下： ${prefix}-${spring-profile.active}.${file-extension} prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。 spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符 - 也将不存在，datald 的拼接格式变成${prefix}.${file-extension} file-exetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.file-extension来配置。目前只支持properties和yaml类型。 通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。 搭建nacos环境 在商品微服务中引入nacos的依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-config\u003c/artifactId\u003e \u003c/dependency\u003e 在微服务中添加nacos config的配置 注意:不能使用原来的application.yml作为配置文件，而是新建一个bootstrap.yml作为配置文件 配置文件优先级(由高到低): bootstrap.properties -\u003e bootstrap.yml -\u003e application.properties -\u003e application.yml spring: application: name: product-service cloud: nacos: config: server-addr: 127.0.0.1:8848 #nacos中心地址 file-extension: yaml # 配置文件格式 profiles: active: dev # 环境标识 在nacos中添加配置,然后把商品微服务application.yml配置复制到配置内容中. 注释本地的application.yam中的内容， 启动程序进行测试 如果依旧可以成功访问程序，说明我们nacos的配置中心功能已经实现 完整配置 DataID+Group+Namespace确定读取哪个配置文件 dataId的完整格式:${prefix}-${spring-profile.active}.${file-extension} spring: application: name: product-service cloud: nacos: config: server-addr: 127.0.0.1:8848 #nacos中心地址 file-extension: yaml # 配置文件格式 # namespace: # group: profiles: active: dev # 环境标识 动态刷新 在controller上加注解@RefreshScope 配置共享 同一微服务配置共享 只需要提取一个以 spring.application.name 命名的配置文件，然后将其所有环境的公共配置放在里面即可 不加「-开发环境」就可以 不同微服务配置共享 不同为服务之间实现配置共享的原理类似于文件引入，就是定义一个公共配置，然后在当前配置中引入。 在nacos中定义一个DataID为global-config.yaml的配置，用于所有微服务共享 globalConfig: global 修改bootstrap.yaml spring: application: name: product-service cloud: nacos: config: server-addr: 127.0.0.1:8848 #nacos中心地址 file-cextension: yaml # 配置文件格式 shared-configs: - data-id: global-config.yaml # 配置要引入的配置 refresh: true profiles: active: test # 环境标识 在NacosConfigController.java中新增一个方法 @RestController @RefreshScope public class NacosConfigController { @Value(\"${appConfig.name}\") private String appConfigName; @Value(\"${env}\") private String env; @Value(\"${globalConfig}\") private String globalConfig; @RequestMapping(\"/nacosConfig1\") public String nacosConfig(){ return \"远程信息:\"+appConfigName; } @RequestMapping(\"/nacosConfig2\") public String nacosConfig2(){ return \"公共配置:\"+appConfigName+\",环境配置信息:\"+env; } @RequestMapping(\"/nacosConfig3\") public String nacosConfig3(){ return \"全局配置:\"+globalConfig+\",公共配置:\"+appConfigName+\",环境配置信息:\"+env; } } 重启服务并测试. ","date":"2021-09-04","objectID":"/springcloud/:1:4","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Nacos持久化 nacos-server-1.1.4\\nacos\\conf录下找到nacos-mysql.sql文件，执行脚本。 nacos-server-1.1.4\\nacos\\conf目录下找到application.properties，添加以下配置（按需修改对应值）。 spring.datasource.platform=mysql db.num=1 db.url.0=jdbc:mysql://localhost:3306/nacos_devtest?characterEncoding=utf8\u0026connectTimeout=1000\u0026socketTimeout=3000\u0026autoReconnect=true db.user=root db.password=1234 重启 ","date":"2021-09-04","objectID":"/springcloud/:1:5","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Nacos集群 必须持久化 配置cluster.conf # 三个服务器加端口 192.168.111.144:3333 192.168.111.144:4444 192.168.111.144:5555 分别启动三个nacos 配置nginx作为负载均衡器 upstream cluster{ server 127.0.0.1:3333; server 127.0.0.1:4444; server 127.0.0.1:5555; } server { listen 1111; server_name 127.0.0.1; location / { proxy_pass http://cluster; } } 启动2222 3333 4444 nginx 测试 测试通过nginx，访问nacos - http://127.0.0.1:1111/nacos/#/login 修改配置看是否会同步？会 让微服务cloudalibaba-provider-payment9002启动注册进nacos集群 - 修改配置文件 server: port: 9002 spring: application: name: nacos-payment-provider c1oud: nacos: discovery: #配置Nacos地址 #server-addr: Localhost:8848 #换成nginx的1111端口，做集群 server-addr: 192.168.111.144:1111 management: endpoints: web: exposure: inc1ude: '*' 启动微服务cloudalibaba-provider-payment9002 访问nacos，查看注册结果 总结 ","date":"2021-09-04","objectID":"/springcloud/:1:6","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Ribbon 负载均衡 ","date":"2021-09-04","objectID":"/springcloud/:2:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"配置负载均衡策略 com.netflix.loadbalancer.IRule , 具体的负载策略如下图所示: 策略名 策略描述 实现说明 AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例； 使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态 WeightedResponseTimeRule 根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。 一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权 RetryRule 对选定的负载均衡策略机上重试机制。 在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server RoundRobinRule 轮询方式轮询选择server 轮询index，选择index对应位置的server RandomRule 随机选择一个server 在index上随机，选择index对应位置的server BestAvailableRule 选择一个最小的并发请求的server 逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server ZoneAvoidanceRule(默认) 复合判断server所在区域的性能和server的可用性选择server 使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。 我们可以通过修改配置来调整Ribbon的负载均衡策略，在application.yml中增加如下配置: \u003c调用的服务名\u003e: # 调用的提供者的名称 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule ","date":"2021-09-04","objectID":"/springcloud/:2:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"OpenFeign 远程调用 ","date":"2021-09-04","objectID":"/springcloud/:3:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"简单使用 pom \u003c!--fegin组件--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e 启动类 @EnableFeignClients @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class OrderServer { public static void main(String[] args) { SpringApplication.run(OrderServer.class,args); } } 使用 直接复制对应微服务的controller 注意⚠️： 请求路径注意复制完整 每个参数都需要注解 @Component @FeignClient(value = \"cloud-payment-service\") public interface PaymentFeignService { /** * 方法的参数必须有注解 * @PathVariable 路径变量 * @RequestParam 参数 * @RequestBody 参数对象 * * @param pid * @return */ @GetMapping(value = \"/payment/get/{id}\") public CommonResult getPamentById(@PathVariable(\"id\")Long id); } ","date":"2021-09-04","objectID":"/springcloud/:3:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"OpenFeign超时控制 OpenFeign默认等待1秒钟，超过后报错 yml配置 #设置feign客户端超时时间(OpenFeign默认支持ribbon)(单位：毫秒) ribbon: #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间 ReadTimeout: 5000 #指的是建立连接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 ","date":"2021-09-04","objectID":"/springcloud/:3:2","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"OpenFeign日志增强 配置日志bean NONE：默认的，不显示任何日志; BASIC：仅记录请求方法、URL、响应状态码及执行时间; HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息; FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。 package com.atguigu.springcloud.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FeignConfig { @Bean Logger.Level feignLoggerLevel() { //NONE：默认的，不显示任何日志; //BASIC：仅记录请求方法、URL、响应状态码及执行时间; //HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息; //FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。 return Logger.Level.FULL; } } YML文件里需要开启日志的Feign客户端 logging: level: # feign日志以什么级别监控哪个接口 com.lun.springcloud.service.PaymentFeignService: debug ","date":"2021-09-04","objectID":"/springcloud/:3:3","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"集成Sentinel,服务降级处理 yaml配置 product-service: # 调用的提供者的名称 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 使用 ProductFeignApi @FeignClient(name = \"product-service\",fallback = ProductFeignFallBack.class) public interface ProductFeignApi { @RequestMapping(\"/product/{pid}\") public Product findByPid( @PathVariable(\"pid\") Long pid); } ProductFeignFallBack @Component public class ProductFeignFallBack implements ProductFeignApi { @Override public Product findByPid(Long pid) { Product product = new Product(); product.setPid(-1L); product.setPname(\"兜底数据\"); product.setPprice(0.0); return product; } } ","date":"2021-09-04","objectID":"/springcloud/:3:4","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel 服务保护 ","date":"2021-09-04","objectID":"/springcloud/:4:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"订单微服务集成Sentinel 为微服务集成Sentinel非常简单, 只需要加入Sentinel的依赖即可 在shop-order-server项目的pom文件中添加如下依赖 \u003c!--sentinel组件--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-sentinel\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2021-09-04","objectID":"/springcloud/:4:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"安装Sentinel控制台 Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。 下载jar包 https://github.com/alibaba/Sentinel/releases 启动控制台 # 直接使用jar命令启动项目(控制台本身是一个SpringBoot项目) java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.0.jar 修改shop-order-server项目中的配置文件application.yml,新增如下配置: spring: cloud: sentinel: transport: port: 9999 #跟控制台交流的端口,随意指定一个未使用的端口即可 dashboard: localhost:8080 # 指定控制台服务的地址 通过浏览器访问localhost:8080 进入控制台 ( 默认用户名密码是 sentinel/sentinel ) 注意: 默认是没显示order-service的，需要访问几次接口，然后再刷新sentinel管控台才可以看到. ","date":"2021-09-04","objectID":"/springcloud/:4:2","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"实现一个接口的限流 第一步: 簇点链路—\u003e流控 第二步: 在单机阈值填写一个数值，表示每秒上限的请求数 第三步:通过控制台快速频繁访问, 观察效果 ","date":"2021-09-04","objectID":"/springcloud/:4:3","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel容错的维度 流量控制：流量控制在网络传输中是一个常用的概念，它用于调整网络包的数据。任意时间到来的请求往往是 随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。 熔断降级：当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则 对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。 系统负载保护：Sentinel 同时提供系统维度的自适应保护能力。当系统负载较高的时候，如果还持续让 请求进入可能会导致系统崩溃，无法响应。在集群环境下，会把本应这台机器承载的流量转发到其 它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，Sentinel 提供了对应的保 护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请 求。 ","date":"2021-09-04","objectID":"/springcloud/:4:4","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel规则种类 Sentinel主要提供了这五种的流量控制，接下来我们每种都给同学们演示一下. ","date":"2021-09-04","objectID":"/springcloud/:4:5","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel规则-流控 流控规则 流量控制，其原理是监控应用流量的QPS(每秒查询率) 或并发线程数等指标，当达到指定的阈值时 对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。 资源名：唯一名称，默认是请求路径，可自定义 针对来源：指定对哪个微服务进行限流，默认指default，意思是不区分来源，全部限制 阈值类型/单机阈值： QPS（每秒请求数量）: 当调用该接口的QPS达到阈值的时候，进行限流 线程数：当调用该接口的线程数达到阈值的时候，进行限流 是否集群：暂不需要集群 QPS流控 前面演示的QPS流控 线程数流控 删除掉之前的QPS流控，新增线程数流控 在Jmeter中新增线程 访问 localhost:8091/sentinel2 会发现已经被限流 流控模式 点击上面设置流控规则的编辑按钮，然后在编辑页面点击高级选项，会看到有流控模式一栏。 sentinel共有三种流控模式，分别是： 直接（默认）：接口达到限流条件时，开启限流 关联：当关联的资源达到限流条件时，开启限流 [适合做应用让步] 链路：当从某个接口过来的资源达到限流条件时，开启限流 直接流控模式 前面演示的案例就是这种. 关联流控模式 关联流控模式指的是，当指定接口关联的接口达到限流条件时，开启对指定接口开启限流。 场景:当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢. 在SentinelController.java中增加一个方法，重启订单服务 @RequestMapping(\"/sentinel3\") public String sentinel3(){ return \"sentinel3\"; } 配置限流规则, 将流控模式设置为关联，关联资源设置为的 /sentinel2 通过postman软件向/sentinel2连续发送请求，注意QPS一定要大于3 访问/sentinel3,会发现已经被限流 链路流控模式 链路流控模式指的是，当从某个接口过来的资源达到限流条件时，开启限流。 在shop-order-server项目的application.yml文件中新增如下配置: spring: cloud: sentinel: web-context-unify: false 在shop-order-server项目中新增TraceServiceImpl.java package cn.wolfcode.service.impl; @Service @Slf4j public class TraceServiceImpl { @SentinelResource(value = \"tranceService\") public void tranceService(){ log.info(\"调用tranceService方法\"); } } 在shop-order-server项目中新增TraceController.java package cn.wolfcode.controller; @RestController public class TraceController { @Autowired private TraceServiceImpl traceService; @RequestMapping(\"/trace1\") public String trace1(){ traceService.tranceService(); return \"trace1\"; } @RequestMapping(\"/trace2\") public String trace2(){ traceService.tranceService(); return \"trace2\"; } } 重新启动订单服务并添加链路流控规则 分别通过 /trace1 和 /trace2 访问, 发现/trace1没问题, /trace2的被限流了 流控效果 快速失败（默认）: 直接失败，抛出异常，不做任何额外的处理，是最简单的效果 Warm Up：它从开始阈值到最大QPS阈值会有一个缓冲阶段，一开始的阈值是最大QPS阈值的 1/3，然后慢慢增长，直到最大阈值，适用于将突然增大的流量转换为缓步增长的场景。 排队等待：让请求以均匀的速度通过，单机阈值为每秒通过数量，其余的排队等待； 它还会让设 置一个超时时间，当请求超过超时间时间还未处理，则会被丢弃。 ","date":"2021-09-04","objectID":"/springcloud/:4:6","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel规则-降级 降级规则就是设置当满足什么条件的时候，对服务进行降级。Sentinel提供了三个衡量条件： 慢调用比例: 选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。 异常比例: 当单位统计时长内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。 异常数：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。 慢调用比例案例 在shop-order-server项目中新增FallBackController.java类,代码如下: package cn.wolfcode.controller; @RestController @Slf4j public class FallBackController { @RequestMapping(\"/fallBack1\") public String fallBack1(){ try { log.info(\"fallBack1执行业务逻辑\"); //模拟业务耗时 TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return \"fallBack1\"; } } 新增降级规则: 上面配置表示，如果在1S之内,有【超过1个的请求】且这些请求中【响应时间\u003e最大RT】的【请求数量比例\u003e10%】，就会触发熔断，在接下来的10s之内都不会调用真实方法，直接走降级方法。 比如: 最大RT=900,比例阈值=0.1,熔断时长=10,最小请求数=10 情况1: 1秒内的有20个请求，只有10个请求响应时间\u003e900ms, 那慢调用比例=0.5，这种情况就会触发熔断 情况2: 1秒内的有20个请求，只有1个请求响应时间\u003e900ms, 那慢调用比例=0.05，这种情况不会触发熔断 情况3: 1秒内的有8个请求，只有6个请求响应时间\u003e900ms, 那慢调用比例=0.75，这种情况不会触发熔断，因为最小请求数这个条件没有满足. 注意: 我们做实验的时候把最小请求数设置为1，因为在1秒内，手动操作很难在1s内发两个请求过去，所以要做出效果,最好把最小请求数设置为1。 异常比例案例 在shop-order-server项目的FallBackController.java类新增fallBack2方法: int i=0; @RequestMapping(\"/fallBack2\") public String fallBack2(){ log.info(\"fallBack2执行业务逻辑\"); //模拟出现异常，异常比例为33% if(++i%3==0){ throw new RuntimeException(); } return \"fallBack2\"; } 新增降级规则: 上面配置表示，在1s之内，,有【超过3个的请求】，异常比例30%的情况下，触发熔断，熔断时长为10s. 异常数案例 在shop-order-server项目的FallBackController.java类新增fallBack3方法: @RequestMapping(\"/fallBack3\") public String fallBack3(String name){ log.info(\"fallBack3执行业务逻辑\"); if(\"wolfcode\".equals(name)){ throw new RuntimeException(); } return \"fallBack3\"; } 新增降级规则 上面配置表示，在1s之内，,有【超过3个的请求】，请求中超过2个请求出现异常就会触发熔断，熔断时长为10s ","date":"2021-09-04","objectID":"/springcloud/:4:7","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel规则-热点 何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如： 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。 在shop-order-server项目中新增HotSpotController.java,代码如下: package cn.wolfcode.controller; @RestController @Slf4j public class HotSpotController { @RequestMapping(\"/hotSpot1\") @SentinelResource(value = \"hotSpot1\") public String hotSpot1(Long productId){ log.info(\"访问编号为:{}的商品\",productId); return \"hotSpot1\"; } } 注意:一定需要在请求方法上贴@SentinelResource直接，否则热点规则无效 新增热点规则: 在热点规则中编辑规则,在编辑之前一定要先访问一下/hotSpot1,不然参数规则无法新增. 新增参数规则: 点击保存，可以看到已经新增了参数规则. 访问localhost:8091/hotSpot?productId=1 访问会降级 访问localhost:8091/hotSpot?productId=2 访问不会降级 ","date":"2021-09-04","objectID":"/springcloud/:4:8","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel规则-授权 很多时候，我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问控制（黑白名单控制）的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。 在shop-order-server中新建RequestOriginParserDefinition.java,定义请求来源如何获取 @Component public class RequestOriginParserDefinition implements RequestOriginParser { @Override public String parseOrigin(HttpServletRequest request) { /** * 定义从请求的什么地方获取来源信息 * 比如我们可以要求所有的客户端需要在请求头中携带来源信息 */ String serviceName = request.getParameter(\"serviceName\"); return serviceName; } } 在shop-order-server中新建AuthController.java,代码如下: @RestController @Slf4j public class AuthController { @RequestMapping(\"/auth1\") public String auth1(String serviceName){ log.info(\"应用:{},访问接口\",serviceName); return \"auth1\"; } } 新增授权规则 访问测试 访问localhost:8091/auth1?serviceName=pc 不能访问 访问localhost:8091/auth1?serviceName=app 可以访问 ","date":"2021-09-04","objectID":"/springcloud/:4:9","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel规则-系统规则 系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。 系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。 系统规则支持以下的模式： Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load 作为启发指标，进行自适应系统保护。当系统 load 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。 CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。 ","date":"2021-09-04","objectID":"/springcloud/:4:10","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel 自定义异常返回 当前面设定的规则没有满足是，我们可以自定义异常返回. FlowException 限流异常 DegradeException 降级异常 ParamFlowException 参数限流异常 AuthorityException 授权异常 SystemBlockException 系统负载异常 在shop-order-server项目中定义异常返回处理类 package cn.wolfcode.error; @Component public class ExceptionHandlerPage implements BlockExceptionHandler { @Override public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception { response.setContentType(\"application/json;charset=utf-8\"); ResultData data = null; if (e instanceof FlowException) { data = new ResultData(-1, \"接口被限流了\"); } else if (e instanceof DegradeException) { data = new ResultData(-2, \"接口被降级了\"); }else if (e instanceof ParamFlowException) { data = new ResultData(-3, \"参数限流异常\"); }else if (e instanceof AuthorityException) { data = new ResultData(-4, \"授权异常\"); }else if (e instanceof SystemBlockException) { data = new ResultData(-5, \"接口被降级了...\"); } response.getWriter().write(JSON.toJSONString(data)); } } @Data @AllArgsConstructor//全参构造 @NoArgsConstructor//无参构造 class ResultData { private int code; private String message; } ","date":"2021-09-04","objectID":"/springcloud/:4:11","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"@SentinelResource的使用 在定义了资源点之后，我们可以通过Dashboard来设置限流和降级策略来对资源点进行保护。同时还能 通过@SentinelResource来指定出现异常时的处理策略。 @SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 其主要参数如下: 属性 作用 value 资源名称，必需项（不能为空） entryType entry 类型，可选项（默认为 EntryType.OUT） blockHandler/blockHandlerClass blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 fallback/fallbackClass fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求： 1. 返回值类型必须与原函数返回值类型一致； 2.方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。 3.fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 defaultFallback 默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求： 1. 返回值类型必须与原函数返回值类型一致； 2. 方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。 3. defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。 exceptionsToIgnore 用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。 定义限流和降级后的处理方法 直接将限流和降级方法定义在方法中 package cn.wolfcode.controller; @RestController @Slf4j public class AnnoController { @RequestMapping(\"/anno1\") @SentinelResource(value = \"anno1\", blockHandler=\"anno1BlockHandler\", fallback = \"anno1Fallback\" ) public String anno1(String name){ if(\"wolfcode\".equals(name)){ throw new RuntimeException(); } return \"anno1\"; } public String anno1BlockHandler(String name,BlockException ex){ log.error(\"{}\", ex); return \"接口被限流或者降级了\"; } //Throwable时进入的方法 public String anno1Fallback(String name,Throwable throwable) { log.error(\"{}\", throwable); return \"接口发生异常了\"; } } ","date":"2021-09-04","objectID":"/springcloud/:4:12","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sentinel规则持久化 推模式(基于文件) ​ 通过前面的讲解，我们已经知道，可以通过Dashboard来为每个Sentinel客户端设置各种各样的规 则，但是这里有一个问题，就是这些规则默认是存放在内存中，极不稳定，所以需要将其持久化。 ​ 本地文件数据源会定时轮询文件的变更，读取规则。这样我们既可以在应用本地直接修改文件来更 新规则，也可以通过 Sentinel 控制台推送规则。以本地文件数据源为例，推送过程如下图所示： 首先 Sentinel 控制台通过 API 将规则推送至客户端并更新到内存中，接着注册的写数据源会将新的 规则保存到本地的文件中。 编写处理类 package cn.wolfcode.sentinel; public class FilePersistence implements InitFunc { @Value(\"${spring.application.name}\") private String appcationName; @Override public void init() throws Exception { String ruleDir = System.getProperty(\"user.home\") + \"/sentinel-rules/\" + appcationName; String flowRulePath = ruleDir + \"/flow-rule.json\"; String degradeRulePath = ruleDir + \"/degrade-rule.json\"; String systemRulePath = ruleDir + \"/system-rule.json\"; String authorityRulePath = ruleDir + \"/authority-rule.json\"; String paramFlowRulePath = ruleDir + \"/param-flow-rule.json\"; this.mkdirIfNotExits(ruleDir); this.createFileIfNotExits(flowRulePath); this.createFileIfNotExits(degradeRulePath); this.createFileIfNotExits(systemRulePath); this.createFileIfNotExits(authorityRulePath); this.createFileIfNotExits(paramFlowRulePath); // 流控规则 ReadableDataSource\u003cString, List\u003cFlowRule\u003e\u003e flowRuleRDS = new FileRefreshableDataSource\u003c\u003e( flowRulePath, flowRuleListParser ); FlowRuleManager.register2Property(flowRuleRDS.getProperty()); WritableDataSource\u003cList\u003cFlowRule\u003e\u003e flowRuleWDS = new FileWritableDataSource\u003c\u003e( flowRulePath, this::encodeJson ); WritableDataSourceRegistry.registerFlowDataSource(flowRuleWDS); // 降级规则 ReadableDataSource\u003cString, List\u003cDegradeRule\u003e\u003e degradeRuleRDS = new FileRefreshableDataSource\u003c\u003e( degradeRulePath, degradeRuleListParser ); DegradeRuleManager.register2Property(degradeRuleRDS.getProperty()); WritableDataSource\u003cList\u003cDegradeRule\u003e\u003e degradeRuleWDS = new FileWritableDataSource\u003c\u003e( degradeRulePath, this::encodeJson ); WritableDataSourceRegistry.registerDegradeDataSource(degradeRuleWDS); // 系统规则 ReadableDataSource\u003cString, List\u003cSystemRule\u003e\u003e systemRuleRDS = new FileRefreshableDataSource\u003c\u003e( systemRulePath, systemRuleListParser ); SystemRuleManager.register2Property(systemRuleRDS.getProperty()); WritableDataSource\u003cList\u003cSystemRule\u003e\u003e systemRuleWDS = new FileWritableDataSource\u003c\u003e( systemRulePath, this::encodeJson ); WritableDataSourceRegistry.registerSystemDataSource(systemRuleWDS); // 授权规则 ReadableDataSource\u003cString, List\u003cAuthorityRule\u003e\u003e authorityRuleRDS = new FileRefreshableDataSource\u003c\u003e( authorityRulePath, authorityRuleListParser ); AuthorityRuleManager.register2Property(authorityRuleRDS.getProperty()); WritableDataSource\u003cList\u003cAuthorityRule\u003e\u003e authorityRuleWDS = new FileWritableDataSource\u003c\u003e( authorityRulePath, this::encodeJson ); WritableDataSourceRegistry.registerAuthorityDataSource(authorityRuleWDS); // 热点参数规则 ReadableDataSource\u003cString, List\u003cParamFlowRule\u003e\u003e paramFlowRuleRDS = new FileRefreshableDataSource\u003c\u003e( paramFlowRulePath, paramFlowRuleListParser ); ParamFlowRuleManager.register2Property(paramFlowRuleRDS.getProperty()); WritableDataSource\u003cList\u003cParamFlowRule\u003e\u003e paramFlowRuleWDS = new FileWritableDataSource\u003c\u003e( paramFlowRulePath, this::encodeJson ); ModifyParamFlowRulesCommandHandler.setWritableDataSource(paramFlowRuleWDS); } private Converter\u003cString, List\u003cFlowRule\u003e\u003e flowRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cFlowRule\u003e\u003e() { } ); private Converter\u003cString, List\u003cDegradeRule\u003e\u003e degradeRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cDegradeRule\u003e\u003e() { } ); private Converter\u003cString, List\u003cSystemRule\u003e\u003e systemRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cSystemRule\u003e\u003e() { } ); private Converter\u003cString, List\u003cAuthorityRule\u003e\u003e authorityRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cAuthorityRule\u003e\u003e() { } ); private Converter\u003cString, List\u003cParamFlowRule\u003e\u003e paramFlowRuleListParser = source -\u003e JSON.parseObject( source, new TypeReference\u003cList\u003cParamFlowRule\u003e\u003e() { } ); private void mkdirIfNotExits(String filePath) throws IOException { File file = new File(filePath); i","date":"2021-09-04","objectID":"/springcloud/:4:13","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Gateway 网关 三大核心概念 Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由； Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由； Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。 ","date":"2021-09-04","objectID":"/springcloud/:5:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"模块搭建 新建模块 pom \u003c!--gateway网关--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--nacos客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e yaml server: port: 9000 spring: application: name: api-gateway cloud: nacos: discovery: server-addr: localhost:8848 gateway: discovery: locator: enabled: true # 让gateway可以发现nacos中的微服务 启动类 @SpringBootApplication @EnableDiscoveryClient public class ApiGatewayServer { public static void main(String[] args) { SpringApplication.run(ApiGatewayServer.class,args); } } 使用 http://ip地址:端口号/服务名/请求 例如： localhost:9000/order-service/sentinel2 ","date":"2021-09-04","objectID":"/springcloud/:5:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"路由 默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能（不写死一个地址）。 spring: application: name: api-gateway cloud: nacos: discovery: server-addr: localhost:8848 gateway: discovery: locator: enabled: true # 让gateway可以发现nacos中的微服务 routes: - id: product_route uri: lb://product-service #匹配后提供服务的路由地址 predicates: - Path=/product-serv/** filters: - StripPrefix=1 - id: order_route uri: lb://order-service predicates: - Path=/order-serv/** filters: - StripPrefix=1 ","date":"2021-09-04","objectID":"/springcloud/:5:2","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"断言 常用的Route Predicate Factory The After Route Predicate Factory The Before Route Predicate Factory The Between Route Predicate Factory The Cookie Route Predicate Factory The Header Route Predicate Factory The Host Route Predicate Factory The Method Route Predicate Factory The Path Route Predicate Factory The Query Route Predicate Factory The RemoteAddr Route Predicate Factory The weight Route Predicate Factory spring: application: name: api-gateway cloud: nacos: discovery: server-addr: localhost:8848 gateway: discovery: locator: enabled: true # 让gateway可以发现nacos中的微服务 routes: - id: product_route uri: lb://product-service #匹配后提供服务的路由地址 predicates: # - Header=X-Request-Id, \\d+ # - Cookie=username,zzyy # - After=2021-05-16T19:53:59.024+08:00[Asia/Shanghai] - Path=/product-serv/** # 断言，路径相匹配的进行路由 filters: - StripPrefix=1 ","date":"2021-09-04","objectID":"/springcloud/:5:3","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"过滤 StripPrefix=1 去除第一段路由 自定义局部过滤器 注意： 命名：xxxGatewayFilterFactory 使用：- xxx= 参数顺序 @Component public class TimeGatewayFilterFactory extends AbstractGatewayFilterFactory\u003cTimeGatewayFilterFactory.Config\u003e { private static final String BEGIN_TIME = \"beginTime\"; //构造函数 public TimeGatewayFilterFactory() { super(TimeGatewayFilterFactory.Config.class); } //读取配置文件中的参数 赋值到 配置类中 @Override public List\u003cString\u003e shortcutFieldOrder() { return Arrays.asList(\"show\",\"count\"); } @Override public GatewayFilter apply(Config config) { return new GatewayFilter() { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { if(!config.show){ return chain.filter(exchange); } exchange.getAttributes().put(BEGIN_TIME, System.currentTimeMillis()); /** * pre的逻辑 * chain.filter().then(Mono.fromRunable(()-\u003e{ * post的逻辑 * })) */ return chain.filter(exchange).then(Mono.fromRunnable(()-\u003e{ Long startTime = exchange.getAttribute(BEGIN_TIME); if (startTime != null) { System.out.println(exchange.getRequest().getURI() + \"请求耗时: \" + (System.currentTimeMillis() - startTime) + \"ms\"); } })); } }; } @Setter @Getter static class Config{ private boolean show; private int count; } } 全局过滤器 @Component public class AuthGlobalFilter implements GlobalFilter { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { String token = exchange.getRequest().getQueryParams().getFirst(\"token\"); if (StringUtils.isBlank(token)) { System.out.println(\"鉴权失败\"); exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } } ","date":"2021-09-04","objectID":"/springcloud/:5:4","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"集成Sentinel实现网关限流 网关是所有请求的公共入口，所以可以在网关进行限流，而且限流的方式也很多，我们本次采用前 面学过的Sentinel组件来实现网关的限流。Sentinel支持对SpringCloud Gateway、Zuul等主流网关进 行限流。 从1.6.0版本开始，Sentinel提供了SpringCloud Gateway的适配模块，可以提供两种资源维度的限流： route维度：即在Spring配置文件中配置的路由条目，资源名为对应的routeId 自定义API维度：用户可以利用Sentinel提供的API来自定义一些API分组 网关集成Sentinel https://github.com/alibaba/Sentinel/wiki/网关限流 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.csp\u003c/groupId\u003e \u003cartifactId\u003esentinel-spring-cloud-gateway-adapter\u003c/artifactId\u003e \u003c/dependency\u003e 编写配置类 package cn.wolfcode.config; @Configuration public class GatewayConfiguration { private final List\u003cViewResolver\u003e viewResolvers; private final ServerCodecConfigurer serverCodecConfigurer; public GatewayConfiguration(ObjectProvider\u003cList\u003cViewResolver\u003e\u003e viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer) { this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList); this.serverCodecConfigurer = serverCodecConfigurer; } // 配置限流的异常处理器 @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() { // Register the block exception handler for Spring Cloud Gateway. return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer); } // 初始化一个限流的过滤器 @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public GlobalFilter sentinelGatewayFilter() { return new SentinelGatewayFilter(); } //增加对商品微服务的 限流 @PostConstruct private void initGatewayRules() { Set\u003cGatewayFlowRule\u003e rules = new HashSet\u003c\u003e(); rules.add(new GatewayFlowRule(\"product_route\") .setCount(3) .setIntervalSec(1) ); GatewayRuleManager.loadRules(rules); } } 重启网关服务并测试. 修改限流默认返回格式 在配置类GatewayConfiguration.java中添加如下配置 @PostConstruct public void initBlockHandlers() { BlockRequestHandler blockRequestHandler = new BlockRequestHandler() { public Mono\u003cServerResponse\u003e handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) { Map map = new HashMap\u003c\u003e(); map.put(\"code\", 0); map.put(\"message\", \"接口被限流了\"); return ServerResponse.status(HttpStatus.OK). contentType(MediaType.APPLICATION_JSON). body(BodyInserters.fromValue(map)); } }; GatewayCallbackManager.setBlockHandler(blockRequestHandler); } 重启并测试 自定义API分组 自定义API分组是一种更细粒度的限流规则定义 在shop-order-server项目中添加ApiController package cn.wolfcode.controller; @RestController @RequestMapping(\"/api\") public class ApiController { @RequestMapping(\"/hello\") public String api1(){ return \"api\"; } } 重启shop-order-server项目. 在api-gateway项目的配置GatewayConfiguration.java中添加如下配置: @PostConstruct private void initCustomizedApis() { Set\u003cApiDefinition\u003e definitions = new HashSet\u003c\u003e(); ApiDefinition api1 = new ApiDefinition(\"order_api\") .setPredicateItems(new HashSet\u003cApiPredicateItem\u003e() {{ add(new ApiPathPredicateItem().setPattern(\"/order-serv/api/**\"). setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX)); }}); definitions.add(api1); GatewayApiDefinitionManager.loadApiDefinitions(definitions); } @PostConstruct private void initGatewayRules() { Set\u003cGatewayFlowRule\u003e rules = new HashSet\u003c\u003e(); rules.add(new GatewayFlowRule(\"product_route\") .setCount(3) .setIntervalSec(1) ); rules.add(new GatewayFlowRule(\"order_api\"). setCount(1). setIntervalSec(1)); GatewayRuleManager.loadRules(rules); } 直接访问localhost:8091/api/hello 是不会发生限流的，访问localhost:9000/order-serv/api/hello 就会出现限流了. ","date":"2021-09-04","objectID":"/springcloud/:5:5","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Sleuth+Zipkin 链路追踪 ","date":"2021-09-04","objectID":"/springcloud/:6:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"集成链路追踪组件Sleuth \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-sleuth\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2021-09-04","objectID":"/springcloud/:6:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Zipkin+Sleuth整合 下载Zipkin的jar包，在官网可以下载. 通过命令行，输入下面的命令启动ZipKin Server java -jar zipkin-server-2.22.1-exec.jar 通过浏览器访问 localhost:9411访问 添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zipkin\u003c/artifactId\u003e \u003c/dependency\u003e yaml spring: zipkin: base-url: http://127.0.0.1:9411/ #zipkin server的请求地址 discoveryClientEnabled: false #让nacos把它当成一个URL，而不要当做服务名 sleuth: sampler: probability: 1.0 #采样的百分比 调用接口后访问 localhost:9411查看 ","date":"2021-09-04","objectID":"/springcloud/:6:2","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"分布式调度 ","date":"2021-09-04","objectID":"/springcloud/:7:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Elastic-Job 搭建 需要zooker pom \u003cdependency\u003e \u003cgroupId\u003ecom.dangdang\u003c/groupId\u003e \u003cartifactId\u003eelastic-job-lite-spring\u003c/artifactId\u003e \u003cversion\u003e2.1.5\u003c/version\u003e \u003c/dependency\u003e yaml elasticjob: zookeeper-url: localhost:2181 group-name: elastic-job-group 注册中心配置类 @Configuration public class RegistryCenterConfig { @Bean(initMethod = \"init\") public CoordinatorRegistryCenter createRegistryCenter( @Value(\"${elasticjob.zookeeper-url}\") String zookeeperUrl, @Value(\"${elasticjob.group-name}\") String groupName) { //zk的配置 ZookeeperConfiguration zookeeperConfiguration = new ZookeeperConfiguration(zookeeperUrl, groupName); //设置zk超时时间 zookeeperConfiguration.setSessionTimeoutMilliseconds(100); //创建注册中心 return new ZookeeperRegistryCenter(zookeeperConfiguration); } } 任务调度抽取公共方法 public class ElasticJobLite { public static LiteJobConfiguration createJobConfiguration( //具体类 final Class\u003c? extends ElasticJob\u003e jobClass, //cron表达式 final String cron, //分片数量 final int shardingTotalCount, //分片表达式 final String shardingItemParameters, //job类型 DataflowJob[true] SimpleJob[false] boolean dataflowType ) { // 定义作业核心配置 JobCoreConfiguration.Builder jobCoreConfigurationBuilder = JobCoreConfiguration.newBuilder(jobClass.getSimpleName(), cron, shardingTotalCount); //分片 if (!StringUtils.isEmpty(shardingItemParameters)) { jobCoreConfigurationBuilder.shardingItemParameters(shardingItemParameters); } //初始化JobTypeConfiguration JobTypeConfiguration jobConfig; //DataflowJob[true] SimpleJob[false] if (dataflowType) { //定义Dataflow类型配置 jobConfig = new DataflowJobConfiguration(jobCoreConfigurationBuilder.build(), jobClass.getCanonicalName(), true); } else { // 定义SIMPLE类型配置 jobConfig = new SimpleJobConfiguration(jobCoreConfigurationBuilder.build(), jobClass.getCanonicalName()); } // 定义Lite作业根配置 return LiteJobConfiguration.newBuilder(jobConfig).overwrite(true).build(); } } 任务类 @Component public class MyElasticJob implements SimpleJob { public void execute(ShardingContext shardingContext) { System.out.println(\"定时任务开始====\u003e\"+new Date()); } } 配置使用 @Configuration public class ElasticJobConfig { @Autowired private CoordinatorRegistryCenter registryCenter; @Bean(initMethod = \"init\") public SpringJobScheduler initSimpleElasticJob(MyElasticJob myElasticJob) { SpringJobScheduler springJobScheduler = new SpringJobScheduler(myElasticJob, registryCenter, ElasticJobLite.createJobConfiguration( MyElasticJob.class, \"0/3 * * * * ?\", 1, null, false) ); return springJobScheduler; } } 分片 ​ 作业分片是指任务的分布式执行，需要将一个任务拆分为多个独立的任务项，然后由分布式的应用实例分别执行某一个或者几个分布项。 ​ 例如：Elastic-Job快速入门中文件备份的案例，现有两台服务器，每台服务器分别跑一个应用实例。为了快速执行作业，那么可以讲任务分成4片，每个应用实例都执行两片。作业遍历数据逻辑应为：实例1查找text和image类型文件执行备份，实例2查找radio和vedio类型文件执行备份。如果由于服务器拓容应用实例数量增加为4，则作业遍历数据的逻辑应为: 4个实例分别处理text,image,radio,video类型的文件。 ​ 可以看到，通过对任务的合理分片化，从而达到任务并行处理的效果. 分片项与业务处理解耦 ​ Elastic-Job并不直接提供数据处理的功能,框架只会将分片项分配至各个运行中的作业服务器，开发者需要自行处理分片项与真实数据的对应关系 最大限度利用资源 将分片项设置大于服务器的数据，最好是大于服务器倍数的数量，作业将会合理利用分布式资源，动态的分配分片项. ​ 例如: 3台服务器，分成10片，则分片项结果为服务器A=0,1,2;服务器B=3,4,5;服务器C=6,7,8,9.如果 服务器C奔溃，则分片项分配结果为服务器A=0,1,2,3,4;服务器B=5,6,7,8,9.在不丢失分片项的情况下，最大限度利用现有的资源提高吞吐量. 注： shardingContext.getShardingParameter() 获取分片信息 job @Component public class FileCustomElasticJob implements SimpleJob { @Autowired private FileCustomMapper fileCustomMapper; @Override public void execute(ShardingContext shardingContext) { doWork(shardingContext.getShardingParameter()); } private void doWork(String fileType){ List\u003cFileCustom\u003e fileList = fileCustomMapper.selecByType(fileType); System.out.println(\"类型为:\"+fileType+\",文件，需要备份个数:\"+fileList.size()); for(FileCustom fileCustom:fileList){ backUpFile(fileCustom); } } private void backUpFile(FileCustom fileCustom){ try { //模拟备份动作 TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"执行文件备份====\u003e\"+fileCustom); fileCustomMapper.changeState(fileCustom.getId(),1); } } 配置 @Configuration public class ElasticJobConfig { @Autowired private CoordinatorRegistryCenter registryCenter; @Bean(initMethod = \"init\") public SpringJobScheduler initFileCustomE","date":"2021-09-04","objectID":"/springcloud/:7:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Canal 数据同步 ","date":"2021-09-04","objectID":"/springcloud/:8:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"原理 模仿mysql主从的slave ","date":"2021-09-04","objectID":"/springcloud/:8:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"准备 对于自建 MySQL , 需要先开启 Binlog 写入功能，配置 binlog-format 为 ROW 模式，my.cnf 中配置如下 [mysqld] log-bin=mysql-bin # 开启 binlog binlog-format=ROW # 选择 ROW 模式 server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 注意：针对阿里云 RDS for MySQL , 默认打开了 binlog , 并且账号默认具有 binlog dump 权限 , 不需要任何权限或者 binlog 设置,可以直接跳过这一步 授权 canal 链接 MySQL 账号具有作为 MySQL slave 的权限, 如果已有账户可直接 grant CREATE USER canal IDENTIFIED BY 'Canal_2021'; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%'; -- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ; FLUSH PRIVILEGES; 重启mysql //centos6 service mysqld restart //centos7 systemctl restart mysqld ","date":"2021-09-04","objectID":"/springcloud/:8:2","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"启动 下载canal,我们使用的版本是1.1.4版本 https://github.com/alibaba/canal/releases/tag/canal-1.1.4 解压缩 mkdir /usr/local/canal tar -zxvf software/canal.deployer-1.1.4.tar.gz -C /usr/local/canal/ 解压完成后，进入 /tmp/canal 目录，可以看到如下结构 drwxr-xr-x 2 jianghang jianghang 136 2013-02-05 21:51 bin drwxr-xr-x 4 jianghang jianghang 160 2013-02-05 21:51 conf drwxr-xr-x 2 jianghang jianghang 1.3K 2013-02-05 21:51 lib drwxr-xr-x 2 jianghang jianghang 48 2013-02-05 21:29 logs 配置修改 vi /usr/local/canal/conf/example/instance.properties ## mysql serverId canal.instance.mysql.slaveId = 1234 #position info，需要改成自己的数据库信息 canal.instance.master.address = 127.0.0.1:3306 canal.instance.master.journal.name = canal.instance.master.position = canal.instance.master.timestamp = #canal.instance.standby.address = #canal.instance.standby.journal.name = #canal.instance.standby.position = #canal.instance.standby.timestamp = #username/password，需要改成自己的数据库信息 canal.instance.dbUsername = canal canal.instance.dbPassword = canal canal.instance.defaultDatabaseName = canal.instance.connectionCharset = UTF-8 #table regex canal.instance.filter.regex = .\\*\\\\\\\\..\\* canal.instance.connectionCharset 代表数据库的编码方式对应到 java 中的编码类型，比如 UTF-8，GBK , ISO-8859-1 如果系统是1个 cpu，需要将 canal.instance.parser.parallel 设置为 false 启动 sh /usr/local/canal/bin/startup.sh 查看 server 日志 tail -f -n 50 logs/canal/canal.log 2013-02-05 22:45:27.967 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## start the canal server. 2013-02-05 22:45:28.113 [main] INFO com.alibaba.otter.canal.deployer.CanalController - ## start the canal server[10.1.29.120:11111] 2013-02-05 22:45:28.210 [main] INFO com.alibaba.otter.canal.deployer.CanalLauncher - ## the canal server is running now ...... 查看 instance 的日志 tail -f -n 50 logs/example/example.log 2013-02-05 22:50:45.636 [main] INFO c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [canal.properties] 2013-02-05 22:50:45.641 [main] INFO c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer - Loading properties file from class path resource [example/instance.properties] 2013-02-05 22:50:45.803 [main] INFO c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start CannalInstance for 1-example 2013-02-05 22:50:45.810 [main] INFO c.a.otter.canal.instance.spring.CanalInstanceWithSpring - start successful.... 关闭 sh /usr/local/canal/bin/stop.sh 不能用 kill -9 进程 如果杀了, 需要删除 canal.pid 再次启动,就可以了 ","date":"2021-09-04","objectID":"/springcloud/:8:3","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"sh脚本 starCanal.sh # !/bin/bash echo '------------------canal-starter-------------------------' sh /usr/local/canal/bin/startup.sh echo '------------------canal-started-------------------------' shutdownCanal.sh # !/bin/bash echo '------------------canal-shutdown-------------------------' sh /usr/local/canal/bin/stop.sh echo '------------------canal-shutdowned-------------------------' ","date":"2021-09-04","objectID":"/springcloud/:8:4","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"集成 1.首先启动Canal Server，具体部署参考给的文档 2.添加依赖 \u003cdependency\u003e \u003cgroupId\u003etop.javatool\u003c/groupId\u003e \u003cartifactId\u003ecanal-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.2.1-RELEASE\u003c/version\u003e \u003c/dependency\u003e 3.添加配置如下 canal: server: Canal服务部署的地址:11111 destination: example logging: level: root: info top: javatool: canal: client: client: AbstractCanalClient: error 4.添加Handler @Slf4j @Component @CanalTable(value = \"t_order_info\") public class OrderaInfoHandler implements EntryHandler\u003cOrderInfo\u003e { @Autowired private StringRedisTemplate redisTemplate; @Override public void insert( OrderInfo orderInfo) { log.info(\"当有数据插入的时候会触发这个方法\"); } @Override public void update(OrderInfo before, OrderInfo after) { log.info(\"当有数据更新的时候会触发这个方法\"); } @Override public void delete(OrderInfo orderInfo) { log.info(\"当有数据删除的时候会触发这个方法\"); } } 实体类 package cn.wolfcode.domain; import lombok.Getter; import lombok.Setter; import lombok.ToString; import javax.persistence.Column; import javax.persistence.Table; import java.io.Serializable; import java.math.BigDecimal; import java.util.Date; @Setter @Getter @Table(name = \"t_order_info\") @ToString public class OrderInfo implements Serializable { public static final Integer STATUS_ARREARAGE = 0;//未付款 public static final Integer STATUS_ACCOUNT_PAID = 1;//已付款 public static final Integer STATUS_CANCEL = 2;//手动取消订单 public static final Integer STATUS_TIMEOUT = 3;//超时取消订单 public static final Integer STATUS_REFUND = 4;//已退款 public static final Integer PAYTYPE_ONLINE = 0;//在线支付 public static final Integer PAYTYPE_INTERGRAL = 1;//积分支付 @Column(name = \"order_no\") private String orderNo;//订单编号 @Column(name = \"user_id\") private Long userId;//用户ID @Column(name = \"product_id\") private Long productId;//商品ID @Column(name = \"product_name\") private String productName;//商品名称 @Column(name = \"product_img\") private String productImg;//商品图片 @Column(name = \"product_count\") private Integer productCount;//商品总数 @Column(name = \"product_price\") private BigDecimal productPrice;//商品原价 @Column(name = \"seckill_price\") private BigDecimal seckillPrice;//秒杀价格 @Column(name = \"intergral\") private Long intergral;//消耗积分 @Column(name = \"status\") private Integer status = STATUS_ARREARAGE;//订单状态 @Column(name = \"create_date\") private Date createDate;//订单创建时间 @Column(name = \"seckill_date\") private Date seckillDate;//秒杀的日期 @Column(name = \"seckill_time\") private Integer seckillTime;// 秒杀场次 @Column(name = \"seckill_id\") private Long seckillId;//秒杀商品ID } ","date":"2021-09-04","objectID":"/springcloud/:8:5","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Seata分布式事务 ","date":"2021-09-04","objectID":"/springcloud/:9:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Seata-At Seata主要由三个重要组件组成： TC：Transaction Coordinator 事务协调器，管理全局的分支事务的状态，用于全局性事务的提交 和回滚。 TM：Transaction Manager 事务管理器，用于开启、提交或者回滚全局事务。 RM：Resource Manager 资源管理器，用于分支事务上的资源管理，向TC注册分支事务，上报分 支事务的状态，接受TC的命令来提交或者回滚分支事务。 举例 程序中 Seata-AT模式的执行流程如下: A服务的TM向TC申请开启一个全局事务，TC就会创建一个全局事务并返回一个唯一的XID A服务的RM向TC注册分支事务，并及其纳入XID对应全局事务的管辖 A服务执行分支事务，向数据库做操作4. A服务开始远程调用B服务，此时XID会在微服务的调用链上传播 B服务的RM向TC注册分支事务，并将其纳入XID对应的全局事务的管辖 B服务执行分支事务，向数据库做操作 全局事务调用链处理完毕，TM根据有无异常向TC发起全局事务的提交或者回滚 TC协调其管辖之下的所有分支事务， 决定是否回滚 Seata-AT模式实现2PC与传统2PC的差别： 架构层次方面，传统2PC方案的 RM 实际上是在数据库层，RM本质上就是数据库自身，通过XA协议实现，而 Seata的RM是以jar包的形式作为中间件层部署在应用程序这一侧的。 两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率。 AT模式代码实现 分布式事务发起方只需要贴@GlobalTransactional注解即可 分支分布式事务贴上@Transactional即可 发起方 如果是远程调用需要判断返回值(关注是否做了统一异常处理以及统一返回类型)或者降级抛出异常 /** * show 订单积分支付 * @param orderNo 订单号 * @return 提示信息 */ @Override @GlobalTransactional @Transactional public String doIntergral(String orderNo) { //1.通过orderInfo 查询订单信息 从mysql中查询 OrderInfo orderInfo = orderInfoMapper.find(orderNo); //2.修改订单状态为已支付,支付类型为积分支付 orderInfoMapper.changePayStatus(orderNo, OrderInfo.STATUS_ACCOUNT_PAID, OrderInfo.PAYTYPE_INTERGRAL); //3.远程调用积分服务，修改用户的积分(减积分) OperateIntergralVo vo = new OperateIntergralVo(); vo.setPk(orderNo); vo.setValue(orderInfo.getIntergral()); vo.setInfo(\"积分消费\"); vo.setUserId(orderInfo.getUserId()); Result\u003cString\u003e stringResult = intergralFeign.remoteIntergralPay(vo); //远程失败两种情况 //1 远程发生异常 //2 远程服务宕机，服务降级 if (stringResult.getCode() == 500000 || StringUtils.isEmpty(stringResult)) { System.out.println(\"远程异常\"); throw new BusinessException(SeckillCodeMsg.INTERGRAL_SERVER_ERROR); } System.out.println(\"远程异常没判断出来\"); //4.支付日志 PayLog payLog = new PayLog(); payLog.setTradeNo(orderNo); payLog.setOutTradeNo(orderNo); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); payLog.setNotifyTime(simpleDateFormat.format(new Date())); payLog.setTotalAmount(orderInfo.getIntergral().toString()); payLog.setPayType(OrderInfo.PAYTYPE_INTERGRAL); payLogMapper.insert(payLog); return \"积分支付成功\"; } 分支 @Transactional public String intergralPay(OperateIntergralVo vo) { //1.添加日志 实现幂等性 AccountLog accountLog = new AccountLog(); accountLog.setPkValue(vo.getPk()); accountLog.setType(AccountLog.TYPE_DECR); accountLog.setAmount(vo.getValue()); accountLog.setGmtTime(new Date()); accountLog.setInfo(vo.getInfo()); accountLogMapper.insert(accountLog); // int a = 1/0; 模拟异常 //2.修改积分 usableIntegralMapper.addIntergral(vo.getUserId(), -vo.getValue()); return \"\"; } ","date":"2021-09-04","objectID":"/springcloud/:9:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"Seata-TCC TCC模型图 异常处理 空回滚 Try方法未执行,Cancel执行了 出现原因: Try超时 分布式事务回滚，触发Cancel 解决方案: Cancel方法需要识别出是否执行Try方法,如果执行了就正常执行Cancel,如果没有就直接结束 增加事务日志表来实现这个功能. CREATE TABLE `account_transaction` ( `tx_id` varchar(100) NOT NULL COMMENT '事务Txid', `action_id` varchar(100) NOT NULL COMMENT '分支事务id', `gmt_create` datetime NOT NULL COMMENT '创建时间', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `user_id` varchar(100) NOT NULL COMMENT '账户Uid', `amount` varchar(100) NOT NULL COMMENT '变动金额', `type` varchar(100) NOT NULL DEFAULT '' COMMENT '变动类型', PRIMARY KEY (`tx_id`,`action_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 幂等 多次调用二阶段方法 出现原因: 网络异常 分支事务所在服务器宕机 解决方案: 做幂等性处理 CREATE TABLE `account_transaction` ( `tx_id` varchar(100) NOT NULL COMMENT '事务Txid', `action_id` varchar(100) NOT NULL COMMENT '分支事务id', `gmt_create` datetime NOT NULL COMMENT '创建时间', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `user_id` varchar(100) NOT NULL COMMENT '账户Uid', `amount` varchar(100) NOT NULL COMMENT '变动金额', `type` varchar(100) NOT NULL DEFAULT '' COMMENT '变动类型', `state` smallint(4) NOT NULL COMMENT '状态: 1.初始化 2.已提交 3.已回滚', PRIMARY KEY (`tx_id`,`action_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 防悬挂 Cancel比Try先执行 出现原因: Try超时(拥堵) 分布式事务回滚触发Cancel 要允许空回滚，但是要拒绝空回滚之后的Try方法. 解决方案: 在Try方法中, 如果根据全局事务ID能查询出数据出来,说明在try方法之前执行了空回滚，此时就不能进行try方法。否则就正常执行try方法. 异常处理流程图 Try方法 Comfirm方法 Cancel方法 TCC模式代码实现 分布式事务发起方只需要贴@GlobalTransactional注解即可 分支事务需要完成下面步骤: 在接口上贴上@LocalTCC和@TwoPhaseBusinessAction注解 发起方 @Override @GlobalTransactional @Transactional public String refund(String orderNo) { //1.通过orderInfo 查询订单信息 从mysql中查询 OrderInfo orderInfo = orderInfoMapper.find(orderNo); switch (orderInfo.getPayType()) { case OrderInfo.PAYTYPE_INTERGRAL: refoundIntergral(orderInfo); break; case OrderInfo.PAYTYPE_ONLINE: break; } return null; } /** * show 订单积分退货 * @param orderInfo 订单信息 */ private void refoundIntergral(OrderInfo orderInfo) { //1 增加退款日志 RefundLog refundLog = new RefundLog(); refundLog.setOutTradeNo(orderInfo.getOrderNo()); refundLog.setRefundAmount(orderInfo.getIntergral().toString()); refundLog.setRefundReason(\"不想要了\"); refundLog.setRefundType(orderInfo.getPayType()); refundLog.setRefundTime(new Date()); refundLogMapper.insert(refundLog); //2 订单状态 1\u003e\u003e4 orderInfoMapper.changeRefundStatus(orderInfo.getOrderNo(), OrderInfo.STATUS_REFUND); //3 远程调用积分服务 加积分 OperateIntergralVo vo = new OperateIntergralVo(); vo.setPk(orderInfo.getOrderNo()); vo.setValue(orderInfo.getIntergral()); vo.setInfo(\"积分退款\"); vo.setUserId(orderInfo.getUserId()); Result\u003cString\u003e stringResult = intergralFeign.remoteIntergralUnfundTry(vo); if (StringUtils.isEmpty(stringResult) || stringResult.getCode() == 500000) { throw new BusinessException(SeckillCodeMsg.INTERGRAL_SERVER_ERROR); } } 分支方 接口 @LocalTCC public interface IUsableIntegralService { /** * show TCC事务 * @param vo * @param context * @return */ @TwoPhaseBusinessAction(name = \"remoteIntergralUnfundTry\", commitMethod = \"incrIntergralCommit\", rollbackMethod = \"incrIntergralRollback\") String remoteIntergralUnfundTry(@BusinessActionContextParameter(paramName = \"operateIntergralVo\") OperateIntergralVo vo, BusinessActionContext context); String incrIntergralCommit(BusinessActionContext context); String incrIntergralRollback(BusinessActionContext context); } 实现类 @Service public class UsableIntegralServiceImpl implements IUsableIntegralService { @Resource private UsableIntegralMapper usableIntegralMapper; @Resource private AccountTransactionMapper accountTransactionMapper; @Resource private AccountLogMapper accountLogMapper; /** * TCC事务 退款 */ @Override public String remoteIntergralUnfundTry(@BusinessActionContextParameter(paramName = \"operateIntergralVo\") OperateIntergralVo vo, BusinessActionContext context) { //1查询事务信息 AccountTransaction accountTransactionReturn = accountTransactionMapper.get(context.getXid(), String.valueOf(context.getBranchId())); //2判断是否有信息 if (!StringUtils.isEmpty(accountTransactionReturn)) { //有 switch (accountTransactionReturn.getState()) { //try 幂等 case Acco","date":"2021-09-04","objectID":"/springcloud/:9:2","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"其他 ","date":"2021-09-04","objectID":"/springcloud/:10:0","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"单服务集群IDEA -Dserver.port=8001 ","date":"2021-09-04","objectID":"/springcloud/:10:1","tags":["微服务","框架","整理"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["运维"],"content":"gitlab私服搭建 ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:0:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"前期准备 ​ 安装的时候,使用桥接模式.方便后面使用. ​ 硬件配置,内存8G,系统centos7,网络桥接模式 安装centos7, ​ ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:1:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"修改为静态IP地址,验证网络是否可以连通 ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:2:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"安装gitlab 软件名称:gitlab-ce-13.1.11-ce.0.el7.x86_64.rpm 前期准备工作 1\\安装SSH协议 yum install -y curl policycoreutils-python openssh-server 2\\设置SSH服务开机自启动 systemctl enable sshd 3\\启动SSH服务 systemctl start sshd 4\\安装Postfix以发送通知邮件 yum -y install postfix 5\\将postfix服务设置成开机自启动 systemctl enable postfix 6\\启动postfix systemctl start postfix 7\\安装vim编辑器 yum install vim -y 安装gitlab rpm -ivh gitlab-ce-13.1.11-ce.0.el7.x86_64.rpm 修改配置文件 #编辑配置文件 vim /etc/gitlab/gitlab.rb #修改访问URL #格式：external_url 'http://ip:端口' external_url 'http://ip:8000' 重置Gitlab gitlab-ctl reconfigure 启动Gitlab gitlab-ctl restart 首次访问修改密码 ​ 访问：ip:8000/ ​ 密码设置为 7092890jiang ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:3:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"汉化 点击右上角 用户 –\u003esettings–\u003ePreferences -\u003e Localization -\u003e Language -\u003e 简体中文 ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:4:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["运维"],"content":"常见问题 502错误 如果出现502错误,优先增加内存. 1\\ 端口被占用 检查这个文件 /etc/gitlab/gitlab.rb external_url 'http://ip:8000' 修改后, ​ gitlab-ctl reconfigure ​ gitlab-ctl restart 2\\ 内存不足 ​ 1) 增加虚拟机内存 ​ 2) 开启交换分区swap 0-查看swap分区是否启动 cat /proc/swaps 1- 新建一个文件夹 mkdir /data 2-创建一个4G大小的交换分区 bs*count=4294971392(4G)； dd if=/dev/zero of=/data/swap bs=512 count=8388616 3-指定swap分区 mkswap /data/swap 4-查看内核参数vm.swappiness中的数值是否为0，如果为0则根据实际需要调整成60 查看： cat /proc/sys/vm/swappiness 设置： sysctl -w vm.swappiness=60 5-启动分区 swapon /data/swap echo “/data/swap swap swap defaults 0 0” \u003e\u003e /etc/fstab 6-再次查看分区是否启动 cat /proc/swaps 7-重启gitlab gitlab-ctl restart ","date":"2021-09-02","objectID":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/:5:0","tags":["git"],"title":"gitlab私服搭建","uri":"/gitlab%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"},{"categories":["Spring"],"content":"SSM ","date":"2021-07-26","objectID":"/ssm/:0:0","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"项目结构 projectname src main java resources mvc.xml applicationContext.xml db.properties mybatis-config.xml log4j.properties shiro.xml shiro-ehcache.xml generatorConfig.xml webapp WEB_INF views web.xml css … test ","date":"2021-07-26","objectID":"/ssm/:0:1","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"项目搭建 ","date":"2021-07-26","objectID":"/ssm/:1:0","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"pom.xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecn.wolfcode\u003c/groupId\u003e \u003cartifactId\u003ewolfcar\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003cspring.version\u003e5.0.8.RELEASE\u003c/spring.version\u003e \u003cshiro.version\u003e1.5.2\u003c/shiro.version\u003e \u003c/properties\u003e \u003cpackaging\u003ewar\u003c/packaging\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- aop--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.8.13\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-test\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e1.1.19\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.45\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.4.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e1.3.1\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 分页--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper\u003c/artifactId\u003e \u003cversion\u003e5.1.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.25\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.0.1\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.16.22\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- 将freemarker等第三方库整合进Spring应用上下文的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context-support\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- freemaker--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.freemarker\u003c/groupId\u003e \u003cartifactId\u003efreemarker\u003c/artifactId\u003e \u003cversion\u003e2.3.30\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.6\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 核心--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-core\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 的 Web 模块--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-web\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 和 Spring 集成--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-spring\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 底层使用的 ehcache 缓存--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-ehcache\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 依赖的日志包--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-logging\u003c/groupId\u003e \u003cartifactId\u003ecommons-logging\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 依赖的工具包--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e \u003c!--Freemarker 的 shiro 标签库--\u003e \u003cdependency\u003e \u003cgroupId\u003enet.mingsoft\u003c/groupId\u003e \u003cartifactId\u003eshiro-freemarker-tags\u003c/artifactId\u003e \u003cversion\u003e1.0.1\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-all\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.ali","date":"2021-07-26","objectID":"/ssm/:1:1","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"web.xml配置 \u003cweb-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"\u003e \u003cfilter\u003e \u003cfilter-name\u003echaracterEncodingFilter\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003echaracterEncodingFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:mvc.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003cmultipart-config\u003e \u003cmax-file-size\u003e1024000\u003c/max-file-size\u003e \u003cmax-request-size\u003e1024000\u003c/max-request-size\u003e \u003c/multipart-config\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcherServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c!-- shiro 配置 --\u003e \u003cfilter\u003e \u003cfilter-name\u003eshiroFilter\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.DelegatingFilterProxy\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eshiroFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e ","date":"2021-07-26","objectID":"/ssm/:1:2","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"mvc.xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!-- 注解扫描 --\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.controller\"/\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.advice\"/\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.service\"/\u003e \u003c!-- 处理静态资源 使用默认的Servlet来响应静态文件 --\u003e \u003cmvc:default-servlet-handler/\u003e \u003cmvc:annotation-driven/\u003e \u003cimport resource=\"classpath:shiro.xml\"/\u003e \u003cimport resource=\"classpath:applicationContext.xml\"/\u003e \u003c!-- 不使用commons-fileupload时 --\u003e \u003c!-- \u003cbean class=\"org.springframework.web.multipart.support.StandardServletMultipartResolver\"\u003e--\u003e \u003c!-- \u003c/bean\u003e--\u003e \u003c!--文件上传解析器 id必须是multipartResolver--\u003e \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e \u003c!--最大上传文件大小 10M--\u003e \u003cproperty name=\"maxUploadSize\" value=\"#{1024*1024*10}\"/\u003e \u003c/bean\u003e \u003c!-- 注册 FreeMarker 配置类 --\u003e \u003cbean class=\"cn.wolfcode.wolfcar.config.MyFreemarkerConfiger\"\u003e \u003c!-- 配置 FreeMarker 的文件编码 --\u003e \u003cproperty name=\"defaultEncoding\" value=\"UTF-8\" /\u003e \u003c!-- 配置 FreeMarker 寻找模板的路径 --\u003e \u003cproperty name=\"templateLoaderPath\" value=\"/WEB-INF/views/\" /\u003e \u003cproperty name=\"freemarkerSettings\"\u003e \u003cprops\u003e \u003c!-- 兼容模式 ，配了后不需要另外处理空值问题，时间格式除外 --\u003e \u003cprop key=\"classic_compatible\"\u003etrue\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 注册 FreeMarker 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"\u003e \u003c!-- 是否把session中的attribute复制到模板的属性集中，可以使用FreeMarker的表达式来访问并显示--\u003e \u003cproperty name=\"exposeSessionAttributes\" value=\"true\" /\u003e \u003c!-- 配置逻辑视图自动添加的后缀名 --\u003e \u003cproperty name=\"suffix\" value=\".ftl\" /\u003e \u003c!-- 配置响应头中 Content-Type 的指 --\u003e \u003cproperty name=\"contentType\" value=\"text/html;charset=UTF-8\" /\u003e \u003c/bean\u003e \u003c/beans\u003e freemaker配置类 config.MyFreemarkerConfiger package cn.wolfcode.wolfcar.config; import com.jagregory.shiro.freemarker.ShiroTags; import freemarker.template.Configuration; import freemarker.template.TemplateException; import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer; import java.io.IOException; public class MyFreemarkerConfiger extends FreeMarkerConfigurer { @Override public void afterPropertiesSet() throws IOException, TemplateException { //继承之前的属性配置，这步不能省 super.afterPropertiesSet(); Configuration cfg = this.getConfiguration(); cfg.setSharedVariable(\"shiro\", new ShiroTags());//注册shiro 标签 } } ","date":"2021-07-26","objectID":"/ssm/:1:3","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"applicationContext.xml配置 注意修改包 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"\u003e \u003ccontext:property-placeholder location=\"classpath:db.properties\"/\u003e \u003c!-- 数据源 --\u003e \u003cbean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"\u003e \u003cproperty name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/\u003e \u003cproperty name=\"url\" value=\"${jdbc.url}\"/\u003e \u003cproperty name=\"username\" value=\"${jdbc.username}\"/\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"/\u003e \u003c/bean\u003e \u003c!-- 数据库链接 --\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003c!-- 数据源 --\u003e \u003cproperty name=\"dataSource\" ref=\"druidDataSource\"/\u003e \u003c!-- 配置mapper中实体类别名 --\u003e \u003cproperty name=\"typeAliasesPackage\" value=\"cn.wolfcode.wolfcar.domain\"/\u003e \u003c!-- mybatis配置 --\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003c!-- 将pageHelper配置到sqlsessionfactory --\u003e \u003cproperty name=\"plugins\"\u003e \u003carray\u003e \u003cbean class=\"com.github.pagehelper.PageInterceptor\"\u003e \u003cproperty name=\"properties\"\u003e \u003c!--使用下面的方式配置参数，一行配置一个，下面配的是合理化分页 --\u003e \u003cvalue\u003e reasonable=true \u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/array\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 扫描mapper接口 注入spring --\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"basePackage\" value=\"cn.wolfcode.wolfcar.mapper\"/\u003e \u003c/bean\u003e \u003c!-- 开启事务注解配置 --\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"druidDataSource\"/\u003e \u003c/bean\u003e \u003ctx:annotation-driven transaction-manager=\"transactionManager\"/\u003e \u003c/beans\u003e db.properties jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/wolfcar?characterEncoding=utf8 jdbc.username=root jdbc.password=123456 mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003csettings\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003csetting name=\"aggressiveLazyLoading\" value=\"false\"/\u003e \u003csetting name=\"lazyLoadTriggerMethods\" value=\"clone\"/\u003e \u003c/settings\u003e \u003c/configuration\u003e ","date":"2021-07-26","objectID":"/ssm/:1:4","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"shirt.xml 配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.realm\"\u003e\u003c/context:component-scan\u003e \u003c!-- aop自动代理 --\u003e \u003cbean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\" depends-on=\"lifecycleBeanPostProcessor\" /\u003e \u003c!-- 管理shiro生命周期 --\u003e \u003cbean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"\u003e\u003c/bean\u003e \u003c!-- 安全管理器 --\u003e \u003cbean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"\u003e \u003cproperty name=\"securityManager\" ref=\"securityManager\"/\u003e \u003c/bean\u003e \u003c!--指定当前需要使用的凭证匹配器--\u003e \u003cbean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"\u003e \u003c!-- 指定加密算法 --\u003e \u003cproperty name=\"hashAlgorithmName\" value=\"MD5\"/\u003e \u003c/bean\u003e \u003cbean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"\u003e \u003c!--引用指定的安全管理器--\u003e \u003cproperty name=\"securityManager\" ref=\"securityManager\"/\u003e \u003c!--shiro默认的登录地址是/login.jsp 现在要指定我们自己的登录页面地址--\u003e \u003cproperty name=\"loginUrl\" value=\"/login.html\"/\u003e \u003cproperty name=\"successUrl\" value=\"/employee/list\"\u003e\u003c/property\u003e \u003c!--路径对应的规则--\u003e \u003cproperty name=\"filterChainDefinitions\"\u003e \u003cvalue\u003e /index.htm=anon /employee/login=anon /css/**=anon /img/**=anon /js/**=anon /**=authc \u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"\u003e \u003c!--注册自定义数据源--\u003e \u003cproperty name=\"realm\" ref=\"myRealm\"\u003e\u003c/property\u003e \u003c!--注册缓存管理器--\u003e \u003cproperty name=\"cacheManager\" ref=\"cacheManager\"/\u003e \u003c/bean\u003e \u003c!-- 缓存管理器 --\u003e \u003cbean id=\"cacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"\u003e \u003c!-- 设置配置文件 --\u003e \u003cproperty name=\"cacheManagerConfigFile\" value=\"classpath:shiro-ehcache.xml\"/\u003e \u003c/bean\u003e \u003c/beans\u003e shiro 配置类（认证 授权） package cn.wolfcode.wolfcar.realm; import cn.wolfcode.wolfcar.domain.Employee; import cn.wolfcode.wolfcar.service.IEmployeeService; import cn.wolfcode.wolfcar.service.IPermissionService; import cn.wolfcode.wolfcar.service.IRoleService; import org.apache.shiro.authc.*; import org.apache.shiro.authc.credential.CredentialsMatcher; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.apache.shiro.util.ByteSource; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import javax.annotation.Resource; import java.util.List; @Component public class MyRealm extends AuthorizingRealm{ @Resource private IEmployeeService employeeService; @Resource private IRoleService roleService; @Resource private IPermissionService permissionService; @Autowired public void setCredentialsMatcher(CredentialsMatcher credentialsMatcher) { super.setCredentialsMatcher(credentialsMatcher); } @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { //获取当前的主体对象 Employee employee = (Employee) principals.getPrimaryPrincipal(); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); if(employee.isAdmin()){ info.addRole(\"admin\"); info.addStringPermission(\"*:*\"); return info; } //获取当前用户的角色 List\u003cString\u003e rolesnlist = roleService.getRoleSnByEmployeeId(employee.getId()); //获取当前用户的权限 List\u003cString\u003e permissionList = permissionService.getPermissionExpressionByEmployeeId(employee.getId()); //给当前用户添加角色和权限（授权） info.addRoles(rolesnlist); info.addStringPermissions(permissionList); return info; } //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { UsernamePasswordToken ","date":"2021-07-26","objectID":"/ssm/:1:5","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"log4j.properties # Global logging configuration log4j.rootLogger=ERROR, stdout log4j.logger.cn.wolfcode.wolfcar.mapper=TRACE # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n ","date":"2021-07-26","objectID":"/ssm/:1:6","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"generatorConfig.xml mybatis逆向工程 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003c!-- 配置生成器 --\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"mysql\" defaultModelType=\"hierarchical\" targetRuntime=\"MyBatis3Simple\"\u003e \u003c!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --\u003e \u003cproperty name=\"autoDelimitKeywords\" value=\"false\" /\u003e \u003c!-- 生成的Java文件的编码 --\u003e \u003cproperty name=\"javaFileEncoding\" value=\"UTF-8\" /\u003e \u003c!-- 格式化java代码 --\u003e \u003cproperty name=\"javaFormatter\" value=\"org.mybatis.generator.api.dom.DefaultJavaFormatter\" /\u003e \u003c!-- 格式化XML代码 --\u003e \u003cproperty name=\"xmlFormatter\" value=\"org.mybatis.generator.api.dom.DefaultXmlFormatter\" /\u003e \u003c!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --\u003e \u003cproperty name=\"beginningDelimiter\" value=\"`\" /\u003e \u003cproperty name=\"endingDelimiter\" value=\"`\" /\u003e \u003ccommentGenerator\u003e \u003cproperty name=\"suppressDate\" value=\"true\" /\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\" /\u003e \u003c/commentGenerator\u003e \u003c!-- 必须要有的，使用这个配置链接数据库 @TODO:是否可以扩展 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql:///wolfcar\" userId=\"root\" password=\"123456\"\u003e \u003c!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --\u003e \u003c/jdbcConnection\u003e \u003c!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --\u003e \u003cjavaTypeResolver type=\"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl\"\u003e \u003c!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale\u003e0;length\u003e18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length\u003c5：使用Short； --\u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\" /\u003e \u003c/javaTypeResolver\u003e \u003c!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --\u003e \u003cjavaModelGenerator targetPackage=\"cn.wolfcode.wolfcar.domain\" targetProject=\"src/main/java\"\u003e \u003c!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --\u003e \u003cproperty name=\"constructorBased\" value=\"false\" /\u003e \u003c!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --\u003e \u003cproperty name=\"immutable\" value=\"false\" /\u003e \u003c!-- 设置是否在getter方法中，对String类型字段调用trim()方法 \u003cproperty name=\"trimStrings\" value=\"true\" /\u003e --\u003e \u003c/javaModelGenerator\u003e \u003c!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --\u003e \u003csqlMapGenerator targetPackage=\"cn.wolfcode.wolfcar.mapper\" targetProject=\"src/main/resources\"\u003e \u003c!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/sqlMapGenerator\u003e \u003c!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --\u003e \u003cjavaClientGenerator targetPackage=\"cn.wolfcode.wolfcar.mapper\" type=\"XMLMAPPER\" targetProject=\"src/main/java\"\u003e \u003c!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 \u003cproperty name=\"rootInterface\" value=\"\"/\u003e --\u003e \u003c/javaClientGenerator\u003e \u003ctable tableName=\"consumption_item\"\u003e \u003cproperty name=\"useActualColumnNames\" value=\"true\"/\u003e \u003cproperty name=\"constructorBased\" value=\"false\" /\u003e \u003cgeneratedKey column=\"id\" sqlStatement=\"JDBC\" /\u003e \u003c/table\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e ","date":"2021-07-26","objectID":"/ssm/:1:7","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"分解 ","date":"2021-07-26","objectID":"/ssm/:2:0","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"一.FreeMarker pom \u003c!-- 将freemarker等第三方库整合进Spring应用上下文的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context-support\u003c/artifactId\u003e \u003cversion\u003e${spring.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- freemaker--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.freemarker\u003c/groupId\u003e \u003cartifactId\u003efreemarker\u003c/artifactId\u003e \u003cversion\u003e2.3.30\u003c/version\u003e \u003c/dependency\u003e mvc配置视图解析器 \u003c!-- 注册 FreeMarker 配置类 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\"\u003e \u003c!-- 配置 FreeMarker 的文件编码 --\u003e \u003cproperty name=\"defaultEncoding\" value=\"UTF-8\" /\u003e \u003c!-- 配置 FreeMarker 寻找模板的路径 --\u003e \u003cproperty name=\"templateLoaderPath\" value=\"/WEB-INF/views/\" /\u003e \u003cproperty name=\"freemarkerSettings\"\u003e \u003cprops\u003e \u003c!-- 兼容模式 ，配了后不需要另外处理空值问题，时间格式除外 --\u003e \u003cprop key=\"classic_compatible\"\u003etrue\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c!-- 注册 FreeMarker 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"\u003e \u003c!-- 是否把session中的attribute复制到模板的属性集中，可以使用FreeMarker的表达式来访问并显示--\u003e \u003cproperty name=\"exposeSessionAttributes\" value=\"true\" /\u003e \u003c!-- 配置逻辑视图自动添加的后缀名 --\u003e \u003cproperty name=\"suffix\" value=\".ftl\" /\u003e \u003c!-- 配置响应头中 Content-Type 的指 --\u003e \u003cproperty name=\"contentType\" value=\"text/html;charset=UTF-8\" /\u003e \u003c/bean\u003e 添加配置 例如配置shiro标签 配置类 package cn.wolfcode.wolfcar.config; import com.jagregory.shiro.freemarker.ShiroTags; import freemarker.template.Configuration; import freemarker.template.TemplateException; import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer; import java.io.IOException; public class MyFreemarkerConfiger extends FreeMarkerConfigurer { @Override public void afterPropertiesSet() throws IOException, TemplateException { //继承之前的属性配置，这步不能省 super.afterPropertiesSet(); Configuration cfg = this.getConfiguration(); cfg.setSharedVariable(\"shiro\", new ShiroTags());//注册shiro 标签 } } mvc视图解析器修改 \u003c!-- 注册 FreeMarker 配置类 --\u003e \u003cbean class=\"cn.wolfcode.wolfcar.config.MyFreemarkerConfiger\"\u003e \u003c!-- 配置 FreeMarker 的文件编码 --\u003e \u003cproperty name=\"defaultEncoding\" value=\"UTF-8\" /\u003e \u003c!-- 配置 FreeMarker 寻找模板的路径 --\u003e \u003cproperty name=\"templateLoaderPath\" value=\"/WEB-INF/views/\" /\u003e \u003cproperty name=\"freemarkerSettings\"\u003e \u003cprops\u003e \u003c!-- 兼容模式 ，配了后不需要另外处理空值问题，时间格式除外 --\u003e \u003cprop key=\"classic_compatible\"\u003etrue\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e 常用标签 判空：全扩起来加！ 例如：value=\"${(qo.startDate?string(‘yyyy-MM-dd’))!}\" 指令：其实就是指 ftl 的标签，这些标签一般以符号#开头 include指令 在当前模板文件中引入另一个模板文件 \u003c!--freemarker引入模板文件 之前已经配置了模板路径为/WEB-INF/views/ 这里就不需要写了 --\u003e \u003c#include \"/common/link.ftl\" \u003e assign指令 使用该指令可以在当前模板中创建一个新的变量， 或者替换一个已经存在的变量 创建变量 currentMenu并赋值： \u003c#assign currentMenu=\"department\"/\u003e 可使用${}获取该变量 ${currentMenu} list指令 用于循环遍历序列 \u003c#list pageInfo.list as department\u003e \u003ctr\u003e \u003ctd\u003e${department_index+1}\u003c/td\u003e \u003ctd\u003e${department.name}\u003c/td\u003e \u003ctd\u003e${department.sn}\u003c/td\u003e \u003c/tr\u003e \u003c#/list\u003e 注释：FreeMarker的注释和 HTML 的注释相似，但是它用\u003c#–和–\u003e来分隔的。任何介于这两个分隔符（包含分隔符本身）之间内容会被 FreeMarker 忽略，不会显示到页面，一般用来注释有freemarker指令相关的代码。 \u003c#-- \u003ctd\u003e${department.name}\u003c/td\u003e --\u003e if指令 用于条件判断 \u003c#if condition\u003e ... \u003c#elseif condition2\u003e ... \u003c#elseif condition3\u003e ... \u003c#else\u003e ... \u003c/#if\u003e condition : 将被计算成布尔值的表达式 elseif 和 else 是可选的 ","date":"2021-07-26","objectID":"/ssm/:2:1","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"二.分页插件 前端 \u003cdiv style=\"text-align: center;\"\u003e \u003cul id=\"pagination\" class=\"pagination\"\u003e\u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e //分页 $(function(){ $(\"#pagination\").twbsPagination({ totalPages: ${result.pages} || 1, startPage: ${result.pageNum} || 1, visiblePages:5, first:\"首页\", prev:\"上页\", next:\"下页\", last:\"尾页\", initiateStartPageClick:false, onPageClick:function(event,page){ $(\"#currentPage\").val(page); $(\"#searchForm\").submit(); } }); }) \u003c/script\u003e 后端 pom \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper\u003c/artifactId\u003e \u003cversion\u003e5.1.2\u003c/version\u003e \u003c/dependency\u003e xml配置 \u003c!-- 数据库链接 --\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003c!-- 将pageHelper配置到sqlsessionfactory --\u003e \u003cproperty name=\"plugins\"\u003e \u003carray\u003e \u003cbean class=\"com.github.pagehelper.PageInterceptor\"\u003e \u003cproperty name=\"properties\"\u003e \u003c!--使用下面的方式配置参数，一行配置一个，下面配的是合理化分页 --\u003e \u003cvalue\u003e reasonable=true \u003c/value\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/array\u003e \u003c/property\u003e \u003c/bean\u003e 实现代码 package cn.wolfcode.wolfcar.query; import lombok.*; @Setter @Getter @NoArgsConstructor @AllArgsConstructor @ToString public class QueryObject { private int currentPage = 1; private int pageSize = 10; } public PageInfo\u003cDepartment\u003e query(QueryObject qo) { //使用分页插件,传入当前页,每页显示数量 PageHelper.startPage(qo.getCurrentPage(), qo.getPageSize()); List\u003cDepartment\u003e departments = departmentMapper.selectForList(qo); return new PageInfo(departments); } ","date":"2021-07-26","objectID":"/ssm/:2:2","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"三.Bootstrap 模态框 代码去https://v5.bootcss.com/ $('#模态框的id').modal('show'); //官方文档中表示通过该方法即可弹出模态框 //关闭模态框 $(\"#模态框的id\").modal(\"hide\"); ","date":"2021-07-26","objectID":"/ssm/:2:3","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"四.sweetalert2 弹出框插件 引入插件 \u003clink rel=\"stylesheet\" href=\"/js/plugins/sweetalert2/sweetalert2.min.css\"\u003e \u003cscript src=\"/js/plugins/sweetalert2/sweetalert2.min.js\"\u003e\u003c/script\u003e 使用插件（如何配置看官方文档） $(function(){ Swal.fire({ title: 'Are you sure?', text: \"You won't be able to revert this!\", icon: 'warning', showCancelButton: true, confirmButtonColor: '#3085d6', cancelButtonColor: '#d33', confirmButtonText: 'Yes, delete it!' }).then((result) =\u003e { if (result.value) { //点击确认按钮后做的事情 Swal.fire( 'Deleted!', 'Yrour file has been deleted.', 'success' ) } }) }) ","date":"2021-07-26","objectID":"/ssm/:2:4","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"五.表单验证插件 引入插件 \u003c!--引入验证插件的样式文件--\u003e \u003clink rel=\"stylesheet\" href=\"/js/plugins/bootstrap-validator/css/bootstrapValidator.min.css\"/\u003e \u003c!--引入验证插件的js文件--\u003e \u003cscript type=\"text/javascript\" src=\"/js/plugins/bootstrap-validator/js/bootstrapValidator.min.js\"\u003e\u003c/script\u003e \u003c!--中文语言库--\u003e \u003cscript type=\"text/javascript\" src=\"/js/plugins/bootstrap-validator/js/language/zh_CN.js\"\u003e\u003c/script\u003e 使用插件 $(\"#editForm\").bootstrapValidator({ feedbackIcons: { //图标 valid: 'glyphicon glyphicon-ok', invalid: 'glyphicon glyphicon-remove', validating: 'glyphicon glyphicon-refresh' }, fields:{ //配置要验证的字段 username:{ validators:{ //验证的规则 notEmpty:{ //不能为空 message:\"用户名必填\" //错误时的提示信息 }, stringLength: { //字符串的长度范围 min: 1, max: 5 } } }, password:{ validators:{ notEmpty:{ //不能为空 message:\"密码必填\" //错误时的提示信息 }, } }, repassword:{ validators:{ notEmpty:{ //不能为空 message:\"密码必填\" //错误时的提示信息 }, identical: {//两个字段的值必须相同 field: 'password', message: '两次输入的密码必须相同' }, } }, email: { validators: { emailAddress: {} //邮箱格式 } }, age:{ validators: { between: { //数字的范围 min: 18, max: 60 } } } } }).on('success.form.bv', function() { //表单所有数据验证通过后执行里面的代码 //提交异步表单 $(\"#editForm\").ajaxSubmit(function() { }) }); ","date":"2021-07-26","objectID":"/ssm/:2:5","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"六.POI操作excel poi中关于excel的概念 Workbook（对应为一个excel） Sheet（excel中的表） Row（表中的行） Column（表中的列） Cell（表中的单元格，由行号和列号组成） pom \u003cdependency\u003e \u003cgroupId\u003eorg.apache.poi\u003c/groupId\u003e \u003cartifactId\u003epoi\u003c/artifactId\u003e \u003cversion\u003e4.1.2\u003c/version\u003e \u003c/dependency\u003e controller //导出 @RequestMapping(\"/exportXls\") public void exportXls(HttpServletResponse response) throws Exception { //文件下载的响应头（让浏览器访问资源的的时候以下载的方式打开） response.setHeader(\"Content-Disposition\",\"attachment;filename=employee.xls\"); //创建excel文件 Workbook wb = employeeService.exportXls(); //把excel的数据输出给浏览器 wb.write(response.getOutputStream()); } //导入 @RequestMapping(\"/importXls\") @ResponseBody public JsonResult importXls(MultipartFile file) throws Exception { employeeService.importXls(file); return new JsonResult(); } service //导出 public Workbook exportXls() { //创建excel文件 Workbook wb = new HSSFWorkbook(); //创建sheet Sheet sheet = wb.createSheet(\"员工名单\"); //标题行 Row row = sheet.createRow(0); //设置内容到单元格中 row.createCell(0).setCellValue(\"姓名\"); row.createCell(1).setCellValue(\"邮箱\"); row.createCell(2).setCellValue(\"年龄\"); //查询员工数据 List\u003cEmployee\u003e employees = employeeMapper.selectAll(); for (int i = 0; i \u003c employees.size(); i++) { Employee employee = employees.get(i); //创建行(每个员工就是一行) row = sheet.createRow(i+1); //设置内容到单元格中 row.createCell(0).setCellValue(employee.getName()); row.createCell(1).setCellValue(employee.getEmail()); row.createCell(2).setCellValue(employee.getAge()); } return wb; } //导入 public void importXls(MultipartFile file) throws Exception { //把接收到的文件以excel的方式去读取并操作 Workbook wb = new HSSFWorkbook(file.getInputStream()); //读取第一页 Sheet sheet = wb.getSheetAt(0); //获取最后一行的索引 int lastRowNum = sheet.getLastRowNum(); //从索引为1的行数开始读(忽略标题行) for (int i = 1; i \u003c= lastRowNum; i++) { //获取行数据 Row row = sheet.getRow(i); String name = row.getCell(0).getStringCellValue(); //判断如果用户名是空，就不再往下读 if(!StringUtils.hasLength(name.trim())){ return; } Employee employee = new Employee(); employee.setName(name); employee.setEmail(row.getCell(1).getStringCellValue()); if(cell.getCellType() == CellType.NUMERIC){ //获取数值类型的单元格内容 double cellValue = row.getCell(2).getNumericCellValue(); employee.setAge((int)cellValue); }else{ //获取文本格式的单元格内容 String age = row.getCell(2).getStringCellValue(); employee.setAge(Integer.valueOf(age)); } //设置默认密码1 employee.setPassword(\"1\"); //调用保存方法 this.save(employee,null); } } ","date":"2021-07-26","objectID":"/ssm/:2:6","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"七.统一异常处理 @ControllerAdvice @ExceptionHandler(Exception.class) 异常处理的类必须加到ioc容器中 package cn.wolfcode.wolfcar.advice; import cn.wolfcode.wolfcar.result.JSonResult; import com.alibaba.fastjson.JSON; import org.apache.shiro.authc.IncorrectCredentialsException; import org.apache.shiro.authc.UnknownAccountException; import org.apache.shiro.authz.AuthorizationException; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.method.HandlerMethod; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @ControllerAdvice public class MyControllerAdvice { @ExceptionHandler(AuthorizationException.class) public String func(AuthorizationException e, HttpServletResponse response, HandlerMethod handlerMethod) throws IOException { e.printStackTrace();; ResponseBody methodAnnotation = handlerMethod.getMethodAnnotation(ResponseBody.class); if (methodAnnotation == null) { return \"common/nopermission\"; } else { response.setContentType(\"application/json;charset=utf-8\"); JSonResult jSonResult = JSonResult.error(\"没有权限\"); response.getWriter().write(JSON.toJSONString(jSonResult)); return null; } } @ExceptionHandler(UnknownAccountException.class) public String unknownAccountExceptionHandler(AuthorizationException e, HttpServletResponse resp) throws IOException { e.printStackTrace(); resp.setContentType(\"application/json;charset=utf-8\"); JSonResult jsonreslut = JSonResult.error(\"无此用户\"); resp.getWriter().write(JSON.toJSONString(jsonreslut)); return null; } @ExceptionHandler(IncorrectCredentialsException.class) public String incorrectCredentialsExceptionHandler(AuthorizationException e, HttpServletResponse resp) throws IOException { e.printStackTrace(); resp.setContentType(\"application/json;charset=utf-8\"); JSonResult jsonreslut = JSonResult.error(\"密码错误\"); resp.getWriter().write(JSON.toJSONString(jsonreslut)); return null; } @ExceptionHandler(Exception.class) public String exceptionHandler(AuthorizationException e, HttpServletResponse resp, HandlerMethod handlerMethod) throws IOException { e.printStackTrace(); ResponseBody ann = handlerMethod.getMethodAnnotation(ResponseBody.class); if(ann == null){ return \"common/error\"; }else{ resp.setContentType(\"application/json;charset=utf-8\"); JSonResult jsonreslut = JSonResult.error(\"系统错误，请联系管理员\"); resp.getWriter().write(JSON.toJSONString(jsonreslut)); return null; } } } ","date":"2021-07-26","objectID":"/ssm/:2:7","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"八.shiro ","date":"2021-07-26","objectID":"/ssm/:2:8","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":" Subject（用户）： 访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体； Subject 一词是一个专业术语，其基本意思是“当前的操作用户”。 在程序任意位置可使用：Subject currentUser = SecurityUtils.getSubject() 获取到subject主体对象，类似 Employee user = UserContext.getUser() SecurityManager（安全管理器）：它是 shiro 功能实现的核心，负责与后边介绍的其他组件(认证器/授权器/缓存控制器)进行交互，实现 subject 委托的各种功能。有点类似于SpringMVC 中的 DispatcherServlet 前端控制器，负责进行分发调度。 Realms（数据源）： Realm 充当了 Shiro 与应用安全数据间的“桥梁”或者“连接器”。；可以把Realm 看成 DataSource，即安全数据源。执行认证（登录）和授权（访问控制）时，Shiro 会从应用配置的 Realm 中查找相关的比对数据。以确认用户是否合法，操作是否合理。 Authenticator（认证器）： 用于认证，从 Realm 数据源取得数据之后进行执行认证流程处理。 Authorizer（授权器）：用户访问控制授权，决定用户是否拥有执行指定操作的权限。 SessionManager （会话管理器）：Shiro 与生俱来就支持会话管理，这在安全类框架中都是独一无二的功能。即便不存在 web 容器环境，shiro 都可以使用自己的会话管理机制，提供相同的会话 API。 CacheManager （缓存管理器）：用于缓存认证授权信息等。 Cryptography（加密组件）： Shiro 提供了一个用于加密解密的工具包。 认证-授权 在RBAC基础上 用户（Employee）：角色施加的主体；用户通过拥有某个或多个角色以得到对应的权限。 角色（Role）：表示一组权限的集合。 权限（Permission）：一个资源代表一个权限，是否能访问该资源，就是看是否有该权限。 pom \u003cproperties\u003e \u003cshiro.version\u003e1.5.2\u003c/shiro.version\u003e \u003c/properties\u003e \u003c!--shiro 核心--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-core\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 的 Web 模块--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-web\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 和 Spring 集成--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-spring\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 底层使用的 ehcache 缓存--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-ehcache\u003c/artifactId\u003e \u003cversion\u003e${shiro.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 依赖的日志包--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-logging\u003c/groupId\u003e \u003cartifactId\u003ecommons-logging\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--shiro 依赖的工具包--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e \u003c!--Freemarker 的 shiro 标签库--\u003e \u003cdependency\u003e \u003cgroupId\u003enet.mingsoft\u003c/groupId\u003e \u003cartifactId\u003eshiro-freemarker-tags\u003c/artifactId\u003e \u003cversion\u003e1.0.1\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.apache.shiro\u003c/groupId\u003e \u003cartifactId\u003eshiro-all\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 配置 代理过滤器 因为真正的shiroFilter需要注入很多复杂的对象，而web.xml中只能配置字符串或数字的参数，是不能满足的，因此我们会把shiroFilter交给 Spring 进行管理，通过spring的xml文件来配置。 \u003cfilter\u003e \u003cfilter-name\u003eshiroFilter\u003c/filter-name\u003e \u003cfilter-class\u003e org.springframework.web.filter.DelegatingFilterProxy \u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eshiroFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e 编写单独的shiro配置 shiro.xml 并在 mvc.xml中引入 shiro.xml anon: 匿名过滤器，即不需要登录即可访问；一般用于静态资源过滤； 示例 /static/**=anon authc: 表示需要认证(登录)才能使用; 示例 /**=authc ***roles:***角色授权过滤器，验证用户是否拥有资源角色； 示例 /admin/*=roles[admin] ***perms:***权限授权过滤器，验证用户是否拥有资源权限； 示例 /employee/input=perms[“user:update”] ***logout:***注销过滤器 示例 /logout=logout \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:component-scan base-package=\"cn.wolfcode.wolfcar.realm\"\u003e\u003c/context:component-scan\u003e \u003c!-- aop自动代理 --\u003e \u003cbean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\" depends-on=\"lifecycleBeanPostProcessor\" /\u003e \u003c!-- 管理shiro生命周期 --\u003e \u003cbean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"\u003e\u003c/bean\u003e \u003c!-- 安全管理器 --\u003e \u003cbean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"\u003e \u003cproperty name=\"securityManager\" ref=\"securityManager\"/\u003e \u003c/bean\u003e \u003cbean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"\u003e \u003c!--引用指定的安全管理器--\u003e \u003cproperty name=\"securityManager\" ref=\"security","date":"2021-07-26","objectID":"/ssm/:2:9","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"九.文件上传下载commons-fileupload 准备 添加文件上传依赖 \u003c!--fileupload--\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-fileupload\u003c/groupId\u003e \u003cartifactId\u003ecommons-fileupload\u003c/artifactId\u003e \u003cversion\u003e1.3.1\u003c/version\u003e \u003c/dependency\u003e 添加文件上传解析器 \u003c!--文件上传解析器 id必须是multipartResolver--\u003e \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e \u003c!--最大上传文件大小 10M--\u003e \u003cproperty name=\"maxUploadSize\" value=\"#{1024*1024*10}\"/\u003e \u003c/bean\u003e 上传 @RequestMapping(\"/saveOrUpdate\") public String saveOrUpdate(MultipartFile file, Business business, HttpServletRequest request) throws IOException, IllegalAccessException { //判断有无上传文件 if (file.getSize() != 0) { //删除旧文件 if (business.getId() != null) { String license_img = business.getLicense_img(); //获取当前项目路径 String realPath = request.getServletContext().getRealPath(\"/\"); File oldFile = new File(realPath+license_img); oldFile.delete(); } //处理图片名称 String originalFilename = file.getOriginalFilename(); String date = DateUtil.format(new Date(), \"yyyyMMddHHmmss\"); String s1 = RandomUtil.randomNumbers(5); String[] split = originalFilename.split(\"\\\\.\"); String s = split[split.length-1]; StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(date); stringBuffer.append(s1); stringBuffer.append(\".\"); stringBuffer.append(s); String filename = stringBuffer.toString(); //处理地址 String realPath = request.getServletContext().getRealPath(\"/img/\"); //建立文件 File file1 = new File(realPath,filename); //文件传输 FileOutputStream fileOutputStream = new FileOutputStream(file1); InputStream inputStream = file.getInputStream(); byte[] bytes = new byte[100]; int len = 0; while ((len = inputStream.read(bytes)) != -1) { fileOutputStream.write(bytes,0,len); } fileOutputStream.close(); //存储 business.setLicense_img(\"/img/\"+filename); } //处理乱码问题 CharaUtil.convert(business,Business.class); if (business.getId() == null) { BusinessService.insert(business); } else { BusinessService.updateByPrimaryKey(business); } return \"redirect:/business/list\"; } 下载 @RequestMapping(value = \"/download\") public void download(HttpServletRequest request, HttpServletResponse response)throws IOException { //模拟文件，myfile.txt为需要下载的文件 String filename = \"aaa\"; String path = \"D:\\\\file\" + \"\\\\\" + filename; //获取输入流 InputStream bis = new BufferedInputStream(new FileInputStream(newFile(path))); //转码，免得文件名中文乱码 filename = URLEncoder.encode(filename, \"UTF-8\");//设置文件下载头 response.addHeader(\"Content-Disposition\", \"attachment;filename=\" + filename); //1.设置文件ContentType类型，这样设置，会自动判断下载文件类型 response.setContentType(\"multipart/form-data\"); BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream()); int len = 0; while ((len = bis.read()) != -1) { out.write(len); out.flush(); } out.close(); } ","date":"2021-07-26","objectID":"/ssm/:2:10","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"十.统一返回JSON @Setter @Getter public class JSonResult\u003cT\u003e { private int code; private String msg; private boolean success; private T data; public static \u003cT\u003e JSonResult success(T data) { JSonResult jSonResult = new JSonResult(); jSonResult.setSuccess(true); jSonResult.setData(data); return jSonResult; } public static \u003cT\u003e JSonResult error(String msg){ JSonResult jsonResult = new JSonResult(); jsonResult.setSuccess(false); jsonResult.setMsg(msg); return jsonResult; } } ","date":"2021-07-26","objectID":"/ssm/:2:11","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"十一.枚举解决状态问题 枚举类 public enum AppointmentStatusEnum { PEND(0,\"待确认\"), PERFORM(1,\"履行中\"), CONSUME(2,\"消费中\"), FINISH(3,\"归档\"), FAILURE(4,\"废弃\"); private String name; private Integer value; AppointmentStatusEnum(Integer value,String name) { this.value = value; this.name =name; } public static String getName(Integer value) { AppointmentStatusEnum[] valus = values(); for (AppointmentStatusEnum appointmentStatusEnum : valus) { if (appointmentStatusEnum.value.equals(value)) { return appointmentStatusEnum.name; } } return null; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getValue() { return value; } public void setValue(Integer value) { this.value = value; } } 使用 实体类使用 public String getStatusName() { String name = AppointmentStatusEnum.getName(this.status); return name; } 获取所有值 AppointmentStatusEnum[] values = AppointmentStatusEnum.values(); model.addAttribute(\"statuses\", values); ","date":"2021-07-26","objectID":"/ssm/:2:12","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["Spring"],"content":"十二.json转换问题 工具类(自写)反射 package cn.wolfcode.wolfcar.util; import cn.hutool.core.date.DateUtil; import com.alibaba.fastjson.JSON; import java.lang.reflect.Field; import java.util.Date; import java.util.HashMap; import java.util.Map; public class JsonUtil { public static String Convert(Object obj,Class clzz) throws IllegalAccessException { Map\u003cString,Object\u003e map = new HashMap\u003c\u003e(); Field[] fields = clzz.getDeclaredFields(); for (Field field:fields) { field.setAccessible(true); Object o = field.get(obj); map.put(field.getName(),o); } return JSON.toJSONString(map); } public static String Convert(Object obj, Class clzz, String format) throws IllegalAccessException { Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(); Field[] fields = clzz.getDeclaredFields(); for (Field field : fields) { field.setAccessible(true); if(field.getType().equals(Date.class)){ String sdate = DateUtil.format((Date) field.get(obj), format); map.put(field.getName(), sdate); } else map.put(field.getName(), field.get(obj)); } return JSON.toJSONString(map); } } 实体类使用 package cn.wolfcode.wolfcar.domain; import cn.wolfcode.wolfcar.myenum.AppointmentStatusEnum; import cn.wolfcode.wolfcar.util.JsonUtil; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.format.annotation.DateTimeFormat; import java.util.Date; @Data @AllArgsConstructor @NoArgsConstructor public class Appointment { private Long id; private String ano; private Integer status; // private Long category_id; private SystemDictionaryItem category; private String info; private String contact_tel; private String contact_name; // private Long business_id; private Business business; private Date create_time; @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm\") private Date appointment_time; public String getStatusName() { String name = AppointmentStatusEnum.getName(this.status); return name; } public String getJson() throws IllegalAccessException { return JsonUtil.Convert(this,Appointment.class,\"yyyy-MM-dd HH:mm\"); } } 前端使用 \u003ca href=\"javascript:void(0);\" data-json='${tmp.json}' class=\"btn btn-info btn-xs btn-input btnedit\" \u003e \u003cspan class=\"glyphicon glyphicon-pencil\"\u003e\u003c/span\u003e 编辑 \u003c/a\u003e $(\".btnedit\").click(function (){ var json = $(this).data(\"json\"); $(\"#business\").val(json.business.id); $(\"input[name=appointment_time]\").val(json.appointment_time); $(\"#category\").val(json.category.id); $(\"input[id=contact_name]\").val(json.contact_name); $(\"input[id=contact_tel]\").val(json.contact_tel); $(\"textarea[name=info]\").html(json.info); $(\"input[name=id]\").val(json.id); $(\"#editModal\").modal(\"show\"); }); ","date":"2021-07-26","objectID":"/ssm/:2:13","tags":["框架","整理"],"title":"SSM","uri":"/ssm/"},{"categories":["工具"],"content":"Typora使用Custom Command上传图片配置 ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:0:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"1.使用 node 安装 PicGo-Core sudo npm install -g picgo ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:1:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"2.使用 picgo 命令安装 gitee-uploader 插件 picgo install gitee-uploader ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:2:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"3.配置 Typroa 上传服务设定 上传服务：Custom Command 命令：[your node path] [your picgo path] upload 例：/usr/local/bin/node /usr/local/lib/node_modules/picgo/bin/picgo upload ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:3:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"4.配置文件 以阿里云为例 位置：/Users/\u003cUserName\u003e/.picgo/config.json { \"picBed\": { \"uploader\": \"aliyun\", \"current\": \"aliyun\", \"transformer\": \"path\", \"aliyun\": { \"accessKeyId\": \"\", \"accessKeySecret\": \"\", \"bucket\": \"\", // 存储空间名 \"area\": \"\", // 存储区域代号 \"path\": \"\", // 自定义存储路径 \"customUrl\": \"\", // 自定义域名，注意要加 http://或者 https:// \"options\": \"\" // 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+ } }, \"picgoPlugins\": {} } ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:4:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"5.配置时间戳重命名文件 安装插件 picgo install super-prefix 配置/Users/\u003cUserName\u003e/.picgo/config.json { \"picBed\": { ··· } }, \"picgoPlugins\": { \"picgo-plugin-super-prefix\": true, \"picgo-plugin-gitee-uploader\": true }, \"picgo-plugin-super-prefix\": { \"prefixFormat\": \"YYYY/MM/DD/\", \"fileFormat\": \"YYYYMMDD-HHmmss\" } } ","date":"2021-04-29","objectID":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/:5:0","tags":["图床"],"title":"Typora使用Custom Command上传图片配置","uri":"/typora%E4%BD%BF%E7%94%A8custom-command%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"Redis ","date":"2020-06-01","objectID":"/redis/:0:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"一.基本指令 key * //查询当前数据库所有的键 exists \u003ckey\u003e //判断某个键是否存在 1：true 2：false type \u003ckey\u003e //查看键的类型 del \u003ckey\u003e //删除键 expire \u003ckey\u003e \u003cseconds\u003e //为键设置过启德的时间 单位为秒 ttl \u003ckey\u003e //查看还有多长时间过期 “-1”代表永不过期 “-2”代表已过期 dbsize //查看当前库的key的数量 Flushdb //清空当前库 Flushall //通杀全部库 ","date":"2020-06-01","objectID":"/redis/:1:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"二.Redis的五大数据类型 ","date":"2020-06-01","objectID":"/redis/:2:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"1.String(使用最多) get \u003ckey\u003e //查询对应的键值 set \u003ckey\u003e \u003cvalue\u003e //添加键值对 append \u003ckey\u003e \u003cvalue\u003e //给给定的key追加值 strlen \u003ckey\u003e //获取值的长度 setnx \u003ckey\u003e \u003cvalue\u003e //只有在key不存在时设置key的值 incr \u003ckey\u003e //将key存储的数字值+1 只能对数字操作 decr \u003ckey\u003e //将key存储的数字值-1 只能对数字操作 incrby \u003ckey\u003e \u003c步长\u003e //将key存储的数字值+步长 只能对数字操作 decrby \u003ckey\u003e \u003c步长\u003e //将key存储的数字值-步长 只能对数字操作 mset \u003ckey1\u003e \u003cvalue1\u003e \u003ckey2\u003e \u003cvalue2\u003e ... //同时设置多个键值对 mget \u003ckey1\u003e \u003ckey2\u003e \u003ckey3\u003e ... //同时获取多尔衮value msetnx \u003ckey1\u003e \u003cvalue1\u003e \u003ckey2\u003e \u003cvalue2\u003e ... //同时设置多个键值对;当且仅当所有给定的key都不存在时 getrange \u003ckey\u003e \u003c起始位置\u003e \u003c结束位置\u003e //截取一段值；起始位置从0开始；包前也包后 setrange \u003ckey\u003e \u003c起始位置\u003e \u003cvalue\u003e //从起始位置开始赋值覆盖 setex \u003ckey\u003e \u003c过期时间\u003e \u003cvalue\u003e //设置键值的同时，设置过期时间 getset \u003ckey\u003e \u003cvalue\u003e //以旧换新 设置了新值的同时获得旧值 ","date":"2020-06-01","objectID":"/redis/:2:1","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"2.List 单键多值 底层是双向链表 对两端的操作性高，通过索引操作中间节点性能较差 lpush/rpush \u003ckey\u003e \u003cvalue1\u003e \u003cvalue2\u003e... //从左边/右边加入一个或多个值 lpop/rpop \u003ckey\u003e //从左边/右边取出一个值 rpoplpush \u003ckey1\u003e \u003ckey2\u003e //从key1的右边取出一个放在key2的左边 lrange \u003ckey\u003e \u003cstart\u003e \u003cstop\u003e //按照索引下标获得元素（从左到右）负值从右到左 lindex \u003ckey\u003e \u003cindex\u003e //按照索引下标获得元素（从左到右） llen \u003ckey\u003e //获得列表长r度 linsert \u003ckey\u003e after/before \u003cvalue\u003e \u003cnewvalue\u003e //在value 后/前插入 newvalue 的值 如果有相同的值 只对第一个起作用 lrem \u003ckey\u003e \u003cn\u003e \u003cvalue\u003e //删除n个value 正数从左往右删 负数从右往左 0代表删除所有 ","date":"2020-06-01","objectID":"/redis/:2:2","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"3.Set 与list功能类似 但是value不能重复 String类型的无序集合 底层是value为空的hash表 删除查找的复杂度都是O(1) sadd \u003ckey\u003e \u003cvalue1\u003e \u003cvalue2\u003e... //加入一个或多个值 smembers \u003ckey\u003e //取出该集合的所有值 sismember \u003ckey\u003e \u003cvalue\u003e //判断集合\u003ckey\u003e是否为含有该\u003cvalue\u003e值，有返回1，没有返回0 scard \u003ckey\u003e //返回该集合的元素个数 srem \u003ckey\u003e \u003cvalue1\u003e \u003cvalue2\u003e //删除集合中的某个元素 spop \u003ckey\u003e //随机从元素中吐出一个值 srandmember \u003ckey\u003e \u003cn\u003e //随机从元素中吐出N个值,不会删除 sinter \u003ckey1\u003e \u003ckey2\u003e //返回两个集合的交集 sunion \u003ckey1\u003e \u003ckey2\u003e //返回两个集合的并集 sdiff \u003ckey1\u003e \u003ckey2\u003e //返回两个集合的差集 ","date":"2020-06-01","objectID":"/redis/:2:3","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"4.Hash 是键值对集合 适合存储对象 类似java中的 Map\u003cString,String\u003e hset \u003ckey\u003e \u003cfield\u003e \u003cvalue\u003e //为指定的key设定field和value hget \u003ckey\u003e \u003cfield\u003e //取出指定的value hmset \u003ckey\u003e \u003cfield\u003e \u003cvalue\u003e \u003cfield\u003e \u003cvalue\u003e... //为指定的key设定一个或多个field和value hexists \u003ckey\u003e \u003cfield\u003e //在key里面是否存在指定的field hkeys \u003ckey\u003e //获取hash表所有key hvals \u003ckey\u003e //获取hash表所有值 hgetall \u003ckey\u003e //获取hash表所有的键值对 hincrby \u003ckey\u003e \u003cfield\u003e \u003cincrement\u003e //增加某个field的值,只能是数字 hsetnx \u003ckey\u003e \u003cfield\u003e \u003cvalue\u003e //当不存在才创建该field hlen \u003ckey\u003e //获取hash表中的字段数量 hdel \u003ckey\u003e \u003cfield1\u003e \u003cfield2\u003e //删除一个或多个hash表的字段 ","date":"2020-06-01","objectID":"/redis/:2:4","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"5.ZSet 在Set的基础上加上评分 zadd \u003ckey\u003e \u003cscore1\u003e \u003cvalue1\u003e //将一个或多个元素及其评分加入;相同元素，不同分数，会将分数更新 zrange \u003ckey\u003e \u003cstart\u003e \u003cstop\u003e [WITHSCORES] // 指定输出索引范围内的成员;[WITHSCORES]可以携带分数 zrevrange \u003ckey\u003e \u003cstart\u003e \u003cstop\u003e //返回有序集中指定区间内的成员，通过索引，分数从高到底 zrangebyscore \u003ckey\u003e \u003cmin\u003e \u003cmax\u003e //指定输出score区间内的成员 zincrby \u003ckey\u003e \u003cincrement\u003e \u003cvalue\u003e //为value元素的分数加上增量 zrem \u003ckey\u003e \u003cvalue\u003e //移除有序集合中的一个或多个成员 zcard \u003ckey\u003e //获取集合中的元素数量 zcount \u003ckey\u003e \u003cmin\u003e \u003cmax\u003e //计算在有序集合中指定区间分数的成员数 zrank \u003ckey\u003e \u003cvalue\u003e 返回有序集合指定成员的排名 使用zset实现文章访问量的排行 redis2:0\u003ezadd test 100000 java 80000 python 50000 php 120000 c++ 20000 js \"5\" redis2:0\u003ezrevrange test 0 -1 1) \"c++\" 2) \"java\" 3) \"python\" 4) \"php\" 5) \"js\" redis2:0\u003ezrevrangebyscore test 120000 10redis2:0\u003e0000 1) \"c++\" 2) \"java\" ","date":"2020-06-01","objectID":"/redis/:2:5","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"三.Redis的相关配置 ip地址绑定 默认 “bind 127.0.0.1”只接受本机访问 使其他机器访问解决方法 注释“bind 127.0.0.1” 取消绑定id “protected-mode yes” yes改为no 关闭保护模式 tcp-backlog 默认“tcp-backlog 511” 可以理解为请求到达后至进程处理前的队列 timeout 一个空闲的客户端维持多长时间(秒)会关闭，0代表永不关闭，默认0 tcp-keepalive 对客户端的心跳检测 官方推荐60s daemonize 是否为后台进程 pidfile 存放pid文件的位置 loglevel 默认 loglevel notice 日志级别 四个等级 database 设定库的数量 默认16 maxclient 最大客户端链接数 maxmemory 设置内存量 超过后 会根据maxmemory-policy指定移除 maxmemory-policy volatile-lru 使用LRU（最近最少使用）算法移除key，只对设置了过期时间的键 allkeys-lru 使用LRU算法移除key volatile-random 在过期集合中移除key，只对设置了过期时间的键 allkeys-random 随机移除 volatile-ttl(即将过期) 移除ttl最小的key noeviction 不移除(头铁 等着报错) maxmemory-samples 设置样本大小 3-7 一般3或5 ","date":"2020-06-01","objectID":"/redis/:3:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"四.连接java(SSM) jar： jedis-xxx.jar package com.jsh; import redis.clients.jedis.Jedis; public class Test { public static void main(String[] args) { Jedis jedis = new Jedis(\"127.0.0.1\",6379); String result = jedis.ping(); System.out.println(result); // jedis.set(\"a\",\"a\"); jedis.get(\"a\"); System.out.println(\"a\"); jedis.close(); } } ","date":"2020-06-01","objectID":"/redis/:4:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"手机短信验证例子 前端 \u003cform class=\"navbar-form navbar-left\" role=\"search\" id=\"codeform\"\u003e \u003cdiv class=\"form-group\"\u003e \u003cinput type=\"text\" class=\"form-control\" placeholder=\"填写手机号\" name=\"phone_no\"\u003e \u003cbutton type=\"button\" class=\"btn btn-default\" id=\"sendCode\"\u003e发送验证码\u003c/button\u003e\u003cbr\u003e \u003cfont id=\"countdown\" color=\"red\" \u003e\u003c/font\u003e \u003cbr\u003e \u003cinput type=\"text\" class=\"form-control\" placeholder=\"填写验证码\" name=\"verify_code\"\u003e \u003cbutton type=\"button\" class=\"btn btn-default\" id=\"verifyCode\"\u003e确定\u003c/button\u003e \u003cfont id=\"result\" color=\"green\" \u003e\u003c/font\u003e\u003cfont id=\"error\" color=\"red\" \u003e\u003c/font\u003e \u003c/div\u003e \u003c/form\u003e \u003cscript type=\"text/javascript\"\u003e var t=120;//设定倒计时的时间 var interval; function refer(){ $(\"#countdown\").text(\"请于\"+t+\"秒内填写验证码 \"); // 显示倒计时 t--; // 计数器递减 if(t\u003c=0){ clearInterval(interval); $(\"#countdown\").text(\"验证码已失效，请重新发送！ \"); } } $(function(){ $(\"#sendCode\").click( function () { $.post(\"/Verify_code/CodeSenderServlet\",$(\"#codeform\").serialize(),function(data){ if(data==\"true\"){ t=120; clearInterval(interval); interval= setInterval(\"refer()\",1000);//启动1秒定时 }else if (data==\"limit\"){ clearInterval(interval); $(\"#countdown\").text(\"单日发送超过次数！ \") } }); }); $(\"#verifyCode\").click( function () { $.post(\"/Verify_code/CodeVerifyServlet\",$(\"#codeform\").serialize(),function(data){ if(data==\"true\"){ $(\"#result\").attr(\"color\",\"green\"); $(\"#result\").text(\"验证成功\"); clearInterval(interval); $(\"#countdown\").text(\"\"); }else{ $(\"#result\").attr(\"color\",\"red\"); $(\"#result\").text(\"验证失败\"); } }); }); }); \u003c/script\u003e controller 模拟接收短信验证码并缓存 @WebServlet(\"/CodeSenderServlet\") public class CodeSenderServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CodeSenderServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取手机号 String phone_no = request.getParameter(\"phone_no\"); //模拟获取验证码 String code = getCode(6); //拼接key String codeKey = \"Verify_code:\" + phone_no + \":code\";//Verify_code:12345:code String countKey = \"Verify_code:\" + phone_no + \":count\"; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); //判断发送验证码的次数 String count = jedis.get(countKey); if(count == null) { //代表第一次 jedis.setex(countKey, 24*60*60, \"1\"); }else if(Integer.parseInt(count) \u003c= 2) { jedis.incr(countKey); }else if(Integer.parseInt(count) \u003e 2) { response.getWriter().print(\"limit\"); jedis.close(); return ; } //向redis中进行存储，以手机号为键，以验证码为值 jedis.setex(codeKey, 120, code); jedis.close(); response.getWriter().print(true); } //模拟短信 private String getCode(int length) { String code = \"\"; Random random = new Random(); for(int i = 0; i \u003c length; i++) { int rand = random.nextInt(10); code += rand; } return code; } } 从缓存中取出返回到前端 package com.atguigu.servlet; @WebServlet(\"/CodeVerifyServlet\") public class CodeVerifyServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CodeVerifyServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取验证码和手机号 String phone_no = request.getParameter(\"phone_no\"); String verify_code = request.getParameter(\"verify_code\"); //拼接key String codeKey = \"Verify_code:\" + phone_no + \":code\"; //从redis中获取手机号所对应的验证码 Jedis jedis = new Jedis(\"127.0.0.1\", 6379); String code = jedis.get(codeKey); if(code.equals(verify_code)) { response.getWriter().print(true); } jedis.close(); } } ","date":"2020-06-01","objectID":"/redis/:4:1","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"五.Redis事务 编译出错会直接取消 例如：单词拼写错误 某一步如果在运行时出错 只会取消那一步的操作 multi //开启事务 exec //提交事务 discard //取消事务 演示 redis2:0\u003emulti \"OK\" redis2:0\u003eset a a \"QUEUED\" redis2:0\u003eset b c \"QUEUED\" redis2:0\u003eexec 1) \"OK\" 2) \"OK\" 监视 watch \u003ckey\u003e //监视key 如果发现被改变 事务取消 unwatch // 取消对所有key的监视 如果exec或discard执行了 就不需要再执行unwatch 三特性 单独的隔离操作：事务中的所有命令都会序列化，按顺序的执行。事务在等待执行的时候，不会被其他客户端发送来的米命令请求打断 没有隔离级别的概念：队列中的所有命令没有提交exec之前都是不会被执行的 不保证原子性：redis中如果一条命令执行失败，其后的命令仍然会被执行，没有回滚 ","date":"2020-06-01","objectID":"/redis/:5:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"六.持久化 ","date":"2020-06-01","objectID":"/redis/:6:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"RDB 在指定的时间间隔内生成内存中整个数据集的持久化快照。快照文件默认被存储在当前文件夹中，名称为dump.rdb，可以通过dir和dbfilename参数来修改默认值。 恢复数据特别快，节省空间，存储的是数据 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何的IO操作的，这就确保了极高的性能。 缺点：最后一次持久化后数据可能丢失 配置文件 # redis是基于内存的数据库，可以通过设置该值定期写入磁盘。 # 注释掉“save”这一行配置项就可以让保存数据库功能失效 # 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） # 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） # 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化） save 900 1 save 300 10 save 60 10000 #当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误 stop-writes-on-bgsave-error yes #使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间 推荐压缩 rdbcompression yes #是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。 rdbchecksum yes #rdb文件的名称 dbfilename dump.rdb #数据目录，数据库的写入会在这个目录。 dir ./ 默认在当前文件夹下 触发条件 通过配制文件中的save条件（可自己配置） save 900 1 save 300 10 save 60 10000 手动通过save和bgsave命令 save：save时只管保存，其他不管，全部阻塞 bgsave：redis会在后台异步的进行快照操作，同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的事件 如何恢复 关闭Redis 把备份的文件拷贝到工作目录下 启动Redis,会自动加载 ","date":"2020-06-01","objectID":"/redis/:6:1","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"AOF 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作补不可记录），只许追加文件但不可以改写文件，redis启动之初会读取改文件重新构建数据。保存的是appendonly.aof文件 aof机制默认关闭，可以通过appendonly = yes参数开启aof机制，通过appendfilename = myaoffile.aof指定aof文件名称。 #aof持久化策略的配置 #no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 #always表示每次写入都执行fsync，以保证数据同步到磁盘。 #everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。 appendfsync everysec 对于触发aof重写机制也可以通过配置文件来进行设置： # aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。 auto-aof-rewrite-percentage 100 # 设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写 auto-aof-rewrite-min-size 64mb # 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题。如果对延迟要求很高的应用，这个字段可以设置为yes，，设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,不会造成阻塞的问题（因为没有磁盘竞争），等rewrite完成后再写入，这个时候redis会丢失数据。Linux的默认fsync策略是30秒。可能丢失30秒数据。因此，如果应用系统无法忍受延迟，而可以容忍少量的数据丢失，则设置为yes。如果应用系统无法忍受数据丢失，则设置为no。 no-appendfsync-on-rewrite no 如何恢复 正常恢复 ​ 将文件放到dir指定的文件夹下，当redis启动的时候会自动加载数据，注意：aof文件的优先级比dump大。 异常恢复 有些操作可以直接到appendonly.aof文件里去修改。 eg：使用了flushall这个命令，此刻持久化文件中就会有这么一条命令记录，把它删掉就可以了 写坏的文件可以通过 redis-check-aof --fix进行修复 优势 根据不同的策略，可以实现每秒，每一次修改操作的同步持久化，就算在最恶劣的情况下只会丢失不会超过两秒数据。 当文件太大时，会触发重写机制，确保文件不会太大。 文件可以简单的读懂 劣势 aof文件的大小太大，就算有重写机制，但重写所造成的阻塞问题是不可避免的 aof文件恢复速度慢。 ","date":"2020-06-01","objectID":"/redis/:6:2","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"总结 如果你只希望你的数据在服务器运行的时候存在，可以不使用任何的持久化方式 一般建议同时开启两种持久化方式。AOF进行数据的持久化，确保数据不会丢失太多，而RDB更适合用于备份数据库，留着一个做万一的手段。 性能建议： 因为RDB文件只用做后备用途，建议只在slave上持久化RDB文件，而且只要在15分钟备份一次就够了，只保留900 1这条规则。 如果Enalbe AOF,好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价：1、带来了持续的IO；2、AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。 如果不Enable AOF,仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时宕掉，会丢失10几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。 ","date":"2020-06-01","objectID":"/redis/:6:3","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"七.复制(master/slaver) 就是我们常说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主 读写分离 容灾恢复 主服务器用来写 从服务器用来读 不管何时 从机都和主机数据相同 主机shutdown后，从机等待 ","date":"2020-06-01","objectID":"/redis/:7:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"配置(配置从服务器，不配置主服务器) 拷贝多个redis文件include 开启daemonize yes Pid文件名字pidfile 指定端口port Log文件名字 Dump.rdb名字dbfilename Appendonly关掉或者换名字 如果要永久 在配置文件中 配置 slaveof 命令 info replication //打印主从相关信息 slaveof \u003cip\u003e \u003cport\u003e //成为某个实例的从服务器 slaveof no one //将从机变为主机 ","date":"2020-06-01","objectID":"/redis/:7:1","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"薪火相传 含义:就是上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。 ","date":"2020-06-01","objectID":"/redis/:7:2","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"哨兵模式 反客为主的自动版，能够后台监控Master库是否故障，如果故障了根据投票数自动将slave库转换为主库。一组sentinel能同时监控多个Master。 使用步骤： 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错； 配置哨兵，在sentinel.conf文件中填入内容(可以配置多个)： #说明：最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机。 sentinel monitor 被监控数据库名字（自己起名字） ip port 1 启动哨兵模式(路径按照自己的需求进行配置)： redis-sentinel /myredis/sentinel.conf 注意： 当master挂掉后，会通过选票进行选出下一个master。而且只有使用了sentinel.conf启动的才能开启选票 当原来的master后来后，很不幸变成了slave。 ","date":"2020-06-01","objectID":"/redis/:7:3","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"八.Redis集群（以后再学） 实现了水平扩容，启动N个节点，将整个数据库储存分布在N个节点中，每个节点存储数据的1/N ","date":"2020-06-01","objectID":"/redis/:8:0","tags":["非关系型数据库"],"title":"Redis","uri":"/redis/"},{"categories":["数据库"],"content":"SQL ","date":"2020-03-26","objectID":"/sql/:0:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"创建数据库 : CREATE DATABASE 数据库名; CREATE DATABASE teach; ","date":"2020-03-26","objectID":"/sql/:1:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"进入数据库：USE 数据库名; USE teach; ","date":"2020-03-26","objectID":"/sql/:2:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"创建表：CREATE TABLE 表名; ​ 属性名 属性类型 完整性约束, ​ 属性名 属性类型 完整性约束, ​ 属性名 属性类型 完整性约束 ​ ); 完整性约束： 主码约束: PRIMARY KEY 参照完整性约束：FOREIGN KEY…REFERENCES… 唯一性约束: UNIQUE 非空值约束：NOT NULL 取值约束：CHECK 属性类型： 整数 bigint: 以8个字节来存储正负数, 范围：-2 63 到 2 63 -1 int: 以4个字节来存储正负数，范围：-2 31 到 2 31 -1 smallint: 以2个字节来存储正负数.，范围：-2 15 到 2 15 -1 tinyint: 是最小的整数类型,存储正整数，仅用1字节,范围:0至2 8 -1 bit: 值只能是0或1，当输入0以外的其他值时，系统均认为是1 常用来表示真假、男女等二值选择。 精确数值 decimal:用来存储从-1038+1到1038 -1的固定精度和范围的数值型数据 • 必须指定范围和精度：decimal (p,q) 例：decimal (10,2) numeric:和decimal相同 浮点 float: 用8个字节来存储数据.最多可为53位. 范围为:-1.79E+308至1.79E+308. real: 位数为24,用4个字节 数字范围:-3.04E+38至3.04E+38 字符串 char: char(n)固定的长度为 n个字符的字符串, 不足的长度会用空格 补上. varchar: varchar(n)可变的最长长度为n个字符的字符串，尾部的空 格会去掉. 时间日期 date: 日期类型 • DATE ‘yyyy-mm-dd’ • Example: DATE ‘2004-09-30’ time:时间类型 • TIME ‘hh:mm:ss’ • Example: TIME ‘15:30:02.5‘ datetime:日期时间类型 CREATE TABLE student( sid CHAR(8) PRIMARY KEY, sname VARCHAR(20) NOT NULL, sgender CHAR(1), sdept INT, sbirth DATE ); 当多个属性为主键时 CREATE TABLE SC( Sno CHAR(5) , Cno INT , Grade INT, PRIMARY KEY (Sno, Cno)); ","date":"2020-03-26","objectID":"/sql/:3:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"修改基本表 ALTER TABLE \u003c表名\u003e [ ADD \u003c新列名\u003e \u003c数据类型\u003e | 完整性约束 ] [ DROP \u003c列名\u003e|\u003c完整性约束名\u003e ] [ MODIFY \u003c列名\u003e \u003c数据类型\u003e ]； ADD子句：增加新列和新的完整性约束条件 DROP子句：删除指定列或完整性约束条件 MODIFY子句：用于修改列名和数据类型 ","date":"2020-03-26","objectID":"/sql/:4:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"ADD ALTER TABLE 表名 ADD 属性名 属性类型; ALTER TABLE student ADD stime DATETIME; ","date":"2020-03-26","objectID":"/sql/:4:1","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"DROP ALTER TABLE 表名 DROP 属性名; ALTER TABLE Student DROP 主键约束的名字; ALTER TABLE student DROP STIME; ","date":"2020-03-26","objectID":"/sql/:4:2","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"MODIFY 更改数据类型 ALTER TABLE student MODIFY sname VARCHAR(20); ","date":"2020-03-26","objectID":"/sql/:4:3","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"删除基本表 DROP TABLE \u003c表名\u003e; DROP TABLE student; ","date":"2020-03-26","objectID":"/sql/:4:4","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"增删改查 ","date":"2020-03-26","objectID":"/sql/:5:0","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"SELECT SELECT ALL|DISTINCT(默认ALL(不去重) DISTINCT(去重)) 属性名(查询目标列或者表达式) FROM 表名（从哪个表中查询） WHERE 分组前条件 GROUP BY 属性名（根据属性值相同进行分组） HAVING 表达式（分组后条件） ORDER BY 属性名 ASC|DESC（根据属性名进行排序 默认升序(ASC) 降序(DESC)） 查询全体学生的学号和姓名 SELECT sno,sname FROM student; 查询全体学生的详细信息 SELECT * FROM student; 查询全体学生的出生日期 NOW()取得当前时间 SELECT 2020-sage FROM student; 查询出的值可以进行运算 SELECT YEAR(NOW())-sage FROM student; NOW()取得当前时间 对查询出的结果的列取别名 AS(可以省略) SELECT YEAR(NOW())-sage AS birthyear FROM student; SELECT sno AS s,sname AS b FROM student; 去重 DISTINCT SELECT DISTINCT sno FROM sc; 查询结果 变小写 变大写 SELECT LOWER(sdept) FROM student; SELECT UPPER(sdept) FROM student; where语句 查询所有年龄在20岁以下的学生姓名及其年龄 SELECT sname,sage FROM student WHERE sage\u003c20; 属性 BETWEEN 条件1 AND 条件2; --[例9] 查询年龄在20~23岁(包括20岁和23岁)之间的学生的姓名、系别和年龄 SELECT sname,sdept,sage FROM student WHERE sage BETWEEN 20 AND 23; --[例10] 查询年龄不在20~23岁之间的学生姓名、系别和年龄 SELECT sname,sdept,sage FROM student WHERE sage NOT BETWEEN 20 AND 23; 属性名 IN(‘属性一’,‘属性二’,‘属性三’) --[例11] 查询信息系(IS)、数学系(MA)和计算机科学系(CS)学生的姓名和性别 SELECT sname,ssex FROM student WHERE sdept IN('CS','IS','MA'); --[例12]查询既不是信息系、数学系，也不是计算机科学系的学生的姓名和性别 SELECT sname,ssex FROM student WHERE sdept NOT IN('CS','IS','MA'); like 模糊查询 %表示若干字符 _表示一个字符 避免原字符串中存在%或_的方法: 例十八 ，例十九 --[例14] 查询所有姓刘学生的姓名、学号和性别 SELECT sname,sno,ssex FROM student WHERE sname LIKE '刘%'; --[例15] 查询所有不姓刘的学生姓名、学号和性别 SELECT sname,sno,ssex FROM student WHERE sname NOT LIKE '刘%'; --[例16] 查询姓\"欧阳\"且全名为三个汉字的学生的姓名 SELECT sname FROM student WHERE sname LIKE '欧阳_'; --[例17] 查询名字中第2个字为\"阳\"字的学生的姓名和学号 SELECT sname FROM student WHERE sname LIKE '_阳%'; --[例18] 查询DB_Design课程的课程号和学分。 SELECT cno,ccredit FROM course WHERE cname LIKE 'DB\\_Design' ESCAPE'\\\\'; --[例19] 查询以\"DB_\"开头，且倒数第3个字符为 i的课程的详细情况 SELECT * FROM course WHERE cname LIKE 'DB\\_%i__' ESCAPE'\\\\'; IS NULL 判断为空 不可以使用 = NULL --[例20] 某些学生选修课程后没有参加考试，所以有选课记录，但没有考试成绩。查询缺少成绩的学生的学号和相应的课程号。 SELECT sno,cno FROM sc WHERE grade IS NULL; -- [例21] 查所有有成绩的学生学号和课程号 SELECT sno,cno FROM sc WHERE grade IS NOT NULL; 排序 ORDER BY 默认为升序 加上DESC变为降序 --[例25] 查询选修了3号课程的学生的学号及其成绩， --查询结果按分数降序排列 SELECT sno,grade FROM sc ORDER BY grade DESC; --[例26] 查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。 SELECT * FROM student ORDER BY sdept,sage DESC; COUNT(属性名) 返回数量 COUNT(*)表示全部 可以使用DISTINCT --[例27] 查询学生总人数。 SELECT COUNT(*) FROM student; --[例28] 查询选修了课程的学生人数。 SELECT COUNT(DISTINCT SNO) FROM sc; 平均值AVG 最大值MAX 最小值MIN --[例29] 计算1号课程的学生平均成绩 SELECT AVG(Grade) FROM sc WHERE cno=1; --[例30] 查询选修1号课程的学生最高分数 SELECT MAX(Grade) FROM sc WHERE cno=1; 分组 GROUP BY 属性名 --[例31] 求各个课程号及相应的选课人数。 SELECT cno,COUNT(sno) FROM sc GROUP BY cno; --[例32] 求各个课程号及相应的课程成绩在90分以上的学生人数 SELECT cno,COUNT(*) FROM sc WHERE grade\u003e=90 GROUP BY cno; HAVING 对分组后的数据进行判断 --[例33] 查询选修了3门以上课程的学生学号 SELECT sno FROM sc GROUP BY sno HAVING COUNT(*)\u003e=3; --[例34] 查询有3门以上课程在90分以上的学生的学号 --及90分以上的课程数 SELECT sno,COUNT(*) FROM sc WHERE grade\u003e=90 GROUP BY sno HAVING COUNT(*)\u003e=3; --[例35] 统计每门课程的最高分 SELECT cno,grade FROM sc GROUP BY cno HAVING MAX(Grade); 关联查询 --[例32] 查询每个学生及其选修课程的情况。 SELECT student.*,sc.* FROM student,sc; --[例33] 对[例32]用自然连接完成 SELECT student.*,sc.* FROM student,sc WHERE student.sno=sc.sno; --例：查询计算机系（CS）学生的学号，姓名，所在系， --选修的课程号，课程名和成绩 SELECT sc.sno,sname,sdept,sc.cno,cname,grade FROM student,sc,course WHERE student.sno=sc.sno AND course.cno=sc.cno AND sdept='CS'; -- [例34] 查询每一门课的直接先修课的课程名 SELECT a1.`Cname`,a2.`Cname` FROM course a1,course a2 WHERE a1.Cpno=a2.Cno; --[例35] 查询每一门课的间接先修课的课程号（即先修课的先修课）。 SELECT a1.cno,a2.cpno FROM course a1,course a2 WHERE a1.Cpno=a2.Cno; --[例36] 查询同时选修2号课程和3号课程学生的学号。 SELECT c1.sno FROM sc c1,sc c2 WHERE c1.sno = c2.sno AND c1.cno!=c2.cno AND c1.cno=2 AND c2.cno =3; 左连接查询 left join 右连接 right join 左连接，左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。 -- 例，查询全体学生信息及其选课信息 SELECT student.*,sc.* FROM student LEFT JOIN sc ON student.sno=sc.sno; 嵌套查询 -- [例37] 查询与“刘晨”在同一个系学习的学生。 -- ① 确定“刘晨”所在系名 SELECT Sdept FROM student WHERE sname = '刘晨'; -- ② 查找所有在IS系学习的学生。 SELECT * FROM student WHERE sdept IN (SELECT Sdept FROM student WHERE sname = '刘晨'); -- [例39]查","date":"2020-03-26","objectID":"/sql/:5:1","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"INSERT INSERT INTO 表名(属性名1，属性名2……) VALUES(属性值1，属性值二……); /*[例1]将一个新学生记录(学号:95020;姓名:陈冬; 性别:男;所在系:IS;年龄:18岁)插入到Student表中 */ INSERT INTO student VALUES('95020','陈冬','M',18,'IS'); -- [例2] 插入一条选课记录( '95020'，'1 ') INSERT INTO sc(sno,cno) VALUES ('95020','1'); 可以插入子查询的值 -- [例3] 对每一个系，求学生的平均年龄, -- 并把结果存入数据表 -- 第一步：建表 /*学生平均年龄*/ CREATE TABLE studentAvgAge( sdept VARCHAR(20), avgage SMALLINT ); -- 第二步：插入数据 INSERT INTO studentAvgAge SELECT sdept,AVG(sage) FROM student GROUP BY sdept; ","date":"2020-03-26","objectID":"/sql/:5:2","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"UPDATE UPDATE 表名 SET 属性名=属性值 WHERE 条件； --[例4] 将学生95001的年龄改为22岁。 UPDATE student SET sage = 22 WHERE sno='95001'; -- 将学生95001的年龄改为21岁,性别改为女性。 UPDATE student SET sage = 21,ssex='F' WHERE sno='95001'; --[例5] 将所有学生的年龄增加1岁 UPDATE student SET sage=sage+1; --[例6] 将信息系所有学生的年龄增加1岁 UPDATE student SET sage=sage+1 WHERE sdept='CS'; --[例7] 将计算机科学系全体学生的成绩置零 UPDATE sc SET grade = 0 WHERE sno IN(SELECT sno FROM student WHERE sdept='IS'); ","date":"2020-03-26","objectID":"/sql/:5:3","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["数据库"],"content":"DELETE DELETE FROM 表名 WHERE 条件 TRUNCATE删除所有数据保留表 --[例8] 删除学号为95019的学生记录 DELETE FROM student WHERE sno='95020'; --[例9] 删除2号课程的所有选课记录 DELETE FROM sc WHERE cno='2'; --[例10] 删除所有的学生选课记录 -- 删除所有数据 TRUNCATE TABLE sc; --[例11] 删除计算机科学系所有学生的选课记录。 DELETE FROM sc WHERE sno IN (SELECT sno FROM student WHERE sdept='IS'); ","date":"2020-03-26","objectID":"/sql/:5:4","tags":["sql"],"title":"SQL","uri":"/sql/"},{"categories":["工具"],"content":"hexo框架个人博客搭建 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1 环境准备 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1.1 Node.js和npm安装 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:1","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1.2(选) npm 淘宝镜像 npm install -g cnpm --registry.npm.taobao.org ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:2","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1.3 hexo框架安装 cnpm install -g hexo-cli ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:3","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"1.4git安装配置 git官网 下载对应系统安装包 运行安装包 一路下一步 开始菜单运行 Git Bash(运行成功表示git安装成功) git安装好去GitHub上注册一个账号 设置git：在Git Bush命令行中输入 # 配置用户名 git config --global user.name \"username\" //（ \"username\"是自己的账户名） # 配置邮箱 git config --global user.email \"username@email.com\" //(\"username@email.com\"注册账号时用的邮箱) ​ 以上命令执行结束后，可用 git config –global –list 命令查看配置是否OK 6. 生成ssh,在命令框中输入以下命令 ssh-keygen -t rsa ​ 连续敲三次回车，结束后去系统盘目录下（一般在 C:\\Users\\你的用户名.ssh）(mac: /Users/用户/.ssh）查看是否有：ssh文件夹生成 7. 将ssh文件夹中的公钥（ id_rsa.pub）添加到GitHub管理平台中，在GitHub的个人账户的设置中找到如下界面 title随便起一个，将公钥（ id_rsa.pub）文件中内容复制粘贴到key中，然后点击Ass SSH key就好啦 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:4","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2 建立本地网站 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2.1 在本地建立一个文件夹 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:1","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2.2 cmd命令进入这个文件夹 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:2","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2.3 hxeo生成博客 sudo hexo init ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:3","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"2.4 启动博客 hexo s ​ 进入网站 说明建立成功 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:4","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3 上传至github ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.1 建立仓库 登录github 新建一个仓库 仓库名必须是 “«你的username».github.io” ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:1","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.2 网站根目录安装git插件 cnpm install --save hexo-deployer-git ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:2","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.3 设置文件“_config.yml”（最底部） deploy: type: git repo: //你的仓库地址 branch: master ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:3","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.4 部署到远端 hexo d //需要登陆 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:4","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"3.5 访问 ​ ”https://«你的username».github.io“ ​ 成功 END ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:5","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"补充 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"主题可以更改 ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:1","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"其他指令 hexo clean hexo g ","date":"2020-02-29","objectID":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:2","tags":[],"title":"hexo框架个人博客搭建","uri":"/%E9%9A%8F%E7%AC%94-hexo%E6%A1%86%E6%9E%B6%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]